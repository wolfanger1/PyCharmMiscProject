Index: FFZ/FFZ10.py
===================================================================
diff --git a/FFZ/FFZ10.py b/FFZ/FFZ10.py
deleted file mode 100644
--- a/FFZ/FFZ10.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,344 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    CardMaker,
-    LineSegs,
-    Vec3
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import math
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kameraeinstellungen (Fahrtrichtung wird entlang der Y-Achse angenommen)
-        self.cam.setPos(0, -30, 10)
-        self.cam.lookAt(0, 0, 0)
-
-        # Licht und Raster
-        self.setup_light()
-        self.create_grid(center_extent=10, cell_size=0.1)
-
-        # Fahrzeug erstellen (stationär) und Referenz speichern
-        self.vehicle = self.create_vehicle()
-
-        # Slider für Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Slider zur manuellen Steuerung der Forkhöhe (0 bis 1 Meter)
-        self.fork_slider = DirectSlider(
-            range=(0.0, 1.0),
-            value=0.0,
-            pageSize=0.01,
-            command=self.update_fork_height,
-            pos=(-0.7, 0, -0.85),
-            scale=0.3
-        )
-        self.fork_label = DirectLabel(
-            text="Fork Höhe: 0.00m",
-            pos=(-0.7, 0, -0.75),
-            scale=0.07
-        )
-
-        # Laufzeitanzeige
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom via Mausrad
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben (z. B. für Anzeigen aktualisieren sowie für die automatische Kabelbewegung)
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_cable, "UpdateCableTask")
-        # Das Fahrzeug fährt stationär.
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_fork_height(self, height=0, *args):
-        try:
-            height = float(height)
-        except ValueError:
-            height = 0.0
-        self.fork_node.setZ(height)
-        self.fork_label['text'] = f"Fork Höhe: {height:.2f}m"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def create_grid(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            x += cell_size
-
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        grid_np = self.render.attachNewNode(node)
-        grid_np.setColor(0.7, 0.7, 0.7, 1)
-        return grid_np
-
-    def setup_light(self):
-        ambient_light = AmbientLight("ambient_light")
-        ambient_light.setColor((0.5, 0.5, 0.5, 1))
-        ambient_np = self.render.attachNewNode(ambient_light)
-        self.render.setLight(ambient_np)
-
-        directional_light = DirectionalLight("directional_light")
-        directional_light.setColor((1, 1, 1, 1))
-        directional_np = self.render.attachNewNode(directional_light)
-        directional_np.setPos(10, -10, 10)
-        self.render.setLight(directional_np)
-
-    def create_vehicle(self):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Fahrmodul (Chassis): 1 x 0.5 x 1.2, rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-
-        # Gabelmodul (Fork): Statt eines massiven Blocks – zwei "Zähne"
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-        self.fork_node = fork_node
-
-        # Mast: Erzeuge einen Rahmen, der nur Kanten in X- und Z-Richtung besitzt.
-        mast_node = vehicle_node.attachNewNode("mast")
-        # Top-Bar
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        # Bottom-Bar
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        # Left-Bar
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        # Right-Bar
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-
-        # Füge Diagonalen auf der oberen Fläche des Mastes hinzu.
-        self.add_diagonals_to_mast(mast_node)
-
-        # Berechne den Schnittpunkt der Diagonalen: (0.5, 0.05, 1.0) in Mast-Koordinaten.
-        intersection = Vec3(0.5, 0.05, 1.0)
-
-        # Füge einen gelben Zylinder hinzu; Maße: Durchmesser=0.1, Höhe=0.1.
-        # Wir nehmen an, dass das Modell "models/cylinder" verfügbar ist und in seinen
-        # Originalmaßen (Radius=1, Höhe=2) vorliegt – daher skalieren wir auf 0.05 in X/Y und 0.05 in Z.
-        cylinder = loader.loadModel("models/cylinder")
-        cylinder.setColor(1, 1, 0, 1)  # Gelb
-        cylinder.setScale(0.05, 0.05, 0.05)
-        cylinder.reparentTo(mast_node)
-        cylinder.setPos(intersection)
-
-        # Füge den Lidar-Kreis hinzu (Radius=1.5), zentriert am selben Schnittpunkt.
-        self.add_lidar_circle(mast_node, intersection, 1.5)
-
-        vehicle_node.setPos(-0.5, 0, 0)
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        """
-        Zeichnet zwei diagonale Linien auf der oberen Fläche des Mastes.
-        Die obere Fläche erstreckt sich von (0,0,1.0) bis (1,0.1,1.0) in Mast-Koordinaten.
-        """
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)  # Orange
-        # Diagonale 1: von (0,0,1.0) zu (1,0.1,1.0)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        # Diagonale 2: von (1,0,1.0) zu (0,0.1,1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        """
-        Fügt einen Kreis (Lidar-Sensor) hinzu, der in der XY-Ebene (konstant z)
-        verläuft. Der Kreis wird als Linienzug (LineSegs) gezeichnet und hat
-        den übergebenen Radius.
-        """
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1, 1, 1, 1)  # Weiß
-        segments = 64
-        # Starte bei 0°:
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        # Unterseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        # Oberseite
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        # Vorderseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        # Rückseite
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        # Linke Seite
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        # Rechte Seite
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def update_cable(self, task):
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)  # Werte zwischen 0 und 1
-        self.fork_node.setZ(new_height)
-        self.fork_label['text'] = f"Fork Höhe: {new_height:.2f}m"
-        return Task.cont
-
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: Grundmodell/Gm8.py
===================================================================
diff --git a/Grundmodell/Gm8.py b/Grundmodell/Gm8.py
deleted file mode 100644
--- a/Grundmodell/Gm8.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,594 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Für das Paketspawning an den Annahmestationen
-        self.pickup_packages = {}  # station (NodePath) -> (Paket, Spawnzeit, Timer Node)
-        self.last_removed = {}     # station -> Zeitpunkt der letzten Entfernung
-
-        # Für Graph-Daten und Aufträge
-        self.graph_data = []       # Tupel: (Sim-Zeit, Pakete pro Minute, Durchschnittliche Liegedauer)
-        self.graph_opened = False
-
-        # Beispielhafte Aufträge (diese Liste kannst du bei Bedarf dynamisch aktualisieren)
-        self.orders = [
-            {"id": 1, "status": "Wartend", "ziel": "Abgabestation 2"},
-            {"id": 2, "status": "In Bearbeitung", "ziel": "Abgabestation 3"}
-        ]
-
-        # Ursprung (Koordinatenachsen)
-        self.draw_origin()
-
-        # Kameraeinstellungen: Das ganze Feld soll gut sichtbar sein.
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # Licht und Bodenraster erzeugen
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-
-        # Mauer erzeugen
-        self.create_wall()
-
-        # Stationen erzeugen
-        self.create_annahme_stations()
-        self.create_abgabe_stations()
-        self.create_garagen_stations()
-
-        # Setze auf ALLE Annahmestationen ein Paket
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # UI: Slider und Info-Anzeige zur Simulationssteuerung
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tastaturbindungen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)  # Auftragsübersicht per Taste A anzeigen
-
-        # Tasks
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # Annahmestationen
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, 0.5))
-            green_dot.reparentTo(self.render)
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, 0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-    # Abgabestationen
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_abgabe_station(pt)
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, 0.5))
-            green_dot.reparentTo(self.render)
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, 0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    # Garagenstationen
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 2)
-        v5 = pos + Vec3(1, 0, 2)
-        v6 = pos + Vec3(1, 2, 2)
-        v7 = pos + Vec3(0, 2, 2)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 2)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            center = pt + Vec3(0.5, 1, 1)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        cube = self.loader.loadModel("models/box")
-        cube.setScale(1, 1, 1)
-        cube.setPos(x, y, z + 1)
-        cube.setColor(farbe)
-        cube.reparentTo(self.render)
-        return cube
-
-    def check_and_spawn_packages(self, task):
-        # Nachdem ein Paket abtransportiert wurde: Nach 10 s erscheint ein neues Paket.
-        spawn_delay = self.sim_time(10)
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-    def update_package_timers(self, task):
-        # Aktualisiere lediglich den angezeigten Timer
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            elapsed = self.sim_clock - spawn_time
-            timer_np.node().setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor != 0 else t
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-    # Neue Funktion: Auftragsübersicht anzeigen
-    def show_order_list(self):
-        # Erstelle einen Textstring mit allen Aufträgen
-        order_str = "\n".join(
-            [f"Auftrag {order['id']}: Status = {order['status']}, Ziel = {order['ziel']}"
-             for order in self.orders]
-        )
-        print("Auftragsliste:\n" + order_str)
-        # Zeige die Auftragsübersicht in einem DirectLabel an (bei erneuter Betätigung wird das alte Label zerstört)
-        if hasattr(self, "order_label"):
-            self.order_label.destroy()
-        self.order_label = DirectLabel(text=order_str, scale=0.05, pos=(-1.3, 0, 0.8))
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: Feld/Feld6.py
===================================================================
diff --git a/Feld/Feld6.py b/Feld/Feld6.py
deleted file mode 100644
--- a/Feld/Feld6.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,435 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import math
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte für Simulationszeit und Zeitskalierung
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Ursprung (Koordinatenachsen) zeichnen zur Orientierung
-        self.draw_origin()
-
-        # Kameraeinstellungen: Das ganze Feld soll gut sichtbar sein.
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # Licht und Bodenraster erzeugen
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-
-        # Erzeuge die Mauer (das umschließende Rechteck)
-        self.create_wall()
-
-        # Erzeuge Aufnahmestationen (Grün, X = 0; offene Seite in positive X-Richtung)
-        self.create_annahme_stations()
-
-        # Erzeuge Abgabestationen (Rot, X = 21; offene Seite in negative X-Richtung)
-        self.create_abgabe_stations()
-
-        # Erzeuge Garagenstationen (Maße: 1x2x2, reines Blau; Öffnung in negative Y; Dächer vorhanden; dekorative Kreuze auf den geschlossenen Seiten)
-        self.create_garagen_stations()
-
-        # Slider und Info-Anzeige zur Simulationssteuerung
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktion: Mit dem Mausrad hereinz- bzw. herauszoomen.
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Tasks zur Aktualisierung der Simulationszeit und der Info-Anzeige
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        # X-Achse (rot)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        # Y-Achse (grün)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        # Z-Achse (blau)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        """
-        Zeichnet ein Kreuz (X) auf einer rechteckigen Fläche, definiert durch 4 Eckpunkte.
-        """
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        # Offene Seite: Kante zwischen v1 und v2 wird weggelassen.
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_annahme_station(pt)
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Dekorative Kreuze hinzufügen (für Annahmestationen, offene Seite = rechte Seite)
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            # Offene Seite: x = pt.x+1, also Kreuze auf:
-            # linke Seite: [v0, v3, v7, v4]
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            # Front: [v0, v1, v5, v4]
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            # Rückwand: [v3, v2, v6, v7]
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        # Öffnung in negative X: linke Kante (v0->v3 und v7->v4) wird ausgelassen.
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_abgabe_station(pt)
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Dekorative Kreuze hinzufügen (für Abgabestationen, offene Seite = linke Seite)
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            # Offene Seite ist links (x = pt.x), also Kreuze auf:
-            # rechte Seite: [v1, v2, v6, v5]
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            # Front: [v0, v1, v5, v4]
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            # Rückwand: [v3, v2, v6, v7]
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 2)
-        v5 = pos + Vec3(1, 0, 2)
-        v6 = pos + Vec3(1, 2, 2)
-        v7 = pos + Vec3(0, 2, 2)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),  # Untere Fläche
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),  # Obere Fläche
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)  # Vertikale Kanten
-        ]
-        # Offene Front: alle Kanten, bei denen beide Endpunkte den y-Wert pos.getY() haben, werden ausgelassen.
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        # Dekoration: Kreuze auf geschlossenen Seiten (nicht auf dem Dach)
-        # Rückwand (hintere Fläche: y = pos.y+2): v3, v2, v6, v7
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        # Linke Seite (x = pos.x): v0, v3, v7, v4
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        # Rechte Seite (x = pos.x+1): v1, v2, v6, v5
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 2)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            center = pt + Vec3(0.5, 1, 1)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: KI/KI22.py
===================================================================
diff --git a/KI/KI22.py b/KI/KI22.py
deleted file mode 100644
--- a/KI/KI22.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,440 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs
-)
-
-# Wir nutzen globalClock für dt.
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit
-        self.base_speed = 1.5
-        # Zeitskalierungsfaktor
-        self.speed_factor = 1.0
-        # Simulationszeitticker in simulierten Sekunden
-        self.sim_clock = 0.0
-        # Zähler der abgegebenen Pakete
-        self.delivered_packages = 0
-        # Speichert über die gesamte Simulation die maximal erreichte Liegedauer eines Paketes
-        self.max_overall_wait_time = 0.0
-
-        # Zeitpunkt des Simulationsstarts (reale Zeit)
-        self.sim_start_real = globalClock.getFrameTime()
-
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erstelle 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeuge initialisieren – zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}           # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {} # Fahrzeug -> aktuell reservierte Abgabestation
-
-        # Fahrzeug 1: startet sofort.
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-        # Markiere den Fahrzeugmittelpunkt (weißer Punkt) und füge den Lidar-Kreis als zusätzliche Visualisierung hinzu.
-        self.add_center_marker(vehicle1)
-        self.add_offset_circle(vehicle1, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Fahrzeug 2: startet 8 simulierte Sekunden später.
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)  # y-Offset von 2 Einheiten.
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-        self.add_center_marker(vehicle2)
-        self.add_offset_circle(vehicle2, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Globaler Pool für Pickup-Pakete und Zeitstempel (in simulierten Sekunden).
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider zur Anpassung des Zeitskalierungsfaktors.
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Info-Anzeige.
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tasks.
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_vehicle2_start, "CheckVehicle2StartTask")
-        # Neuer Task zur Aktualisierung der Lidar-Farbe.
-        self.taskMgr.add(self.update_lidar_status, "UpdateLidarStatusTask")
-
-        # Starte Liefervorgänge.
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-        # Fahrzeug 2 startet, sobald 8 simulierte Sekunden erreicht sind (via Task).
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        """
-        Fügt dem Fahrzeug einen weißen Punkt als Markierung des Fahrzeugmittelpunkts hinzu.
-        """
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))  # Weiß.
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def add_offset_circle(self, vehicle, offset=Vec3(0.5, 0.5, 0.01),
-                          circle_radius=1.5, num_segments=32):
-        """
-        Zeichnet einen Kreis als Visualisierung der Lidar-Grenze des Fahrzeugs.
-        Der Kreis wird relativ zum Fahrzeug angehängt (als Kindknoten) und über
-        den angegebenen Offset positioniert. Der Kreis ist standardmäßig grün.
-        """
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))  # Standard: grün.
-        for i in range(num_segments + 1):
-            angle = 2 * math.pi * i / num_segments
-            x = circle_radius * math.cos(angle)
-            y = circle_radius * math.sin(angle)
-            if i == 0:
-                ls.moveTo(x, y, 0)
-            else:
-                ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        circle_np = vehicle.attachNewNode(circle_geom)
-        circle_np.setPos(offset)
-        # Verwende PythonTag, um den Kreis zu speichern.
-        vehicle.setPythonTag("lidar_circle", circle_np)
-
-    def update_lidar_status(self, task):
-        """
-        Überprüft für jedes Fahrzeug, ob dessen Lidar-Kreis (als Grenze des Sensors)
-        mit einem anderen Fahrzeug kollidieren könnte. Liegt der Abstand zwischen
-        den Fahrzeugmittelpunkten unter 3 m (d.h. beider Lidar-Radien sind überlappend),
-        wird der Kreis rot; andernfalls bleibt er grün.
-        """
-        sensor_threshold = 3.0  # Summe der Radien 1.5+1.5.
-        for vehicle in self.vehicles:
-            if vehicle.hasPythonTag("lidar_circle"):
-                lidar_circle = vehicle.getPythonTag("lidar_circle")
-                pos1 = vehicle.getPos(self.render)
-                collision = False
-                for other in self.vehicles:
-                    if other is not vehicle:
-                        pos2 = other.getPos(self.render)
-                        distance = (pos1 - pos2).length()
-                        if distance < sensor_threshold:
-                            collision = True
-                            break
-                if collision:
-                    lidar_circle.setColor(LColor(1, 0, 0, 1))  # rot.
-                else:
-                    lidar_circle.setColor(LColor(0, 1, 0, 1))  # grün.
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-
-        if current_max_wait_time > 0:
-            current_wait_text = f"Liegedauer (aktuell): {current_max_wait_time:.1f}s"
-        else:
-            current_wait_text = "Kein Paket an Annahmestation"
-
-        maximal_wait_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-
-        if self.sim_clock > 0:
-            delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0)
-        else:
-            delivered_per_minute = 0
-
-        self.info_label['text'] = (f"Laufzeit: {formatted_time}\n"
-                                   f"Abgegebene Pakete: {self.delivered_packages}\n"
-                                   f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-                                   f"{current_wait_text}\n"
-                                   f"{maximal_wait_text}")
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def check_vehicle2_start(self, task):
-        if self.sim_clock >= 8.0 and not hasattr(self, 'vehicle2_started'):
-            self.vehicle2_started = True
-            self.start_delivery_cycle(self.vehicles[1], self.vehicles[1].getPos())
-            return Task.done
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(
-            station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1)
-        )
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            direction = target - current_pos
-            distance = direction.length()
-            step = (self.base_speed * self.speed_factor) * dt
-            if distance <= step:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-            else:
-                vehicle.setPos(current_pos + direction.normalized() * step)
-                return Task.cont
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        pickup_pos = pickup_station.getPos()
-
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.occupied_pickups.remove(pickup_station)
-            def wait_for_dropoff(task):
-                if any(ds not in self.occupied_dropoffs for ds in self.abgabe_stationen):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_for_dropoff, f"WaitDropoff_{id(vehicle)}")
-            return
-
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_pos = dropoff_station.getPos()
-
-        self.move_vehicle_to(vehicle, pickup_pos, lambda: self.after_pickup(vehicle, pickup_station, dropoff_pos))
-
-    def after_pickup(self, vehicle, pickup_station, dropoff_pos):
-        self.pickup_package(vehicle, pickup_station)
-        self.move_vehicle_to(vehicle, dropoff_pos, lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        self.drop_cargo(vehicle)
-        start_wait = self.sim_clock
-        def wait_task(task):
-            if self.sim_clock - start_wait >= self.sim_time(1):
-                self.finish_cycle(vehicle)
-                return Task.done
-            return Task.cont
-        self.taskMgr.add(wait_task, f"WaitAfterDrop_{id(vehicle)}")
-
-    def finish_cycle(self, vehicle):
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        if dropoff_station in self.occupied_dropoffs:
-            self.occupied_dropoffs.remove(dropoff_station)
-            del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
-
Index: KI/KI4.py
===================================================================
diff --git a/KI/KI4.py b/KI/KI4.py
deleted file mode 100644
--- a/KI/KI4.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,261 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData,
-    GeomNode, GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode
-)
-
-# Hol den globalen Clock über ClockObject (so funktioniert es in Panda3D)
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.interval.IntervalGlobal import Sequence, Wait, LerpPosInterval, Func
-from direct.task import Task
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Fahrzeuggeschwindigkeit: Ursprünglich 1.5 m/s, um den Faktor 5 erhöht → 7.5 m/s
-        self.speed = 1.5 * 5
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie mit gleichem Abstand.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            # Annahmestation links (rot) bei x = -9
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            # Abgabestation rechts (grün) bei x = 9
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeug initialisieren
-        self.vehicle = self.loader.loadModel("models/box")
-        self.vehicle.setScale(1, 1, 0.5)
-        self.vehicle.setColor(LColor(0, 0, 1, 1))
-        self.vehicle.setPos(0, 0, 0)
-        self.vehicle.reparentTo(self.render)
-
-        self.cargo = None  # Das aktuell transportierte Paket
-        # Dictionary für alle Pickup-Pakete:
-        # Schlüssel = Pickup-Station, Wert = (Paket, Spawnzeit, TextNode)
-        self.pickup_packages = {}
-
-        # Starte einen Task, der regelmäßig prüft, ob an einer Annahmestation ein Paket fehlt.
-        self.taskMgr.doMethodLater(5, self.check_and_spawn_packages, "CheckSpawnPackages")
-        # Task zum Aktualisieren der angezeigten Wartezeit für alle wartenden Pakete.
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-
-        # Start des ersten Lieferzyklus
-        self.start_delivery_cycle()
-
-    def check_and_spawn_packages(self, task):
-        """
-        Für jede Annahmestation wird geprüft, ob bereits ein Paket vorhanden ist.
-        Falls nicht, wird an dieser Station (mit Spawnzeit = globalClock.getFrameTime())
-        ein Paket erzeugt.
-        """
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                self.spawn_package_at_station(station)
-        return Task.again
-
-    def spawn_package_at_station(self, station):
-        """
-        Erzeugt ein Paket (als Würfel) an der gegebenen Station.
-        Das Paket wird an die Position der Station (mit einem Z-Offset von +1)
-        gesetzt. Zusätzlich wird ein TextNode oberhalb des Pakets erstellt,
-        der später die verstrichene Zeit anzeigt. Anschließend wird im Dictionary
-        der Station das Tuple (Paket, Spawnzeit, TextNode) abgelegt.
-        """
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = globalClock.getFrameTime()
-
-        # Erzeuge einen TextNode zur Anzeige der Wartezeit
-        timer_text_node = TextNode("package_timer")
-        timer_text_node.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text_node)
-        timer_np.setScale(0.5)
-        # Positioniere den Text etwas oberhalb des Pakets (das Paket wird mit Z+1 gesetzt)
-        timer_np.setPos(0, 0, 1.2)
-
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        """
-        Aktualisiert den Text aller wartenden Pakete, sodass über jedem Paket
-        die aktuelle Wartezeit angezeigt wird.
-        """
-        current_time = globalClock.getFrameTime()
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = current_time - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def start_delivery_cycle(self, start_pos=None):
-        """
-        Ablauf:
-          1. Das Fahrzeug startet vom aktuellen Punkt (start_pos)
-             und sucht unter allen Annahmestationen das Paket, welches am längsten wartet.
-          2. Das Fahrzeug fährt zu dieser Annahmestation und nimmt das Paket auf.
-          3. Anschließend wird zufällig eine Abgabestation gewählt, zu der das Fahrzeug fährt.
-          4. Dort wird das Paket auf den Würfel der Abgabestation gesetzt; nach 1 Sekunde
-             wird es entfernt.
-          5. Der nächste Zyklus startet ab der aktuellen Position (der Abgabestation).
-        """
-        if start_pos is None:
-            start_pos = self.vehicle.getPos()
-
-        # Falls gerade keine Pakete existieren, kurz warten.
-        if not self.pickup_packages:
-            self.taskMgr.doMethodLater(1, lambda t: self.start_delivery_cycle(start_pos), "RetryCycle")
-            return
-
-        # Auswahl der Annahmestation mit dem ältesten Paket (kleinster Spawnzeitwert)
-        pickup_station = min(self.pickup_packages, key=lambda s: self.pickup_packages[s][1])
-        pickup_pos = pickup_station.getPos()
-        seg1_duration = (pickup_pos - start_pos).length() / self.speed
-
-        # Zufällige Auswahl einer Abgabestation
-        dropoff_station = random.choice(self.abgabe_stationen)
-        self.current_dropoff_station = dropoff_station  # Für drop_cargo()
-        dropoff_pos = dropoff_station.getPos()
-        seg2_duration = (dropoff_pos - pickup_pos).length() / self.speed
-
-        cycle = Sequence(
-            # Fahrt zur Annahmestation (Pickup-Station, bei der das älteste Paket liegt)
-            LerpPosInterval(self.vehicle, duration=seg1_duration, pos=pickup_pos),
-            # Nach der Ankunft: Paket vom Pickup-Punkt aufnehmen
-            Func(self.pickup_package, pickup_station),
-            # Fahrt zur zufällig ausgewählten Abgabestation
-            LerpPosInterval(self.vehicle, duration=seg2_duration, pos=dropoff_pos),
-            Func(self.drop_cargo),
-            Wait(1),
-            Func(self.remove_cargo),
-            # Starte nächsten Zyklus von der aktuellen Position aus (Abgabestation)
-            Func(self.start_delivery_cycle, self.vehicle.getPos())
-        )
-        cycle.start()
-
-    def pickup_package(self, station):
-        """
-        Nimmt das an der gegebenen Pickup-Station wartende Paket vom Boden und hängt es
-        als Kind des Fahrzeugs an. Gleichzeitig wird der Eintrag aus dem Dictionary entfernt
-        und der zugehörige Timer-Text gelöscht.
-        """
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            # Entferne den Timer-Text, da das Paket abgeholt wurde
-            timer_np.removeNode()
-            package.wrtReparentTo(self.vehicle)
-            package.setPos(0, 0, 1)
-            self.cargo = package
-
-    def drop_cargo(self):
-        """
-        Setzt das Paket exakt auf den Würfel der (zufällig ausgewählten) Abgabestation
-        (Z-Offset +1).
-        """
-        self.cargo.wrtReparentTo(self.render)
-        targetPos = self.current_dropoff_station.getPos() + Vec3(0, 0, 1)
-        self.cargo.setPos(targetPos)
-
-    def remove_cargo(self):
-        """
-        Entfernt das aktuell transportierte Paket aus der Szene.
-        """
-        if self.cargo:
-            self.cargo.removeNode()
-            self.cargo = None
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-
-        # Horizontale Linien
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        # Vertikale Linien
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        """
-        Erzeugt ein Wireframe-Box-Modell als Station.
-        """
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        """
-        Erzeugt einen Würfel (als Paket), der etwas über dem Boden platziert wird.
-        """
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        """
-        Einfaches Beleuchtungssetup: Ambient- und Richtungslicht.
-        """
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-# Starte die Simulation
-app = LagerSimulation()
-app.run()
Index: Grundmodell Erweitert Split Angepasst/environment_visualization.py
===================================================================
diff --git a/Grundmodell Erweitert Split Angepasst/environment_visualization.py b/Grundmodell Erweitert Split Angepasst/environment_visualization.py
deleted file mode 100644
--- a/Grundmodell Erweitert Split Angepasst/environment_visualization.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,1041 +0,0 @@
-# environment_visualization.py
-
-from panda3d.core import (
-    LineSegs, LColor, Vec3, Vec2, GeomVertexFormat, GeomVertexData,
-    GeomVertexWriter, GeomLines, Geom, GeomNode, TextNode, CardMaker,
-    AmbientLight, DirectionalLight
-)
-import math
-
-def attach_label(node, offset=Vec3(1, 0, 0), scale=1):
-    """
-    Hängt einen Text-Node an den übergebenen Node an, der dessen Namen anzeigt.
-    """
-    text_node = TextNode("node_label")
-    text_node.setText(node.getName())
-    text_node.setAlign(TextNode.ACenter)
-    text_np = node.attachNewNode(text_node)
-    text_np.setScale(scale)
-    text_np.setPos(offset)
-    text_np.setBillboardAxis()
-    return text_np
-
-###############################################################################
-# NodeManager
-###############################################################################
-
-class NodeManager:
-    def __init__(self, render):
-        self.render = render
-        # Alle erzeugten Nodes werden in diesem Dictionary mit eindeutigen Namen
-        # abgelegt.
-        self.nodes = {}
-        # Zähler zur eindeutigen Namensvergabe
-        self.counters = {"blue": 0, "green": 0}
-
-    def register_node(self, node, node_type):
-        self.counters[node_type] += 1
-        unique_name = f"{node_type}_node_{self.counters[node_type]}"
-        node.setName(unique_name)
-        self.nodes[unique_name] = node
-        return unique_name
-
-    def create_blue_dot(self, loader, pos, scale=0.1):
-        blue_dot = loader.loadModel("models/misc/sphere")
-        blue_dot.setScale(scale)
-        blue_dot.setColor(LColor(0, 0, 1, 1))
-        blue_dot.setPos(pos)
-        blue_dot.reparentTo(self.render)
-        self.register_node(blue_dot, "blue")
-        attach_label(blue_dot, Vec3(2, 0, 0), 5)
-        return blue_dot
-
-    def create_green_dot(self, loader, pos, scale=0.1):
-        green_dot = loader.loadModel("models/misc/sphere")
-        green_dot.setScale(scale)
-        green_dot.setColor(LColor(0, 1, 0, 1))
-        green_dot.setPos(pos)
-        green_dot.reparentTo(self.render)
-        self.register_node(green_dot, "green")
-        attach_label(green_dot, Vec3(2, 0, 0), 5)
-        return green_dot
-
-    def list_all_nodes(self):
-        return list(self.nodes.keys())
-
-    def get_node(self, unique_name):
-        return self.nodes.get(unique_name)
-
-###############################################################################
-# EnvironmentVisualizer (überarbeitete Version)
-###############################################################################
-
-class EnvironmentVisualizer:
-    def __init__(self, render, loader):
-        """
-        Initialisiert den Visualisierer mit den für Panda3D benötigten Objekten.
-        """
-        self.render = render
-        self.loader = loader
-        self.node_manager = NodeManager(render)
-        # Hier werden z. B. alle erzeugten Wandsegmente gesammelt.
-        self.wall_segments = []
-
-    def setup_environment(self):
-        """
-        Diese Methode fasst alle Schritte zusammen, die für den Aufbau der Umgebung
-        nötig sind. Neben dem Erzeugen von Ursprung, Licht, Boden, Wand, Stations- und Garagen­-objekten
-        werden auch diverse Verbindungslinien und Markierungen (zum Beispiel zwischen blauen Punkten)
-        erstellt.
-        Die Methode gibt ein Dictionary mit allen wichtigen Elementen zurück.
-        """
-        # Ursprung (Koordinatensystem) zeichnen
-        origin_node = self.draw_origin()
-
-        # Licht und Bodenraster erzeugen
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-
-        # Wand erstellen – hier werden die erzeugten Wandsegmente in self.wall_segments gespeichert
-        self.create_wall()
-
-        # Annahmestationen erzeugen: Hier gehen wir davon aus, dass die Methode ein Tupel zurückgibt.
-        annahme_stations, station_blue_dots = self.create_annahme_stations()
-        annahme_dict = {
-            "annahme_stations": annahme_stations,
-            "station_blue_dots": station_blue_dots,
-            "white_lines": None,  # Hier können zusätzliche Objekte ergänzt werden
-            "connecting_line": None
-        }
-
-        # Abgabestationen erzeugen:
-        abgabe_stations, abgabe_blue_dots = self.create_abgabe_stations()
-        abgabe_dict = {
-            "abgabe_stations": abgabe_stations,
-            "abgabe_blue_dots": abgabe_blue_dots,
-            "abgabe_white_lines": None,  # Platzhalter für zukünftige Erweiterungen
-            "abgabe_extra_blue_dot": None,
-            "abgabe_extra_line": None
-        }
-
-        # Garagenstationen erzeugen:
-        garagen_stations, garagen_parking_points = self.create_garagen_stations()
-
-        # Weitere Objekte:
-        edge_between_blue = self.draw_edge_between_blue_nodes("blue_node_26", "blue_node_21")
-        self.connect_annahme_abgabe_blue_dots(color=LColor(1, 1, 1, 1), thickness=2.0)
-        # Optional: Weitere Verbindungsaufbauten (z. B. für Annahme- und Abgabestationen, Garagen) können hier aufgerufen werden:
-        self.connect_annahme_stations(color=LColor(1, 1, 1, 1), thickness=2.0)
-        self.connect_abgabe_stations(color=LColor(1, 1, 1, 1), thickness=2.0)
-        self.connect_garagen_blue_dots(line_color=LColor(1, 1, 1, 1), thickness=2.0, text_color=LColor(0, 0, 1, 1))
-
-        # Optionale gelbe Punkte:
-        yellow_station_points = self.create_yellow_station_points(offset=3.0, scale=0.1)
-        yellow_abgabe_points = self.create_yellow_abgabe_points(offset=3.0, scale=0.1)
-        yellow_garage_points = self.create_yellow_garage_points(offset=3.0, scale=0.1)
-
-        # Alle Objekte in einem Dictionary zusammenfassen:
-        env = {
-            "origin": origin_node,
-            "wall_segments": self.wall_segments,
-            "annahme_stations": annahme_dict["annahme_stations"],
-            "station_blue_dots": annahme_dict["station_blue_dots"],
-            "white_lines": annahme_dict["white_lines"],
-            "annahme_connecting_line": annahme_dict.get("connecting_line"),
-            "abgabe_stations": abgabe_dict["abgabe_stations"],
-            "abgabe_blue_dots": abgabe_dict["abgabe_blue_dots"],
-            "abgabe_white_lines": abgabe_dict["abgabe_white_lines"],
-            "abgabe_extra_blue_dot": abgabe_dict["abgabe_extra_blue_dot"],
-            "abgabe_extra_line": abgabe_dict["abgabe_extra_line"],
-            "garagen_stations": garagen_stations,
-            "garagen_parking_points": garagen_parking_points,
-            "edge_between_blue": edge_between_blue,
-            "yellow_station_points": yellow_station_points,
-            "yellow_abgabe_points": yellow_abgabe_points,
-            "yellow_garage_points": yellow_garage_points
-        }
-        return env
-
-    # ---------------------------------------------------------------------------
-    # Basisaufbau
-    # ---------------------------------------------------------------------------
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        origin_np = self.render.attachNewNode(ls.create())
-        return origin_np
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-        return alight_np, dlight_np
-
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return None
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-        if not hasattr(self, 'wall_segments'):
-            self.wall_segments = []
-        self.wall_segments.append(wall_np)
-        return wall_np
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        seg1 = self.add_wall_segment(p1, p2)
-        seg2 = self.add_wall_segment(p2, p3)
-        seg3 = self.add_wall_segment(p3, p4)
-        seg4 = self.add_wall_segment(p4, p1)
-        return [seg1, seg2, seg3, seg4]
-
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        station_np = self.render.attachNewNode(ls.create())
-        return station_np
-
-    def create_annahme_stations(self):
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        annahme_stations = []
-        station_blue_dots = {}
-        self.annahme_blue_dot_list = []  # Für spätere Verbindungen
-
-        for i, pt in enumerate(station_points, start=1):
-            self.create_annahme_station(pt)  # Zeichnet den Basisrahmen
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            annahme_stations.append(station_dummy)
-
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            green_dot = self.node_manager.create_green_dot(self.loader, center + Vec3(0, 0, -0.5), 0.1)
-
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            station_dummy.setPythonTag("white_center", (start_line + end_line) * 0.5)
-            line_vec = end_line - start_line
-            if line_vec.length() != 0:
-                station_dummy.setPythonTag("white_direction", Vec2(line_vec.getX(), line_vec.getY()).normalized())
-            else:
-                station_dummy.setPythonTag("white_direction", Vec2(1, 0))
-
-            blue_dot = self.node_manager.create_blue_dot(self.loader, end_line)
-            station_blue_dots[station_dummy] = blue_dot
-            self.annahme_blue_dot_list.append(blue_dot)
-
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (z. B. Kreuze) – hier als Beispiel:
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-            if i == 1:
-                self.blue_dot = blue_dot
-                self.station_green_dot = green_dot
-                self.white_line_center = (start_line + end_line) * 0.5
-                if line_vec.length() != 0:
-                    self.station_white_direction = Vec2(line_vec.getX(), line_vec.getY()).normalized()
-                else:
-                    self.station_white_direction = Vec2(1, 0)
-
-        return annahme_stations, station_blue_dots
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        abgabe_np = self.render.attachNewNode(ls.create())
-        return abgabe_np
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        abgabe_stations = []
-        abgabe_blue_dots = []
-
-        for i, pt in enumerate(station_points, start=1):
-            node = self.create_abgabe_station(pt)
-            abgabe_stations.append(node)
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            green_dot = self.node_manager.create_green_dot(self.loader, center + Vec3(0, 0, -0.5), 0.1)
-
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            blue_dot = self.node_manager.create_blue_dot(self.loader, end_line)
-            abgabe_blue_dots.append(blue_dot)
-
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Optionale zusätzliche Markierungen:
-            self.add_cross_on_face([pt + Vec3(1, 0, 0), pt + Vec3(1, 1, 0), pt + Vec3(1, 1, 1), pt + Vec3(1, 0, 1)],
-                                   color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([pt + Vec3(0, 0, 0), pt + Vec3(1, 0, 0), pt + Vec3(1, 0, 1), pt + Vec3(0, 0, 1)],
-                                   color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([pt + Vec3(0, 1, 0), pt + Vec3(1, 1, 0), pt + Vec3(1, 1, 1), pt + Vec3(0, 1, 1)],
-                                   color=LColor(1, 0, 0, 1))
-
-        return abgabe_stations, abgabe_blue_dots
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 3)
-        v5 = pos + Vec3(1, 0, 3)
-        v6 = pos + Vec3(1, 2, 3)
-        v7 = pos + Vec3(0, 2, 3)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 3)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        self.garagen_blue_dots = []  # Liste zum Speichern der blauen Marker für die Garagen
-
-        self.garagen_stations = []
-        self.garagen_parking_points = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            self.garagen_stations.append(pt)
-            # ParkpunktGarage: Verschoben um 0.5 in negativer Y-Richtung:
-            center = pt + Vec3(0.5, 0.5, 1.5)
-            ParkpunktGarage = center + Vec3(0, 0, 0.7)
-            # Neuer Startpunkt: Unterer Mittelpunkt der Garage (z = 0)
-            garage_base_center = pt + Vec3(0.5, 1.0, 0)  # wichtig als Ausgangspunkt für die Linien plus blauen Punkte davor
-
-            self.garagen_parking_points.append(ParkpunktGarage)
-            # Zeichne die weiße Linie: Sie beginnt am Parkpunkt der Garage und verläuft 3 Meter in X‑Richtung.
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = garage_base_center
-            end_line = start_line + Vec3(0, -3, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            blue_dot = self.node_manager.create_blue_dot(self.loader, end_line)
-            self.garagen_blue_dots.append(blue_dot)
-
-
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-        # Am Ende sicherstellen, dass ein Tupel zurückgegeben wird:
-        return self.garagen_stations, self.garagen_parking_points
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        """
-        Zeichnet ein Kreuz (d.h. zwei Diagonallinien) auf der Fläche, definiert durch vier Eckpunkte in 'corners'.
-
-        Parameters:
-          corners (list of Vec3): Liste der vier Eckpunkte.
-          color (LColor): Farbe des Kreuzes.
-          thickness (float): Linienstärke.
-
-        Returns:
-          NodePath: Der NodePath, der die gezeichneten Linien beinhaltet.
-        """
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    def create_yellow_end_points_on_line(self, start_dot, end_dot, offset=3.0, scale=0.1):
-        """
-        Zeichnet gelbe Punkte an beiden Enden der Verbindungslinie.
-
-        Die Punkte werden 3 Meter (offset) in Richtung des Verbindungsmittelpunktes gesetzt:
-          - Vom Startmarker: Verschiebung in Richtung des Endmarkers.
-          - Vom Endmarker: Verschiebung entgegengesetzt zur Verbindungsrichtung.
-
-        Um doppelte Beschriftungen zu vermeiden, werden alle automatisch angehängten
-        Label-Knoten (mit dem Namen "node_label") entfernt.
-
-        Rückgabe:
-          Ein Tupel (yellow_point_start, yellow_point_end)
-        """
-        # Ermittle die Weltpositionen der beiden Marker:
-        start_pos = start_dot.getPos(self.render)
-        end_pos = end_dot.getPos(self.render)
-
-        # Berechne den Richtungsvektor und normalisiere ihn:
-        direction = end_pos - start_pos
-        norm = direction.length()
-        if norm == 0:
-            print("Start- und Endpunkt sind identisch, gelbe Punkte können nicht berechnet werden.")
-            return None, None
-        direction_normalized = direction / norm
-
-        # Setze die gelben Punkte 3 Meter in Richtung des Mittelpunkts der Verbindung:
-        yellow_start_pos = start_pos + (direction_normalized * offset)
-        yellow_end_pos = end_pos - (direction_normalized * offset)
-
-        # Erzeuge die Punkte über den NodeManager
-        yellow_point_start = self.node_manager.create_blue_dot(self.loader, yellow_start_pos, scale)
-        # Entferne automatisch angehängte Label-Knoten (sofern vorhanden)
-        for child in yellow_point_start.getChildren():
-            if child.getName() == "node_label":
-                child.removeNode()
-        yellow_point_start.setColor(LColor(1, 1, 0, 1))  # Gelb
-
-        yellow_point_end = self.node_manager.create_blue_dot(self.loader, yellow_end_pos, scale)
-        for child in yellow_point_end.getChildren():
-            if child.getName() == "node_label":
-                child.removeNode()
-        yellow_point_end.setColor(LColor(1, 1, 0, 1))  # Gelb
-
-        return yellow_point_start, yellow_point_end
-
-    def connect_annahme_abgabe_blue_dots(self, color=LColor(1, 1, 1, 1), thickness=2.0, text_color=LColor(0, 0, 1, 1)):
-        """
-        Verbindet jeden blauen Marker der Annahmestationen mit dem entsprechenden blauen Marker
-        der Abgabestationen, zeichnet dabei die Verbindungslinie (mit Label "Verbindung X")
-        und erzeugt pro Verbindungslinie genau zwei gelbe Punkte.
-
-        Es wird über alle Verbindungslinien hinweg fortlaufend nummeriert, sodass der erste
-        gelbe Punkt "yellow_node_1", der zweite "yellow_node_2", der dritte "yellow_node_3" usw.
-        lautet.
-
-        Die erzeugten gelben Punkte werden als Tupel in der Instanzvariablen
-        self.annahme_abgabe_yellow_points gespeichert.
-        """
-        # Überprüfe, ob beide Listen vorhanden sind:
-        if not hasattr(self, "annahme_blue_dot_list") or not hasattr(self, "abgabe_blue_dots"):
-            print("Es sind nicht alle blauen Punkte vorhanden!")
-            return
-
-        if len(self.annahme_blue_dot_list) != len(self.abgabe_blue_dots):
-            print("Die Anzahl der blauen Punkte der Annahme- und Abgabestationen stimmt nicht überein!")
-            return
-
-        from panda3d.core import TextNode, Vec3
-        yellow_points = []  # Hier werden die Tupel gelber Punkte gesammelt
-        global_yellow_counter = 1  # Globaler Zähler über alle Verbindungslinien
-
-        for idx, (blue_annahme, blue_abgabe) in enumerate(zip(self.annahme_blue_dot_list, self.abgabe_blue_dots),
-                                                          start=1):
-            # Zeichne die Verbindungslinie zwischen den blauen Punkten:
-            ls = LineSegs()
-            ls.setThickness(thickness)
-            ls.setColor(color)
-            ls.moveTo(blue_annahme.getPos())
-            ls.drawTo(blue_abgabe.getPos())
-            self.render.attachNewNode(ls.create())
-
-            # Berechne den Mittelpunkt und erstelle ein Label für die Verbindung (z. B. "Verbindung 1")
-            pos_a = blue_annahme.getPos(self.render)
-            pos_b = blue_abgabe.getPos(self.render)
-            midpoint = (pos_a + pos_b) * 0.5
-
-            label_text = f"Verbindung {idx}"
-            tn = TextNode("line_label")
-            tn.setText(label_text)
-            tn.setAlign(TextNode.ACenter)
-            label_np = blue_annahme.attachNewNode(tn)
-            relative_offset = blue_annahme.getRelativePoint(self.render, midpoint)
-            label_np.setPos(relative_offset)
-            label_np.setScale(5)
-            label_np.setBillboardPointEye()
-
-            # Erzeuge exakt zwei gelbe Punkte für diese Verbindungslinie:
-            yellow_start, yellow_end = self.create_yellow_end_points_on_line(
-                blue_annahme, blue_abgabe, offset=3.0, scale=0.1
-            )
-
-            # Beschrifte den ersten gelben Punkt mit der globalen Nummer und erhöhe den Zähler:
-            tn_yellow_start = TextNode("yellow_label")
-            tn_yellow_start.setText(f"yellow_node_{global_yellow_counter}")
-            tn_yellow_start.setAlign(TextNode.ACenter)
-            label_np_start = yellow_start.attachNewNode(tn_yellow_start)
-            label_np_start.setScale(3)
-            label_np_start.setBillboardPointEye()
-            global_yellow_counter += 1
-
-            # Beschrifte den zweiten gelben Punkt:
-            tn_yellow_end = TextNode("yellow_label")
-            tn_yellow_end.setText(f"yellow_node_{global_yellow_counter}")
-            tn_yellow_end.setAlign(TextNode.ACenter)
-            label_np_end = yellow_end.attachNewNode(tn_yellow_end)
-            label_np_end.setScale(3)
-            label_np_end.setBillboardPointEye()
-            global_yellow_counter += 1
-
-            yellow_points.append((yellow_start, yellow_end))
-
-        self.annahme_abgabe_yellow_points = yellow_points
-        return yellow_points
-
-    def connect_garagen_blue_dots(self, line_color=LColor(1, 1, 1, 1), thickness=2.0, text_color=LColor(0, 0, 1, 1)):
-        """
-        Verbindet alle blauen Punkte der Garagen (self.garagen_blue_dots) mit einer durchgehenden Linie
-        in der Farbe `line_color` und versieht jeden Abschnitt zwischen zwei benachbarten blauen Punkten
-        mit einer Beschriftung. Die Nummerierung der Beschriftungen beginnt bei 11 (also "Verbindung 11",
-        "Verbindung 12" usw.). Nur die Schrift wird in der Farbe `text_color` (blau) dargestellt,
-        die Linie behält ihre eigene Farbe.
-
-        Parameter:
-          line_color (LColor): Farbe der Verbindungslinie, standardmäßig Weiß.
-          thickness (float): Dicke der Verbindungslinie, standardmäßig 2.0.
-          text_color (LColor): Farbe der Beschriftung, standardmäßig Blau.
-        """
-        from panda3d.core import TextNode, Vec3
-
-        # Überprüfe, ob die Liste der Garagen-Blaupunkte existiert und Elemente enthält
-        if not hasattr(self, "garagen_blue_dots") or not self.garagen_blue_dots:
-            print("Keine blauen Punkte der Garagen vorhanden!")
-            return
-
-        # Erstelle die durchgehende Linie in der Farbe line_color
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(line_color)
-
-        first_pos = self.garagen_blue_dots[0].getPos(self.render)
-        ls.moveTo(first_pos)
-        for blue_dot in self.garagen_blue_dots[1:]:
-            ls.drawTo(blue_dot.getPos(self.render))
-        self.render.attachNewNode(ls.create())
-
-        # Für jeden Abschnitt zwischen zwei benachbarten blauen Punkten:
-        for i in range(len(self.garagen_blue_dots) - 1):
-            pos1 = self.garagen_blue_dots[i].getPos(self.render)
-            pos2 = self.garagen_blue_dots[i + 1].getPos(self.render)
-            midpoint = (pos1 + pos2) * 0.5
-
-            # Erzeuge das Label mit der entsprechenden Nummerierung (beginnend bei 11)
-            label_text = f"Verbindung {i + 11}"
-            tn = TextNode("garage_line_label")
-            tn.setText(label_text)
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(text_color)
-
-            # Hänge das Label an den Render-Knoten, damit die Platzierung in Weltkoordinaten erfolgt
-            label_np = self.render.attachNewNode(tn)
-            # Positioniere das Label am Mittelpunkt der Verbindung mit einem kleinen Z-Offset
-            label_np.setPos(midpoint + Vec3(0, 0, 0.5))
-            # Setze die Skalierung entsprechend (hier z. B. 0.3, anpassbar je nach Bedarf)
-            label_np.setScale(0.3)
-            # Richte den Text mittels Billboarding so aus, dass er immer zur Kamera zeigt
-            label_np.setBillboardPointEye()
-
-    def connect_annahme_stations(self, color=LColor(1, 1, 1, 1), thickness=2.0):
-        """
-        Verbindet alle blauen Marker der Annahmestationen (gespeichert in self.annahme_blue_dot_list)
-        mit einer durchgehenden Linie in der angegebenen Farbe und Dicke.
-
-        Parameter:
-          color (LColor): Farbe der Verbindungslinie, standardmäßig Weiß (LColor(1, 1, 1, 1)).
-          thickness (float): Dicke der Linie, standardmäßig 2.0.
-        """
-        # Prüfen, ob überhaupt blaue Marker für die Annahmestationen vorhanden sind
-        if not hasattr(self, "annahme_blue_dot_list") or not self.annahme_blue_dot_list:
-            print("Keine blauen Marker der Annahmestationen vorhanden!")
-            return
-
-        from panda3d.core import LineSegs
-
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-
-        # Verwende die Weltkoordinaten der blauen Marker, um den Pfad zu erstellen
-        first_pos = self.annahme_blue_dot_list[0].getPos(self.render)
-        ls.moveTo(first_pos)
-        for blue_dot in self.annahme_blue_dot_list[1:]:
-            ls.drawTo(blue_dot.getPos(self.render))
-
-        # Hänge den erzeugten Linien-Node an den Render-Knoten, sodass die Linie in der Szene sichtbar wird
-        self.render.attachNewNode(ls.create())
-
-    def connect_abgabe_stations(self, color=LColor(1, 1, 1, 1), thickness=2.0):
-        """
-        Verbindet alle blauen Marker der Abgabestationen (gespeichert in self.abgabe_blue_dots)
-        mit einer durchgehenden Linie in der angegebenen Farbe und Dicke.
-
-        Parameter:
-          color (LColor): Farbe der Verbindungslinie, standardmäßig Weiß (LColor(1, 1, 1, 1)).
-          thickness (float): Dicke der Verbindungslinie, standardmäßig 2.0.
-        """
-        # Prüfe, ob die Liste der Abgabestationen-Blaupunkte existiert und Elemente enthält
-        if not hasattr(self, "abgabe_blue_dots") or not self.abgabe_blue_dots:
-            print("Keine blauen Marker der Abgabestationen vorhanden!")
-            return
-
-        from panda3d.core import LineSegs
-
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-
-        # Starte am ersten blauen Marker
-        first_pos = self.abgabe_blue_dots[0].getPos(self.render)
-        ls.moveTo(first_pos)
-        # Verbinde alle folgenden blauen Marker in ihrer Reihenfolge
-        for blue_dot in self.abgabe_blue_dots[1:]:
-            ls.drawTo(blue_dot.getPos(self.render))
-
-        # Hänge den Linien-Node an den Render-Knoten, sodass die Linie in der Szene angezeigt wird
-        self.render.attachNewNode(ls.create())
-
-    def create_fixed_blue_dot(self, pos=Vec3(18.5, 54.5, 0), scale=0.1):
-        """
-        Erstellt (falls noch nicht vorhanden) einen blauen Punkt an der festen Position (18,55,0)
-        und speichert ihn als Attribut (self._fixed_blue_dot). Wird er bereits existieren,
-        so wird dieser wieder zurückgegeben.
-
-        Parameter:
-          pos   - Zielposition (Default: Vec3(18,55,0))
-          scale - Skalierung des blauen Punktes (Default: 0.1)
-
-        Rückgabe:
-          NodePath des fixierten blauen Punktes.
-        """
-        if hasattr(self, '_fixed_blue_dot') and self._fixed_blue_dot is not None:
-            return self._fixed_blue_dot
-        blue_dot = self.node_manager.create_blue_dot(self.loader, pos, scale)
-        self._fixed_blue_dot = blue_dot
-        return blue_dot
-
-    def create_fixed_connection_line(self, abgabe_index=10, thickness=2.0, color=LColor(1, 1, 1, 1)):
-        # Überprüfe, ob genügend Abgabestations-Markierungen vorhanden sind.
-        if not hasattr(self, 'abgabe_blue_dots') or len(self.abgabe_blue_dots) < abgabe_index:
-            print(f"Abgabestation {abgabe_index} existiert nicht!")
-            return None
-
-        # Hole den blauen Marker der gewünschten Abgabestation (Index abgabe_index-1)
-        abgabe_dot = self.abgabe_blue_dots[abgabe_index - 1]
-
-        # Verwende den bereits erzeugten fixierten blauen Punkt
-        fixed_dot = self.create_fixed_blue_dot()
-
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(abgabe_dot.getPos(self.render))
-        ls.drawTo(fixed_dot.getPos(self.render))
-        connection_line = self.render.attachNewNode(ls.create())
-        return connection_line
-
-    def create_garage5_connection_line(self, thickness=2.0, color=LColor(1, 1, 1, 1)):
-        """
-        Erstellt eine Verbindungslinie zwischen dem fixierten blauen Punkt (z. B. an (18,55,0))
-        und dem blauen Marker der fünften Garage.
-
-        Voraussetzung:
-          - Es existiert bereits ein fixierter blauer Punkt (mittels create_fixed_blue_dot())
-          - Die Liste self.garagen_blue_dots enthält mindestens 5 Einträge, wobei der
-            fünfte Marker (Index 4) den blauen Marker der fünften Garage repräsentiert.
-
-        Rückgabe:
-          NodePath des Linien-Objekts.
-        """
-        # Prüfe, ob mindestens 5 Garagen-Blaupunkte vorhanden sind.
-        if not hasattr(self, 'garagen_blue_dots') or len(self.garagen_blue_dots) < 5:
-            print("Nicht genügend Garage-Markierungen vorhanden!")
-            return None
-
-        # Hole den fixierten blauen Punkt – dieser wird über create_fixed_blue_dot() erstellt/abgerufen.
-        fixed_point = self.create_fixed_blue_dot()
-
-        # Hole den blauen Marker der 5. Garage (Index 4, da Listen bei 0 beginnen)
-        garage5_dot = self.garagen_blue_dots[4]
-
-        # Zeichne die Verbindungslinie von fixed_point zu garage5_dot.
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(fixed_point.getPos(self.render))
-        ls.drawTo(garage5_dot.getPos(self.render))
-
-        connection_line = self.render.attachNewNode(ls.create())
-        return connection_line
-
-    def create_connection_line_first_garage_to_10_annahme(self, thickness=2.0, color=LColor(1, 1, 1, 1)):
-        """
-        Erstellt eine Verbindungslinie zwischen:
-          • Dem blauen Marker der ersten Garage (aus self.garagen_blue_dots, Index 0)
-          • Dem blauen Marker der 10. Annahmestation (aus self.annahme_blue_dot_list, Index 9)
-
-        Parameter:
-          thickness (float): Linienstärke (Standard: 2.0)
-          color     (LColor): Farbe der Linie (Standard: Weiß, LColor(1, 1, 1, 1))
-
-        Rückgabe:
-          NodePath des Linien-Objekts oder None, wenn die notwendigen Marker nicht existieren.
-        """
-        # Überprüfe, ob der erste Garage-Blaupunkt existiert.
-        if not hasattr(self, 'garagen_blue_dots') or len(self.garagen_blue_dots) < 1:
-            print("Der blauen Marker der ersten Garage existiert nicht!")
-            return None
-
-        # Überprüfe, ob mindestens 10 Annahme-Blaupunkte existieren.
-        if not hasattr(self, 'annahme_blue_dot_list') or len(self.annahme_blue_dot_list) < 10:
-            print("Nicht genügend Annahmestationen vorhanden (mindestens 10 erforderlich)!")
-            return None
-
-        start_dot = self.garagen_blue_dots[0]
-        end_dot = self.annahme_blue_dot_list[9]
-
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(start_dot.getPos(self.render))
-        ls.drawTo(end_dot.getPos(self.render))
-
-        connection_line = self.render.attachNewNode(ls.create())
-        return connection_line
-
-    def create_yellow_station_points(self, offset=3.0, scale=0.1):
-        """
-        Erstellt für jeden blauen Punkt der Annahmestationen einen gelben Punkt,
-        der 3 Meter (offset) in positiver Y-Richtung von dem blauen Punkt entfernt liegt.
-
-        Für jeden gelben Punkt wird ein Label in der Form
-            "yellow_station_node_X"
-        angehängt, wobei X global fortlaufend gezählt wird.
-
-        Rückgabe:
-          Eine Liste mit den NodePaths der erzeugten gelben Punkte.
-        """
-        from panda3d.core import TextNode, Vec3
-        yellow_station_points = []
-        global_counter = 1  # Globaler Zähler über alle Annahmestationen
-
-        # Iteriere über alle blauen Punkte der Annahmestationen
-        for blue_dot in self.annahme_blue_dot_list:
-            # Hole die Weltposition des blauen Punktes
-            pos = blue_dot.getPos(self.render)
-            # Offener Offset in Y-Richtung (positiv)
-            new_pos = pos + Vec3(0, offset, 0)
-            # Erzeuge einen gelben Punkt an dieser Position
-            yellow_point = self.node_manager.create_blue_dot(self.loader, new_pos, scale)
-            # Optional: Entferne den standardmäßig angehängten Label-Knoten,
-            # falls dieser vorhanden ist.
-            for child in yellow_point.getChildren():
-                if child.getName() == "node_label":
-                    child.removeNode()
-            yellow_point.setColor(LColor(1, 1, 0, 1))  # Setze Farbe Gelb
-
-            # Erzeuge ein Label in der Form "yellow_station_node_X"
-            tn = TextNode("yellow_station_label")
-            tn.setText(f"yellow_station_node_{global_counter}")
-            tn.setAlign(TextNode.ACenter)
-            label_np = yellow_point.attachNewNode(tn)
-            label_np.setScale(3)
-            label_np.setBillboardPointEye()
-
-            yellow_station_points.append(yellow_point)
-            global_counter += 1
-
-        return yellow_station_points
-
-    def create_yellow_abgabe_points(self, offset=3.0, scale=0.1):
-        """
-        Erstellt für jeden blauen Punkt der Abgabestationen einen gelben Punkt,
-        der 3 Meter (offset) in positiver Y-Richtung vom blauen Marker entfernt ist.
-
-        Für jeden gelben Punkt wird ein Label in der Form
-            "yellow_abgabe_node_X"
-        angehängt, wobei X global fortlaufend nummeriert wird (über alle Abgabestationen).
-
-        Rückgabe:
-          Eine Liste der NodePaths der erzeugten gelben Abgabe-Punkte.
-        """
-        from panda3d.core import TextNode, Vec3
-        yellow_abgabe_points = []
-        global_counter = 1  # Globaler Zähler für die Nummerierung
-
-        # Iteriere über alle blauen Punkte, die Abgabestationen repräsentieren
-        for blue_dot in self.abgabe_blue_dots:
-            # Ermittele die Weltposition des blauen Punktes
-            pos = blue_dot.getPos(self.render)
-            # Verschiebe den Punkt um den angegebenen Offset in positiver Y-Richtung
-            new_pos = pos + Vec3(0, offset, 0)
-            # Erzeuge den gelben Punkt (ohne zusätzliche Label, da diese später entfernt werden)
-            yellow_point = self.node_manager.create_blue_dot(self.loader, new_pos, scale)
-            # Entferne automatisch angehängte Label (z. B. "node_label"), wenn vorhanden
-            for child in yellow_point.getChildren():
-                if child.getName() == "node_label":
-                    child.removeNode()
-            yellow_point.setColor(LColor(1, 1, 0, 1))  # Setze die Farbe auf Gelb
-
-            # Erzeuge ein Label im Format "yellow_abgabe_node_X"
-            tn = TextNode("yellow_abgabe_label")
-            tn.setText(f"yellow_abgabe_node_{global_counter}")
-            tn.setAlign(TextNode.ACenter)
-            label_np = yellow_point.attachNewNode(tn)
-            label_np.setScale(3)
-            label_np.setBillboardPointEye()
-
-            yellow_abgabe_points.append(yellow_point)
-            global_counter += 1
-
-        return yellow_abgabe_points
-
-    def create_yellow_garage_points(self, offset=3.0, scale=0.1):
-        """
-        Erstellt für jeden blauen Punkt der Garagen (aus self.garagen_blue_dots) einen gelben Punkt,
-        der 3 Meter in positiver X-Richtung vom blauen Punkt entfernt liegt.
-
-        Der gelbe Punkt für Garage 5 (also der fünfte Punkt in der Liste) wird ausgelassen.
-
-        Für jeden erstellten gelben Punkt wird ein Label im Format "yellow_garage_node_X" angehängt,
-        wobei X global fortlaufend gezählt wird.
-
-        Rückgabe:
-          Eine Liste der NodePaths der erzeugten gelben Garage-Punkte.
-        """
-        from panda3d.core import TextNode, Vec3
-        yellow_garage_points = []
-        global_counter = 1  # global fortlaufender Zähler für die Beschriftung
-
-        # Iteriere über alle blauen Garagen-Punkte anhand ihrer Reihenfolge in der Liste
-        for idx, blue_dot in enumerate(self.garagen_blue_dots):
-            # Überspringe den blauen Punkt der Garage 5 (bei Index 4, da Zählung bei 0 beginnt)
-            if idx == 4:
-                continue
-
-            # Hole die Weltposition des aktuellen blauen Punktes
-            pos = blue_dot.getPos(self.render)
-            # Verschiebe 3 Meter in positiver X-Richtung:
-            new_pos = pos + Vec3(offset, 0, 0)
-
-            # Erzeuge den gelben Punkt an der neuen Position
-            yellow_point = self.node_manager.create_blue_dot(self.loader, new_pos, scale)
-            # Entferne automatisch angehängte Label-Knoten (falls vorhanden)
-            for child in yellow_point.getChildren():
-                if child.getName() == "node_label":
-                    child.removeNode()
-            # Setze die Farbe auf Gelb:
-            yellow_point.setColor(LColor(1, 1, 0, 1))
-
-            # Erzeuge ein Label im Format "yellow_garage_node_X"
-            tn = TextNode("yellow_garage_label")
-            tn.setText(f"yellow_garage_node_{global_counter}")
-            tn.setAlign(TextNode.ACenter)
-            label_np = yellow_point.attachNewNode(tn)
-            label_np.setScale(3)
-            label_np.setBillboardPointEye()
-
-            yellow_garage_points.append(yellow_point)
-            global_counter += 1
-
-        return yellow_garage_points
-
Index: Grundmodell/Gm17.py
===================================================================
diff --git a/Grundmodell/Gm17.py b/Grundmodell/Gm17.py
deleted file mode 100644
--- a/Grundmodell/Gm17.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,1547 +0,0 @@
-import random
-import math
-import tkinter as tk  # Für das extra Fenster der Auftragsübersicht
-from tkinter import ttk  # Für die tabellarische Darstellung (Treeview)
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-from direct.task.TaskManagerGlobal import taskMgr
-
-
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5  # Wird in update_vehicle genutzt
-        self.state_timer = 0.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Paketspawning an den Annahmestationen:
-        # Mapping: station (Dummy-Node) -> (Paket, Spawnzeit, Timer Node)
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-        # Neues Attribut: Verknüpfung Fahrzeug -> transportiertes Paket
-        self.cargos = {}
-
-        # NEU: Initialisiere die belegten Annahmestationen
-        self.occupied_pickups = set()  # Oder: [] für eine Liste
-
-        # Graph-Daten (Sim-Zeit, Pakete pro Minute, durchschnittliche Liegedauer)
-        self.graph_data = []
-        self.graph_opened = False
-
-        # Auftragsverwaltung: Speichere alle Aufträge (für die Anzeige) sowie in
-        # einer Queue (Liste) zur sequentiellen Abarbeitung.
-        self.orders = {}         # Für die Anzeige
-        self.orders_queue = []   # Für die Fahrzeugabwicklung (FIFO)
-        self.next_order_id = 1
-
-        # Tkinter-Fenster für Auftragsübersicht
-        self.order_win = None
-        self.order_tree = None
-
-        # Umgebung initialisieren
-        self.draw_origin()
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.create_wall()
-        self.create_annahme_stations()
-        self.create_abgabe_stations()  # Hier wird auch self.abgabe_stations angelegt.
-        self.create_garagen_stations()
-
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # Fahrzeuge in den Garagen erstellen (genau 5 Fahrzeuge)
-        self.create_garage_vehicles()
-
-        # NEU: Auftragssystem für das Testfahrzeug initialisieren
-        # Zustände: "idle", "to_pickup", "wait_pickup", "to_delivery", "deliver"
-        self.first_vehicle_order_state = "idle"
-        self.attached_package = None
-        self.current_order = None  # Der aktuell abgearbeitete Auftrag
-        self.taskMgr.add(self.vehicle_order_task, "VehicleOrderTask")
-
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-        self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    # ---------------------------
-    # SIMULATION UND UI-METHODEN
-    # ---------------------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    # ---------------------------
-    # METHODEN FÜR RASTER, LICHT, MAUER, URSPRUNG
-    # ---------------------------
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # STATIONSOBJEKTE UND ZUORDNUNG
-    # -----------------------------------
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        """
-        Erzeugt die Annahmestationen und erstellt für jede Station:
-          - Einen weißen Marker zur Orientierung
-          - Einen grünen Punkt (optional)
-          - Eine weiße Linie, an deren Endpunkt ein blauer Marker als Ziel in der "Translate‑Phase" dient
-
-        Zusätzlich wird ein Dictionary self.station_blue_dots aufgebaut, in dem jedem Annahmestations‑Node
-        der zugehörige blaue Marker zugeordnet wird. Außerdem wird für die erste Station die globale Variable
-        self.station_white_direction festgelegt.
-        """
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        self.station_blue_dots = {}
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basisstation (zum Beispiel als Rahmen)
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Erzeuge den weißen Marker als Orientierung
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Erzeuge den grünen Punkt (optional)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zeichne die weiße Linie: Sie beginnt bei center + Vec3(0, 0, -0.5) und verläuft 3 Meter in X‑Richtung.
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Erzeuge den blauen Marker, der als Ziel in der Translate‑Phase dient
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            # Speichere den blauen Marker im Dictionary, sodass er später erzeugt werden kann
-            self.station_blue_dots[station_dummy] = blue_dot
-
-            # Optionale Textanzeige der Stationsnummer
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) – falls benötigt:
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-            # Für die erste Station (oder den ersten relevanten Pickup) setzen wir globale Referenzen,
-            # die in vehicle_order_task benötigt werden.
-            if i == 1:
-                self.blue_dot = blue_dot
-                self.station_green_dot = green_dot
-                # Berechne den Mittelpunkt der weißen Linie als Referenz (optional)
-                self.white_line_center = (start_line + end_line) * 0.5
-                line_vec = end_line - start_line
-                if line_vec.length() != 0:
-                    self.station_white_direction = Vec2(line_vec.getX(), line_vec.getY()).normalized()
-                else:
-                    self.station_white_direction = Vec2(1, 0)  # Fallback-Wert
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        self.abgabe_stations = []  # Liste der Abgabestationen
-        self.abgabe_blue_dots = []  # Liste zum Speichern der blauen Marker für die Abgabe
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basiskonstruktion der Abgabestation
-            node = self.create_abgabe_station(pt)
-            self.abgabe_stations.append(node)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Marker am Zentrum (weiß)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Grüner Punkt: center + Vec3(0, 0, -0.5)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Weiße Linie: Startet bei center + Vec3(0, 0, -0.5)
-            # und verläuft 3 Meter in negativer X-Richtung
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt: wird an der Endposition der Linie erzeugt
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            # Speichere den blauen Marker für spätere Navigation der Abgabestation
-            self.abgabe_blue_dots.append(blue_dot)
-
-            # Anzeige der Stationsnummer (textuell)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) auf der Station
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 3)
-        v5 = pos + Vec3(1, 0, 3)
-        v6 = pos + Vec3(1, 2, 3)
-        v7 = pos + Vec3(0, 2, 3)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 3)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        self.garagen_stations = []
-        self.garagen_parking_points = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            self.garagen_stations.append(pt)
-            # ParkpunktGarage: Verschoben um 0.5 in negativer Y-Richtung:
-            center = pt + Vec3(0.5, 0.5, 1.5)
-            ParkpunktGarage = center + Vec3(0, 0, 0.7)
-            self.garagen_parking_points.append(ParkpunktGarage)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def create_garage_vehicles(self):
-        """
-        Erzeugt nur das erste Fahrzeug in der Simulation.
-
-        Ursprünglich wurde für jeden Garagen-Parkpunkt ein Fahrzeug erstellt.
-        Mit dieser Anpassung wird nur das Fahrzeug am ersten Parkpunkt erzeugt,
-        alle weiteren Fahrzeuge werden nicht erzeugt.
-        """
-        self.garage_vehicles = []
-        if self.garagen_parking_points:
-            park = self.garagen_parking_points[0]  # Nur der erste Parkpunkt wird verwendet.
-            veh = self.create_vehicle(park_point=None)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            # Statt newPos.setZ(0.1) setzen wir den Z-Wert als Offset zum berechneten Wert:
-            newPos.setZ(newPos.getZ() + 0.1)
-            veh.setPos(newPos)
-            self.garage_vehicles.append(veh)
-
-            # Erzeuge Fahrzeugmarker
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # FAHRZEUGERSTELLUNG (FFZ20-INTEGRATION)
-    # -----------------------------------
-    def create_vehicle(self, park_point=None):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Chassis: 1 x 0.5 x 1.2, Farbe Rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # Fork (Gabel): Zwei Zähne
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-        self.fork_node = fork_node
-
-        # Berechne den Mittelpunkt der Gabel (mittels der linken und rechten Eckpunkte)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_corner_global = fork_node.getPos() + left_corner_local
-        right_corner_global = fork_node.getPos() + right_corner_local
-
-        ls_new = LineSegs()
-        ls_new.setThickness(2.0)
-        ls_new.setColor(1, 1, 1, 1)
-        ls_new.moveTo(left_corner_global)
-        ls_new.drawTo(right_corner_global)
-        vehicle_node.attachNewNode(ls_new.create())
-
-        midpoint = (left_corner_global + right_corner_global) * 0.5
-        white_line_vec = right_corner_global - left_corner_global
-        if white_line_vec.length() != 0:
-            white_line_dir = white_line_vec.normalized()
-        else:
-            white_line_dir = Vec3(0, 0, 0)
-        candidate = Vec3(-white_line_dir.getY(), white_line_dir.getX(), 0)
-        vehicle_pos = vehicle_node.getPos()
-        if candidate.dot(vehicle_pos - midpoint) < 0:
-            candidate = -candidate
-        if candidate.length() != 0:
-            perp_direction = candidate.normalized()
-        else:
-            perp_direction = Vec3(0, 0, 0)
-        line_length = 1.0
-        line_end = midpoint + perp_direction * line_length
-        ls_mid = LineSegs()
-        ls_mid.setThickness(2.0)
-        ls_mid.setColor(1, 1, 1, 1)
-        ls_mid.moveTo(midpoint)
-        ls_mid.drawTo(line_end)
-        vehicle_node.attachNewNode(ls_mid.create())
-
-        # Fahrzeug: Gabel – grüner Punkt (als Referenz)
-        green_point_global = midpoint + perp_direction * 0.5
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        self.fork_green = green_marker_np  # Global abgespeichert
-
-        # Mast: Erzeuge den Mast und hänge den Zylinder als Referenz an
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-
-        self.add_diagonals_to_mast(mast_node)
-        intersection = Vec3(0.5, 0.05, 1.0)
-
-        # Fahrzeug: Zylinder – Erzeuge den Zylinder und speichere ihn global
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-        self.vehicle_cylinder = cylinder_node  # Global abgespeichert
-
-        # Optional: Zusätzliche Fahrzeugbestandteile (wie Lidar) können hier ergänzt werden.
-
-        if park_point is None:
-            vehicle_node.setPos(intersection.x, intersection.y, 0)
-        else:
-            vehicle_node.setPos(park_point - intersection)
-
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    # -----------------------------------
-    # FEHLENDE METHODEN: Paketspawning, Würfelerzeugung u.a.
-    # -----------------------------------
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Bestimme zufällig eine Abgabestation als Ziel
-        if hasattr(self, "abgabe_stations") and self.abgabe_stations:
-            target_index = random.randint(1, len(self.abgabe_stations))
-        else:
-            target_index = 1
-
-        # Erstelle den Auftrag zur Annahmestation
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def update_order_table(self):
-        """
-        Aktualisiert die Auftragsübersicht in der Tkinter-Tabelle und zeigt in der
-        letzten Spalte den zugewiesenen Fahrzeugnamen (oder "-" falls noch keiner zugeordnet wurde).
-        """
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen (z. B. "annahme_station_3") die Stationsnummer.
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z. B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige in der letzten Spalte den zugewiesenen Fahrzeugnamen an (oder "-" falls noch kein Fahrzeug zugewiesen ist).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END, values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = 5.0  # 5 Sekunden Verzögerung zwischen Spawns
-        for station in self.annahme_stations:
-            # Wenn aktuell kein Paket an der Station ist
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                # Prüfe, ob seit der letzten Entnahme mindestens 5 Sekunden vergangen sind
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0.0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Wir legen hier die Spalten in der gewünschten Reihenfolge an: Auftrags ID, Annahmestation, Ziel, Fahrzeug.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Paket wird relativ zur Gabel positioniert
-            green_point_pos = self.fork_green.getPos(self.fork_node)
-            package.wrtReparentTo(self.fork_node)
-            package.setPos(
-                green_point_pos.getX() + 0.5,  # Versatz in X
-                green_point_pos.getY() - 0.5,  # Versatz in Y
-                green_point_pos.getZ() + 1  # Z-Offset
-            )
-
-            self.cargos[vehicle] = package
-
-            # Aktualisiere den letzten Entfernen-Zeitpunkt der Station
-            self.last_removed[station] = self.sim_clock
-
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-        # Andernfalls (falls kein Paket vorhanden) keine Aktion.
-
-    from direct.task.TaskManagerGlobal import taskMgr  # Sicherstellen, dass taskMgr verfügbar ist
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden removeCargoTask aufruft,
-            # und übergib dabei das cargo als extra Argument:
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return Task.done
-
-    def select_next_order(self):
-        """
-        Wählt den nächsten (dringendsten) Auftrag anhand folgender Kriterien:
-          - Zuerst: Auftrag mit der höchsten Liegedauer (je länger ein Paket liegt, desto dringlicher)
-          - Bei Gleichstand: Auftrag, bei dem die Entfernung zur Annahmestation des Fahrzeugs am geringsten ist.
-
-        Der ausgewählte Auftrag wird außerdem mit einer Fahrzeugzuordnung (hier "Fahrzeug 1") versehen.
-        """
-        # Filtern aller Aufträge mit dem Status "Wartend"
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        # Berechne für jeden Auftrag die Liegedauer
-        for order in waiting_orders:
-            dwell_time = self.sim_clock - order.get("spawn_time", self.sim_clock)
-            order["dwell_time"] = dwell_time
-
-        # Bestimme den maximalen Liegedauerwert
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01  # Kleine Toleranz zur Berücksichtigung von Rundungsfehlern
-
-        # Finde alle Aufträge, deren Liegedauer nahezu dem Maximum entspricht
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        # Wir nehmen als Referenz das erste Fahrzeug aus der Liste self.garage_vehicles
-        if not self.garage_vehicles:
-            return None
-        vehicle = self.garage_vehicles[0]
-        vehicle_pos = vehicle.getPos(self.render)
-
-        def distance_to_station(order):
-            station = order.get("pickup_station")
-            if station:
-                station_pos = station.getPos(self.render)
-                return (station_pos - vehicle_pos).length()
-            return float('inf')
-
-        # Sortiere die Kandidaten nach dem Abstand der Pickup-Station zum Fahrzeug
-        candidates.sort(key=distance_to_station)
-        chosen_order = candidates[0]
-        chosen_order["vehicle"] = "Fahrzeug 1"  # Hier kannst du ggf. die passende Fahrzeug-ID hinterlegen
-        return chosen_order
-
-    def vehicle_order_task(self, task):
-        """
-        Diese Methode steuert das Fahrzeug bis einschließlich Phase 2.
-        Falls noch kein Auftrag zugewiesen wurde, wird dieser anhand der höchsten Liegedauer
-        (mittels select_next_order) ausgewählt. Das Fahrzeug fährt dann zum blauen Marker
-        der entsprechenden Pickup-Station (Phase 1: translate). In Phase 2 (rotate) richtet es sich
-        in Richtung des berechneten Winkelvektors (station_white_direction) aus.
-        """
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-
-        # Falls noch nicht vorhanden, initialisiere vehicle_state.
-        if not hasattr(self, 'vehicle_state'):
-            self.vehicle_state = "translate"
-
-        # Verwende den korrekten Attributnamen: self.garage_vehicles
-        if not self.garage_vehicles:
-            return task.cont
-        vehicle = self.garage_vehicles[0]
-
-        # ------------------ Phase 1: Translate ------------------
-        if self.vehicle_state == "translate":
-            # Falls noch kein Auftrag zugewiesen wurde, den dringendsten Auftrag wählen.
-            if self.current_order is None:
-                next_order = self.select_next_order()
-                if next_order is not None:
-                    self.current_order = next_order
-                    self.current_order["status"] = "In Bearbeitung"
-                    print(f"Auftrag {self.current_order['id']} wird zugewiesen.")
-                else:
-                    print("Kein Auftrag verfügbar – Fallback zum globalen Ziel.")
-            # Bestimme den blauen Zielpunkt:
-            if self.current_order is not None:
-                pickup_station = self.current_order.get("pickup_station")
-                if pickup_station in self.station_blue_dots:
-                    blue_target = self.station_blue_dots[pickup_station].getPos(self.render)
-                else:
-                    blue_target = self.blue_dot.getPos(self.render)
-            else:
-                blue_target = self.blue_dot.getPos(self.render)
-
-            # Fahrzeug bewegt sich in Richtung des blauen Markers.
-            local_mast = Vec3(0.5, 0.05, 1.0)
-            mast_global = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(local_mast)
-            target_xy = Vec2(blue_target.getX(), blue_target.getY())
-            mast_xy = Vec2(mast_global.getX(), mast_global.getY())
-            error_vector = target_xy - mast_xy
-            threshold = 0.05  # Toleranz: 5 cm
-            if error_vector.length() > threshold:
-                direction = error_vector.normalized()
-                move_distance = 1.5 * dt
-                current_pos = vehicle.getPos(self.render)
-                new_pos = Vec3(current_pos.getX() + direction.getX() * move_distance,
-                               current_pos.getY() + direction.getY() * move_distance,
-                               0)
-                vehicle.setPos(new_pos)
-            else:
-                # Exakte Positionierung am blauen Ziel.
-                local_offset = vehicle.getQuat(self.render).xform(local_mast)
-                exact_pos = Vec3(blue_target.getX() - local_offset.getX(),
-                                 blue_target.getY() - local_offset.getY(),
-                                 0)
-                vehicle.setPos(exact_pos)
-                self.vehicle_state = "rotate"
-
-        # ------------------ [Phase 2: Rotate] ------------------
-        elif self.vehicle_state == "rotate":
-            desired_angle = math.degrees(math.atan2(self.station_white_direction.getY(),
-                                                    self.station_white_direction.getX()))
-            desired_angle = (desired_angle + 180) % 360  # berücksichtige 180°-Offset
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_angle - current_heading + 180) % 360) - 180
-            kp_heading = 0.5
-            new_heading = current_heading + kp_heading * angle_diff
-            vehicle.setH(new_heading)
-            if abs(angle_diff) < 1.0:
-                self.vehicle_state = "turn_right"
-
-        # ------------------ [Phase 3: Turn Right] ------------------
-        elif self.vehicle_state == "turn_right":
-            # Initialisierung: Einmalige Festlegung des Start- und Ziel-Headings
-            if not hasattr(self, "turn_right_init"):
-                self.turn_right_init = vehicle.getH() % 360
-                self.turn_right_target = (self.turn_right_init + 90) % 360
-                print("Phase 3: Initialisiert. Start Heading =", self.turn_right_init,
-                      "Target Heading =", self.turn_right_target)
-
-            # Aktuelles Heading und Fehlerberechnung (minimale Winkelabweichung im Bereich [-180, 180])
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((self.turn_right_target - current_heading + 180) % 360) - 180
-
-            # Proportionale Regelung: Drehgeschwindigkeit (in Grad/Sekunde)
-            kp_turn = 0.5
-            turn_rate = kp_turn * angle_diff
-
-            # Inkrementelle Aktualisierung des Headings basierend auf dt
-            new_heading = current_heading + turn_rate * dt
-            vehicle.setH(new_heading)
-
-            print("Phase 3: Aktuelles Heading =", current_heading,
-                  "Winkelabweichung =", angle_diff,
-                  "Neues Heading =", new_heading)
-
-            # Zustandswechsel, wenn der Fehler klein genug ist
-            if abs(angle_diff) < 1.0:
-                print("Phase 3: Drehung abgeschlossen. Übergang in 'approach'.")
-                self.vehicle_state = "approach"
-                del self.turn_right_init, self.turn_right_target
-
-        # ------------------ [Phase 4: Approach] ------------------
-        elif self.vehicle_state == "approach":
-            if self.current_order is not None:
-                # Verwende den in self.current_order gespeicherten Pickup-Knoten.
-                pickup_station = self.current_order.get("pickup_station")
-                # Berechne den Zielpunkt: Position der Pickup-Station plus Offset:
-                # 1.2 in X‑Richtung und 1 in Y‑Richtung
-                target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-            else:
-                # Fallback: Falls kein Auftrag vorliegt, benutze den global gesetzten green_dot plus Offset
-                target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-
-            current = vehicle.getPos(self.render)
-            error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-            if error_vec.length() > 0.05:
-                direction = error_vec.normalized()
-                move_distance = 1.5 * dt
-                new_pos = Vec3(
-                    current.getX() + direction.getX() * move_distance,
-                    current.getY() + direction.getY() * move_distance,
-                    target.getZ()
-                )
-                vehicle.setPos(new_pos)
-            else:
-                self.vehicle_state = "pickup"
-
-        # ------------------ [Phase 5: Pickup] ------------------
-        elif self.vehicle_state == "pickup":
-            current_z = self.fork_node.getZ()
-            target_z = 1.0  # Höhe der Gabel beim Aufnehmen
-            raise_speed = 0.5
-            if current_z < target_z:
-                self.fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-            else:
-                if self.current_order is None:
-                    if self.orders_queue:
-                        self.current_order = self.orders_queue.pop(0)
-                    else:
-                        print("Keine verfügbaren Aufträge. Überspringe Pickup-Phase.")
-                        self.vehicle_state = "drive_out"
-                        return task.cont
-                pickup_station = self.current_order["pickup_station"]
-                self.pickup_package(vehicle, pickup_station)
-                self.package_attached = True
-                self.drive_out_start = vehicle.getPos(self.render)
-                self.drive_out_target = self.drive_out_start + vehicle.getQuat(self.render).getForward() * 5.0
-                self.vehicle_state = "drive_out"
-
-        # ------------------ [Phase 6: Drive Out] ------------------
-        elif self.vehicle_state == "drive_out":
-            current_z = self.fork_node.getZ()
-            if current_z > 0.0:
-                lower_speed = 0.5
-                self.fork_node.setZ(max(0.0, current_z - lower_speed * dt))
-            current_pos = vehicle.getPos(self.render)
-            diff = self.drive_out_target - current_pos
-            if diff.length() > 0.1:
-                move_distance = 0.5 * dt
-                step = diff.normalized() * move_distance
-                vehicle.setPos(current_pos + step)
-            else:
-                self.vehicle_state = "to_delivery"
-
-        # ------------------ [Phase 7: To Delivery] ------------------
-        elif self.vehicle_state == "to_delivery":
-            delivery_target_str = self.current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current_pos = vehicle.getPos(self.render)
-            diff = blue_target - current_pos
-            threshold = 0.5  # großzügiger Toleranzwert in Metern
-            move_distance = 1.5 * dt
-            if move_distance > diff.length():
-                vehicle.setPos(blue_target)
-            else:
-                vehicle.setPos(current_pos + diff.normalized() * move_distance)
-            if (blue_target - vehicle.getPos(self.render)).length() <= threshold:
-                print("Phase 7 abgeschlossen: Fahrzeug hat den blauen Punkt der Abgabestation erreicht.")
-                self.vehicle_state = "align_delivery"
-
-        # ------------------ [Phase 8: Align Delivery] ------------------
-        elif self.vehicle_state == "align_delivery":
-            desired_heading = 90.0
-
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_heading - current_heading + 180) % 360) - 180
-
-            print("Phase 8: Align Delivery | Current Heading: {:.2f}°, Desired: {:.2f}°, Diff: {:.2f}°".format(
-                current_heading, desired_heading, angle_diff))
-
-            fixed_turn_speed = 90.0  # Grad pro Sekunde
-            turn_amount = fixed_turn_speed * dt
-
-            if abs(angle_diff) < 1.0:
-                vehicle.setH(desired_heading)
-                print("Phase 8 abgeschlossen: Fahrzeug ausgerichtet (Heading = {:.2f}°).".format(desired_heading))
-                # Nach erfolgreicher Ausrichtung wechseln wir in die neue Phase (Delivery Center)
-                self.vehicle_state = "delivery_center"
-            else:
-                if angle_diff > 0:
-                    new_heading = current_heading + turn_amount
-                else:
-                    new_heading = current_heading - turn_amount
-                new_heading %= 360
-                vehicle.setH(new_heading)
-                print("Phase 8: Rotating - New Heading set to {:.2f}°".format(new_heading))
-
-        # ------------------ [Phase 9: Delivery Approach] ------------------
-        elif self.vehicle_state == "delivery_center":
-            # Extrahiere aus dem Auftrag den Zielindex, z. B. "Abgabestation 3"
-            delivery_target_str = self.current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-
-            # Wähle den entsprechenden blauen Marker aus der Liste der Abgabestation-Marker
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-
-            current = vehicle.getPos(self.render)
-            target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-            print("Phase 9: Zielpunkt der Abgabestation =", target_point)
-
-            # Berechne den Fehlervektor im XY-Bereich zwischen der aktuellen Fahrzeugposition und target_point
-            error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-            tolerance = 0.05  # Toleranz in Metern im XY-Bereich
-            move_distance = 1.5 * dt  # Annäherungsgeschwindigkeit analog zu Phase 4
-
-            if error_vec.length() > tolerance:
-                direction = error_vec.normalized()
-                new_pos = Vec3(
-                    current.getX() + direction.getX() * move_distance,
-                    current.getY() + direction.getY() * move_distance,
-                    current.getZ()  # Z bleibt unverändert (Boden)
-                )
-                vehicle.setPos(new_pos)
-                print("Phase 9: Fahrzeug bewegt sich von", current, "nach", new_pos)
-            else:
-                vehicle.setPos(target_point)
-                print("Phase 9: Fahrzeug hat den Zielpunkt erreicht.")
-                self.vehicle_state = "drop"  # Wechsel in die Drop-Phase
-
-            # (Optional) Hebe parallel das Gabelmodul (fork_node) sanft an, falls benötigt.
-            current_fork_z = self.fork_node.getZ()
-            if current_fork_z < 1.0:
-                new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-                self.fork_node.setZ(new_fork_z)
-                print("Phase 9: Gabel wird angehoben (Z =", new_fork_z, ").")
-
-        # ------------------ [Phase 10: Dropoff] ------------------
-        elif self.vehicle_state == "drop":
-            # Zuerst: Paket absetzen, falls es noch angebunden ist.
-            if self.package_attached:
-                # Extrahiere aus dem Auftrag den Zielindex, z. B. "Abgabestation 3"
-                delivery_target_str = self.current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-
-                # Wähle den entsprechenden blauen Marker aus der Liste der Abgabestation-Marker
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-
-                # Jetzt wird das Paket abgesetzt:
-                self.drop_cargo(vehicle)
-                print("Phase 10: Paket abgesetzt.")
-                self.package_attached = False
-
-            else:
-                # Nachdem das Paket abgesetzt wurde, senke die Gabeln ab.
-                current_z = self.fork_node.getZ()
-                if current_z > 0.0:
-                    lower_speed = 0.5  # Absenkgeschwindigkeit in m/s
-                    new_z = max(0.0, current_z - lower_speed * dt)
-                    self.fork_node.setZ(new_z)
-                    print("Phase 10: Gabel wird abgesenkt, aktueller Z-Wert =", new_z)
-                else:
-                    print("Phase 10: Dropoff vollständig abgeschlossen.")
-                    # Entferne den Auftrag aus der Auftragsliste
-                    if self.current_order is not None:
-                        order_id = self.current_order["id"]
-                        if order_id in self.orders:
-                            del self.orders[order_id]
-                    # Setze den Zustand für den nächsten Auftrag zurück.
-                    self.vehicle_state = "translate"
-                    self.current_order = None
-
-        # ------------------ [Phase 11: Exit Station and Start Next Order] ------------------
-        elif self.vehicle_state == "phase11":
-            # Verwende den in Phase 10 gespeicherten blauen Marker der Abgabestation
-            if hasattr(self, "last_delivery_marker"):
-                target_point = self.last_delivery_marker
-            else:
-                # Fallback: wenn der Marker nicht gespeichert wurde, bestimme ihn aus dem aktuellen Auftrag
-                delivery_target_str = self.current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    target_point = self.abgabe_blue_dots[0].getPos(self.render)
-            print("Phase 11: Zielpunkt (blauer Marker) =", target_point)
-
-            # Hole die aktuelle Fahrzeugposition
-            current_pos = vehicle.getPos(self.render)
-            diff = target_point - current_pos
-
-            # Bewege das Fahrzeug mit konstanter Geschwindigkeit von 0.5 m/s
-            if diff.length() > 0.1:
-                move_distance = 0.5 * dt
-                step = diff.normalized() * move_distance
-                vehicle.setPos(current_pos + step)
-                print("Phase 11: Fahrzeug fährt aus der Station, neue Position =", current_pos + step)
-            else:
-                # Zielpunkt erreicht – nächster Auftrag wird eingeleitet.
-                vehicle.setPos(target_point)
-                print("Phase 11: Fahrzeug hat den blauen Marker erreicht. Nächster Auftrag wird gestartet.")
-                self.vehicle_state = "next_order"  # Zustandswechsel zur nächsten Auftragsphase
-
-        return task.cont
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: Grundmodell Erweitert Split/GES2.py
===================================================================
diff --git a/Grundmodell Erweitert Split/GES2.py b/Grundmodell Erweitert Split/GES2.py
deleted file mode 100644
--- a/Grundmodell Erweitert Split/GES2.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,2088 +0,0 @@
-# Standardbibliothek
-import random
-import math
-import time
-import ctypes
-import multiprocessing
-from multiprocessing import Queue, Process
-from functools import partial
-import tkinter as tk
-from tkinter import ttk
-
-# Drittanbieter
-import matplotlib
-import matplotlib.pyplot as plt
-from PyQt5 import QtWidgets, QtCore
-import pyqtgraph as pg
-
-# Panda3D und Direct (Engine-spezifische Importe)
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.task.TaskManagerGlobal import taskMgr
-from direct.gui.DirectGui import DirectButton, DirectSlider, DirectLabel
-
-from direct.showbase.ShowBase import ShowBase
-from environment_visualization import EnvironmentVisualizer
-
-class LagerSimulation(ShowBase):
-    def __init__(self, graph_queue=None):
-        # Basisinitialisierung (ShowBase, etc.)
-        super().__init__()
-
-        # ------------------------------------------------------------------------
-        # 1. Umgebung aufbauen: Verwende den extrahierten EnvironmentVisualizer
-        # ------------------------------------------------------------------------
-        self.env_viz = EnvironmentVisualizer(self.render, self.loader)
-
-        # Rufe die Methoden des Visualizers auf, um die Umgebung zu erstellen.
-        self.env_viz.draw_origin()
-        self.env_viz.erzeuge_licht()
-        self.env_viz.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.env_viz.create_wall()
-        self.env_viz.create_annahme_stations()
-        self.env_viz.create_abgabe_stations()
-        self.env_viz.create_garagen_stations()
-
-        # Um in anderen Methoden (z. B. für Paket- oder Auftrags-Handling) auf die Stationen
-        # und deren Marker zugreifen zu können, übergeben wir die entsprechenden Listen.
-        self.annahme_stations = self.env_viz.annahme_stations
-        self.station_blue_dots = self.env_viz.station_blue_dots
-        self.abgabe_stations = self.env_viz.abgabe_stations
-        self.abgabe_blue_dots = self.env_viz.abgabe_blue_dots
-        self.garagen_stations = self.env_viz.garagen_stations
-        self.garagen_parking_points = self.env_viz.garagen_parking_points
-
-        # Setze den Pickup-Offset (dieser Vektor wird bei der Steuerung genutzt)
-        self.pickup_offset = Vec3(0.5, -0.5, 0)
-
-        # Falls du weitere Referenzen (wie self.blue_dot, self.station_green_dot) brauchst, ebenfalls setzen.
-        if hasattr(self.env_viz, 'blue_dot'):
-            self.blue_dot = self.env_viz.blue_dot
-        if hasattr(self.env_viz, 'station_green_dot'):
-            self.station_green_dot = self.env_viz.station_green_dot
-
-        # ------------------------------------------------------------------------
-        # 2. Restliche Initialisierung (Simulationsvariablen, UI, Tasks, etc.)
-        # (Der restliche Code bleibt weitgehend unverändert.)
-        # ------------------------------------------------------------------------
-
-        self.paused = False
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5
-
-        # Weitere Attribute, z. B. für KPIs, Paket- und Auftragsverwaltung usw.
-        self.delivered_packages = 0
-        self.pickup_packages = {}
-        self.last_removed = {}
-        self.orders = {}
-        self.orders_queue = []
-        self.next_order_id = 1
-        # (Weitere Initialisierungen kommen hier…)
-        self.cargos = {}
-        # Falls du auch weitere Attribute benötigst, wie beispielsweise eine Liste der belegten Pickup-Stations:
-        self.occupied_pickups = set()
-
-        self.max_overall_wait_time = 0.0  # Maximale Wartezeit der Pakete
-        self.total_dwell_time = 0.0  # Summe aller Liegedauern abgeholter Pakete
-        self.picked_up_count = 0  # Anzahl abgeholter Pakete
-        self.total_delivery_time = 0.0  # Summe aller Lieferzeiten
-        self.total_delivery_count = 0  # Anzahl der Lieferungen
-        self.max_overall_delivery_time = 0.0
-
-        self.graph_queue = None
-        self.graph_data = []
-        self.graph_process = None
-
-        # Beispiel: Initialisierung des Tkinter-Fensters
-        self.tk_root = tk.Tk()
-        self.tk_root.withdraw()
-
-        # Weiterer Code: Kamera, Lichter (falls weiterhin benötigt – ansonsten übernehmen wir vollständig den Visualizer)
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # UI-bezogene Attribute initialisieren:
-        self.order_win = None
-        self.order_tree = None
-        self.graph_queue = None
-        self.graph_data = []
-
-        # TensorFlow-Modell und RL-Agent initialisieren (wie gehabt)
-        try:
-            import tensorflow as tf
-            self.tf_model = tf.keras.models.load_model("mein_model.keras")
-            print("TensorFlow Modell erfolgreich geladen.")
-        except Exception as e:
-            print(f"Fehler beim Laden des TensorFlow Modells: {e}")
-            self.tf_model = None
-
-        state_bins = ((10, 10), (10, 10))
-        action_space = [0, 1, 2]
-        self.rl_agent = RLAgent(state_bins, action_space, learning_rate=0.1, discount_factor=0.9, epsilon=0.2)
-        self.training_data = []  # Trainingsdatenliste
-
-        # Spawn-Einstellungen (Standardwerte)
-        self.package_spawn_delay = 5.0
-        self.package_spawn_distribution = "uniform"
-        # Hier speichern wir die Variablen für die Stationen als Dictionary (Index -> BooleanVar)
-        self.spawn_station_vars = {}
-        # Falls du beispielsweise 10 Annahmestationen hast:
-        for i in range(10):
-            self.spawn_station_vars[i] = tk.BooleanVar(value=False)
-
-        # Fahrzeuge in den Garagen instanziieren:
-        self.create_garage_vehicles()
-        # --- UI-Elemente für Simulationssteuerung ---
-        # Slider für Simulationsgeschwindigkeit
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        self.paused = False
-        # Pause-Knopf neben dem Slider platzieren – z.B. rechts davon.
-        self.pause_button = DirectButton(
-            text="Pause",
-            command=self.toggle_pause,
-            pos=(-0.5, 0, -0.85),  # Leicht links vom Slider
-            scale=0.07
-        )
-
-        # --- Tastenzuordnungen ---
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-        # Taste "c" öffnet das Fahrzeug-Kontrollfenster
-        self.accept("c", self.show_vehicle_control)
-
-        # --- Tasks (TaskMgr) hinzufügen ---
-        self.taskMgr.add(self._tk_update, "tkUpdateTask")
-        self.taskMgr.add(self.update_delivery_timers, "UpdateDeliveryTimersTask")
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClock")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_graph_data, "UpdateGraphDataTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-    # ---------------1. Initialisierung & Simulationssteuerung---------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        self.sim_clock += dt
-        return Task.cont
-
-    def toggle_pause(self):
-        if not self.paused:
-            # Speichern des aktuellen speed_factor, damit wir ihn beim Resume wiederherstellen können
-            self.previous_speed_factor = self.speed_factor
-            self.speed_factor = 0  # Simulation einfrieren: alle dt-basierte Updates ergeben 0
-            self.pause_button['text'] = "Weiter"
-            self.paused = True
-            print("Gesamte Simulation angehalten")
-        else:
-            # Wiederaufnahme der Simulation: speed_factor auf den vorherigen Wert zurücksetzen
-            self.speed_factor = self.previous_speed_factor if hasattr(self, 'previous_speed_factor') else 1.0
-            self.pause_button['text'] = "Pause"
-            self.paused = False
-            print("Simulation läuft wieder")
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        # dt jetzt skaliert mit der Simulationsgeschwindigkeit
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-    # ---------------2. Graphik & UI (GUI-/Tk-/Matplotlib-Funktionen)---------------
-    def open_graph(self):
-        # Starte den Graphprozess per Taste G (nur, wenn er noch nicht läuft)
-        if self.graph_process is None or not self.graph_process.is_alive():
-            from multiprocessing import Queue, Process
-            self.graph_queue = Queue()
-
-            # Sende alle bisher gesammelten Daten in die Queue:
-            for data in self.graph_data:
-                try:
-                    self.graph_queue.put(data, block=False)
-                except Exception:
-                    pass
-
-            from graph_pyqt import graph_process_pyqt
-            self.graph_process = Process(target=graph_process_pyqt, args=(self.graph_queue,))
-            self.graph_process.start()
-            print("Graphprozess gestartet.")
-        else:
-            print("Graphprozess läuft bereits.")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2, self.ax3) = plt.subplots(3, 1, figsize=(8, 9))
-
-        # Erster Plot: Pakete pro Minute
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-
-        # Zweiter Plot: Durchschnittliche Liegedauer
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-
-        # Dritter Plot: Durchschnittliche Lieferzeit
-        self.line3, = self.ax3.plot([], [], marker="o", color="green", label="Durchschnittliche Lieferzeit (s)")
-        self.ax3.set_xlabel("Simulationszeit (s)")
-        self.ax3.set_ylabel("Lieferzeit (s)")
-        self.ax3.set_title("Durchschnittliche Lieferzeit")
-        self.ax3.legend()
-        self.ax3.grid(True)
-
-        plt.show(block=False)
-        # Starte im Tkinter-Hauptloop eine periodische Aktualisierung:
-        self.tk_root.after(500, self.tk_graph_update)  # alle 500ms
-
-    def tk_graph_update(self):
-        # GIL sichern: Gibt einen Statuswert zurück, der später wieder freigegeben wird.
-        gil_state = ctypes.pythonapi.PyGILState_Ensure()
-        try:
-            times = [data[0] for data in self.graph_data]
-            rates = [data[1] for data in self.graph_data]
-            dwell = [data[2] for data in self.graph_data]
-            delivery = [data[3] for data in self.graph_data]
-
-            self.line1.set_data(times, rates)
-            self.ax1.relim()
-            self.ax1.autoscale_view()
-
-            self.line2.set_data(times, dwell)
-            self.ax2.relim()
-            self.ax2.autoscale_view()
-
-            self.line3.set_data(times, delivery)
-            self.ax3.relim()
-            self.ax3.autoscale_view()
-
-            self.fig.canvas.draw_idle()
-            self.fig.canvas.flush_events()
-        finally:
-            ctypes.pythonapi.PyGILState_Release(gil_state)
-
-        # Nächsten Aufruf in 500ms einplanen
-        self.tk_root.after(500, self.tk_graph_update)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-
-        # Bestimme die maximale Liegedauer aktueller Pakete an den Annahmestationen
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-
-        # Lieferzeit-Kennzahlen ermitteln: für Fahrzeuge, die aktuell ein Paket tragen
-        current_delivery_time = 0.0
-        for veh in self.garage_vehicles:
-            if veh.getPythonTag("package_attached"):
-                ds = veh.getPythonTag("delivery_start_time")
-                if ds:
-                    elapsed_delivery = self.sim_clock - ds
-                    current_delivery_time = max(current_delivery_time, elapsed_delivery)
-        avg_delivery_time = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        # Aktualisiere den Info-Label-Text
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s\n"
-            f"Lieferzeit (aktuell): {current_delivery_time:.1f}s\n"
-            f"Lieferzeit (maximal): {self.max_overall_delivery_time:.1f}s\n"
-            f"Durchschn. Lieferzeit: {avg_delivery_time:.1f}s"
-        )
-        return Task.cont
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def update_graph_data(self, task):
-        if self.sim_clock > 0:
-            ppm = self.delivered_packages / (self.sim_clock / 60)
-        else:
-            ppm = 0.0
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        avg_delivery = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        new_data = (self.sim_clock, ppm, avg_dwell, avg_delivery)
-        # Speichere alle Daten ab Simulationsbeginn:
-        self.graph_data.append(new_data)
-
-        # Zusätzlich: Falls der Graphprozess aktiv ist, schicke den neuen Datensatz auch an die Queue
-        if self.graph_queue is not None:
-            try:
-                self.graph_queue.put(new_data, block=False)
-            except Exception:
-                pass
-        return Task.cont
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Hier werden nur die gewünschten Spalten "ID", "Annahmestation", "Ziel" und "Fahrzeug" definiert.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    #-------Fahrzeugsteuerung(Bedienfenster)-------
-    def update_vehicle_control(self):
-        for veh, var in self.vehicle_state_vars.items():
-            new_state = var.get()
-            if new_state == "idle" and veh.getPythonTag("current_order") is not None:
-                veh.setPythonTag("standby_pending", True)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Standby angefordert (Auftrag wird fortgesetzt).")
-            else:
-                veh.setPythonTag("standby_pending", False)
-                veh.setPythonTag("order_state", new_state)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Zustand auf {new_state} gesetzt.")
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-    def update_cable(self, task):
-        # Verwende die simulative Zeit, die bereits in update_sim_clock hochgezählt wird
-        t = self.sim_clock
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    def create_garage_vehicles(self):
-        self.garage_vehicles = []
-        vehicle_id_counter = 1
-        for park in self.garagen_parking_points:
-            veh = self.create_vehicle(park_point=park)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            newPos.setZ(0)
-            veh.setPos(newPos)
-
-            # Fahrzeuge starten im Standby (idle)
-            veh.setPythonTag("current_order", None)
-            veh.setPythonTag("order_state", "idle")
-            veh.setPythonTag("package_attached", False)
-            veh.setPythonTag("vehicle_id", vehicle_id_counter)
-            # Speichere den Parkpunkt als Rückkehrziel
-            veh.setPythonTag("garage_target", park)
-            # Speichere auch das Anfangs-Heading, um es später beim Parken wiederherzustellen.
-            veh.setPythonTag("start_heading", veh.getH())
-            vehicle_id_counter += 1
-
-            self.garage_vehicles.append(veh)
-
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-            # Füge einen Textknoten hinzu, der die Fahrzeugnummer vorne auf dem Fahrzeug anzeigt.
-            # Wir suchen den Mast-Knoten.
-            mast = veh.find("**/mast")
-            if not mast.isEmpty():
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)  # Schwarz
-                tn.setAlign(TextNode.ACenter)
-                text_np = mast.attachNewNode(tn)
-                # Positioniere den Text relativ zum Mast: Wir nutzen den Vektor "intersection"
-                # und versetzen ihn in Z-Richtung um 0.2 Einheiten oberhalb des Zylinders.
-                text_np.setPos(intersection.x, intersection.y, intersection.z + 0.2)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-            else:
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)
-                tn.setAlign(TextNode.ACenter)
-                text_np = veh.attachNewNode(tn)
-                text_np.setPos(0, 1.2, 1.5)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-
-            self.taskMgr.add(partial(self.vehicle_order_task, veh),
-                             f"VehicleOrderTask_{veh.getPythonTag('vehicle_id')}")
-
-    # --------------- Erstellung des Fahrzeugs---------------
-    def create_vehicle(self, park_point=None):
-        # Erzeuge den übergeordneten Fahrzeug-Knoten
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # --------------------------
-        # Chassis erstellen (1 x 0.5 x 1.2, Farbe Rot)
-        # --------------------------
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # --------------------------
-        # Gabel (Fork) erstellen: Zwei Zähne
-        # --------------------------
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        vehicle_node.setPythonTag("fork_node", fork_node)
-
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-
-        # --------------------------
-        # Statt weißer Kante von der Gabel: bereits eingezeichnete grüne Mittellinie verwenden.
-        # In diesem Beispiel nehmen wir an, dass du schon eine „mittlere“ Linie gezeichnet hast.
-        # Zeichne die grüne Mittellinie, z. B. von einem Punkt an der Gabel (als Ausgangspunkt)
-        # bis zu einem Referenzpunkt – hier nutzen wir einen zuvor festgelegten Offset.
-        #
-        # Wir definieren:
-        #   - Den Ausgangspunkt als den grün markierten Punkt, der den mittleren Punkt der Gabel repräsentieren soll.
-        #   - Den Zielpunkt als den Referenzpunkt, der als Idealwert in create_vehicle bestimmt wurde.
-        # In unserem Beispiel berechnen wir den Zielpunkt einmalig aus den lokalen Offsets an der weißen Kante.
-        # (Diese Werte kannst du bei Bedarf anpassen.)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_global = fork_node.getPos(self.render) + left_corner_local
-        right_global = fork_node.getPos(self.render) + right_corner_local
-        # Berechne den idealen (statischen) Mittelpunkt als Referenz – dieser wird nur einmal gesetzt.
-        midpoint_white = (left_global + right_global) * 0.5
-        # Nun lege den grünen Marker so, dass er exakt in der Mitte der Gabel liegt.
-        # Hier entspricht der grüne Punkt der Mittellinie der Gabel.
-        green_point_global = midpoint_white  # Hier wird angenommen, dass der ideale Mittelpunkt gleich dem Referenzpunkt ist.
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        vehicle_node.setPythonTag("fork_green", green_marker_np)
-
-        # Zeichne die grüne Mittellinie.
-        # Als Beispiel: Zeichne eine Linie vom grünen Marker in Richtung +Y (relativ zum Fahrzeug),
-        # weil du den idealen Zustand so festgelegt hast, dass genau diese Linie mit der Station übereinstimmen soll.
-        ls_mid = LineSegs()
-        ls_mid.setThickness(2.0)
-        ls_mid.setColor(0, 1, 0, 1)  # grün
-        # Starte die Linie am grünen Marker.
-        ls_mid.moveTo(green_point_global)
-        # Zeichne beispielsweise eine Linie 1 Einheit lang in +Y-Richtung:
-        ls_mid.drawTo(green_point_global + Vec3(0, 1, 0))
-        fork_center_line = vehicle_node.attachNewNode(ls_mid.create())
-        # Speichere den NodePath der grünen Mittellinie
-        vehicle_node.setPythonTag("fork_center_line", fork_center_line)
-        print("[DEBUG] create_vehicle: Grüne Mittellinie (fork_center_line) gesetzt.")
-
-        # --------------------------
-        # Restliche Fahrzeugteile (Mast, Lenkachse, etc.)
-        # --------------------------
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-        self.add_diagonals_to_mast(mast_node)
-
-        intersection = Vec3(0.5, 0.05, 1.0)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        # --------------------------
-        # Lenkachse erzeugen (Pivot-Node)
-        # --------------------------
-        steering_axis = mast_node.attachNewNode("steering_axis")
-        steering_axis.setPos(0.5, 0.25, -1.2)
-        steering_axis.setH(90)
-        vehicle_node.setPythonTag("steering_axis", steering_axis)
-
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(steering_axis)
-        cylinder_node.setPos(0, 0, 0)
-        self.vehicle_cylinder = steering_axis
-        self.add_steering_arrow(steering_axis, color=(0, 1, 0, 1))
-
-        # --------------------------
-        # Positioniere das Fahrzeug am Parkpunkt
-        # --------------------------
-        if park_point is None:
-            vehicle_node.setPos(0, 0, 0)
-        else:
-            intersection = Vec3(0, 0, 1.0)
-            vehicle_node.setPos(park_point - vehicle_node.getQuat().xform(intersection))
-
-        # ********** Ursprung (Koordinatensystem) am Fahrzeug einzeichnen **********
-        ls_x = LineSegs()
-        ls_x.setThickness(2)
-        ls_x.setColor(LColor(1, 0, 0, 1))
-        ls_x.moveTo(0, 0, 0)
-        ls_x.drawTo(1, 0, 0)
-        vehicle_node.attachNewNode(ls_x.create())
-
-        ls_y = LineSegs()
-        ls_y.setThickness(2)
-        ls_y.setColor(LColor(0, 1, 0, 1))
-        ls_y.moveTo(0, 0, 0)
-        ls_y.drawTo(0, 1, 0)
-        vehicle_node.attachNewNode(ls_y.create())
-
-        ls_z = LineSegs()
-        ls_z.setThickness(2)
-        ls_z.setColor(LColor(0, 0, 1, 1))
-        ls_z.moveTo(0, 0, 0)
-        ls_z.drawTo(0, 0, 1)
-        vehicle_node.attachNewNode(ls_z.create())
-
-        from panda3d.core import TextNode
-        tn_x = TextNode("label_x")
-        tn_x.setText("X")
-        tn_x.setTextColor(1, 0, 0, 1)
-        label_x = vehicle_node.attachNewNode(tn_x)
-        label_x.setScale(0.3)
-        label_x.setPos(2.0, 0, 0)
-
-        tn_y = TextNode("label_y")
-        tn_y.setText("Y")
-        tn_y.setTextColor(0, 1, 0, 1)
-        label_y = vehicle_node.attachNewNode(tn_y)
-        label_y.setScale(0.3)
-        label_y.setPos(0, 2.0, 0)
-
-        tn_z = TextNode("label_z")
-        tn_z.setText("Z")
-        tn_z.setTextColor(0, 0, 1, 1)
-        label_z = vehicle_node.attachNewNode(tn_z)
-        label_z.setScale(0.3)
-        label_z.setPos(0, 0, 2.0)
-
-        return vehicle_node
-
-    def add_steering_arrow(self, steering_axis, color=(0, 1, 0, 1)):
-        """
-        Erzeugt einen Pfeil, der die Vorwärtsrichtung (lokale X-Achse) des Lenkpivots anzeigt.
-        Der Pfeil wird als Kind des übergebenen steering_axis-Node angehängt und passt sich
-        automatisch dessen Rotation an.
-        """
-        arrow_ls = LineSegs()
-        arrow_ls.setThickness(2.0)
-        arrow_ls.setColor(*color)
-
-        # Zeichne eine Linie von (0,0,0) bis (2,0,0) – das ist die Basis des Pfeils
-        arrow_ls.moveTo(0, 0, 0)
-        arrow_ls.drawTo(2, 0, 0)
-
-        # Zeichne den Pfeilkopf: zwei kurze schräge Linien am Ende der Pfeillinie
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, 0.3, 0)
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, -0.3, 0)
-
-        arrow_np = steering_axis.attachNewNode(arrow_ls.create())
-        arrow_np.setPos(0, 0, 0)  # Falls nötig, hier noch zusätzlichen Offset anpassen
-        return arrow_np
-
-    def rotate_around_pivot(self, vehicle, pivot, delta_angle):
-        """
-        Dreht das Fahrzeug (vehicle) um den gegebenen Pivotpunkt (pivot) um delta_angle (in Grad).
-        Dabei wird die Position des Fahrzeugs neu berechnet, sodass es um den Pivot rotiert.
-        """
-        # Aktuelle globale Fahrzeugposition
-        pos = vehicle.getPos(self.render)
-        # Globaler Pivotpunkt
-        pivot_pos = pivot.getPos(self.render)
-        # Berechne den Vektor vom Pivot zum Fahrzeug
-        rel = pos - pivot_pos
-        # Wandle den Drehwinkel in Bogenmaß um
-        rad = math.radians(delta_angle)
-        cos_val = math.cos(rad)
-        sin_val = math.sin(rad)
-        # Drehe den relativen Vektor
-        new_x = rel.getX() * cos_val - rel.getY() * sin_val
-        new_y = rel.getX() * sin_val + rel.getY() * cos_val
-        new_rel = Vec3(new_x, new_y, rel.getZ())
-        # Neue globale Fahrzeugposition
-        new_pos = pivot_pos + new_rel
-        vehicle.setPos(new_pos)
-        # Aktualisiere auch das Heading des Fahrzeugs (aufaddieren des Drehwinkels)
-        vehicle.setH(vehicle.getH() + delta_angle)
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    # ---------------6. Paket- & Auftragsverwaltung---------------
-        # Beispiel einer Methode, die weiterhin auf die extrahierten Umgebungselemente zugreift:
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Je nach gewählter Verteilung kannst du hier Anpassungen vornehmen.
-        # Für den Moment wählen wir einfach zufällig aus allen Abgabestationen,
-        # falls keine spezielle Logik für die Verteilung implementiert ist.
-        target_index = random.randint(1, len(self.abgabe_stations))
-
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def check_and_spawn_packages(self, task):
-        # Verwende den neuen Delay-Wert aus den Einstellungen
-        spawn_delay = self.package_spawn_delay
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-        # Beispiel für eine vorhandene Methode, die auf die Umgebungselemente zugreift:
-    def update_order_table(self):
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen die Stationsnummer (oder verwende "N/A").
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z.B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige den zugewiesenen Fahrzeugnamen an (oder "-" falls noch keiner zugeordnet wurde).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END,
-                                   values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if hasattr(self, 'order_win') and self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    # ---------------7. Cargo-Handling (Pickup, Drop & Timer)---------------
-    def pickup_package(self, vehicle, station):
-        # Falls das Fahrzeug bereits ein Paket trägt, abbrechen.
-        if vehicle.getPythonTag("package_attached"):
-            return
-
-        # Führe den Pickup nur aus, wenn an der Station ein Paket vorhanden ist.
-        if station in self.pickup_packages:
-            # Hole das Paket, den Spawn-Zeitpunkt und den zugehörigen Timer-Knoten.
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            # Entferne den Timer-Knoten, sodass der angezeigte Zähler nicht weiter aktualisiert wird.
-            timer_np.removeNode()
-            # Berechne die Liegedauer (Differenz zwischen aktueller Simulationszeit und Spawn-Zeit).
-            dwell_time = self.sim_clock - spawn_time
-            # Aktualisiere globale Kennzahlen.
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Suche in den Aufträgen nach dem Auftrag, dessen Paket mit diesem Paket übereinstimmt,
-            # und speichere den errechneten Endwert (fixe Liegedauer) sowie den Status.
-            for order_id, order in self.orders.items():
-                if order.get("package") == package:
-                    order["dwell_time"] = dwell_time
-                    order["status"] = "Abgeholt"
-                    break
-
-            # Hole Referenzen zum Gabel-Knoten und zum grünen Marker des Fahrzeugs.
-            fork_node = vehicle.getPythonTag("fork_node")
-            fork_green = vehicle.getPythonTag("fork_green")
-            green_point_pos = fork_green.getPos(fork_node)
-
-            # Übergib das Paket an den Gabel-Knoten (sodass es optisch dem Fahrzeug zugeordnet wird)
-            # und positioniere es relativ zum grünen Marker.
-            package.wrtReparentTo(fork_node)
-            package.setPos(green_point_pos.getX() + 0.5,
-                           green_point_pos.getY() - 0.5,
-                           green_point_pos.getZ() + 1)
-            self.cargos[vehicle] = package
-
-            # Starte den Lieferzeit-Timer: Speichere den Zeitpunkt, an dem das Paket abgeholt wurde,
-            # und hänge einen neuen Timer-Knoten an das Paket.
-            vehicle.setPythonTag("delivery_start_time", self.sim_clock)
-            from panda3d.core import TextNode
-            delivery_timer_text = TextNode("delivery_timer")
-            delivery_timer_text.setText("0.0s")
-            delivery_timer_np = package.attachNewNode(delivery_timer_text)
-            delivery_timer_np.setScale(0.5)
-            delivery_timer_np.setPos(0, 0, 1.2)
-            package.setPythonTag("delivery_timer", delivery_timer_np)
-
-            # Aktualisiere den Zeitpunkt, zu dem an dieser Station zuletzt ein Paket entfernt wurde.
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-
-            # Berechne Lieferzeit:
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start is not None:
-                delivery_time = self.sim_clock - delivery_start
-                self.total_delivery_time += delivery_time
-                self.total_delivery_count += 1
-                self.max_overall_delivery_time = max(self.max_overall_delivery_time, delivery_time)
-                vehicle.clearPythonTag("delivery_start_time")
-
-            # Entferne den Lieferzeit-Timer vom Paket
-            delivery_timer_np = cargo.getPythonTag("delivery_timer")
-            if delivery_timer_np:
-                delivery_timer_np.removeNode()
-
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden das Paket entfernt
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def update_delivery_timers(self, task):
-        for vehicle, package in list(self.cargos.items()):
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start:
-                elapsed_delivery = self.sim_clock - delivery_start
-                delivery_timer_np = package.getPythonTag("delivery_timer")
-                if delivery_timer_np and not delivery_timer_np.isEmpty():
-                    delivery_timer_np.node().setText(f"{elapsed_delivery:.1f}s")
-        return Task.cont
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-
-    # ---------------8. Auftrags-/Fahrzeuglogik---------------
-    def select_next_order(self, vehicle):
-        # Sammle alle Aufträge, die noch "Wartend" sind
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        # Aktualisiere die Dwell-Zeit für jeden Auftrag
-        for order in waiting_orders:
-            order["dwell_time"] = self.sim_clock - order.get("spawn_time", self.sim_clock)
-
-        # Wähle den Auftrag mit der maximalen Dwell-Zeit (evtl. mit etwas Toleranz)
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        # Finde aus den Kandidaten den Auftrag, dessen Pickup-Station (order["pickup_station"])
-        # am nächsten zur aktuellen Fahrzeugposition liegt.
-        vehicle_pos = vehicle.getPos(self.render)
-        candidates.sort(key=lambda order: (order["pickup_station"].getPos(self.render) - vehicle_pos).length())
-        return candidates[0]
-
-    def show_vehicle_control(self):
-        # Falls das Fenster bereits existiert, verwende es und bringe es in den Vordergrund.
-        if hasattr(self, "control_win") and self.control_win.winfo_exists():
-            self.control_win.deiconify()
-            self.control_win.lift()
-            self.control_win.focus_force()
-            return
-
-        self.control_win = tk.Toplevel(self.tk_root)
-        self.control_win.title("Kontrollfenster")
-        self.control_win.protocol("WM_DELETE_WINDOW", self.control_win.withdraw)
-        self.control_win.attributes("-topmost", True)
-        self.control_win.after(100, lambda: self.control_win.attributes("-topmost", False))
-
-        # Fahrzeugsteuerung: Erstelle Widgets für jedes Fahrzeug
-        self.vehicle_state_vars = {}
-        row = 0
-        for veh in self.garage_vehicles:
-            frame = tk.Frame(self.control_win)
-            frame.grid(row=row, column=0, sticky="w", padx=5, pady=2)
-            vid = veh.getPythonTag("vehicle_id")
-            label = tk.Label(frame, text=f"Fahrzeug {vid}")
-            label.pack(side=tk.LEFT)
-            state = veh.getPythonTag("order_state") or "idle"
-            var = tk.StringVar(value=state)
-            self.vehicle_state_vars[veh] = var
-            rb_active = tk.Radiobutton(frame, text="Aufträge bearbeiten", variable=var, value="translate")
-            rb_active.pack(side=tk.LEFT)
-            rb_standby = tk.Radiobutton(frame, text="Standby", variable=var, value="idle")
-            rb_standby.pack(side=tk.LEFT)
-            row += 1
-
-        update_btn = tk.Button(self.control_win, text="Übernehmen", command=self.update_vehicle_control)
-        update_btn.grid(row=row, column=0, pady=5)
-        row += 1
-
-        # Spawn-Einstellungen hinzufügen im selben Fenster in einem Rahmen
-        spawn_frame = tk.LabelFrame(self.control_win, text="Spawn Einstellungen", padx=5, pady=5)
-        spawn_frame.grid(row=row, column=0, sticky="w", padx=5, pady=5)
-
-        # Verzögerungseingabe: persistent per DoubleVar
-        tk.Label(spawn_frame, text="Spawnverzögerung (Sekunden):").grid(row=0, column=0, sticky="w")
-        self.spawn_delay_var = tk.DoubleVar(value=self.package_spawn_delay)
-        delay_entry = tk.Entry(spawn_frame, textvariable=self.spawn_delay_var, width=6)
-        delay_entry.grid(row=0, column=1, sticky="w")
-
-        # Dropdown für Spawn-Verteilung
-        tk.Label(spawn_frame, text="Verteilung:").grid(row=1, column=0, sticky="w")
-        self.spawn_distribution_var = tk.StringVar(value=self.package_spawn_distribution)
-        distribution_options = ["uniform", "clustered", "custom"]
-        distribution_menu = tk.OptionMenu(spawn_frame, self.spawn_distribution_var, *distribution_options)
-        distribution_menu.grid(row=1, column=1, sticky="w")
-
-        # Checkbuttons für Annahmestationen (angenommen, es gibt mindestens 10)
-        tk.Label(spawn_frame, text="Annahmestationen:").grid(row=2, column=0, sticky="w", pady=(5, 0))
-        stations_frame = tk.Frame(spawn_frame)
-        stations_frame.grid(row=3, column=0, columnspan=2, sticky="w")
-
-        # Für jeden Checkbutton verwenden wir persistente BooleanVar-Objekte, die wir in self.spawn_station_vars speichern.
-        # (Überprüfe, ob self.annahme_stations mindestens 10 Elemente hat.)
-        for i in range(min(10, len(self.annahme_stations))):
-            # Bei der Initialisierung in __init__ solltest du self.spawn_station_vars[i] bereits angelegt haben.
-            cb = tk.Checkbutton(stations_frame, text=f"Annahmestation {i + 1}",
-                                variable=self.spawn_station_vars[i])
-            cb.pack(anchor="w")
-
-        def apply_spawn_from_control():
-            self.package_spawn_delay = self.spawn_delay_var.get()
-            self.package_spawn_distribution = self.spawn_distribution_var.get()
-            selected = []
-            for i, var in self.spawn_station_vars.items():
-                if var.get():
-                    selected.append(self.annahme_stations[i])
-            self.package_spawn_stations = selected
-            print(
-                f"Spawn Einstellungen übernommen: Delay={self.package_spawn_delay}s, Distribution={self.package_spawn_distribution}, "
-                f"Stations: {[i + 1 for i, var in self.spawn_station_vars.items() if var.get()]}")
-            # Optional: Hier direkt Pakete an den ausgewählten Annahmestationen spawnen
-            for station in self.package_spawn_stations:
-                self.spawn_package_at_station(station)
-
-        apply_btn = tk.Button(spawn_frame, text="Einstellungen übernehmen und spawnen",
-                              command=apply_spawn_from_control)
-        apply_btn.grid(row=4, column=0, columnspan=2, pady=5)
-
-        def apply_spawn_from_control():
-            self.package_spawn_delay = self.spawn_delay_var.get()
-            self.package_spawn_distribution = self.spawn_distribution_var.get()
-            selected = []
-            for i, var in self.spawn_station_vars.items():
-                if var.get():
-                    selected.append(self.annahme_stations[i])
-            self.package_spawn_stations = selected
-            print(
-                f"Spawn Einstellungen übernommen: Delay={self.package_spawn_delay}s, Distribution={self.package_spawn_distribution}, "
-                f"Stations: {[i + 1 for i, var in self.spawn_station_vars.items() if var.get()]}")
-            # Spawne sofort Pakete an den ausgewählten Annahmestationen
-            for station in self.package_spawn_stations:
-                self.spawn_package_at_station(station)
-
-        apply_btn = tk.Button(spawn_frame, text="Einstellungen übernehmen und spawnen",
-                              command=apply_spawn_from_control)
-        apply_btn.grid(row=4, column=0, columnspan=2, pady=5)
-
-    def show_spawn_control(self):
-        spawn_win = tk.Toplevel(self.tk_root)
-        spawn_win.title("Paketspawn Einstellungen")
-
-        # Eingabefeld für Spawnverzögerung
-        tk.Label(spawn_win, text="Spawnverzögerung (Sekunden):").pack(pady=2)
-        delay_entry = tk.Entry(spawn_win)
-        delay_entry.insert(0, str(self.package_spawn_delay))
-        delay_entry.pack(pady=2)
-
-        # Dropdown für Spawn-Verteilung
-        tk.Label(spawn_win, text="Spawn-Verteilung:").pack(pady=2)
-        distribution_options = ["uniform", "clustered", "custom"]
-        distribution_var = tk.StringVar(value=self.package_spawn_distribution)
-        distribution_menu = tk.OptionMenu(spawn_win, distribution_var, *distribution_options)
-        distribution_menu.pack(pady=2)
-
-        # Frame für Checkboxes der Annahmestationen (angenommen, es gibt 10)
-        tk.Label(spawn_win, text="Annahmestationen auswählen (1-10):").pack(pady=2)
-        stations_frame = tk.Frame(spawn_win)
-        stations_frame.pack(pady=2)
-
-        station_vars = {}
-        # Nutze hier self.annahme_stations (idealerweise 10 Elemente) und beschrifte die Checkbuttons entsprechend.
-        for idx, station in enumerate(self.annahme_stations):
-            var = tk.BooleanVar(value=False)
-            station_label = f"Annahmestation {idx + 1}"
-            cb = tk.Checkbutton(stations_frame, text=station_label, variable=var)
-            cb.pack(anchor="w")
-            station_vars[idx] = var
-
-        def apply_spawn_settings():
-            try:
-                new_delay = float(delay_entry.get())
-            except ValueError:
-                new_delay = self.package_spawn_delay  # Falls die Eingabe fehlerhaft ist
-            new_distribution = distribution_var.get().strip()
-
-            new_stations = []
-            # Sammle alle Stationen, deren Checkboxes angekreuzt sind
-            for idx, var in station_vars.items():
-                if var.get():
-                    new_stations.append(self.annahme_stations[idx])
-
-            self.package_spawn_delay = new_delay
-            self.package_spawn_distribution = new_distribution
-            self.package_spawn_stations = new_stations
-
-            print(f"Spawn-Einstellungen aktualisiert: Delay={new_delay}s, Distribution='{new_distribution}', "
-                  f"Stationen: {[f'Annahmestation {idx + 1}' for idx, var in station_vars.items() if var.get()]}")
-
-            # Sobald die Einstellungen übernommen wurden, spawne sofort Pakete an den ausgewählten Stationen.
-            for station in self.package_spawn_stations:
-                self.spawn_package_at_station(station)
-
-            spawn_win.destroy()
-
-        tk.Button(spawn_win, text="Einstellungen speichern", command=apply_spawn_settings).pack(pady=5)
-
-    def vehicle_order_task(self, vehicle, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-
-        # Frame-Zähler einbauen, um die Frequenz der Modellinferenz zu reduzieren
-        frame_count = vehicle.getPythonTag("frame_count")
-        if frame_count is None:
-            frame_count = 0
-        frame_count += 1
-        vehicle.setPythonTag("frame_count", frame_count)
-
-        # Sensordatenerfassung
-        sensor_data = self.collect_sensor_data(vehicle)
-        import numpy as np
-        # Führe die Modellinferenz nur alle 10 Frames durch, um den Hauptthread zu entlasten
-        if self.tf_model is not None and (frame_count % 10 == 0):
-            input_data = sensor_data.reshape(1, sensor_data.shape[0], sensor_data.shape[1], 1)
-            prediction = self.tf_model.predict(input_data)
-            model_delta_angle = prediction[0][0]
-            print(f"[TF] Modell-Korrektur: {model_delta_angle:.2f}°")
-        else:
-            model_delta_angle = 0.0
-            if self.tf_model is not None:
-                print(f"[TF] Modell-Korrektur übersprungen (Frame Count: {frame_count})")
-            else:
-                print("[TF] Kein Modell vorhanden, Modell-Korrektur wird übersprungen.")
-
-        # Berechne den idealen Korrekturwert (unverändert)
-        ideal_correction = self.compute_ideal_steering_correction(vehicle)
-        print(f"[IDEAL] Ideal berechneter Korrekturwinkel: {ideal_correction:.2f}°")
-
-        # Logge Trainingsdaten nur in der 'translate'-Phase
-        state = vehicle.getPythonTag("order_state")
-        if state == "translate":
-            self.log_training_sample(sensor_data, ideal_correction)
-
-        # Führe die zustandsabhängige Logik aus
-        if state == "translate":
-            self.handle_translate_phase(vehicle, dt)
-        elif state == "rotate":
-            self.handle_rotate_phase(vehicle, dt)
-        elif state == "approach":
-            self.handle_approach_phase(vehicle, dt)
-        elif state == "pickup":
-            self.handle_pickup_phase(vehicle, dt)
-        elif state == "drive_out":
-            self.handle_drive_out_phase(vehicle, dt)
-        elif state == "to_delivery":
-            self.handle_to_delivery_phase(vehicle, dt)
-        elif state == "align_delivery":
-            self.handle_align_delivery_phase(vehicle, dt)
-        elif state == "delivery_center":
-            self.handle_delivery_center_phase(vehicle, dt)
-        elif state == "drop":
-            self.handle_drop_phase(vehicle, dt)
-        elif state == "phase11":
-            self.handle_phase11(vehicle, dt)
-        elif state == "return_to_garage":
-            self.handle_return_to_garage_phase(vehicle, dt)
-        else:
-            print(f"Unbekannter Zustand: {state}")
-
-        return Task.cont
-
-    # -------------------- Handler für einzelne Phasen --------------------
-
-    def handle_translate_phase(self, vehicle, dt):
-        # --- Zusätzlicher Safety-Zweig in der Translate-Phase ---
-        # (1) Zuerst: Falls ein Fahrzeug auf das Ziel (Pickup-Station) wartet, soll gewartet werden.
-        current_order = vehicle.getPythonTag("current_order")
-        station_occupied = False
-        if current_order is not None and "pickup_station" in current_order:
-            pickup_station = current_order["pickup_station"]
-            if self.is_station_occupied(pickup_station, exclude_vehicle=vehicle):
-                station_occupied = True
-                print(
-                    f"[WARTEN] Station {pickup_station.getName()} belegt. Fahrzeug {vehicle.getPythonTag('vehicle_id')} wartet.")
-
-        # (2) Festlegen der Basisgeschwindigkeit:
-        base_speed = 1.5 if not station_occupied else 0.0
-
-        # (3) Kollisionsvermeidung: Passe die Geschwindigkeit an, wenn andere Fahrzeuge in der Nähe sind.
-        adjusted_speed = self.collision_avoidance_adjustment(vehicle, base_speed)
-
-        # --- Rest der originalen Translate-Logik ---
-        # Falls kein Auftrag zugeordnet, versuche einen neuen Auftrag zu wählen.
-        if current_order is None:
-            next_order = self.select_next_order(vehicle)
-            if next_order is not None:
-                next_order["status"] = "In Bearbeitung"
-                next_order["vehicle"] = f"Fahrzeug {vehicle.getPythonTag('vehicle_id')}"
-                vehicle.setPythonTag("current_order", next_order)
-                print(f"Auftrag {next_order['id']} wird zugewiesen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}.")
-            current_order = vehicle.getPythonTag("current_order")
-
-        # Bestimme das Ziel: Zum Beispiel den blauen Marker der Pickup-Station.
-        if current_order is not None:
-            pickup_station = current_order.get("pickup_station")
-            if pickup_station in self.station_blue_dots:
-                target = self.station_blue_dots[pickup_station].getPos(self.render)
-            else:
-                target = self.blue_dot.getPos(self.render)
-        else:
-            target = self.blue_dot.getPos(self.render)
-
-        current_pos = vehicle.getPos(self.render)
-        pivot = vehicle.getPythonTag("steering_axis")
-
-        # Berechne den Offset-Punkt, von dem aus das Fahrzeug navigiert.
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        import math
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-        heading_error = desired_heading_rad - current_heading_rad
-        while heading_error > math.pi:
-            heading_error -= 2 * math.pi
-        while heading_error < -math.pi:
-            heading_error += 2 * math.pi
-
-        # Berechne den Drehwinkel (gilt für die Korrektur) – normale Drehung.
-        gain = 1.0
-        max_delta = gain * dt
-        delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-        self.rotate_around_pivot(vehicle, pivot, math.degrees(delta_heading_rad))
-
-        # Jetzt Vorwärtsbewegung: Verwende dafür die angepasste Geschwindigkeit.
-        global_hpr = pivot.getNetTransform().getHpr()
-        new_heading_rad = math.radians(global_hpr.getX())
-        new_x = current_pos.getX() + adjusted_speed * math.cos(new_heading_rad) * dt
-        new_y = current_pos.getY() + adjusted_speed * math.sin(new_heading_rad) * dt
-        new_pos = Vec3(new_x, new_y, 0)
-        vehicle.setPos(new_pos)
-
-        # Wenn das Fahrzeug nahe genug am Ziel ist, wechsle den Zustand in die Rotationsphase.
-        new_offset_pos = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        if (target - new_offset_pos).length() < 0.1:
-            vehicle.setPythonTag("order_state", "rotate")
-
-        return Task.cont
-
-    def handle_rotate_phase(self, vehicle, dt):
-        import math
-        from panda3d.core import Vec3
-
-        # 1. Hole den grünen Referenzpunkt (fork_green) der Gabel.
-        fork_green = vehicle.getPythonTag("fork_green")
-        if not fork_green or fork_green.isEmpty():
-            print("[DEBUG] handle_rotate_phase: Kein fork_green gefunden!")
-            return
-
-        # 2. Hole den aktuellen Auftrag und die zugehörige Pickup-Station.
-        current_order = vehicle.getPythonTag("current_order")
-        if not current_order or "pickup_station" not in current_order:
-            print("[DEBUG] handle_rotate_phase: Kein aktueller Auftrag oder Station gefunden!")
-            return
-        station = current_order["pickup_station"]
-
-        # Hole den Referenzpunkt der Station (white_center) und den Richtungsvektor (white_direction)
-        white_center = station.getPythonTag("white_center")
-        if white_center is None:
-            print("[DEBUG] handle_rotate_phase: Kein white_center in der Station gefunden!")
-            return
-        target = white_center  # Ziel: Mittelpunkt der weißen Linie
-
-        # 3. Berechne den Drehpunkt des Fahrzeugs.
-        pivot = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-
-        # 4. Falls sich der pivot nahe am Ziel befindet, final: Setze die exakte Ausrichtung.
-        distance = (target - pivot).length()
-        stop_threshold = 0.5  # Schwellenwert, evtl. an Modelldimensionen anpassen
-        if distance < stop_threshold:
-            desired_vector = target - pivot
-            desired_angle = math.degrees(math.atan2(desired_vector.getY(), desired_vector.getX())) + 90
-            desired_angle %= 360
-            vehicle.setH(self.render, desired_angle)
-            print(f"[DEBUG] final step: Fahrzeugheading auf {desired_angle:.2f}° gesetzt.")
-
-            # Final: Richte den grünen Richtungspfeil ("fork_center_line") exakt aus.
-            white_direction = station.getPythonTag("white_direction")
-            if white_direction is not None:
-                desired_arrow_angle = math.degrees(math.atan2(white_direction.getY(), white_direction.getX()))
-                arrow_relative = (desired_arrow_angle - desired_angle + 180) % 360 - 180
-                fork_center_line = vehicle.getPythonTag("fork_center_line")
-                if fork_center_line:
-                    fork_center_line.setH(arrow_relative)
-                    print(f"[DEBUG] final step: Grüner Pfeil auf relativen Winkel {arrow_relative:.2f}° gesetzt.")
-            # Hier ändern wir den Zustand in 'approach' statt "next_phase"
-            vehicle.setPythonTag("order_state", "approach")
-            return
-
-        # 5. Andernfalls: Berechne den gewünschten globalen Winkel (inklusive +90°-Offset)
-        desired_vector = target - pivot
-        desired_angle = math.degrees(math.atan2(desired_vector.getY(), desired_vector.getX())) + 90
-        desired_angle %= 360
-
-        # 6. Ermittle den aktuellen Fahrzeugheading in Weltkoordinaten und berechne die Winkelabweichung.
-        current_heading = vehicle.getH(self.render)
-        angle_diff = (desired_angle - current_heading + 180) % 360 - 180
-
-        if abs(angle_diff) < 2.0:
-            vehicle.setH(self.render, desired_angle)
-            white_direction = station.getPythonTag("white_direction")
-            if white_direction is not None:
-                desired_arrow_angle = math.degrees(math.atan2(white_direction.getY(), white_direction.getX()))
-                arrow_relative = (desired_arrow_angle - desired_angle + 180) % 360 - 180
-                fork_center_line = vehicle.getPythonTag("fork_center_line")
-                if fork_center_line:
-                    fork_center_line.setH(arrow_relative)
-                    print(f"[DEBUG] fine alignment: Grüner Pfeil auf {arrow_relative:.2f}° gesetzt.")
-            # Ändere auch hier sofort den Zustand in "approach"
-            vehicle.setPythonTag("order_state", "approach")
-            return
-
-        # 7. Begrenze die Drehung pro Frame (z.B. 20,9° pro Sekunde)
-        max_rotation_speed = 20.9  # Grad pro Sekunde
-        max_delta = max_rotation_speed * dt
-        delta_angle = max(-max_delta, min(max_delta, angle_diff))
-
-        # 8. Drehe das Fahrzeug schrittweise um delta_angle
-        temp_pivot = self.render.attachNewNode("temp_pivot")
-        temp_pivot.setPos(pivot)
-        self.rotate_around_pivot(vehicle, temp_pivot, delta_angle)
-        temp_pivot.removeNode()
-
-        print(f"[DEBUG] rotating: Gedreht um {delta_angle:.2f}°; Restliche Differenz: {angle_diff - delta_angle:.2f}°")
-
-    def handle_approach_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None:
-            pickup_station = current_order.get("pickup_station")
-            target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-        else:
-            target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-        current = vehicle.getPos(self.render)
-        error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-        if error_vec.length() > 0.05:
-            direction = error_vec.normalized()
-            move_distance = 1.5 * dt
-            new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                           current.getY() + direction.getY() * move_distance, target.getZ())
-            vehicle.setPos(new_pos)
-        else:
-            vehicle.setPos(target)
-            vehicle.setPythonTag("order_state", "pickup")
-
-    def handle_pickup_phase(self, vehicle, dt):
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        target_z = 1.0
-        raise_speed = 0.5
-        if current_z < target_z:
-            fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-        else:
-            if vehicle.getPythonTag("current_order") is None:
-                if self.orders_queue:
-                    vehicle.setPythonTag("current_order", self.orders_queue.pop(0))
-                else:
-                    print(
-                        f"Keine verfügbaren Aufträge für Fahrzeug {vehicle.getPythonTag('vehicle_id')}. Überspringe Pickup-Phase.")
-                    vehicle.setPythonTag("order_state", "drive_out")
-                    return
-            if not vehicle.getPythonTag("package_attached"):
-                pickup_station = vehicle.getPythonTag("current_order")["pickup_station"]
-                self.pickup_package(vehicle, pickup_station)
-                vehicle.setPythonTag("package_attached", True)
-            if vehicle.getPythonTag("drive_out_target") is None:
-                vehicle.setPythonTag("drive_out_target",
-                                     vehicle.getPos(self.render) + vehicle.getQuat(self.render).getForward() * 5.0)
-            vehicle.setPythonTag("order_state", "drive_out")
-
-    def handle_drive_out_phase(self, vehicle, dt):
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        if current_z > 0:
-            lower_speed = 0.5
-            fork_node.setZ(max(0, current_z - lower_speed * dt))
-        current_pos = vehicle.getPos(self.render)
-        drive_out_target = vehicle.getPythonTag("drive_out_target")
-        if drive_out_target is None:
-            drive_out_target = current_pos + vehicle.getQuat(self.render).getForward() * 5.0
-            vehicle.setPythonTag("drive_out_target", drive_out_target)
-        diff = drive_out_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            vehicle.setPythonTag("order_state", "to_delivery")
-            vehicle.setPythonTag("drive_out_target", None)
-
-    def handle_to_delivery_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is None:
-            return Task.cont
-
-        # Bestimme den Zielpunkt der Abgabestation:
-        delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-        try:
-            target_index = int(delivery_target_str.split()[-1])
-        except ValueError:
-            target_index = 1
-        if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-            target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-        else:
-            target = self.abgabe_blue_dots[0].getPos(self.render)
-
-        # Prüfe, ob die Abgabestation bereits durch ein Fahrzeug,
-        # das aktuell ein Paket abgibt oder in der Drop-Phase ist, besetzt ist.
-        if self.is_delivery_station_occupied(target, exclude_vehicle=vehicle, occupancy_threshold=1.0):
-            print(f"[WARTEN] Abgabestation belegt. Fahrzeug {vehicle.getPythonTag('vehicle_id')} wartet.")
-            return Task.cont  # Das Fahrzeug setzt keine Bewegung fort
-
-        # Falls die Abgabestation frei ist, folgt der übliche Bewegungs- und Drehvorgang:
-        current_pos = vehicle.getPos(self.render)
-        pivot = vehicle.getPythonTag("steering_axis")
-        import math
-        desired_heading_rad = math.atan2(target.getY() - current_pos.getY(),
-                                         target.getX() - current_pos.getX())
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-        heading_error = desired_heading_rad - current_heading_rad
-        while heading_error > math.pi:
-            heading_error -= 2 * math.pi
-        while heading_error < -math.pi:
-            heading_error += 2 * math.pi
-        gain = 1.0
-        max_delta = gain * dt
-        delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-        self.rotate_around_pivot(vehicle, pivot, math.degrees(delta_heading_rad))
-
-        # Vorwärtsbewegung:
-        new_heading_rad = math.radians(pivot.getNetTransform().getHpr().getX())
-        speed = 1.5  # Basisgeschwindigkeit
-        new_x = current_pos.getX() + speed * math.cos(new_heading_rad) * dt
-        new_y = current_pos.getY() + speed * math.sin(new_heading_rad) * dt
-        new_pos = Vec3(new_x, new_y, 0)
-        vehicle.setPos(new_pos)
-
-        # Falls das Fahrzeug nahe genug am Ziel ist, wechsele den Zustand:
-        if (target - new_pos).length() < 0.5:
-            print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat die Abgabestation erreicht.")
-            vehicle.setPythonTag("order_state", "align_delivery")
-
-        return Task.cont
-
-    def handle_align_delivery_phase(self, vehicle, dt):
-        desired_heading = 90.0
-        current_heading = vehicle.getH() % 360
-        angle_diff = ((desired_heading - current_heading + 180) % 360) - 180
-        print(
-            f"Phase 8: Align Delivery | Fahrzeug {vehicle.getPythonTag('vehicle_id')}: Current {current_heading:.2f}°, Desired {desired_heading:.2f}°, Diff {angle_diff:.2f}°")
-        fixed_turn_speed = 90.0
-        turn_amount = fixed_turn_speed * dt
-        if abs(angle_diff) < 1.0:
-            vehicle.setH(desired_heading)
-            print(
-                f"Phase 8 abgeschlossen: Fahrzeug {vehicle.getPythonTag('vehicle_id')} ausgerichtet (Heading = {desired_heading:.2f}°).")
-            vehicle.setPythonTag("order_state", "delivery_center")
-        else:
-            new_heading = current_heading + (turn_amount if angle_diff > 0 else -turn_amount)
-            new_heading %= 360
-            vehicle.setH(new_heading)
-            print(f"Phase 8: Rotating - Fahrzeug {vehicle.getPythonTag('vehicle_id')} New Heading: {new_heading:.2f}°")
-
-    def handle_delivery_center_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is None:
-            return
-        delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-        try:
-            target_index = int(delivery_target_str.split()[-1])
-        except ValueError:
-            target_index = 1
-        if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-            blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-        else:
-            blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-        current = vehicle.getPos(self.render)
-        target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-        print(f"Phase 9: Zielpunkt der Abgabestation für Fahrzeug {vehicle.getPythonTag('vehicle_id')}: {target_point}")
-        error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-        tolerance = 0.05
-        move_distance = 1.5 * dt
-        if error_vec.length() > tolerance:
-            direction = error_vec.normalized()
-            new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                           current.getY() + direction.getY() * move_distance, current.getZ())
-            vehicle.setPos(new_pos)
-            print(f"Phase 9: Fahrzeug {vehicle.getPythonTag('vehicle_id')} bewegt sich von {current} nach {new_pos}")
-        else:
-            vehicle.setPos(target_point)
-            print(f"Phase 9: Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den Zielpunkt erreicht.")
-            vehicle.setPythonTag("order_state", "drop")
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_fork_z = fork_node.getZ()
-        if current_fork_z < 1.0:
-            new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-            fork_node.setZ(new_fork_z)
-            print(
-                f"Phase 9: Gabel wird angehoben für Fahrzeug {vehicle.getPythonTag('vehicle_id')} (Z = {new_fork_z}).")
-
-    def handle_drop_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if vehicle.getPythonTag("package_attached"):
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            # (Bei Bedarf kann man hier noch Zielpositionen abfragen.)
-            self.drop_cargo(vehicle)
-            print(f"Phase 10: Paket abgesetzt für Fahrzeug {vehicle.getPythonTag('vehicle_id')}")
-            vehicle.setPythonTag("package_attached", False)
-        else:
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            if current_z > 0:
-                lower_speed = 0.5
-                new_z = max(0, current_z - lower_speed * dt)
-                fork_node.setZ(new_z)
-                print(
-                    f"Phase 10: Gabel wird abgesenkt für Fahrzeug {vehicle.getPythonTag('vehicle_id')}, aktueller Z-Wert: {new_z}")
-            else:
-                print(f"Phase 10: Dropoff abgeschlossen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}")
-                if vehicle.getPythonTag("standby_pending"):
-                    vehicle.setPythonTag("order_state", "return_to_garage")
-                    print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} kehrt zur Garage zurück (Standby).")
-                else:
-                    vehicle.setPythonTag("order_state", "translate")
-                current_order["status"] = "Abgegeben"
-                current_order["delivered_at"] = self.sim_clock
-                vehicle.clearPythonTag("current_order")
-
-    def handle_phase11(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if vehicle.getPythonTag("last_delivery_marker") is not None:
-            target_point = vehicle.getPythonTag("last_delivery_marker")
-        else:
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                target_point = self.abgabe_blue_dots[0].getPos(self.render)
-        print(f"Phase 11: Zielpunkt (blauer Marker) für Fahrzeug {vehicle.getPythonTag('vehicle_id')}: {target_point}")
-        current_pos = vehicle.getPos(self.render)
-        diff = target_point - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            vehicle.setPos(new_pos)
-            print(
-                f"Phase 11: Fahrzeug {vehicle.getPythonTag('vehicle_id')} fährt aus der Station, neue Position: {new_pos}")
-        else:
-            vehicle.setPos(target_point)
-            print(
-                f"Phase 11: Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den blauen Marker erreicht. Nächster Auftrag wird gestartet.")
-            vehicle.setPythonTag("order_state", "next_order")
-
-    def handle_return_to_garage_phase(self, vehicle, dt):
-        garage_target = vehicle.getPythonTag("garage_target")
-        if garage_target is None:
-            garage_target = self.garagen_parking_points[0]
-        current_pos = vehicle.getPos(self.render)
-        diff = garage_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 1.0 * dt
-            new_pos = current_pos + diff.normalized() * move_distance
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            if vehicle.hasPythonTag("start_heading"):
-                vehicle.setH(vehicle.getPythonTag("start_heading"))
-            vehicle.setPythonTag("order_state", "idle")
-            vehicle.setPythonTag("standby_pending", False)
-            print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} ist in der Garage (Standby).")
-
-    def collect_sensor_data(self, vehicle, sensor_range=5, grid_resolution=0.5):
-        """
-        Erzeugt ein einfaches 2D-Occupancy-Grid, das den Bereich um das Fahrzeug simuliert.
-
-        Parameter:
-          sensor_range: Radius (in Welt-Einheiten) um das Fahrzeug.
-          grid_resolution: Größe der einzelnen Zellen im Grid.
-
-        Rückgabe:
-          Ein NumPy-Array (2D) mit 0 (frei) als Platzhalter.
-        """
-        import numpy as np
-        grid_size = int((sensor_range * 2) / grid_resolution)
-        sensor_grid = np.zeros((grid_size, grid_size))
-        # --- Hier kannst du später echte Kollisionsabfragen oder Ray-Casting integrieren ---
-        return sensor_grid
-
-    def compute_ideal_steering_correction(self, vehicle):
-        """
-        Berechnet einen idealen Korrekturwinkel (in Grad) für die Navigation in der 'translate'-Phase.
-        Es wird ein vereinfachtes Modell genutzt, das den Unterschied zwischen dem gewünschten und dem aktuellen
-        Heading (über die Fahrzeug-Steuerachse) ermittelt.
-        """
-        import math
-
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None and "pickup_station" in current_order:
-            pickup_station = current_order["pickup_station"]
-            if pickup_station in self.station_blue_dots:
-                target = self.station_blue_dots[pickup_station].getPos(self.render)
-            else:
-                target = self.blue_dot.getPos(self.render)
-        else:
-            target = self.blue_dot.getPos(self.render)
-
-        current_pos = vehicle.getPos(self.render)
-        # Bestimme einen Offset-Punkt, basierend auf der bereits existierenden pickup_offset
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        # Berechne den gewünschten Heading-Winkel (in Radiant): Richtung von offset_pos zu target
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-
-        # Hole den aktuellen Heading-Wert vom Steuerachsen-Node (pivot)
-        pivot = vehicle.getPythonTag("steering_axis")
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-
-        ideal_correction_rad = desired_heading_rad - current_heading_rad
-        # Winkelbereich anpassen [-pi, pi]
-        while ideal_correction_rad > math.pi:
-            ideal_correction_rad -= 2 * math.pi
-        while ideal_correction_rad < -math.pi:
-            ideal_correction_rad += 2 * math.pi
-
-        return math.degrees(ideal_correction_rad)
-
-    def log_training_sample(self, sensor_data, ideal_angle):
-        """
-        Speichert ein Trainingssample bestehend aus den gesammelten Sensorwerten und dem idealen Korrekturwinkel.
-        """
-        self.training_data.append((sensor_data.copy(), ideal_angle))
-        # Optional: Gib eine Debug-Ausgabe aus, um das Logging zu überwachen.
-        print(
-            f"[LOG] Trainingssample gespeichert: Ideal Correction = {ideal_angle:.2f}°, Sensor Shape = {sensor_data.shape}")
-
-    def apply_safety_rules(self, vehicle, sensor_data, model_delta_angle, ideal_correction):
-        """
-        Kombiniert den vom Modell (model_delta_angle) und den ideal berechneten Korrekturwert (ideal_correction)
-        nur dann mit einem festen Sicherheitswert, wenn die Sensordaten einen kritischen Occupancy-Level anzeigen.
-
-        Falls der Occupancy-Level niedrig ist, wird ausschließlich der ideal vorhandene Korrekturwert verwendet.
-        """
-        import numpy as np
-        # Beispiel: Untersuche die mittlere Zeile des sensor_data-Grids als Indikator für frontale Hindernisse
-        middle_row = sensor_data[sensor_data.shape[0] // 2]
-        occupancy_level = np.sum(middle_row)
-
-        # Definiere einen kritischen Schwellenwert (diesen Wert ggf. anpassen)
-        threshold = 1.0
-
-        if occupancy_level > threshold:
-            print(
-                f"[RULE] Kritischer Occupancy-Level = {occupancy_level:.2f} erkannt. Sicherheitskorrektur wird angewendet.")
-            # Hier legen wir fest, dass in kritischen Situationen der Sicherheitswert stärker gewichtet wird.
-            safety_correction = 15.0  # z. B. 15° als feste Korrektur (Wert anpassen)
-            # Gewichteter Ansatz: Sicherheitskorrektur dominiert, während ein kleiner Anteil des idealen Wertes einfließt.
-            final_angle = 0.7 * safety_correction + 0.3 * ideal_correction
-        else:
-            # Wenn kein kritischer Wert vorliegt, einfach den ideal berechneten Korrekturwert verwenden.
-            final_angle = ideal_correction
-
-        return final_angle
-
-    def collision_avoidance_adjustment(self, current_vehicle, base_speed, safe_distance=3.0):
-        current_pos = current_vehicle.getPos(self.render)
-        adjusted_speed = base_speed
-        # Berechne einen Basisfaktor (z.B. basierend auf Abstand zu anderen Fahrzeugen):
-        for veh in self.garage_vehicles:
-            if veh == current_vehicle:
-                continue
-            other_pos = veh.getPos(self.render)
-            distance = (current_pos - other_pos).length()
-            if distance < safe_distance:
-                factor = (distance / safe_distance) ** 2
-                candidate_speed = base_speed * factor
-                if candidate_speed < adjusted_speed:
-                    adjusted_speed = candidate_speed
-
-        # Hier integrieren wir den RL-Ausdruck:
-        # Nehme als Zustandsvektor bspw. [min_distance_to_others, current_speed]
-        min_distance = min(
-            [(current_pos - v.getPos(self.render)).length() for v in self.garage_vehicles if v != current_vehicle])
-        current_speed = self.current_speed  # oder eine entsprechende Eigenschaft des Fahrzeugs
-        state = [min_distance, current_speed]
-
-        # Angenommen, du hast für jedes Fahrzeug einen eigenen RL-Agenten (oder einen globalen)
-        action = self.rl_agent.select_action(state)
-        # Definiere, wie Aktion in einen zusätzlichen Bremsfaktor übersetzt wird:
-        # Beispiel: Aktion 0: kein zusätzlicher Bremsfaktor, 1: 20% Reduktion, 2: 50% Reduktion
-        action_to_factor = {0: 1.0, 1: 0.8, 2: 0.5}
-        braking_factor = action_to_factor.get(action, 1.0)
-        adjusted_speed *= braking_factor
-
-        return adjusted_speed
-
-    def is_station_occupied(self, station, exclude_vehicle=None, occupancy_threshold=1.0):
-        """
-        Prüft, ob sich bereits ein Fahrzeug an der gegebenen Station (z. B. Pickup‑Station)
-        befindet. Dabei wird als Zielpunkt zumeist der blaue Marker genutzt, der der Station
-        zugeordnet ist. Das Fahrzeug exclude_vehicle (z. B. das aktuell agierende Fahrzeug)
-        wird dabei nicht berücksichtigt.
-        """
-        # Falls ein blauer Marker vorhanden ist, nutze dessen Position als Zielort:
-        if hasattr(self, 'station_blue_dots') and station in self.station_blue_dots:
-            station_pos = self.station_blue_dots[station].getPos(self.render)
-        else:
-            station_pos = station.getPos(self.render)
-        for veh in self.garage_vehicles:
-            if veh == exclude_vehicle:
-                continue
-            if (veh.getPos(self.render) - station_pos).length() < occupancy_threshold:
-                return True
-        return False
-
-    def is_delivery_station_occupied(self, target_pos, exclude_vehicle=None, occupancy_threshold=1.0):
-        """
-        Prüft, ob sich ein Fahrzeug in der Nähe der Abgabestation (target_pos) befindet,
-        welches in einer Lieferphase (z. B. drop, delivery_center oder align_delivery) ist oder noch ein Paket
-        transportiert (package_attached = True). Das Fahrzeug exclude_vehicle (z. B. das aktuell anfahrende Fahrzeug)
-        wird dabei nicht berücksichtigt.
-        """
-        for veh in self.garage_vehicles:
-            if veh == exclude_vehicle:
-                continue
-            # Hole den aktuellen Zustand und ob ein Paket noch angebracht ist.
-            state = veh.getPythonTag("order_state")
-            package_attached = veh.getPythonTag("package_attached")
-            if state in ["drop", "delivery_center", "align_delivery"] or package_attached:
-                if (veh.getPos(self.render) - target_pos).length() < occupancy_threshold:
-                    return True
-        return False
-
-    def check_collisions(self):
-        collision_threshold = 1.0  # z. B. wenn Fahrzeuge näher als 1 Einheit sind
-        collisions = []
-        for i in range(len(self.garage_vehicles)):
-            veh1 = self.garage_vehicles[i]
-            pos1 = veh1.getPos(self.render)
-            for j in range(i + 1, len(self.garage_vehicles)):
-                veh2 = self.garage_vehicles[j]
-                pos2 = veh2.getPos(self.render)
-                if (pos1 - pos2).length() < collision_threshold:
-                    collisions.append((veh1, veh2))
-        return collisions
-
-    def update_rl_on_collisions(self):
-        collisions = self.check_collisions()
-        for veh1, veh2 in collisions:
-            # Für jedes beteiligte Fahrzeug:
-            for veh in (veh1, veh2):
-                # Erstelle einen Zustandsvektor – analog zum, der in collision_avoidance_adjustment verwendet wird.
-                current_pos = veh.getPos(self.render)
-                min_distance = min([(current_pos - v.getPos(self.render)).length()
-                                    for v in self.garage_vehicles if v != veh])
-                current_speed = self.current_speed  # oder fahrzeugspezifisch
-                state = [min_distance, current_speed]
-                # Nehme an, die letzte von deinem Agenten gewählte Aktion ist gespeichert (das könntest du in einem PythonTag ablegen)
-                last_action = veh.getPythonTag("last_braking_action")
-
-                # Definiere den negativen Reward
-                reward = -10
-                # Erfasse den nächsten Zustand (nach Entfernen des Kollisionsereignisses oder nach einer kurzen Verzögerung)
-                next_state = state  # In einem echten Setup wäre hier der nächste gemessene Zustand
-                self.rl_agent.update(state, last_action, reward, next_state)
-                print(f"RL-Update für Fahrzeug {veh.getPythonTag('vehicle_id')}: Kollisionsreward {reward} vergeben.")
-
-import random
-import numpy as np
-
-class RLAgent:
-    def __init__(self, state_bins, action_space, learning_rate=0.1, discount_factor=0.9, epsilon=0.2):
-        """
-        state_bins: Tuple oder Liste, um kontinuierliche Zustände zu diskretisieren (z.B. (max_distance, num_bins))
-        action_space: Liste diskreter Aktionen (z.B. [0, 1, 2] --> 0: keine Bremsung, 1: leicht, 2: stark)
-        """
-        self.state_bins = state_bins
-        self.action_space = action_space
-        self.lr = learning_rate
-        self.gamma = discount_factor
-        self.epsilon = epsilon
-        # Initialisiere Q-Tabelle als Dictionary: key: (discretisierter_state), value: Liste von Q-Werten pro Aktion
-        self.q_table = {}
-
-    def discretize_state(self, state):
-        """
-        Nimmt einen Zustandsvektor (z.B. [distance, speed]) und gibt einen diskreten Zustand zurück.
-        Hier ein Beispiel: Falls state[0] = Abstand und state[1] = Geschwindigkeit.
-        """
-        # Beispiel: Wir nehmen an, dass state_bins = ((max_distance, num_bins), (max_speed, num_bins))
-        discrete_state = []
-        for i, (max_val, bins) in enumerate(self.state_bins):
-            # Begrenze state[i] um max_val:
-            val = min(state[i], max_val)
-            bin_size = max_val / bins
-            discrete_state.append(int(val // bin_size))
-        return tuple(discrete_state)
-
-    def select_action(self, state):
-        discrete_state = self.discretize_state(state)
-        if discrete_state not in self.q_table:
-            self.q_table[discrete_state] = [0.0 for _ in self.action_space]
-        # Epsilon-greedy Auswahl:
-        if random.random() < self.epsilon:
-            return random.choice(self.action_space)
-        else:
-            q_values = self.q_table[discrete_state]
-            return self.action_space[np.argmax(q_values)]
-
-    def update(self, state, action, reward, next_state):
-        s = self.discretize_state(state)
-        s_next = self.discretize_state(next_state)
-        if s not in self.q_table:
-            self.q_table[s] = [0.0 for _ in self.action_space]
-        if s_next not in self.q_table:
-            self.q_table[s_next] = [0.0 for _ in self.action_space]
-        a_index = self.action_space.index(action)
-        # Q-Learning Update-Regel:
-        best_next = max(self.q_table[s_next])
-        self.q_table[s][a_index] += self.lr * (reward + self.gamma * best_next - self.q_table[s][a_index])
-
-
-if __name__ == "__main__":
-    # Wichtig: setze auf Windows die Startmethode auf "spawn"
-    multiprocessing.set_start_method('spawn')
-
-    # Erzeuge eine Queue, auch wenn sie später eventuell neu erstellt wird, wenn "G" gedrückt wird.
-    graph_q = Queue()
-    app = LagerSimulation(graph_q)
-    app.run()
-
-    # Beim Schließen der Simulation den Graphprozess ggf. beenden
-    if app.graph_process is not None:
-        app.graph_process.terminate()
-        app.graph_process.join()
\ No newline at end of file
Index: TestFFZ/TestFFZ7.py
===================================================================
diff --git a/TestFFZ/TestFFZ7.py b/TestFFZ/TestFFZ7.py
deleted file mode 100644
--- a/TestFFZ/TestFFZ7.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,550 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs,
-    CardMaker
-)
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-# Globaler Clock (wird für die Zeitberechnung genutzt)
-globalClock = ClockObject.getGlobalClock()
-
-
-# =============================================================================
-# Klasse: SimulationSurface
-# =============================================================================
-class SimulationSurface(ShowBase):
-    def __init__(self):
-        super().__init__()
-        # Basisparameter und Statistik
-        self.base_speed = 1.5  # Maximalgeschwindigkeit (m/s)
-        self.speed_factor = 1.0
-        self.sim_clock = 0.0
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-        self.sim_start_real = globalClock.getFrameTime()
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        # Umgebung, Stationen, UI, Tasks & Graph aufbauen
-        self.setup_environment()
-        self.setup_stations()
-        self.setup_UI()
-        self.setup_tasks()
-        self.setup_graph()
-
-        # Mausevents (Zoom)
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-    def setup_environment(self):
-        self.erzeuge_licht()
-        self.boden = self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-    def setup_stations(self):
-        # Erzeuge Pickup-Station (bei x = -9) und Drop-Station (bei x = 9, y = 4)
-        self.pickup_station = self.erzeuge_gitterbox(-9, 0, 0, LColor(1, 0, 0, 1))
-        self.drop_station = self.erzeuge_gitterbox(9, 4, 0, LColor(0, 1, 0, 1))
-
-        # Zeichne Align-Punkte zur besseren Orientierung an der Pickup-Station
-        ls1 = LineSegs()
-        ls1.setThickness(3.0)
-        ls1.setColor(LColor(1, 1, 1, 1))
-        p1 = self.pickup_station.getPos(self.render)
-        ls1.moveTo(p1)
-        ls1.drawTo(p1 + Vec3(2, 0, 0))
-        self.render.attachNewNode(ls1.create())
-
-        # Parallele Linie bei der Pickup-Station (1 Einheit Offset in Y-Richtung)
-        ls1_parallel = LineSegs()
-        ls1_parallel.setThickness(3.0)
-        ls1_parallel.setColor(LColor(1, 1, 1, 1))
-        ls1_parallel.moveTo(p1 + Vec3(0, 1, 0))
-        ls1_parallel.drawTo(p1 + Vec3(2, 0, 0) + Vec3(0, 1, 0))
-        self.render.attachNewNode(ls1_parallel.create())
-
-        # Zeichne Align-Punkte zur besseren Orientierung an der Drop-Station
-        ls2 = LineSegs()
-        ls2.setThickness(3.0)
-        ls2.setColor(LColor(1, 1, 1, 1))
-        p2 = self.drop_station.getPos(self.render)
-        ls2.moveTo(p2)
-        ls2.drawTo(p2 + Vec3(-2, 0, 0))
-        self.render.attachNewNode(ls2.create())
-
-        # Parallele Linie bei der Drop-Station (1 Einheit Offset in Y-Richtung)
-        ls2_parallel = LineSegs()
-        ls2_parallel.setThickness(3.0)
-        ls2_parallel.setColor(LColor(1, 1, 1, 1))
-        ls2_parallel.moveTo(p2 + Vec3(0, 1, 0))
-        ls2_parallel.drawTo(p2 + Vec3(-2, 0, 0) + Vec3(0, 1, 0))
-        self.render.attachNewNode(ls2_parallel.create())
-
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-    def setup_UI(self):
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-    def setup_tasks(self):
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-
-    def setup_graph(self):
-        self.graph_opened = False
-        self.accept("g", self.open_graph)
-        self.graph_data = []
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in [self.pickup_station, self.drop_station]:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            current_max = max(current_max, elapsed)
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        current_text = f"Liegedauer (aktuell): {current_max:.1f}s" if current_max > 0 else "Kein Paket"
-        maximal_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-        avg_val = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        delivered = self.delivered_packages
-        ppm = delivered / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\nAbgegebene Pakete: {delivered}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n{current_text}\n{maximal_text}\n"
-            f"Durchschn. Liegedauer: {avg_val:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.setTitle("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.setTitle("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n = 0
-        mi = -center_extent - 0.5
-        ma = center_extent + 0.5
-        y = mi
-        while y <= ma:
-            writer.addData3(mi, y, 0)
-            writer.addData3(ma, y, 0)
-            lines.addVertices(n, n + 1)
-            n += 2
-            y += cell_size
-        x = mi
-        while x <= ma:
-            writer.addData3(x, mi, 0)
-            writer.addData3(x, ma, 0)
-            lines.addVertices(n, n + 1)
-            n += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        box = self.loader.loadModel("models/box")
-        box.setScale(1, 1, 1)
-        box.setPos(x, y, z)
-        box.setColor(farbe)
-        box.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        box.reparentTo(self.render)
-        return box
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        cube = self.loader.loadModel("models/box")
-        cube.setScale(1, 1, 1)
-        cube.setPos(x, y, z + 1)
-        cube.setColor(farbe)
-        cube.reparentTo(self.render)
-        return cube
-
-    def draw_coordinate_axes(self, axis_length=5):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), LColor(1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), LColor(0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), LColor(0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        curr = lens.getFov()[0]
-        new = max(10, curr - 5)
-        lens.setFov(new)
-        print(f"Zoom In: FOV von {curr} auf {new}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        curr = lens.getFov()[0]
-        new = min(100, curr + 5)
-        lens.setFov(new)
-        print(f"Zoom Out: FOV von {curr} auf {new}")
-
-
-# =============================================================================
-# Klasse: VehicleController
-# =============================================================================
-class VehicleController:
-    def __init__(self, surface: SimulationSurface):
-        self.surface = surface
-        self.vehicles = []  # Liste aller Fahrzeuge
-        self.cargos = {}  # Ordnet Fahrzeugen aktuell mitgeführte Pakete zu
-        self.current_dropoffs = {}
-        self.create_vehicles()
-
-    def create_vehicles(self):
-        # Es wird nur ein Fahrzeug erstellt, das an der Pickup-Station startet.
-        start_position = self.surface.pickup_station.getPos()
-        vehicle = self.surface.loader.loadModel("models/box")
-        vehicle.setScale(1, 1, 0.5)
-        vehicle.setColor(LColor(0, 0, 1, 1))
-        vehicle.setPos(start_position)
-        vehicle.reparentTo(self.surface.render)
-        vehicle.setPythonTag("role", "pickup_to_dropoff")
-        vehicle.setPythonTag("phase", "pickup")  # Fährt auf die Station zu
-        vehicle.setPythonTag("speed", 0.0)  # Startet aus dem Stand
-        self.add_center_marker(vehicle)
-        self.attach_lidar_sensor(vehicle, offset=Vec3(0.5, 0.5, 0), radius=2.5)
-        self.vehicles.append(vehicle)
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        marker = self.surface.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def attach_lidar_sensor(self, vehicle, offset=Vec3(0.5, 0.5, 0), radius=2.5):
-        sensor_np = vehicle.attachNewNode("lidar_sensor")
-        sensor_np.setPos(offset)
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 1, 0, 1))
-        segments = 64
-        ls.moveTo(radius * math.cos(0), radius * math.sin(0), 0)
-        for i in range(1, segments + 1):
-            angle = (2 * math.pi * i) / segments
-            x = radius * math.cos(angle)
-            y = radius * math.sin(angle)
-            ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        sensor_np.attachNewNode(circle_geom)
-
-    def get_source_target(self, vehicle):
-        role = vehicle.getPythonTag("role")
-        if role == "pickup_to_dropoff":
-            return self.surface.pickup_station, self.surface.drop_station
-        else:
-            return self.surface.drop_station, self.surface.pickup_station
-
-    def compute_avoidance_vector(self, vehicle):
-        """
-        Berechnet einen Abstoßungsvektor basierend auf der Position aller anderen Fahrzeuge.
-        Je näher ein anderes Fahrzeug ist, desto stärker wirkt der Abstoßungseffekt.
-        """
-        avoidance = Vec3(0, 0, 0)
-        sensor_center = vehicle.getPos(self.surface.render) + Vec3(0.5, 0.5, 0)
-        detection_radius = 2.5  # Sensor-Radius
-        for other in self.vehicles:
-            if other is vehicle:
-                continue
-            other_center = other.getPos(self.surface.render)
-            diff = sensor_center - other_center
-            distance = diff.length()
-            if distance < detection_radius and distance > 0:
-                avoidance += diff.normalized() * (detection_radius - distance)
-        return avoidance
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        max_speed = 1.5
-        accel = 2.5
-        decel = 2.5
-
-        def move_task(task):
-            dt_real = globalClock.getDt()
-            dt = dt_real * self.surface.speed_factor
-
-            pos = vehicle.getPos()
-            to_target = target - pos
-            distance = to_target.length()
-
-            if distance < 0.05:
-                vehicle.setPos(target)
-                on_complete()
-                vehicle.setPythonTag("speed", 0.0)
-                return Task.done
-
-            current_speed = vehicle.getPythonTag("speed")
-
-            # Bei der "deliver"-Phase: Bei Dwell-Delay vor dem Weiterfahren bleiben.
-            if vehicle.getPythonTag("phase") == "deliver":
-                departure_ready_time = vehicle.getPythonTag("departure_ready_time")
-                if self.surface.sim_clock < departure_ready_time:
-                    vehicle.setPythonTag("speed", 0.0)
-                    return Task.cont
-
-            # Berechne den Abstoßungsvektor basierend auf dem Lidar.
-            avoidance_vector = self.compute_avoidance_vector(vehicle)
-            avoidance_weight = 1.0  # Feinjustierbar.
-            if avoidance_vector.length() > 0:
-                desired_direction = (
-                            to_target.normalized() + avoidance_vector.normalized() * avoidance_weight).normalized()
-            else:
-                desired_direction = to_target.normalized()
-
-            # Effektive Bremskraft berechnen
-            effective_decel = decel
-            if avoidance_vector.length() > 0.1:
-                effective_decel *= 1.5
-            if distance < 1.0:
-                effective_decel *= 2
-
-            # Standard-Beschleunigungs-/Bremslogik
-            if distance <= (current_speed ** 2) / (2 * effective_decel):
-                new_speed = max(current_speed - effective_decel * dt, 0)
-            else:
-                new_speed = min(current_speed + accel * dt, max_speed)
-
-            # Prüfung, ob sich das Fahrzeug in einer Station befindet:
-            # Definiere einen Stationsradius, in dem die Geschwindigkeitsbegrenzung gilt.
-            station_region_radius = 2.0
-            is_station_phase = False
-            # Falls das Ziel eine Station ist (Pickup- oder Drop-Station) und das Fahrzeug noch nah dran ist:
-            if (target - self.surface.pickup_station.getPos()).length() < 0.1 or (
-                    target - self.surface.drop_station.getPos()).length() < 0.1:
-                if (pos - target).length() < station_region_radius:
-                    is_station_phase = True
-            # Falls das Fahrzeug gerade aus der Station herausfährt:
-            if not is_station_phase and vehicle.hasPythonTag("departure_station"):
-                departure_station = vehicle.getPythonTag("departure_station")
-                if (pos - departure_station.getPos()).length() < station_region_radius:
-                    is_station_phase = True
-
-            # Wenn wir uns in der Station befinden, erzwinge konstant 0,5 m/s.
-            if is_station_phase:
-                new_speed = 0.5
-
-            movement = desired_direction * new_speed * dt
-            vehicle.setPos(pos + movement)
-            vehicle.setPythonTag("speed", new_speed)
-            return Task.cont
-
-        self.surface.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        vehicle.setPythonTag("job_start", self.surface.sim_clock)
-        vehicle.setPythonTag("phase", "pickup")
-        source, target = self.get_source_target(vehicle)
-        if source not in self.surface.pickup_packages:
-            self.surface.spawn_package_at_station(source)
-        self.move_vehicle_to(vehicle, source.getPos(), lambda: self.after_pickup(vehicle, source, target))
-
-    def after_pickup(self, vehicle, source, target):
-        self.pickup_package(vehicle, source)
-        vehicle.setPythonTag("phase", "deliver")
-        vehicle.setPythonTag("departure_station", source)
-        dwell_delay = 1.0
-        vehicle.setPythonTag("departure_ready_time", self.surface.sim_clock + dwell_delay)
-        self.move_vehicle_to(vehicle, target.getPos(), lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        self.drop_cargo(vehicle)
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, source):
-        if source in self.surface.pickup_packages:
-            package, spawn_time, timer_np = self.surface.pickup_packages.pop(source)
-            timer_np.removeNode()
-            dwell = self.surface.sim_clock - spawn_time
-            self.surface.total_dwell_time += dwell
-            self.surface.picked_up_count += 1
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.surface.last_removed[source] = self.surface.sim_clock
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.surface.render)
-            _, target = self.get_source_target(vehicle)
-            targetPos = target.getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.surface.delivered_packages += 1
-
-    def remove_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-
-
-# =============================================================================
-# Hauptprogramm
-# =============================================================================
-if __name__ == "__main__":
-    surface = SimulationSurface()
-    vehicle_controller = VehicleController(surface)
-    for vehicle in vehicle_controller.vehicles:
-        vehicle_controller.start_delivery_cycle(vehicle, vehicle.getPos())
-    surface.run()
Index: FFZ/FFZ8.py
===================================================================
diff --git a/FFZ/FFZ8.py b/FFZ/FFZ8.py
deleted file mode 100644
--- a/FFZ/FFZ8.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,331 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    CardMaker,
-    LineSegs,
-    Vec3
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import math
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte für Simulationszeit und -geschwindigkeit
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kameraeinstellungen (Fahrtrichtung wird entlang der Y-Achse angenommen)
-        self.cam.setPos(0, -30, 10)
-        self.cam.lookAt(0, 0, 0)
-
-        # Licht und Raster
-        self.setup_light()
-        self.create_grid(center_extent=10, cell_size=0.1)
-
-        # Fahrzeug erstellen und Referenz speichern
-        self.vehicle = self.create_vehicle()
-
-        # Slider zur Anpassung der Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Slider zur Steuerung der Forkhöhe (0 bis 1 Meter)
-        self.fork_slider = DirectSlider(
-            range=(0.0, 1.0),
-            value=0.0,
-            pageSize=0.01,
-            command=self.update_fork_height,
-            pos=(-0.7, 0, -0.85),
-            scale=0.3
-        )
-        self.fork_label = DirectLabel(
-            text="Fork Höhe: 0.00m",
-            pos=(-0.7, 0, -0.75),
-            scale=0.07
-        )
-
-        # Anzeige der Laufzeit
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktionalität
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben hinzufügen
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_cable, "UpdateCableTask")
-        # Das Fahrzeug fährt stationär; update_vehicle Task wird nicht hinzugefügt.
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_fork_height(self, height=0, *args):
-        try:
-            height = float(height)
-        except ValueError:
-            height = 0.0
-        self.fork_node.setZ(height)
-        self.fork_label['text'] = f"Fork Höhe: {height:.2f}m"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def create_grid(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            x += cell_size
-
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        grid_np = self.render.attachNewNode(node)
-        grid_np.setColor(0.7, 0.7, 0.7, 1)
-        return grid_np
-
-    def setup_light(self):
-        ambient_light = AmbientLight("ambient_light")
-        ambient_light.setColor((0.5, 0.5, 0.5, 1))
-        ambient_np = self.render.attachNewNode(ambient_light)
-        self.render.setLight(ambient_np)
-
-        directional_light = DirectionalLight("directional_light")
-        directional_light.setColor((1, 1, 1, 1))
-        directional_np = self.render.attachNewNode(directional_light)
-        directional_np.setPos(10, -10, 10)
-        self.render.setLight(directional_np)
-
-    def create_vehicle(self):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Fahrmodul (Chassis) – Farbe: Rot, Dimensionen: 1 x 0.5 x 1.2
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-
-        # Gabelmodul (Fork) – Statt eines massiven Blocks wird ein Elternknoten erstellt,
-        # unter dem zwei "Zähne" angeordnet werden.
-        fork_node = vehicle_node.attachNewNode("fork")
-        # Positioniere den Fork-Knoten so, dass die freie Seite (global y = -1.2) genutzt wird.
-        fork_node.setPos(0, -1.2, 0)
-
-        # Linker Zahn (Zahn links vom Fork): Größe 0.2 x 1.2 x 0.1 (X, Y, Z)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)  # von X=0 bis X=0.2
-
-        # Rechter Zahn: Größe 0.2 x 1.2 x 0.1
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)  # von X=0.8 bis X=1.0
-
-        # Speichere den Fork-Knoten für spätere Höhenanpassungen
-        self.fork_node = fork_node
-
-        # Mast – nicht mehr als massiver Block, sondern als Rahmen (nur Kanten in X und Z)
-        # Wir bauen einen Rahmen mit außen: 1x1, Rahmenstärke (Border)=0.1, extrudiert in Y (Tiefe = 0.1)
-        mast_node = vehicle_node.attachNewNode("mast")
-        # Obere bzw. untere Balken
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        # Linker und rechter Balken (in Z-Richtung zwischen bottom und top, aber nur an den Seiten)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        # Positioniere den Mast wie bisher
-        mast_node.setPos(0, 0.2, 1.2)
-
-        vehicle_node.setPos(-0.5, 0, 0)
-        return vehicle_node
-
-    def add_rectangle_to_fork(self, fork_node):
-        """
-        Fügt dem Fork-Knoten einen Rahmen (ohne Füllung) hinzu, der
-        in lokalen XY-Koordinaten von (0,0) bis (1,1) auf der oberen Fläche
-        (jetzt z=0.101, da die Höhe des Fork beträgt 0.1) liegt.
-        Zusätzlich werden zwei Diagonalen eingezeichnet.
-        Der Marker am Schnittpunkt der Diagonalen wird um 0.5 in Z angehoben,
-        sodass er bei z=0.601 liegt.
-        """
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)  # Orange
-
-        ls.moveTo(0, 0, 0.101)
-        ls.drawTo(1, 0, 0.101)
-        ls.drawTo(1, 1, 0.101)
-        ls.drawTo(0, 1, 0.101)
-        ls.drawTo(0, 0, 0.101)
-
-        ls.moveTo(0, 0, 0.101)
-        ls.drawTo(1, 1, 0.101)
-        ls.moveTo(1, 0, 0.101)
-        ls.drawTo(0, 1, 0.101)
-
-        fork_node.attachNewNode(ls.create())
-
-        # Marker: Ursprung der Diagonalen: (0.5, 0.5, 0.101) → Marker bei z=0.101+0.5 = 0.601
-        point = loader.loadModel("models/smiley")
-        point.setScale(0.05)
-        point.setPos(0.5, 0.5, 0.601)
-        point.setColor(1, 1, 1, 0.5)  # transparent
-        point.setTransparency(True)
-        point.reparentTo(fork_node)
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        # Unterseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        # Oberseite
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        # Vorderseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        # Rückseite
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        # Linke Seite
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        # Rechte Seite
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def update_cable(self, task):
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)  # Werte zwischen 0 und 1
-        self.fork_node.setZ(new_height)
-        self.fork_label['text'] = f"Fork Höhe: {new_height:.2f}m"
-        return Task.cont
-
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: KI/KI34.py
===================================================================
diff --git a/KI/KI34.py b/KI/KI34.py
deleted file mode 100644
--- a/KI/KI34.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,581 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Matplotlib zum Plotten importieren
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs,
-    CardMaker
-)
-
-# Wir nutzen globalClock für dt.
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit & Zeitskalierungsfaktor
-        self.base_speed = 1.5
-        self.speed_factor = 1.0
-
-        # Simulationszeitticker & Statistik
-        self.sim_clock = 0.0
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        self.sim_start_real = globalClock.getFrameTime()
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Zeichne für jede Annahmestation den Align-Punkt (2 m in positive X-Richtung)
-        for station in self.annahme_stationen:
-            station_pos = station.getPos()
-            ls_pickup = LineSegs()
-            ls_pickup.setThickness(3.0)
-            ls_pickup.setColor(LColor(1, 1, 1, 1))
-            ls_pickup.moveTo(station_pos)
-            ls_pickup.drawTo(station_pos + Vec3(2, 0, 0))
-            self.render.attachNewNode(ls_pickup.create())
-
-        # Zeichne für jede Abgabestation den Align-Punkt (2 m in negative X-Richtung)
-        for station in self.abgabe_stationen:
-            station_pos = station.getPos()
-            ls_dropoff = LineSegs()
-            ls_dropoff.setThickness(3.0)
-            ls_dropoff.setColor(LColor(1, 1, 1, 1))
-            ls_dropoff.moveTo(station_pos)
-            ls_dropoff.drawTo(station_pos + Vec3(-2, 0, 0))
-            self.render.attachNewNode(ls_dropoff.create())
-
-        # --- Anfahrstationen (Startstationen) für die Fahrzeuge ---
-        # Diese Stationen sollen bei Y = 15 nebeneinander mit 4 Meter Abstand in X-Richtung liegen.
-        self.anfahrstationen = []
-        num_departure = 2  # Es sollen zu Beginn nur 2 Fahrzeuge genutzt werden.
-        spacing_departure = 4.0
-        start_x = -spacing_departure * (num_departure - 1) / 2
-        for i in range(num_departure):
-            pos = Vec3(start_x + i * spacing_departure, 15, 0)
-            station = self.erzeuge_gitterbox(pos.getX(), pos.getY(), pos.getZ(), LColor(0.8, 0.8, 0, 1))
-            self.anfahrstationen.append(station)
-
-        # Fahrzeuge erstellen, jeweils eines pro Anfahrstation (insgesamt 2 Fahrzeuge)
-        self.vehicles = []
-        self.cargos = {}              # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}    # Fahrzeug -> zugewiesene Dropoff-Station
-        for i, start_station in enumerate(self.anfahrstationen):
-            vehicle = self.loader.loadModel("models/box")
-            vehicle.setScale(1, 1, 0.5)
-            if i % 2 == 0:
-                vehicle.setColor(LColor(0, 0, 1, 1))
-            else:
-                vehicle.setColor(LColor(0, 0, 0.8, 1))
-            vehicle.setPos(start_station.getPos())
-            vehicle.reparentTo(self.render)
-            self.vehicles.append(vehicle)
-            # Beim Start eines neuen Auftrags ist die Phase "pickup"
-            vehicle.setPythonTag("phase", "pickup")
-            self.add_center_marker(vehicle)
-            self.add_offset_circle(vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Reste der Pick-up-/Drop-off-Logik
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Erfassung von Daten für Graphen (einmal pro Simulationssekunde)
-        self.graph_data = []
-        self.taskMgr.doMethodLater(1, self.record_graph_data, "RecordGraphDataTask")
-
-        # Graphen öffnen per Taste "G" (nach Schließen wieder möglich)
-        self.graph_opened = False
-        self.accept("g", self.open_graph)
-
-        # Zoom-Funktionalität: Mit Mausrad hereinz- bzw. herauszoomen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_lidar_status, "UpdateLidarStatusTask")
-
-        # Liefervorgang starten (Pickup-Phase) für jedes Fahrzeug
-        for vehicle in self.vehicles:
-            self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def zoom_in(self):
-        # Hereinzoomen: Field-of-View (FOV) verkleinern (nicht unter 10°)
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        # Herauszoomen: FOV vergrößern (nicht über 100°)
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def record_graph_data(self, task):
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0
-        self.graph_data.append((self.sim_clock, delivered_per_minute, avg_dwell_time))
-        return Task.again
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def add_offset_circle(self, vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5, num_segments=32):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        for i in range(num_segments + 1):
-            angle = 2 * math.pi * i / num_segments
-            x = circle_radius * math.cos(angle)
-            y = circle_radius * math.sin(angle)
-            if i == 0:
-                ls.moveTo(x, y, 0)
-            else:
-                ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        circle_np = vehicle.attachNewNode(circle_geom)
-        circle_np.setPos(offset)
-        vehicle.setPythonTag("lidar_circle", circle_np)
-
-    def draw_coordinate_axes(self, axis_length=5):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(1, 0, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        ls.setColor(0, 1, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        ls.setColor(0, 0, 1, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), (1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), (0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), (0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def update_lidar_status(self, task):
-        sensor_threshold = 3.0
-        for vehicle in self.vehicles:
-            # Hole die Position des Fahrzeugs
-            pos = vehicle.getPos(self.render)
-            total_avoidance = Vec3(0, 0, 0)
-            # Standardmäßig volle Geschwindigkeit
-            multiplier = 1.0
-            phase = vehicle.getPythonTag("phase") if vehicle.hasPythonTag("phase") else "pickup"
-            for other in self.vehicles:
-                if other is vehicle:
-                    continue
-                pos_other = other.getPos(self.render)
-                diff = pos - pos_other
-                d = diff.length()
-                if d < sensor_threshold:
-                    # Wenn dieses Fahrzeug in Pickup-Phase ist und das andere in Dropoff‑Phase, soll es bremsen.
-                    other_phase = other.getPythonTag("phase") if other.hasPythonTag("phase") else "pickup"
-                    if phase == "pickup" and other_phase == "dropoff":
-                        candidate = 0.3
-                    else:
-                        candidate = 1.0
-                    multiplier = min(multiplier, candidate)
-                    if d > 0:
-                        total_avoidance += diff.normalized() * (sensor_threshold - d)
-            vehicle.setPythonTag("speed_multiplier", multiplier)
-            vehicle.setPythonTag("avoidance", total_avoidance)
-            # Farbige Anzeige: Bei Abbremsen (niedrigerer Multiplikator) wechselt der Lidar-Kreis in Rot
-            if multiplier < 1.0 or total_avoidance.length() > 0.001:
-                vehicle.getPythonTag("lidar_circle").setColor(LColor(1, 0, 0, 1))
-            else:
-                vehicle.getPythonTag("lidar_circle").setColor(LColor(0, 1, 0, 1))
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-        current_wait_text = (
-            f"Liegedauer (aktuell): {current_max_wait_time:.1f}s"
-            if current_max_wait_time > 0 else "Kein Paket an Annahmestation"
-        )
-        maximal_wait_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted_time}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-            f"{current_wait_text}\n"
-            f"{maximal_wait_text}\n"
-            f"Liegedauer (Durchschnitt): {avg_dwell_time:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(
-            station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1)
-        )
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            to_target = target - current_pos
-            distance = to_target.length()
-            multiplier = vehicle.getPythonTag("speed_multiplier") if vehicle.hasPythonTag("speed_multiplier") else 1.0
-            effective_speed = self.base_speed * self.speed_factor * multiplier
-            step_distance = effective_speed * dt
-            if distance <= step_distance:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-            avoidance = vehicle.getPythonTag("avoidance") if vehicle.hasPythonTag("avoidance") else Vec3(0, 0, 0)
-            if avoidance.length() > 0.001:
-                combined = to_target.normalized() + avoidance.normalized() * 0.5
-                combined.normalize()
-                new_direction = combined
-            else:
-                new_direction = to_target.normalized()
-            vehicle.setPos(current_pos + new_direction * step_distance)
-            return Task.cont
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        # Beim Beginn eines neuen Auftrags: Phase setzen auf "pickup" und Startzeit speichern.
-        vehicle.setPythonTag("job_start", self.sim_clock)
-        vehicle.setPythonTag("phase", "pickup")
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        pickup_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        self.move_vehicle_to(vehicle, pickup_align,
-            lambda: self.move_vehicle_to(vehicle, pickup_station.getPos(),
-                lambda: self.after_pickup(vehicle, pickup_station)
-            )
-        )
-
-    def after_pickup(self, vehicle, pickup_station):
-        self.pickup_package(vehicle, pickup_station)
-        # Nach erfolgreichem Pickup: Phase auf "dropoff" setzen
-        vehicle.setPythonTag("phase", "dropoff")
-        self.depart_from_pickup(vehicle, pickup_station,
-            lambda: self.start_dropoff_phase(vehicle)
-        )
-
-    def depart_from_pickup(self, vehicle, pickup_station, callback):
-        departure_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        departure_target = pickup_station.getPos() + Vec3(4, 0, 0)
-        self.move_vehicle_to(vehicle, departure_align,
-            lambda: self.move_vehicle_to(vehicle, departure_target, callback)
-        )
-
-    def start_dropoff_phase(self, vehicle):
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.start_dropoff_phase(vehicle)
-            return
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-        self.move_vehicle_to(vehicle, dropoff_align,
-            lambda: self.move_vehicle_to(vehicle, dropoff_station.getPos(),
-                lambda: self.after_dropoff(vehicle)
-            )
-        )
-
-    def after_dropoff(self, vehicle):
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        self.drop_cargo(vehicle)
-        self.remove_cargo(vehicle, remove_dropoff=True)
-        if dropoff_station is not None:
-            departure_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-            departure_target = dropoff_station.getPos() + Vec3(-4, 0, 0)
-            self.move_vehicle_to(vehicle, departure_align,
-                lambda: self.move_vehicle_to(vehicle, departure_target,
-                    lambda: self.start_delivery_cycle(vehicle, departure_target)
-                )
-            )
-        else:
-            self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle, remove_dropoff=True):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        if remove_dropoff:
-            dropoff_station = self.current_dropoffs.get(vehicle)
-            if dropoff_station in self.occupied_dropoffs:
-                self.occupied_dropoffs.remove(dropoff_station)
-            if vehicle in self.current_dropoffs:
-                del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices+1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices+1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z+1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
Index: Grundmodell/Gm21.py
===================================================================
diff --git a/Grundmodell/Gm21.py b/Grundmodell/Gm21.py
deleted file mode 100644
--- a/Grundmodell/Gm21.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,1565 +0,0 @@
-import random
-import math
-import tkinter as tk  # Für das extra Fenster der Auftragsübersicht
-from tkinter import ttk  # Für die tabellarische Darstellung (Treeview)
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-from direct.task.TaskManagerGlobal import taskMgr
-
-
-from functools import partial
-
-
-
-
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-            super().__init__()
-
-            # Basis-Simulationsvariablen
-            self.sim_clock = 0.0
-            self.speed_factor = 1.0
-            self.current_speed = 1.5  # Wird in update_vehicle genutzt
-            self.state_timer = 0.0
-
-            # Kennzahlen (KPIs)
-            self.delivered_packages = 0
-            self.max_overall_wait_time = 0.0
-            self.total_dwell_time = 0.0
-            self.picked_up_count = 0
-
-            # Paketspawning an den Annahmestationen:
-            # Mapping: station (Dummy-Node) -> (Paket, Spawnzeit, Timer Node)
-            self.pickup_packages = {}
-            self.last_removed = {}
-
-            # Fahrzeug-spezifische Zuordnung: Fahrzeug -> transportiertes Paket
-            self.cargos = {}
-
-            # NEU: Initialisiere die belegten Annahmestationen
-            self.occupied_pickups = set()  # Oder: [] für eine Liste
-
-            # Graph-Daten (Sim-Zeit, Pakete pro Minute, durchschnittliche Liegedauer)
-            self.graph_data = []
-            self.graph_opened = False
-
-            # Auftragsverwaltung: Speichere alle Aufträge (für die Anzeige) sowie in
-            # einer Queue (Liste) zur sequentiellen Abarbeitung.
-            self.orders = {}
-            self.orders_queue = []
-            self.next_order_id = 1
-
-            # Tkinter-Fenster für Auftragsübersicht
-            self.order_win = None
-            self.order_tree = None
-
-            # Umgebung initialisieren
-            self.draw_origin()
-            self.cam.setPos(11, -80, 40)
-            self.cam.lookAt(11, 30, 0)
-            self.erzeuge_licht()
-            self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-            self.create_wall()
-            self.create_annahme_stations()
-            self.create_abgabe_stations()  # Hier wird auch self.abgabe_stations angelegt.
-            self.create_garagen_stations()
-
-            for station in self.annahme_stations:
-                self.spawn_package_at_station(station)
-
-            # Fahrzeuge in den Garagen erstellen (genau 5 Fahrzeuge)
-            self.create_garage_vehicles()
-
-            # NEU: Testvariablen (werden nicht mehr aktiv über diesen globalen Mechanismus gesteuert)
-            self.first_vehicle_order_state = "idle"
-            self.attached_package = None
-            self.current_order = None  # Der aktuell abgearbeitete Auftrag (wird durch Fahrzeuge individuell genutzt)
-
-            # UI – Slider und Info-Anzeige
-            self.speed_slider = DirectSlider(
-                range=(0.1, 10.0),
-                value=self.speed_factor,
-                pageSize=0.1,
-                command=self.update_simulation_speed,
-                pos=(0, 0, -0.85),
-                scale=0.3
-            )
-            self.speed_label = DirectLabel(
-                text=f"Sim Time Factor: {self.speed_factor:.1f}",
-                pos=(0, 0, -0.75),
-                scale=0.07
-            )
-            self.info_label = DirectLabel(
-                text="Laufzeit: 0.0s",
-                pos=(1.2, 0, 0.8),
-                scale=0.07,
-                frameColor=(0, 0, 0, 0)
-            )
-
-            # Tastenzuordnungen
-            self.accept("wheel_up", self.zoom_in)
-            self.accept("wheel_down", self.zoom_out)
-            self.accept("g", self.open_graph)
-            self.accept("a", self.show_order_list)
-            self.accept("d", self.deliver_first_order)
-            # Taste C öffnet das Fahrzeug-Kontrollfenster
-            self.accept("c", self.show_vehicle_control)
-
-            # Task-Manager
-            self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-            self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-            self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-            self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-            self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-            self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    # ---------------------------
-    # SIMULATION UND UI-METHODEN
-    # ---------------------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        # dt jetzt skaliert mit der Simulationsgeschwindigkeit
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    # ---------------------------
-    # METHODEN FÜR RASTER, LICHT, MAUER, URSPRUNG
-    # ---------------------------
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # STATIONSOBJEKTE UND ZUORDNUNG
-    # -----------------------------------
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        """
-        Erzeugt die Annahmestationen und erstellt für jede Station:
-          - Einen weißen Marker zur Orientierung
-          - Einen grünen Punkt (optional)
-          - Eine weiße Linie, an deren Endpunkt ein blauer Marker als Ziel in der "Translate‑Phase" dient
-
-        Zusätzlich wird ein Dictionary self.station_blue_dots aufgebaut, in dem jedem Annahmestations‑Node
-        der zugehörige blaue Marker zugeordnet wird. Außerdem wird für die erste Station die globale Variable
-        self.station_white_direction festgelegt.
-        """
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        self.station_blue_dots = {}
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basisstation (zum Beispiel als Rahmen)
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Erzeuge den weißen Marker als Orientierung
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Erzeuge den grünen Punkt (optional)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zeichne die weiße Linie: Sie beginnt bei center + Vec3(0, 0, -0.5) und verläuft 3 Meter in X‑Richtung.
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Erzeuge den blauen Marker, der als Ziel in der Translate‑Phase dient
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            # Speichere den blauen Marker im Dictionary, sodass er später erzeugt werden kann
-            self.station_blue_dots[station_dummy] = blue_dot
-
-            # Optionale Textanzeige der Stationsnummer
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) – falls benötigt:
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-            # Für die erste Station (oder den ersten relevanten Pickup) setzen wir globale Referenzen,
-            # die in vehicle_order_task benötigt werden.
-            if i == 1:
-                self.blue_dot = blue_dot
-                self.station_green_dot = green_dot
-                # Berechne den Mittelpunkt der weißen Linie als Referenz (optional)
-                self.white_line_center = (start_line + end_line) * 0.5
-                line_vec = end_line - start_line
-                if line_vec.length() != 0:
-                    self.station_white_direction = Vec2(line_vec.getX(), line_vec.getY()).normalized()
-                else:
-                    self.station_white_direction = Vec2(1, 0)  # Fallback-Wert
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        self.abgabe_stations = []  # Liste der Abgabestationen
-        self.abgabe_blue_dots = []  # Liste zum Speichern der blauen Marker für die Abgabe
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basiskonstruktion der Abgabestation
-            node = self.create_abgabe_station(pt)
-            self.abgabe_stations.append(node)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Marker am Zentrum (weiß)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Grüner Punkt: center + Vec3(0, 0, -0.5)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Weiße Linie: Startet bei center + Vec3(0, 0, -0.5)
-            # und verläuft 3 Meter in negativer X-Richtung
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt: wird an der Endposition der Linie erzeugt
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            # Speichere den blauen Marker für spätere Navigation der Abgabestation
-            self.abgabe_blue_dots.append(blue_dot)
-
-            # Anzeige der Stationsnummer (textuell)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) auf der Station
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 3)
-        v5 = pos + Vec3(1, 0, 3)
-        v6 = pos + Vec3(1, 2, 3)
-        v7 = pos + Vec3(0, 2, 3)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 3)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        self.garagen_stations = []
-        self.garagen_parking_points = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            self.garagen_stations.append(pt)
-            # ParkpunktGarage: Verschoben um 0.5 in negativer Y-Richtung:
-            center = pt + Vec3(0.5, 0.5, 1.5)
-            ParkpunktGarage = center + Vec3(0, 0, 0.7)
-            self.garagen_parking_points.append(ParkpunktGarage)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def create_garage_vehicles(self):
-        self.garage_vehicles = []
-        vehicle_id_counter = 1
-        for park in self.garagen_parking_points:
-            veh = self.create_vehicle(park_point=park)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            newPos.setZ(0)
-            veh.setPos(newPos)
-
-            # Fahrzeuge starten zunächst im Standby (idle)
-            veh.setPythonTag("current_order", None)
-            veh.setPythonTag("order_state", "idle")
-            veh.setPythonTag("package_attached", False)
-            veh.setPythonTag("vehicle_id", vehicle_id_counter)
-            vehicle_id_counter += 1
-
-            # Fahrzeug in die Liste aufnehmen
-            self.garage_vehicles.append(veh)
-
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-            # Suche den Mast des Fahrzeugs (angenommen, er wurde mit dem Namen "mast" angehängt)
-            mast = veh.find("**/mast")
-            if not mast.isEmpty():
-                # Erzeuge einen Textknoten, der die Fahrzeugnummer enthält:
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)  # Schwarz
-                tn.setAlign(TextNode.ACenter)
-                text_np = mast.attachNewNode(tn)
-                # Positioniere den Text relativ zum Mast:
-                # Wir nehmen hier den gleichen X- und Y-Versatz wie beim Zylinder (intersection),
-                # und setzen den Text in Z-Richtung um z.B. +0.2 Einheiten oberhalb (also intersection.z + 0.2).
-                text_np.setPos(intersection.x, intersection.y, intersection.z + 0.2)
-                text_np.setScale(0.8)  # Größere Darstellung
-                # Optional können mit setHpr weitere Anpassungen vorgenommen werden, sodass der Text optimal lesbar ist.
-                text_np.setHpr(0, 0, 0)
-            else:
-                # Fallback: Falls kein Mast gefunden wird, hänge den Text direkt an das Fahrzeug.
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)
-                tn.setAlign(TextNode.ACenter)
-                text_np = veh.attachNewNode(tn)
-                text_np.setPos(0, 1.2, 1.5)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-
-            # Registriere den Task für das Fahrzeug:
-            self.taskMgr.add(partial(self.vehicle_order_task, veh),
-                             f"VehicleOrderTask_{veh.getPythonTag('vehicle_id')}")
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # FAHRZEUGERSTELLUNG (FFZ20-INTEGRATION)
-    # -----------------------------------
-    def create_vehicle(self, park_point=None):
-        # Erzeuge den übergeordneten Fahrzeug-Knoten
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # --------------------------
-        # Chassis erstellen (1 x 0.5 x 1.2, Farbe Rot)
-        # --------------------------
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # --------------------------
-        # Gabel (Fork) erstellen: Zwei Zähne
-        # --------------------------
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-
-        # Speichere den Gabel-Knoten als Python-Tag am Fahrzeug
-        vehicle_node.setPythonTag("fork_node", fork_node)
-
-        # --------------------------
-        # Erzeuge den grünen Referenzmarker (Gabel – grüner Punkt)
-        # --------------------------
-        ls_new = LineSegs()
-        ls_new.setThickness(2.0)
-        ls_new.setColor(1, 1, 1, 1)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_corner_global = fork_node.getPos() + left_corner_local
-        right_corner_global = fork_node.getPos() + right_corner_local
-        ls_new.moveTo(left_corner_global)
-        ls_new.drawTo(right_corner_global)
-        vehicle_node.attachNewNode(ls_new.create())
-        midpoint = (left_corner_global + right_corner_global) * 0.5
-        white_line_vec = right_corner_global - left_corner_global
-        white_line_dir = white_line_vec.normalized() if white_line_vec.length() != 0 else Vec3(0, 0, 0)
-        candidate = Vec3(-white_line_dir.getY(), white_line_dir.getX(), 0)
-        perp_direction = candidate.normalized() if candidate.length() != 0 else Vec3(0, 0, 0)
-        green_point_global = midpoint + perp_direction * 0.5
-
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        # Speichere den grünen Marker ebenfalls als Python-Tag
-        vehicle_node.setPythonTag("fork_green", green_marker_np)
-
-        # --------------------------
-        # Mast und weitere Fahrzeugteile
-        # --------------------------
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-        self.add_diagonals_to_mast(mast_node)
-        intersection = Vec3(0.5, 0.05, 1.0)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-        self.vehicle_cylinder = cylinder_node
-
-        # --------------------------
-        # Fahrzeugpositionierung am Parkpunkt
-        # --------------------------
-        if park_point is None:
-            vehicle_node.setPos(intersection.x, intersection.y, 0)
-        else:
-            vehicle_node.setPos(park_point - vehicle_node.getQuat().xform(intersection))
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        # Verwende die simulative Zeit, die bereits in update_sim_clock hochgezählt wird
-        t = self.sim_clock
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    # -----------------------------------
-    # FEHLENDE METHODEN: Paketspawning, Würfelerzeugung u.a.
-    # -----------------------------------
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Bestimme zufällig eine Abgabestation als Ziel
-        if hasattr(self, "abgabe_stations") and self.abgabe_stations:
-            target_index = random.randint(1, len(self.abgabe_stations))
-        else:
-            target_index = 1
-
-        # Erstelle den Auftrag zur Annahmestation
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def update_order_table(self):
-        """
-        Aktualisiert die Auftragsübersicht in der Tkinter-Tabelle und zeigt in der
-        letzten Spalte den zugewiesenen Fahrzeugnamen (oder "-" falls noch keiner zugeordnet wurde).
-        """
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen (z. B. "annahme_station_3") die Stationsnummer.
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z. B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige in der letzten Spalte den zugewiesenen Fahrzeugnamen an (oder "-" falls noch kein Fahrzeug zugewiesen ist).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END, values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = 5.0  # 5 Sekunden Verzögerung zwischen Spawns
-        for station in self.annahme_stations:
-            # Wenn aktuell kein Paket an der Station ist
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                # Prüfe, ob seit der letzten Entnahme mindestens 5 Sekunden vergangen sind
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0.0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Wir legen hier die Spalten in der gewünschten Reihenfolge an: Auftrags ID, Annahmestation, Ziel, Fahrzeug.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Hole die fahrzeugspezifischen Knoten mittels getPythonTag
-            fork_node = vehicle.getPythonTag("fork_node")
-            fork_green = vehicle.getPythonTag("fork_green")
-
-            # Hole die Position des grünen Markers relativ zum Gabelknoten
-            green_point_pos = fork_green.getPos(fork_node)
-
-            # Reparent das Paket zur Gabel des Fahrzeugs und positioniere es entsprechend
-            package.wrtReparentTo(fork_node)
-            package.setPos(
-                green_point_pos.getX() + 0.5,  # Offset in X-Richtung
-                green_point_pos.getY() - 0.5,  # Offset in Y-Richtung
-                green_point_pos.getZ() + 1  # Z-Offset, sodass das Paket oberhalb liegt
-            )
-
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    from direct.task.TaskManagerGlobal import taskMgr  # Sicherstellen, dass taskMgr verfügbar ist
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden removeCargoTask aufruft,
-            # und übergib dabei das cargo als extra Argument:
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return Task.done
-
-    def select_next_order(self, vehicle):
-        # Filtern aller Aufträge mit dem Status "Wartend"
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        # Berechne für jeden Auftrag die Liegedauer
-        for order in waiting_orders:
-            dwell_time = self.sim_clock - order.get("spawn_time", self.sim_clock)
-            order["dwell_time"] = dwell_time
-
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01  # Zur Berücksichtigung von Rundungsfehlern
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        # Verwende das Fahrzeug, das gerade einen Auftrag bekommen soll,
-        # um den Abstand der Pickup-Station zu berechnen.
-        vehicle_pos = vehicle.getPos(self.render)
-
-        def distance_to_station(order):
-            station = order.get("pickup_station")
-            if station:
-                station_pos = station.getPos(self.render)
-                return (station_pos - vehicle_pos).length()
-            return float('inf')
-
-        candidates.sort(key=distance_to_station)
-        chosen_order = candidates[0]
-        # Setze beim Auftrag auch den bearbeitenden Fahrzeugnamen basierend auf unserer benutzerfreundlichen ID:
-        chosen_order["vehicle"] = f"Fahrzeug {vehicle.getPythonTag('vehicle_id')}"
-        return chosen_order
-
-    def vehicle_order_task(self, vehicle, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-
-        # Bleibt im idle-Zustand, wenn nicht über das Kontrollfenster aktiviert
-        if vehicle.getPythonTag("order_state") == "idle":
-            return task.cont
-
-        state = vehicle.getPythonTag("order_state")
-        current_order = vehicle.getPythonTag("current_order")
-
-        # ------------------ Phase 1: Translate ------------------
-        if state == "translate":
-            if current_order is None:
-                next_order = self.select_next_order(vehicle)
-                if next_order is not None:
-                    vehicle.setPythonTag("current_order", next_order)
-                    next_order["status"] = "In Bearbeitung"
-                    print(
-                        f"Auftrag {next_order['id']} wird zugewiesen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}.")
-                else:
-                    print("Kein Auftrag verfügbar – Fallback zum globalen Ziel.")
-            current_order = vehicle.getPythonTag("current_order")
-            if current_order is not None:
-                pickup_station = current_order.get("pickup_station")
-                if pickup_station in self.station_blue_dots:
-                    blue_target = self.station_blue_dots[pickup_station].getPos(self.render)
-                else:
-                    blue_target = self.blue_dot.getPos(self.render)
-            else:
-                blue_target = self.blue_dot.getPos(self.render)
-
-            local_mast = Vec3(0.5, 0.05, 1.0)
-            mast_global = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(local_mast)
-            target_xy = Vec2(blue_target.getX(), blue_target.getY())
-            mast_xy = Vec2(mast_global.getX(), mast_global.getY())
-            error_vector = target_xy - mast_xy
-            threshold = 0.05
-            if error_vector.length() > threshold:
-                direction = error_vector.normalized()
-                move_distance = 1.5 * dt
-                current_pos = vehicle.getPos(self.render)
-                new_pos = Vec3(current_pos.getX() + direction.getX() * move_distance,
-                               current_pos.getY() + direction.getY() * move_distance, 0)
-                vehicle.setPos(new_pos)
-            else:
-                local_offset = vehicle.getQuat(self.render).xform(local_mast)
-                exact_pos = Vec3(blue_target.getX() - local_offset.getX(),
-                                 blue_target.getY() - local_offset.getY(), 0)
-                vehicle.setPos(exact_pos)
-                vehicle.setPythonTag("order_state", "rotate")
-
-        # ------------------ Phase 2: Rotate ------------------
-        elif state == "rotate":
-            desired_angle = math.degrees(math.atan2(self.station_white_direction.getY(),
-                                                    self.station_white_direction.getX()))
-            desired_angle = (desired_angle + 180) % 360
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_angle - current_heading + 180) % 360) - 180
-            kp_heading = 0.5
-            new_heading = current_heading + kp_heading * angle_diff
-            vehicle.setH(new_heading)
-            if abs(angle_diff) < 1.0:
-                vehicle.setPythonTag("order_state", "turn_right")
-
-        # ------------------ Phase 3: Turn Right ------------------
-        elif state == "turn_right":
-            if vehicle.getPythonTag("turn_right_init") is None:
-                vehicle.setPythonTag("turn_right_init", vehicle.getH() % 360)
-                vehicle.setPythonTag("turn_right_target", (vehicle.getPythonTag("turn_right_init") + 90) % 360)
-                print("Phase 3: Initialisiert für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "Start Heading =", vehicle.getPythonTag("turn_right_init"),
-                      "Target Heading =", vehicle.getPythonTag("turn_right_target"))
-            current_heading = vehicle.getH() % 360
-            turn_right_target = vehicle.getPythonTag("turn_right_target")
-            angle_diff = ((turn_right_target - current_heading + 180) % 360) - 180
-            kp_turn = 0.5
-            turn_rate = kp_turn * angle_diff
-            new_heading = current_heading + turn_rate * dt
-            vehicle.setH(new_heading)
-            print("Phase 3: Fahrzeug", vehicle.getPythonTag("vehicle_id"), "- Aktuelles Heading =", current_heading,
-                  "Winkelabweichung =", angle_diff,
-                  "Neues Heading =", new_heading)
-            if abs(angle_diff) < 1.0:
-                print("Phase 3: Drehung abgeschlossen für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      ". Übergang in 'approach'.")
-                vehicle.setPythonTag("order_state", "approach")
-                vehicle.clearPythonTag("turn_right_init")
-                vehicle.clearPythonTag("turn_right_target")
-
-        # ------------------ Phase 4: Approach ------------------
-        elif state == "approach":
-            if current_order is not None:
-                pickup_station = current_order.get("pickup_station")
-                target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-            else:
-                target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-            current = vehicle.getPos(self.render)
-            error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-            if error_vec.length() > 0.05:
-                direction = error_vec.normalized()
-                move_distance = 1.5 * dt
-                new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                               current.getY() + direction.getY() * move_distance,
-                               target.getZ())
-                vehicle.setPos(new_pos)
-            else:
-                vehicle.setPos(target)
-                vehicle.setPythonTag("order_state", "pickup")
-
-        # ------------------ Phase 5: Pickup ------------------
-        elif state == "pickup":
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            target_z = 1.0
-            raise_speed = 0.5
-            if current_z < target_z:
-                fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-            else:
-                if current_order is None:
-                    if self.orders_queue:
-                        vehicle.setPythonTag("current_order", self.orders_queue.pop(0))
-                    else:
-                        print("Keine verfügbaren Aufträge für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                              ". Überspringe Pickup-Phase.")
-                        vehicle.setPythonTag("order_state", "drive_out")
-                        return task.cont
-                pickup_station = vehicle.getPythonTag("current_order")["pickup_station"]
-                self.pickup_package(vehicle, pickup_station)
-                vehicle.setPythonTag("package_attached", True)
-                vehicle.setPythonTag("drive_out_start", vehicle.getPos(self.render))
-                vehicle.setPythonTag("drive_out_target",
-                                     vehicle.getPos(self.render) + vehicle.getQuat(self.render).getForward() * 5.0)
-                vehicle.setPythonTag("order_state", "drive_out")
-
-        # ------------------ Phase 6: Drive Out ------------------
-        elif state == "drive_out":
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            if current_z > 0.0:
-                lower_speed = 0.5
-                fork_node.setZ(max(0.0, current_z - lower_speed * dt))
-            current_pos = vehicle.getPos(self.render)
-            drive_out_target = vehicle.getPythonTag("drive_out_target")
-            diff = drive_out_target - current_pos
-            if diff.length() > 0.1:
-                move_distance = 0.5 * dt
-                step = diff.normalized() * move_distance
-                vehicle.setPos(current_pos + step)
-            else:
-                vehicle.setPythonTag("order_state", "to_delivery")
-
-        # ------------------ Phase 7: To Delivery ------------------
-        elif state == "to_delivery":
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current_pos = vehicle.getPos(self.render)
-            diff = blue_target - current_pos
-            threshold = 0.5
-            move_distance = 1.5 * dt
-            if move_distance > diff.length():
-                vehicle.setPos(blue_target)
-            else:
-                vehicle.setPos(current_pos + diff.normalized() * move_distance)
-            if (blue_target - vehicle.getPos(self.render)).length() <= threshold:
-                print("Phase 7 abgeschlossen: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "hat den blauen Punkt der Abgabestation erreicht.")
-                vehicle.setPythonTag("order_state", "align_delivery")
-
-        # ------------------ Phase 8: Align Delivery ------------------
-        elif state == "align_delivery":
-            desired_heading = 90.0
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_heading - current_heading + 180) % 360) - 180
-            print("Phase 8: Align Delivery | Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                  "Current Heading: {:.2f}°, Desired: {:.2f}°, Diff: {:.2f}°".format(
-                      current_heading, desired_heading, angle_diff))
-            fixed_turn_speed = 90.0
-            turn_amount = fixed_turn_speed * dt
-            if abs(angle_diff) < 1.0:
-                vehicle.setH(desired_heading)
-                print("Phase 8 abgeschlossen: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "ausgerichtet (Heading = {:.2f}°).".format(desired_heading))
-                vehicle.setPythonTag("order_state", "delivery_center")
-            else:
-                if angle_diff > 0:
-                    new_heading = current_heading + turn_amount
-                else:
-                    new_heading = current_heading - turn_amount
-                new_heading %= 360
-                vehicle.setH(new_heading)
-                print("Phase 8: Rotating - Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "New Heading set to {:.2f}°".format(new_heading))
-
-        # ------------------ Phase 9: Delivery Approach ------------------
-        elif state == "delivery_center":
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current = vehicle.getPos(self.render)
-            target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-            print("Phase 9: Zielpunkt der Abgabestation für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                  "=", target_point)
-            error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-            tolerance = 0.05
-            move_distance = 1.5 * dt
-            if error_vec.length() > tolerance:
-                direction = error_vec.normalized()
-                new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                               current.getY() + direction.getY() * move_distance,
-                               current.getZ())
-                vehicle.setPos(new_pos)
-                print("Phase 9: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "bewegt sich von", current, "nach", new_pos)
-            else:
-                vehicle.setPos(target_point)
-                print("Phase 9: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "hat den Zielpunkt erreicht.")
-                vehicle.setPythonTag("order_state", "drop")
-            # Gabel anheben in Phase 9
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_fork_z = fork_node.getZ()
-            if current_fork_z < 1.0:
-                new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-                fork_node.setZ(new_fork_z)
-                print("Phase 9: Gabel für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "wird angehoben (Z =", new_fork_z, ").")
-
-        # ------------------ Phase 10: Dropoff ------------------
-        elif state == "drop":
-            if vehicle.getPythonTag("package_attached"):
-                delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-                self.drop_cargo(vehicle)
-                print("Phase 10: Paket abgesetzt für Fahrzeug", vehicle.getPythonTag("vehicle_id"))
-                vehicle.setPythonTag("package_attached", False)
-            else:
-                fork_node = vehicle.getPythonTag("fork_node")
-                current_z = fork_node.getZ()
-                if current_z > 0.0:
-                    lower_speed = 0.5
-                    new_z = max(0.0, current_z - lower_speed * dt)
-                    fork_node.setZ(new_z)
-                    print("Phase 10: Gabel wird abgesenkt für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          ", aktueller Z-Wert =", new_z)
-                else:
-                    print("Phase 10: Dropoff vollständig abgeschlossen für Fahrzeug",
-                          vehicle.getPythonTag("vehicle_id"))
-                    vehicle.setPythonTag("order_state", "translate")
-                    # Hier ändern wir den Status des Auftrags zu "Abgegeben" statt "Erledigt"
-                    current_order["status"] = "Abgegeben"
-                    current_order["delivered_at"] = self.sim_clock
-                    vehicle.setPythonTag("current_order", None)
-
-        # ------------------ Phase 11: Exit Station and Start Next Order ------------------
-        elif state == "phase11":
-            if vehicle.getPythonTag("last_delivery_marker") is not None:
-                target_point = vehicle.getPythonTag("last_delivery_marker")
-            else:
-                delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    target_point = self.abgabe_blue_dots[0].getPos(self.render)
-                print("Phase 11: Zielpunkt (blauer Marker) für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "=", target_point)
-                current_pos = vehicle.getPos(self.render)
-                diff = target_point - current_pos
-                if diff.length() > 0.1:
-                    move_distance = 0.5 * dt
-                    step = diff.normalized() * move_distance
-                    vehicle.setPos(current_pos + step)
-                    print("Phase 11: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          "fährt aus der Station, neue Position =", current_pos + step)
-                else:
-                    vehicle.setPos(target_point)
-                    print("Phase 11: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          "hat den blauen Marker erreicht. Nächster Auftrag wird gestartet.")
-                    vehicle.setPythonTag("order_state", "next_order")
-
-        return task.cont
-
-    # Neue Methode: Kontrollfenster zur Fahrzeugsteuerung
-    def show_vehicle_control(self):
-        if hasattr(self, "control_win") and self.control_win.winfo_exists():
-            self.control_win.deiconify()
-            self.control_win.lift()
-            return
-        self.control_win = tk.Toplevel()
-        self.control_win.title("Fahrzeugsteuerung")
-        self.vehicle_state_vars = {}  # Dictionary: Fahrzeug -> StringVar
-        row = 0
-        for veh in self.garage_vehicles:
-            frame = tk.Frame(self.control_win)
-            frame.grid(row=row, column=0, sticky="w", padx=5, pady=2)
-            # Verwende die benutzerfreundliche Fahrzeug-ID:
-            vid = veh.getPythonTag("vehicle_id")
-            label = tk.Label(frame, text=f"Fahrzeug {vid}")
-            label.pack(side=tk.LEFT)
-            state = veh.getPythonTag("order_state")
-            if state is None:
-                state = "idle"
-            var = tk.StringVar(value=state)
-            self.vehicle_state_vars[veh] = var
-            rb_active = tk.Radiobutton(frame, text="Aufträge bearbeiten", variable=var, value="translate")
-            rb_active.pack(side=tk.LEFT)
-            rb_standby = tk.Radiobutton(frame, text="Standby", variable=var, value="idle")
-            rb_standby.pack(side=tk.LEFT)
-            row += 1
-        update_btn = tk.Button(self.control_win, text="Übernehmen", command=self.update_vehicle_control)
-        update_btn.grid(row=row, column=0, pady=5)
-
-    def update_vehicle_control(self):
-        for veh, var in self.vehicle_state_vars.items():
-            new_state = var.get()
-            veh.setPythonTag("order_state", new_state)
-            print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Zustand auf {new_state} gesetzt.")
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: Test/KI LAB.py
===================================================================
diff --git a/Test/KI LAB.py b/Test/KI LAB.py
deleted file mode 100644
--- a/Test/KI LAB.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,182 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData,
-    GeomNode, GeomVertexWriter, GeomLines, Geom, Vec3
-)
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.interval.IntervalGlobal import Sequence, Wait, LerpPosInterval, Func
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Die Fahrzeuggeschwindigkeit wurde um den Faktor 5 erhöht (von 1,5 m/s auf 7,5 m/s)
-        self.speed = 1.5 * 5
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie mit gleichem Abstand.
-        station_count = 5
-        spacing = 5
-        # Zentrierter Startwert entlang der Y-Achse
-        y_start = -((station_count - 1) * spacing) / 2
-
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            # Annahmestation links (rot) bei x = -9
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            # Abgabestation rechts (grün) bei x = 9
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeug initialisieren
-        self.vehicle = self.loader.loadModel("models/box")
-        self.vehicle.setScale(1, 1, 0.5)
-        self.vehicle.setColor(LColor(0, 0, 1, 1))
-        self.vehicle.setPos(0, 0, 0)
-        self.vehicle.reparentTo(self.render)
-
-        self.cargo = None  # Aktuell transportiertes Paket
-        self.start_delivery_cycle()  # Start der ersten Liefersequenz
-
-    def start_delivery_cycle(self, start_pos=None):
-        """
-        Das Fahrzeug fährt direkt vom aktuellen Punkt (start_pos) zur nächsten Annahmestation,
-        holt dort ein Paket ab und fährt anschließend zur zugehörigen Abgabestation.
-        Das Paket wird auf den Würfel der Abgabestation gesetzt – nach 1 Sekunde verschwindet es.
-        """
-        # Für den initialen Zyklus gilt: Startposition ist die aktuelle Position des Fahrzeugs.
-        if start_pos is None:
-            start_pos = self.vehicle.getPos()
-
-        # Wähle zufällig einen Index für ein Stationspaar (Annahme und Abgabe liegen in derselben Y-Reihe)
-        idx = random.randrange(len(self.annahme_stationen))
-        red_station = self.annahme_stationen[idx]
-        green_station = self.abgabe_stationen[idx]
-        self.current_dropoff_station = green_station  # Wird in drop_cargo() benötigt
-
-        redPos = red_station.getPos()
-        greenPos = green_station.getPos()
-
-        # Berechne die Dauer der Bewegungen, abhängig von der Strecke und der Geschwindigkeit.
-        seg1_duration = (redPos - start_pos).length() / self.speed
-        seg2_duration = (greenPos - redPos).length() / self.speed
-
-        cycle = Sequence(
-            # Fahrt von der aktuellen Position zur Annahmestation
-            LerpPosInterval(self.vehicle, duration=seg1_duration, pos=redPos),
-            Func(self.spawn_cargo, redPos),
-            Wait(0.25),  # Wartezeit verkürzt für schnelles Erscheinen des Pakets
-            Func(self.attach_cargo_to_vehicle),
-            Wait(0.25),
-            # Fahrt von der Annahmestation zur Abgabestation
-            LerpPosInterval(self.vehicle, duration=seg2_duration, pos=greenPos),
-            Func(self.drop_cargo),  # Paket wird auf den Würfel der Abgabestation gesetzt
-            Wait(1),               # Nach 1 Sekunde wird das Paket entfernt
-            Func(self.remove_cargo),
-            # Nächsten Lieferzyklus starten ab der aktuellen Position (der Abgabestation)
-            Func(self.start_delivery_cycle, self.vehicle.getPos())
-        )
-        cycle.start()
-
-    def spawn_cargo(self, pos):
-        # Erzeugt ein neues Paket (als Würfel) an der angegebenen Position.
-        if self.cargo:
-            self.cargo.removeNode()
-        self.cargo = self.erzeuge_wuerfel(pos.getX(), pos.getY(), pos.getZ(), LColor(1, 1, 0, 1))
-
-    def attach_cargo_to_vehicle(self):
-        # Hängt das Paket als Kind des Fahrzeugs an, damit es mitbewegt wird.
-        self.cargo.wrtReparentTo(self.vehicle)
-        self.cargo.setPos(0, 0, 1)
-
-    def drop_cargo(self):
-        # Wechselt das Paket wieder in die Szene und setzt es exakt auf den Würfel der Abgabestation.
-        self.cargo.wrtReparentTo(self.render)
-        targetPos = self.current_dropoff_station.getPos() + Vec3(0, 0, 1)
-        self.cargo.setPos(targetPos)
-
-    def remove_cargo(self):
-        # Entfernt das Paket dauerhaft aus der Szene.
-        if self.cargo:
-            self.cargo.removeNode()
-            self.cargo = None
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-
-        # Horizontale Linien
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        # Vertikale Linien
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        # Erzeugt ein Wireframe-Box-Modell als Station.
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        # Erzeugt einen Würfel (als Paket), etwas über dem Boden positioniert.
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        # Einfaches Beleuchtungssetup: Ambient- und Richtungslicht.
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-# Starte die Simulation
-app = LagerSimulation()
-app.run()
Index: FFZ/FFZ19.py
===================================================================
diff --git a/FFZ/FFZ19.py b/FFZ/FFZ19.py
deleted file mode 100644
--- a/FFZ/FFZ19.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,470 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    LineSegs,
-    Vec3,
-    NodePath
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import math
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5  # Standardgeschwindigkeit in m/s
-
-        # Kameraeinstellungen (Fahrtrichtung: entlang der Y-Achse)
-        self.cam.setPos(0, -30, 10)
-        self.cam.lookAt(0, 0, 0)
-
-        # Licht und Raster erstellen
-        self.setup_light()
-        self.create_grid(center_extent=10, cell_size=0.1)
-
-        # Fahrzeug erstellen (Chassis, Gabel, Mast, etc.)
-        self.vehicle = self.create_vehicle()
-
-        # Regler für die Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Laufzeitanzeige
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom via Mausrad
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Update-Tasks
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        # Der Task zur Bewegung des Fahrzeugs wurde entfernt – somit fährt das Fahrzeug aktuell nicht.
-        # self.taskMgr.add(self.update_vehicle, "UpdateVehicleTask")
-        # Optional: Der Task für eine mögliche Gabel-Animation (update_cable) kann hinzugefügt werden:
-        # self.taskMgr.add(self.update_cable, "UpdateCableTask")
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        # Fahrzeug steht still, da dieser Task aktuell nicht aufgerufen wird.
-        dt = ClockObject.getGlobalClock().getDt()
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0  # Beschleunigungs-/Verzögerungsrate in m/s²
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    def create_grid(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            x += cell_size
-
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        grid_np = self.render.attachNewNode(node)
-        grid_np.setColor(0.7, 0.7, 0.7, 1)
-        return grid_np
-
-    def setup_light(self):
-        ambient_light = AmbientLight("ambient_light")
-        ambient_light.setColor((0.5, 0.5, 0.5, 1))
-        ambient_np = self.render.attachNewNode(ambient_light)
-        self.render.setLight(ambient_np)
-
-        directional_light = DirectionalLight("directional_light")
-        directional_light.setColor((1, 1, 1, 1))
-        directional_np = self.render.attachNewNode(directional_light)
-        directional_np.setPos(10, -10, 10)
-        self.render.setLight(directional_np)
-
-    def create_vehicle(self):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Fahrmodul (Chassis) – 1 x 0.5 x 1.2 in Rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-
-        # Gabelmodul (Fork) – Zwei Zähne (je 0.2 x 1.2 x 0.1)
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-        self.fork_node = fork_node
-
-        # --- Zeichne die Linie, die die äußersten Ecken des hinteren Endes der Zähne verbindet ---
-        # Lokale Koordinaten: linker Zahn: (0, 0, 0.05), rechter Zahn: (1.0, 0, 0.05)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_corner_global = fork_node.getPos() + left_corner_local
-        right_corner_global = fork_node.getPos() + right_corner_local
-
-        ls_new = LineSegs()
-        ls_new.setThickness(2.0)
-        ls_new.setColor(1, 1, 1, 1)  # Weiß
-        ls_new.moveTo(left_corner_global)
-        ls_new.drawTo(right_corner_global)
-        vehicle_node.attachNewNode(ls_new.create())
-
-        # --- Zusätzliche Linie: von der Mitte der obigen Linie genau senkrecht in Richtung Fahrzeug ---
-        # Berechne den Mittelpunkt der Verbindungslinie:
-        midpoint = (left_corner_global + right_corner_global) * 0.5
-
-        # Errechne den Richtungsvektor der Verbindungslinie:
-        white_line_vec = right_corner_global - left_corner_global
-        if white_line_vec.length() != 0:
-            white_line_dir = white_line_vec.normalized()
-        else:
-            white_line_dir = Vec3(0, 0, 0)
-
-        # Zwei senkrechte Richtungen (in der XY-Ebene):
-        candidate = Vec3(-white_line_dir.getY(), white_line_dir.getX(), 0)
-        # Fahrzeugposition (Chassis): Da das Chassis im Fahrzeugknoten bei (0,0,0) liegt
-        # und der Fahrzeugknoten später auf einen festen Punkt gesetzt wird,
-        # nehmen wir die globale Position des Fahrzeugknotens als Ziel.
-        vehicle_pos = vehicle_node.getPos()
-        # Wähle die senkrechte Richtung, die in Richtung des Fahrzeugs zeigt:
-        if candidate.dot(vehicle_pos - midpoint) < 0:
-            candidate = -candidate
-        if candidate.length() != 0:
-            perp_direction = candidate.normalized()
-        else:
-            perp_direction = Vec3(0, 0, 0)
-
-        # Länge der neuen Linie (z. B. 1 Meter)
-        line_length = 1.0
-        line_end = midpoint + perp_direction * line_length
-
-        ls_mid = LineSegs()
-        ls_mid.setThickness(2.0)
-        ls_mid.setColor(1, 1, 1, 1)  # Weiß
-        ls_mid.moveTo(midpoint)
-        ls_mid.drawTo(line_end)
-        vehicle_node.attachNewNode(ls_mid.create())
-
-        # --- Restlicher Fahrzeugaufbau (Mast, Diagonalen, etc.) ---
-        mast_node = vehicle_node.attachNewNode("mast")
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-
-        self.add_diagonals_to_mast(mast_node)
-        intersection = Vec3(0.5, 0.05, 1.0)
-
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        lidar_center = Vec3(intersection.x, intersection.y, -1)
-        self.add_lidar_circle(mast_node, lidar_center, 2)
-
-        # Positioniere den Fahrzeugknoten so, dass dessen X- und Y-Koordinaten dem Schnittpunkt der Diagonalen entsprechen
-        vehicle_node.setPos(intersection.x, intersection.y, 0)
-
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)  # Orange
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)  # Grün
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        # Top center
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        # Top circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        # Bottom center
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        # Bottom circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        # Top fan
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        # Bottom fan
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        # Side faces
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        # Unterseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        # Oberseite
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        # Vorderseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        # Rückseite
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        # Linke Seite
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        # Rechte Seite
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        # Unterkante
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        # Oberkante
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        # Vertikale Kanten
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: Grundmodell/Gm7.py
===================================================================
diff --git a/Grundmodell/Gm7.py b/Grundmodell/Gm7.py
deleted file mode 100644
--- a/Grundmodell/Gm7.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,575 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Für das Paketspawning an den Annahmestationen
-        self.pickup_packages = {}  # station (NodePath) -> (Paket, Spawnzeit, Timer Node)
-        self.last_removed = {}     # station -> Zeitpunkt der letzten Entfernung
-
-        # Für Graph-Daten und Steuerung
-        self.graph_data = []       # Tupel: (Sim-Zeit, Pakete pro Minute, Durchschnittliche Liegedauer)
-        self.graph_opened = False
-
-        # Ursprung (Koordinatenachsen)
-        self.draw_origin()
-
-        # Kameraeinstellungen: Das ganze Feld soll gut sichtbar sein.
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # Licht und Bodenraster erzeugen
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-
-        # Erzeuge die Mauer (das umschließende Rechteck)
-        self.create_wall()
-
-        # Erzeuge Annahme-, Abgabe- und Garagenstationen
-        self.create_annahme_stations()
-        self.create_abgabe_stations()
-        self.create_garagen_stations()
-
-        # Setze auf ALLE Annahmestationen Pakete
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # UI: Slider und Info-Anzeige zur Simulationssteuerung
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktion: Mit dem Mausrad hereinz- bzw. herauszoomen.
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        # Graph in extra Fenster per Taste "g" öffnen
-        self.accept("g", self.open_graph)
-
-        # Tasks: Aktualisierung der Simulationszeit, Info-Anzeige, Paketspawning, Paket-Timer und Graph-Daten
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, 0.5))
-            green_dot.reparentTo(self.render)
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, 0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_abgabe_station(pt)
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, 0.5))
-            green_dot.reparentTo(self.render)
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, 0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 2)
-        v5 = pos + Vec3(1, 0, 2)
-        v6 = pos + Vec3(1, 2, 2)
-        v7 = pos + Vec3(0, 2, 2)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 2)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            center = pt + Vec3(0.5, 1, 1)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        cube = self.loader.loadModel("models/box")
-        cube.setScale(1, 1, 1)
-        cube.setPos(x, y, z + 1)
-        cube.setColor(farbe)
-        cube.reparentTo(self.render)
-        return cube
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(10)
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            elapsed = self.sim_clock - spawn_time
-            timer_np.node().setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor != 0 else t
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: FFZ/FFZ1.py
===================================================================
diff --git a/FFZ/FFZ1.py b/FFZ/FFZ1.py
deleted file mode 100644
--- a/FFZ/FFZ1.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,265 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte für Simulationszeit und -geschwindigkeit
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kameraeinstellungen: Wir positionieren die Kamera so, dass das Fahrzeug gut sichtbar ist.
-        # Hier wird angenommen, dass die Fahrzeug­richtung entlang der Y-Achse (positiv) zeigt.
-        self.cam.setPos(0, -30, 10)
-        self.cam.lookAt(0, 0, 0)
-
-        # Licht und Raster (Raster-Zellen: 0.1 x 0.1)
-        self.setup_light()
-        self.create_grid(center_extent=10, cell_size=0.1)
-
-        # Fahrzeug mit den drei Modulen erstellen
-        self.create_vehicle()
-
-        # Slider zur Anpassung der Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Anzeige der Laufzeit
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktionalität: Mausrad heran-/herauszoomen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben zur Aktualisierung der Simulationszeit und Anzeige
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def create_grid(self, center_extent=40, cell_size=1):
-        """
-        Erstellt ein Raster in der XY-Ebene mit Zelle 0.1 x 0.1 (bei cell_size=0.1)
-        und zeichnet den Boden bei Z=0.
-        """
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        # Horizontale Linien
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            y += cell_size
-
-        # Vertikale Linien
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            x += cell_size
-
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        grid_np = self.render.attachNewNode(node)
-        grid_np.setColor(0.7, 0.7, 0.7, 1)
-        return grid_np
-
-    def setup_light(self):
-        ambient_light = AmbientLight("ambient_light")
-        ambient_light.setColor((0.5, 0.5, 0.5, 1))
-        ambient_np = self.render.attachNewNode(ambient_light)
-        self.render.setLight(ambient_np)
-
-        directional_light = DirectionalLight("directional_light")
-        directional_light.setColor((1, 1, 1, 1))
-        directional_np = self.render.attachNewNode(directional_light)
-        directional_np.setPos(10, -10, 10)
-        self.render.setLight(directional_np)
-
-    def create_vehicle(self):
-        """
-        Erzeugt ein fahrerloses Transportfahrzeug als 3D-Modell,
-        bestehend aus drei lückenlos verbundenen Modulen:
-
-          • Fahrmodul (Chassis): Größe 1 x 0.5 x 1.2,
-            platziert von (0,0,0) bis (1,0.5,1.2).
-
-          • Gabelmodul (Fork): Größe 1 x 1.2 x 0.3,
-            wird hinten am Fahrmodul angesetzt.
-            Da Fahrmodul in Y von 0 bis 0.5 reicht, gilt dessen Rückseite: y = 0.
-            Erzeugt wird die Box standardmäßig von y = 0 bis 1.2; durch Verschieben
-            um -1.2 in Y liegt sie von y = -1.2 bis 0.
-
-          • Mast: Größe 1 x 0.1 x 1,
-            sitzt oben auf dem Fahrmodul. Da Fahrmodul in Z bis 1.2 reicht, wird
-            der Mast mit seiner Unterkante bei z = 1.2 platziert.
-            Zur Zentrierung in Y (Fahrmodul erstreckt sich von y = 0 bis 0.5)
-            erfolgt eine Verschiebung um (0.5-0.1)/2 = 0.2 in Y.
-        """
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Fahrmodul (Chassis)
-        box_chassis = self.create_box(1, 0.5, 1.2, (0.3, 0.3, 0.3, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setPos(0, 0, 0)  # x: 0-1, y: 0-0.5, z: 0-1.2
-
-        # Gabelmodul (Fork)
-        box_fork = self.create_box(1, 1.2, 0.3, (1.0, 0.0, 0.0, 1))
-        node_fork = vehicle_node.attachNewNode(box_fork)
-        # Mit Verschiebung um -1.2 in Y wird erreicht,
-        # dass seine vordere Fläche (ursprünglich bei y = 1.2) mit der Rückseite des Fahrmoduls (y = 0) verbunden ist.
-        node_fork.setPos(0, -1.2, 0)  # x: 0-1, y: -1.2 bis 0, z: 0-0.3
-
-        # Mast: Sitzt oben auf dem Fahrmodul (untere Fläche bei z = 1.2)
-        box_mast = self.create_box(1, 0.1, 1, (1.0, 1.0, 0.0, 1))
-        node_mast = vehicle_node.attachNewNode(box_mast)
-        # Zur Zentrierung in Y: Fahrmodul erstreckt sich in Y von 0 bis 0.5 → Mittelpunkt = 0.25;
-        # Mast hat Tiefe 0.1 → setze y = 0.25 - 0.05 = 0.2.
-        node_mast.setPos(0, 0.2, 1.2)  # x: 0-1, y: 0.2-0.3, z: 1.2-2.2
-
-        # Optional: Den gesamten Fahrzeug-Knoten zentrieren (hier in X, um x=0-1 mittig zu haben)
-        vehicle_node.setPos(-0.5, 0, 0)
-
-    def create_box(self, width, depth, height, color):
-        """
-        Erzeugt einen einfachen Quader (Box) mit den Dimensionen:
-          - Breite (X): width
-          - Tiefe (Y): depth
-          - Höhe (Z): height
-        Die Box wird in den lokalen Koordinaten von (0,0,0) bis (width, depth, height) aufgebaut
-        und erhält eine einheitliche Farbe.
-        """
-        format = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData('box', format, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, 'vertex')
-        normal = GeomVertexWriter(vdata, 'normal')
-        col = GeomVertexWriter(vdata, 'color')
-
-        # Definition der 8 Eckpunkte des Quaders
-        pts = [
-            (0, 0, 0),              # 0: unten, vorne, links
-            (width, 0, 0),          # 1: unten, vorne, rechts
-            (width, depth, 0),      # 2: unten, hinten, rechts
-            (0, depth, 0),          # 3: unten, hinten, links
-            (0, 0, height),         # 4: oben, vorne, links
-            (width, 0, height),     # 5: oben, vorne, rechts
-            (width, depth, height), # 6: oben, hinten, rechts
-            (0, depth, height)      # 7: oben, hinten, links
-        ]
-        for pt in pts:
-            vertex.addData3f(*pt)
-            col.addData4f(*color)
-            normal.addData3f(0, 0, 1)  # Platzhalter-Normal
-
-        # Erzeugt Flächen: Jede Seite besteht aus 2 Dreiecken
-        triangles = GeomTriangles(Geom.UHStatic)
-
-        def add_face(a, b, c, d):
-            triangles.addVertices(a, b, c)
-            triangles.closePrimitive()
-            triangles.addVertices(a, c, d)
-            triangles.closePrimitive()
-
-        # Unterseite
-        add_face(0, 1, 2, 3)
-        # Oberseite
-        add_face(4, 5, 6, 7)
-        # Vorderseite (y = 0)
-        add_face(0, 1, 5, 4)
-        # Rückseite (y = depth)
-        add_face(3, 2, 6, 7)
-        # Linke Seite (x = 0)
-        add_face(0, 3, 7, 4)
-        # Rechte Seite (x = width)
-        add_face(1, 2, 6, 5)
-
-        geom = Geom(vdata)
-        geom.addPrimitive(triangles)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: Grundmodell/Gm9.py
===================================================================
diff --git a/Grundmodell/Gm9.py b/Grundmodell/Gm9.py
deleted file mode 100644
--- a/Grundmodell/Gm9.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,671 +0,0 @@
-import random
-import math
-import tkinter as tk  # Für das extra Fenster der Auftragsübersicht
-from tkinter import ttk  # Für die tabellarische Darstellung (Treeview)
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Für Paketspawning an den Annahmestationen:
-        # Mapping: station (Dummy-Node) -> (Paket, Spawnzeit, Timer Node)
-        self.pickup_packages = {}
-        # Hier wird gespeichert, wann zuletzt ein Paket entfernt wurde
-        self.last_removed = {}
-
-        # Für Graph-Daten (z. B. Pakete pro Minute) und Aufträge
-        self.graph_data = []  # Tupel: (Sim-Zeit, Pakete pro Minute, Durchschnittliche Liegedauer)
-        self.graph_opened = False
-
-        # Auftragsverwaltung: Jeder aktiv gespawnte Auftrag wird in diesem Dictionary abgelegt.
-        # Schlüssel: Station-Dummy, Wert: { "id": ..., "status": ..., "ziel": ... }
-        self.orders = {}
-        self.next_order_id = 1
-
-        # Tkinter-Fenster für die Auftragsübersicht (wird bei Bedarf erzeugt)
-        self.order_win = None
-        self.order_tree = None
-
-        # Ursprung (Koordinatenachsen)
-        self.draw_origin()
-
-        # Kameraeinstellungen: Das ganze Feld soll gut sichtbar sein.
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # Licht und Bodenraster
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-
-        # Erzeuge die Mauer (das umschließende Rechteck)
-        self.create_wall()
-
-        # Erzeuge Stationen
-        self.create_annahme_stations()
-        self.create_abgabe_stations()
-        self.create_garagen_stations()
-
-        # Setze auf ALLE Annahmestationen Pakete (und erstelle damit Aufträge)
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tastaturbindungen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)  # Öffnet das Auftragsfenster
-        self.accept("d", self.deliver_first_order)  # Simuliert die Abgabe (Lieferung) eines Auftrags
-
-        # Tasks
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-        self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # Annahmestationen
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, 0.5))
-            green_dot.reparentTo(self.render)
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, 0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            # Erstelle einen Auftrag für dieses Paket
-            order = {
-                "id": self.next_order_id,
-                "status": "Wartend",
-                "ziel": f"Abgabestation {random.randint(1, 10)}"
-            }
-            self.orders[station_dummy] = order
-            self.next_order_id += 1
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-    # Abgabestationen
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_abgabe_station(pt)
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, 0.5))
-            green_dot.reparentTo(self.render)
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, 0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    # Garagenstationen
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        # Hier wurde die Höhe von 2 auf 3 erhöht:
-        v4 = pos + Vec3(0, 0, 3)
-        v5 = pos + Vec3(1, 0, 3)
-        v6 = pos + Vec3(1, 2, 3)
-        v7 = pos + Vec3(0, 2, 3)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        # Hier wird das Dach auf pos.z+3 platziert (statt +2)
-        roof.setPos(pos.x, pos.y, pos.z + 3)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            # Berechnung des Mittelpunkts der Garage (wird intern verwendet, aber nicht angezeigt)
-            # Für eine Garage mit 3 m Höhe: Mittelpunkt in Z = 1.5
-            center = pt + Vec3(0.5, 1, 1.5)
-
-            # Neuer Punkt "ParkpunktGarage" vom (internen) Mittelpunkt der Garage + Vektor (0, -1, 1.2)
-            ParkpunktGarage = center + Vec3(0, -1, 1.2)
-            park_marker = self.loader.loadModel("models/misc/sphere")
-            park_marker.setScale(0.15)
-            park_marker.setColor(LColor(1, 0, 1, 1))
-            park_marker.setPos(ParkpunktGarage)
-            park_marker.reparentTo(self.render)
-
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        cube = self.loader.loadModel("models/box")
-        cube.setScale(1, 1, 1)
-        cube.setPos(x, y, z + 1)
-        cube.setColor(farbe)
-        cube.reparentTo(self.render)
-        return cube
-
-    def check_and_spawn_packages(self, task):
-        # Wenn an einer Station kein Paket vorhanden ist, erscheint nach 10 s (Simulationszeit) ein neues.
-        spawn_delay = self.sim_time(10)
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-        # Erstelle einen Auftrag für dieses Paket
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {random.randint(1, 10)}"
-        }
-        self.orders[station] = order
-        self.next_order_id += 1
-
-    def update_package_timers(self, task):
-        # Aktualisiere nur den angezeigten Timer (Pakete bleiben erhalten)
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            elapsed = self.sim_clock - spawn_time
-            timer_np.node().setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor != 0 else t
-
-    def update_order_status(self, task):
-        # Entferne Aufträge mit Status "Abgegeben", deren Abgabezeitpunkt älter als 2 s ist
-        for station, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[station]
-        # Aktualisiere das Auftragsfenster, falls es geöffnet ist
-        if self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def deliver_first_order(self):
-        # Simuliere die Lieferung des ersten Auftrags, der noch den Status "Wartend" hat
-        for station, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        import matplotlib.pyplot as plt
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.setTitle("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.setTitle("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        import matplotlib.pyplot as plt
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-    # Neue Funktion: Auftragsübersicht in einem separaten Fenster (als Tabelle) anzeigen
-    def show_order_list(self):
-        # Wenn das Fenster noch nicht existiert, erstelle es.
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            # Beim Schließen wird das Fenster nur versteckt.
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            self.order_tree = ttk.Treeview(self.order_win, columns=("ID", "Status", "Ziel"), show="headings", height=15)
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Status", text="Status")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Status", width=100, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            # Falls das Fenster bereits existiert, zeige es an.
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-    def update_order_table(self):
-        # Lösche alle vorhandenen Zeilen im Treeview
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-        # Füge alle aktuellen Aufträge hinzu
-        for order in self.orders.values():
-            self.order_tree.insert("", tk.END, values=(order["id"], order["status"], order["ziel"]))
-        self.order_win.update()
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: FFZ/FFZ7.py
===================================================================
diff --git a/FFZ/FFZ7.py b/FFZ/FFZ7.py
deleted file mode 100644
--- a/FFZ/FFZ7.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,325 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    CardMaker,
-    LineSegs,
-    Vec3
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import math
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte für Simulationszeit und -geschwindigkeit
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kameraeinstellungen (Annahme: Fahrtrichtung entlang der Y-Achse)
-        self.cam.setPos(0, -30, 10)
-        self.cam.lookAt(0, 0, 0)
-
-        # Licht und Raster
-        self.setup_light()
-        self.create_grid(center_extent=10, cell_size=0.1)
-
-        # Fahrzeug erstellen und Referenz speichern
-        self.vehicle = self.create_vehicle()
-
-        # Slider zur Anpassung der Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Slider zur Steuerung der Forkhöhe (0 bis 1 Meter)
-        self.fork_slider = DirectSlider(
-            range=(0.0, 1.0),
-            value=0.0,
-            pageSize=0.01,
-            command=self.update_fork_height,
-            pos=(-0.7, 0, -0.85),
-            scale=0.3
-        )
-        self.fork_label = DirectLabel(
-            text="Fork Höhe: 0.00m",
-            pos=(-0.7, 0, -0.75),
-            scale=0.07
-        )
-
-        # Anzeige der Laufzeit
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktionalität
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben hinzufügen:
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_cable, "UpdateCableTask")
-        # update_vehicle wird hier nicht verwendet, da das Fahrzeug stationär bleiben soll.
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_fork_height(self, height=0, *args):
-        try:
-            height = float(height)
-        except ValueError:
-            height = 0.0
-        self.fork_node.setZ(height)
-        self.fork_label['text'] = f"Fork Höhe: {height:.2f}m"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def create_grid(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            x += cell_size
-
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        grid_np = self.render.attachNewNode(node)
-        grid_np.setColor(0.7, 0.7, 0.7, 1)
-        return grid_np
-
-    def setup_light(self):
-        ambient_light = AmbientLight("ambient_light")
-        ambient_light.setColor((0.5, 0.5, 0.5, 1))
-        ambient_np = self.render.attachNewNode(ambient_light)
-        self.render.setLight(ambient_np)
-
-        directional_light = DirectionalLight("directional_light")
-        directional_light.setColor((1, 1, 1, 1))
-        directional_np = self.render.attachNewNode(directional_light)
-        directional_np.setPos(10, -10, 10)
-        self.render.setLight(directional_np)
-
-    def create_vehicle(self):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Fahrmodul (Chassis) – Farbe: Rot, Dimensionen: 1 x 0.5 x 1.2
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-
-        # Gabelmodul (Fork) – Jetzt mit Höhe 0.1 statt 0.2
-        # Wir erstellen einen Elternknoten für die Zähne:
-        fork_node = vehicle_node.attachNewNode("fork")
-        # Positioniere den Fork-Knoten so, dass die freie Seite (global y = -1.2) genutzt wird.
-        fork_node.setPos(0, -1.2, 0)
-
-        # Linker Zahn: Größe 0.2 x 1.2 x 0.1 (in X, Y, Z)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)  # Linker Zahn von X=0 bis X=0.2
-
-        # Rechter Zahn: Größe 0.2 x 1.2 x 0.1
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)  # Rechter Zahn von X=0.8 bis X=1.0
-
-        # Speichere den Fork-Knoten für spätere Höhenanpassungen
-        self.fork_node = fork_node
-
-        # Optional: Hier könntest du weitere Details (z. B. einen Rahmen) hinzufügen,
-        # falls gewünscht. Für dieses Beispiel belassen wir die Zähne so.
-
-        # Mast – Farbe: Dunkles Grau, Dimensionen: 1 x 0.1 x 1, platziert ab z=1.2
-        box_mast = self.create_box(1, 0.1, 1, (0.2, 0.2, 0.2, 1))
-        node_mast = vehicle_node.attachNewNode(box_mast)
-        node_mast.setTwoSided(True)
-        node_mast.setPos(0, 0.2, 1.2)
-
-        vehicle_node.setPos(-0.5, 0, 0)
-        return vehicle_node
-
-    def add_rectangle_to_fork(self, fork_node):
-        """
-        Fügt dem Gabelmodul-Knoten einen Rahmen (ohne Füllung) hinzu, der in lokalen
-        XY-Koordinaten von (0,0) bis (1,1) auf der oberen Fläche (jetzt z = 0.101, da die Höhe 0.1 beträgt)
-        liegt. Zusätzlich werden zwei Diagonalen eingezeichnet und ein Marker am Schnittpunkt,
-        der um 0.5 Einheiten in Z angehoben wird (0.101 + 0.5 = 0.601).
-        """
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)  # Orange
-
-        # Rahmen zeichnen: Oberseite des Gabelmoduls ist jetzt 0.1, also setzen wir den Rahmen knapp darüber (0.101)
-        ls.moveTo(0, 0, 0.101)
-        ls.drawTo(1, 0, 0.101)
-        ls.drawTo(1, 1, 0.101)
-        ls.drawTo(0, 1, 0.101)
-        ls.drawTo(0, 0, 0.101)
-
-        # Diagonale 1: von (0,0) nach (1,1)
-        ls.moveTo(0, 0, 0.101)
-        ls.drawTo(1, 1, 0.101)
-
-        # Diagonale 2: von (1,0) nach (0,1)
-        ls.moveTo(1, 0, 0.101)
-        ls.drawTo(0, 1, 0.101)
-
-        fork_node.attachNewNode(ls.create())
-
-        # Marker am Schnittpunkt der Diagonalen: (0.5, 0.5, 0.101) → Marker bei z = 0.101 + 0.5 = 0.601
-        point = loader.loadModel("models/smiley")
-        point.setScale(0.05)
-        point.setPos(0.5, 0.5, 0.601)
-        point.setColor(1, 1, 1, 0.5)  # transparent
-        point.setTransparency(True)
-        point.reparentTo(fork_node)
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        # Unterseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        # Oberseite
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        # Vorderseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        # Rückseite
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        # Linke Seite
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        # Rechte Seite
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def update_cable(self, task):
-        """
-        Animiert das Heben und Senken des Gabelmoduls (Kabel) automatisch, sodass sich seine Z-Position
-        periodisch (sinusförmig) zwischen 0 und 1 Meter ändert.
-        """
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)  # Werte zwischen 0 und 1
-        self.fork_node.setZ(new_height)
-        self.fork_label['text'] = f"Fork Höhe: {new_height:.2f}m"
-        return Task.cont
-
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: Grundmodell/Gm20.py
===================================================================
diff --git a/Grundmodell/Gm20.py b/Grundmodell/Gm20.py
deleted file mode 100644
--- a/Grundmodell/Gm20.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,1537 +0,0 @@
-import random
-import math
-import tkinter as tk  # Für das extra Fenster der Auftragsübersicht
-from tkinter import ttk  # Für die tabellarische Darstellung (Treeview)
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-from direct.task.TaskManagerGlobal import taskMgr
-
-
-from functools import partial
-
-
-
-
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-            super().__init__()
-
-            # Basis-Simulationsvariablen
-            self.sim_clock = 0.0
-            self.speed_factor = 1.0
-            self.current_speed = 1.5  # Wird in update_vehicle genutzt
-            self.state_timer = 0.0
-
-            # Kennzahlen (KPIs)
-            self.delivered_packages = 0
-            self.max_overall_wait_time = 0.0
-            self.total_dwell_time = 0.0
-            self.picked_up_count = 0
-
-            # Paketspawning an den Annahmestationen:
-            # Mapping: station (Dummy-Node) -> (Paket, Spawnzeit, Timer Node)
-            self.pickup_packages = {}
-            self.last_removed = {}
-
-            # Fahrzeug-spezifische Zuordnung: Fahrzeug -> transportiertes Paket
-            self.cargos = {}
-
-            # NEU: Initialisiere die belegten Annahmestationen
-            self.occupied_pickups = set()  # Oder: [] für eine Liste
-
-            # Graph-Daten (Sim-Zeit, Pakete pro Minute, durchschnittliche Liegedauer)
-            self.graph_data = []
-            self.graph_opened = False
-
-            # Auftragsverwaltung: Speichere alle Aufträge (für die Anzeige) sowie in
-            # einer Queue (Liste) zur sequentiellen Abarbeitung.
-            self.orders = {}
-            self.orders_queue = []
-            self.next_order_id = 1
-
-            # Tkinter-Fenster für Auftragsübersicht
-            self.order_win = None
-            self.order_tree = None
-
-            # Umgebung initialisieren
-            self.draw_origin()
-            self.cam.setPos(11, -80, 40)
-            self.cam.lookAt(11, 30, 0)
-            self.erzeuge_licht()
-            self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-            self.create_wall()
-            self.create_annahme_stations()
-            self.create_abgabe_stations()  # Hier wird auch self.abgabe_stations angelegt.
-            self.create_garagen_stations()
-
-            for station in self.annahme_stations:
-                self.spawn_package_at_station(station)
-
-            # Fahrzeuge in den Garagen erstellen (genau 5 Fahrzeuge)
-            self.create_garage_vehicles()
-
-            # NEU: Testvariablen (werden nicht mehr aktiv über diesen globalen Mechanismus gesteuert)
-            self.first_vehicle_order_state = "idle"
-            self.attached_package = None
-            self.current_order = None  # Der aktuell abgearbeitete Auftrag (wird durch Fahrzeuge individuell genutzt)
-
-            # UI – Slider und Info-Anzeige
-            self.speed_slider = DirectSlider(
-                range=(0.1, 10.0),
-                value=self.speed_factor,
-                pageSize=0.1,
-                command=self.update_simulation_speed,
-                pos=(0, 0, -0.85),
-                scale=0.3
-            )
-            self.speed_label = DirectLabel(
-                text=f"Sim Time Factor: {self.speed_factor:.1f}",
-                pos=(0, 0, -0.75),
-                scale=0.07
-            )
-            self.info_label = DirectLabel(
-                text="Laufzeit: 0.0s",
-                pos=(1.2, 0, 0.8),
-                scale=0.07,
-                frameColor=(0, 0, 0, 0)
-            )
-
-            # Tastenzuordnungen
-            self.accept("wheel_up", self.zoom_in)
-            self.accept("wheel_down", self.zoom_out)
-            self.accept("g", self.open_graph)
-            self.accept("a", self.show_order_list)
-            self.accept("d", self.deliver_first_order)
-            # Taste C öffnet das Fahrzeug-Kontrollfenster
-            self.accept("c", self.show_vehicle_control)
-
-            # Task-Manager
-            self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-            self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-            self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-            self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-            self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-            self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    # ---------------------------
-    # SIMULATION UND UI-METHODEN
-    # ---------------------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        # dt jetzt skaliert mit der Simulationsgeschwindigkeit
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    # ---------------------------
-    # METHODEN FÜR RASTER, LICHT, MAUER, URSPRUNG
-    # ---------------------------
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # STATIONSOBJEKTE UND ZUORDNUNG
-    # -----------------------------------
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        """
-        Erzeugt die Annahmestationen und erstellt für jede Station:
-          - Einen weißen Marker zur Orientierung
-          - Einen grünen Punkt (optional)
-          - Eine weiße Linie, an deren Endpunkt ein blauer Marker als Ziel in der "Translate‑Phase" dient
-
-        Zusätzlich wird ein Dictionary self.station_blue_dots aufgebaut, in dem jedem Annahmestations‑Node
-        der zugehörige blaue Marker zugeordnet wird. Außerdem wird für die erste Station die globale Variable
-        self.station_white_direction festgelegt.
-        """
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        self.station_blue_dots = {}
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basisstation (zum Beispiel als Rahmen)
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Erzeuge den weißen Marker als Orientierung
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Erzeuge den grünen Punkt (optional)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zeichne die weiße Linie: Sie beginnt bei center + Vec3(0, 0, -0.5) und verläuft 3 Meter in X‑Richtung.
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Erzeuge den blauen Marker, der als Ziel in der Translate‑Phase dient
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            # Speichere den blauen Marker im Dictionary, sodass er später erzeugt werden kann
-            self.station_blue_dots[station_dummy] = blue_dot
-
-            # Optionale Textanzeige der Stationsnummer
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) – falls benötigt:
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-            # Für die erste Station (oder den ersten relevanten Pickup) setzen wir globale Referenzen,
-            # die in vehicle_order_task benötigt werden.
-            if i == 1:
-                self.blue_dot = blue_dot
-                self.station_green_dot = green_dot
-                # Berechne den Mittelpunkt der weißen Linie als Referenz (optional)
-                self.white_line_center = (start_line + end_line) * 0.5
-                line_vec = end_line - start_line
-                if line_vec.length() != 0:
-                    self.station_white_direction = Vec2(line_vec.getX(), line_vec.getY()).normalized()
-                else:
-                    self.station_white_direction = Vec2(1, 0)  # Fallback-Wert
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        self.abgabe_stations = []  # Liste der Abgabestationen
-        self.abgabe_blue_dots = []  # Liste zum Speichern der blauen Marker für die Abgabe
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basiskonstruktion der Abgabestation
-            node = self.create_abgabe_station(pt)
-            self.abgabe_stations.append(node)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Marker am Zentrum (weiß)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Grüner Punkt: center + Vec3(0, 0, -0.5)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Weiße Linie: Startet bei center + Vec3(0, 0, -0.5)
-            # und verläuft 3 Meter in negativer X-Richtung
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt: wird an der Endposition der Linie erzeugt
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            # Speichere den blauen Marker für spätere Navigation der Abgabestation
-            self.abgabe_blue_dots.append(blue_dot)
-
-            # Anzeige der Stationsnummer (textuell)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) auf der Station
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 3)
-        v5 = pos + Vec3(1, 0, 3)
-        v6 = pos + Vec3(1, 2, 3)
-        v7 = pos + Vec3(0, 2, 3)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 3)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        self.garagen_stations = []
-        self.garagen_parking_points = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            self.garagen_stations.append(pt)
-            # ParkpunktGarage: Verschoben um 0.5 in negativer Y-Richtung:
-            center = pt + Vec3(0.5, 0.5, 1.5)
-            ParkpunktGarage = center + Vec3(0, 0, 0.7)
-            self.garagen_parking_points.append(ParkpunktGarage)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def create_garage_vehicles(self):
-        self.garage_vehicles = []
-        vehicle_id_counter = 1
-        for park in self.garagen_parking_points:
-            veh = self.create_vehicle(park_point=park)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            newPos.setZ(0)
-            veh.setPos(newPos)
-
-         # Fahrzeuge starten zunächst im Standby (idle)
-            veh.setPythonTag("current_order", None)
-            veh.setPythonTag("order_state", "idle")
-            veh.setPythonTag("package_attached", False)
-        # Setze einen benutzerfreundlichen Fahrzeug-Identifikator
-            veh.setPythonTag("vehicle_id", vehicle_id_counter)
-            vehicle_id_counter += 1
-
-            self.garage_vehicles.append(veh)
-
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-        # Registriere den Task (Fahrzeug-spezifisch)
-            self.taskMgr.add(partial(self.vehicle_order_task, veh),
-                         f"VehicleOrderTask_{veh.getPythonTag('vehicle_id')}")
-
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # FAHRZEUGERSTELLUNG (FFZ20-INTEGRATION)
-    # -----------------------------------
-    def create_vehicle(self, park_point=None):
-        # Erzeuge den übergeordneten Fahrzeug-Knoten
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # --------------------------
-        # Chassis erstellen (1 x 0.5 x 1.2, Farbe Rot)
-        # --------------------------
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # --------------------------
-        # Gabel (Fork) erstellen: Zwei Zähne
-        # --------------------------
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-
-        # Speichere den Gabel-Knoten als Python-Tag am Fahrzeug
-        vehicle_node.setPythonTag("fork_node", fork_node)
-
-        # --------------------------
-        # Erzeuge den grünen Referenzmarker (Gabel – grüner Punkt)
-        # --------------------------
-        ls_new = LineSegs()
-        ls_new.setThickness(2.0)
-        ls_new.setColor(1, 1, 1, 1)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_corner_global = fork_node.getPos() + left_corner_local
-        right_corner_global = fork_node.getPos() + right_corner_local
-        ls_new.moveTo(left_corner_global)
-        ls_new.drawTo(right_corner_global)
-        vehicle_node.attachNewNode(ls_new.create())
-        midpoint = (left_corner_global + right_corner_global) * 0.5
-        white_line_vec = right_corner_global - left_corner_global
-        white_line_dir = white_line_vec.normalized() if white_line_vec.length() != 0 else Vec3(0, 0, 0)
-        candidate = Vec3(-white_line_dir.getY(), white_line_dir.getX(), 0)
-        perp_direction = candidate.normalized() if candidate.length() != 0 else Vec3(0, 0, 0)
-        green_point_global = midpoint + perp_direction * 0.5
-
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        # Speichere den grünen Marker ebenfalls als Python-Tag
-        vehicle_node.setPythonTag("fork_green", green_marker_np)
-
-        # --------------------------
-        # Mast und weitere Fahrzeugteile
-        # --------------------------
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-        self.add_diagonals_to_mast(mast_node)
-        intersection = Vec3(0.5, 0.05, 1.0)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-        self.vehicle_cylinder = cylinder_node
-
-        # --------------------------
-        # Fahrzeugpositionierung am Parkpunkt
-        # --------------------------
-        if park_point is None:
-            vehicle_node.setPos(intersection.x, intersection.y, 0)
-        else:
-            vehicle_node.setPos(park_point - vehicle_node.getQuat().xform(intersection))
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        # Verwende die simulative Zeit, die bereits in update_sim_clock hochgezählt wird
-        t = self.sim_clock
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    # -----------------------------------
-    # FEHLENDE METHODEN: Paketspawning, Würfelerzeugung u.a.
-    # -----------------------------------
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Bestimme zufällig eine Abgabestation als Ziel
-        if hasattr(self, "abgabe_stations") and self.abgabe_stations:
-            target_index = random.randint(1, len(self.abgabe_stations))
-        else:
-            target_index = 1
-
-        # Erstelle den Auftrag zur Annahmestation
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def update_order_table(self):
-        """
-        Aktualisiert die Auftragsübersicht in der Tkinter-Tabelle und zeigt in der
-        letzten Spalte den zugewiesenen Fahrzeugnamen (oder "-" falls noch keiner zugeordnet wurde).
-        """
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen (z. B. "annahme_station_3") die Stationsnummer.
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z. B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige in der letzten Spalte den zugewiesenen Fahrzeugnamen an (oder "-" falls noch kein Fahrzeug zugewiesen ist).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END, values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = 5.0  # 5 Sekunden Verzögerung zwischen Spawns
-        for station in self.annahme_stations:
-            # Wenn aktuell kein Paket an der Station ist
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                # Prüfe, ob seit der letzten Entnahme mindestens 5 Sekunden vergangen sind
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0.0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Wir legen hier die Spalten in der gewünschten Reihenfolge an: Auftrags ID, Annahmestation, Ziel, Fahrzeug.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Hole die fahrzeugspezifischen Knoten mittels getPythonTag
-            fork_node = vehicle.getPythonTag("fork_node")
-            fork_green = vehicle.getPythonTag("fork_green")
-
-            # Hole die Position des grünen Markers relativ zum Gabelknoten
-            green_point_pos = fork_green.getPos(fork_node)
-
-            # Reparent das Paket zur Gabel des Fahrzeugs und positioniere es entsprechend
-            package.wrtReparentTo(fork_node)
-            package.setPos(
-                green_point_pos.getX() + 0.5,  # Offset in X-Richtung
-                green_point_pos.getY() - 0.5,  # Offset in Y-Richtung
-                green_point_pos.getZ() + 1  # Z-Offset, sodass das Paket oberhalb liegt
-            )
-
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    from direct.task.TaskManagerGlobal import taskMgr  # Sicherstellen, dass taskMgr verfügbar ist
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden removeCargoTask aufruft,
-            # und übergib dabei das cargo als extra Argument:
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return Task.done
-
-    def select_next_order(self, vehicle):
-        # Filtern aller Aufträge mit dem Status "Wartend"
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        # Berechne für jeden Auftrag die Liegedauer
-        for order in waiting_orders:
-            dwell_time = self.sim_clock - order.get("spawn_time", self.sim_clock)
-            order["dwell_time"] = dwell_time
-
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01  # Zur Berücksichtigung von Rundungsfehlern
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        # Verwende das Fahrzeug, das gerade einen Auftrag bekommen soll,
-        # um den Abstand der Pickup-Station zu berechnen.
-        vehicle_pos = vehicle.getPos(self.render)
-
-        def distance_to_station(order):
-            station = order.get("pickup_station")
-            if station:
-                station_pos = station.getPos(self.render)
-                return (station_pos - vehicle_pos).length()
-            return float('inf')
-
-        candidates.sort(key=distance_to_station)
-        chosen_order = candidates[0]
-        # Setze beim Auftrag auch den bearbeitenden Fahrzeugnamen basierend auf unserer benutzerfreundlichen ID:
-        chosen_order["vehicle"] = f"Fahrzeug {vehicle.getPythonTag('vehicle_id')}"
-        return chosen_order
-
-    def vehicle_order_task(self, vehicle, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-
-        # Bleibt im idle-Zustand, wenn nicht über das Kontrollfenster aktiviert
-        if vehicle.getPythonTag("order_state") == "idle":
-            return task.cont
-
-        state = vehicle.getPythonTag("order_state")
-        current_order = vehicle.getPythonTag("current_order")
-
-        # ------------------ Phase 1: Translate ------------------
-        if state == "translate":
-            if current_order is None:
-                next_order = self.select_next_order(vehicle)
-                if next_order is not None:
-                    vehicle.setPythonTag("current_order", next_order)
-                    next_order["status"] = "In Bearbeitung"
-                    print(
-                        f"Auftrag {next_order['id']} wird zugewiesen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}.")
-                else:
-                    print("Kein Auftrag verfügbar – Fallback zum globalen Ziel.")
-            current_order = vehicle.getPythonTag("current_order")
-            if current_order is not None:
-                pickup_station = current_order.get("pickup_station")
-                if pickup_station in self.station_blue_dots:
-                    blue_target = self.station_blue_dots[pickup_station].getPos(self.render)
-                else:
-                    blue_target = self.blue_dot.getPos(self.render)
-            else:
-                blue_target = self.blue_dot.getPos(self.render)
-
-            local_mast = Vec3(0.5, 0.05, 1.0)
-            mast_global = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(local_mast)
-            target_xy = Vec2(blue_target.getX(), blue_target.getY())
-            mast_xy = Vec2(mast_global.getX(), mast_global.getY())
-            error_vector = target_xy - mast_xy
-            threshold = 0.05
-            if error_vector.length() > threshold:
-                direction = error_vector.normalized()
-                move_distance = 1.5 * dt
-                current_pos = vehicle.getPos(self.render)
-                new_pos = Vec3(current_pos.getX() + direction.getX() * move_distance,
-                               current_pos.getY() + direction.getY() * move_distance, 0)
-                vehicle.setPos(new_pos)
-            else:
-                local_offset = vehicle.getQuat(self.render).xform(local_mast)
-                exact_pos = Vec3(blue_target.getX() - local_offset.getX(),
-                                 blue_target.getY() - local_offset.getY(), 0)
-                vehicle.setPos(exact_pos)
-                vehicle.setPythonTag("order_state", "rotate")
-
-        # ------------------ Phase 2: Rotate ------------------
-        elif state == "rotate":
-            desired_angle = math.degrees(math.atan2(self.station_white_direction.getY(),
-                                                    self.station_white_direction.getX()))
-            desired_angle = (desired_angle + 180) % 360
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_angle - current_heading + 180) % 360) - 180
-            kp_heading = 0.5
-            new_heading = current_heading + kp_heading * angle_diff
-            vehicle.setH(new_heading)
-            if abs(angle_diff) < 1.0:
-                vehicle.setPythonTag("order_state", "turn_right")
-
-        # ------------------ Phase 3: Turn Right ------------------
-        elif state == "turn_right":
-            if vehicle.getPythonTag("turn_right_init") is None:
-                vehicle.setPythonTag("turn_right_init", vehicle.getH() % 360)
-                vehicle.setPythonTag("turn_right_target", (vehicle.getPythonTag("turn_right_init") + 90) % 360)
-                print("Phase 3: Initialisiert für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "Start Heading =", vehicle.getPythonTag("turn_right_init"),
-                      "Target Heading =", vehicle.getPythonTag("turn_right_target"))
-            current_heading = vehicle.getH() % 360
-            turn_right_target = vehicle.getPythonTag("turn_right_target")
-            angle_diff = ((turn_right_target - current_heading + 180) % 360) - 180
-            kp_turn = 0.5
-            turn_rate = kp_turn * angle_diff
-            new_heading = current_heading + turn_rate * dt
-            vehicle.setH(new_heading)
-            print("Phase 3: Fahrzeug", vehicle.getPythonTag("vehicle_id"), "- Aktuelles Heading =", current_heading,
-                  "Winkelabweichung =", angle_diff,
-                  "Neues Heading =", new_heading)
-            if abs(angle_diff) < 1.0:
-                print("Phase 3: Drehung abgeschlossen für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      ". Übergang in 'approach'.")
-                vehicle.setPythonTag("order_state", "approach")
-                vehicle.clearPythonTag("turn_right_init")
-                vehicle.clearPythonTag("turn_right_target")
-
-        # ------------------ Phase 4: Approach ------------------
-        elif state == "approach":
-            if current_order is not None:
-                pickup_station = current_order.get("pickup_station")
-                target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-            else:
-                target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-            current = vehicle.getPos(self.render)
-            error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-            if error_vec.length() > 0.05:
-                direction = error_vec.normalized()
-                move_distance = 1.5 * dt
-                new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                               current.getY() + direction.getY() * move_distance,
-                               target.getZ())
-                vehicle.setPos(new_pos)
-            else:
-                vehicle.setPos(target)
-                vehicle.setPythonTag("order_state", "pickup")
-
-        # ------------------ Phase 5: Pickup ------------------
-        elif state == "pickup":
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            target_z = 1.0
-            raise_speed = 0.5
-            if current_z < target_z:
-                fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-            else:
-                if current_order is None:
-                    if self.orders_queue:
-                        vehicle.setPythonTag("current_order", self.orders_queue.pop(0))
-                    else:
-                        print("Keine verfügbaren Aufträge für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                              ". Überspringe Pickup-Phase.")
-                        vehicle.setPythonTag("order_state", "drive_out")
-                        return task.cont
-                pickup_station = vehicle.getPythonTag("current_order")["pickup_station"]
-                self.pickup_package(vehicle, pickup_station)
-                vehicle.setPythonTag("package_attached", True)
-                vehicle.setPythonTag("drive_out_start", vehicle.getPos(self.render))
-                vehicle.setPythonTag("drive_out_target",
-                                     vehicle.getPos(self.render) + vehicle.getQuat(self.render).getForward() * 5.0)
-                vehicle.setPythonTag("order_state", "drive_out")
-
-        # ------------------ Phase 6: Drive Out ------------------
-        elif state == "drive_out":
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            if current_z > 0.0:
-                lower_speed = 0.5
-                fork_node.setZ(max(0.0, current_z - lower_speed * dt))
-            current_pos = vehicle.getPos(self.render)
-            drive_out_target = vehicle.getPythonTag("drive_out_target")
-            diff = drive_out_target - current_pos
-            if diff.length() > 0.1:
-                move_distance = 0.5 * dt
-                step = diff.normalized() * move_distance
-                vehicle.setPos(current_pos + step)
-            else:
-                vehicle.setPythonTag("order_state", "to_delivery")
-
-        # ------------------ Phase 7: To Delivery ------------------
-        elif state == "to_delivery":
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current_pos = vehicle.getPos(self.render)
-            diff = blue_target - current_pos
-            threshold = 0.5
-            move_distance = 1.5 * dt
-            if move_distance > diff.length():
-                vehicle.setPos(blue_target)
-            else:
-                vehicle.setPos(current_pos + diff.normalized() * move_distance)
-            if (blue_target - vehicle.getPos(self.render)).length() <= threshold:
-                print("Phase 7 abgeschlossen: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "hat den blauen Punkt der Abgabestation erreicht.")
-                vehicle.setPythonTag("order_state", "align_delivery")
-
-        # ------------------ Phase 8: Align Delivery ------------------
-        elif state == "align_delivery":
-            desired_heading = 90.0
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_heading - current_heading + 180) % 360) - 180
-            print("Phase 8: Align Delivery | Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                  "Current Heading: {:.2f}°, Desired: {:.2f}°, Diff: {:.2f}°".format(
-                      current_heading, desired_heading, angle_diff))
-            fixed_turn_speed = 90.0
-            turn_amount = fixed_turn_speed * dt
-            if abs(angle_diff) < 1.0:
-                vehicle.setH(desired_heading)
-                print("Phase 8 abgeschlossen: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "ausgerichtet (Heading = {:.2f}°).".format(desired_heading))
-                vehicle.setPythonTag("order_state", "delivery_center")
-            else:
-                if angle_diff > 0:
-                    new_heading = current_heading + turn_amount
-                else:
-                    new_heading = current_heading - turn_amount
-                new_heading %= 360
-                vehicle.setH(new_heading)
-                print("Phase 8: Rotating - Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "New Heading set to {:.2f}°".format(new_heading))
-
-        # ------------------ Phase 9: Delivery Approach ------------------
-        elif state == "delivery_center":
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current = vehicle.getPos(self.render)
-            target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-            print("Phase 9: Zielpunkt der Abgabestation für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                  "=", target_point)
-            error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-            tolerance = 0.05
-            move_distance = 1.5 * dt
-            if error_vec.length() > tolerance:
-                direction = error_vec.normalized()
-                new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                               current.getY() + direction.getY() * move_distance,
-                               current.getZ())
-                vehicle.setPos(new_pos)
-                print("Phase 9: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "bewegt sich von", current, "nach", new_pos)
-            else:
-                vehicle.setPos(target_point)
-                print("Phase 9: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "hat den Zielpunkt erreicht.")
-                vehicle.setPythonTag("order_state", "drop")
-            # Gabel anheben in Phase 9
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_fork_z = fork_node.getZ()
-            if current_fork_z < 1.0:
-                new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-                fork_node.setZ(new_fork_z)
-                print("Phase 9: Gabel für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "wird angehoben (Z =", new_fork_z, ").")
-
-        # ------------------ Phase 10: Dropoff ------------------
-        elif state == "drop":
-            if vehicle.getPythonTag("package_attached"):
-                delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-                self.drop_cargo(vehicle)
-                print("Phase 10: Paket abgesetzt für Fahrzeug", vehicle.getPythonTag("vehicle_id"))
-                vehicle.setPythonTag("package_attached", False)
-            else:
-                fork_node = vehicle.getPythonTag("fork_node")
-                current_z = fork_node.getZ()
-                if current_z > 0.0:
-                    lower_speed = 0.5
-                    new_z = max(0.0, current_z - lower_speed * dt)
-                    fork_node.setZ(new_z)
-                    print("Phase 10: Gabel wird abgesenkt für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          ", aktueller Z-Wert =", new_z)
-                else:
-                    print("Phase 10: Dropoff vollständig abgeschlossen für Fahrzeug",
-                          vehicle.getPythonTag("vehicle_id"))
-                    vehicle.setPythonTag("order_state", "translate")
-                    # Hier ändern wir den Status des Auftrags zu "Abgegeben" statt "Erledigt"
-                    current_order["status"] = "Abgegeben"
-                    current_order["delivered_at"] = self.sim_clock
-                    vehicle.setPythonTag("current_order", None)
-
-        # ------------------ Phase 11: Exit Station and Start Next Order ------------------
-        elif state == "phase11":
-            if vehicle.getPythonTag("last_delivery_marker") is not None:
-                target_point = vehicle.getPythonTag("last_delivery_marker")
-            else:
-                delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    target_point = self.abgabe_blue_dots[0].getPos(self.render)
-                print("Phase 11: Zielpunkt (blauer Marker) für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "=", target_point)
-                current_pos = vehicle.getPos(self.render)
-                diff = target_point - current_pos
-                if diff.length() > 0.1:
-                    move_distance = 0.5 * dt
-                    step = diff.normalized() * move_distance
-                    vehicle.setPos(current_pos + step)
-                    print("Phase 11: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          "fährt aus der Station, neue Position =", current_pos + step)
-                else:
-                    vehicle.setPos(target_point)
-                    print("Phase 11: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          "hat den blauen Marker erreicht. Nächster Auftrag wird gestartet.")
-                    vehicle.setPythonTag("order_state", "next_order")
-
-        return task.cont
-
-    # Neue Methode: Kontrollfenster zur Fahrzeugsteuerung
-    def show_vehicle_control(self):
-        if hasattr(self, "control_win") and self.control_win.winfo_exists():
-            self.control_win.deiconify()
-            self.control_win.lift()
-            return
-        self.control_win = tk.Toplevel()
-        self.control_win.title("Fahrzeugsteuerung")
-        self.vehicle_state_vars = {}  # Dictionary: Fahrzeug -> StringVar
-        row = 0
-        for veh in self.garage_vehicles:
-            frame = tk.Frame(self.control_win)
-            frame.grid(row=row, column=0, sticky="w", padx=5, pady=2)
-            # Verwende die benutzerfreundliche Fahrzeug-ID:
-            vid = veh.getPythonTag("vehicle_id")
-            label = tk.Label(frame, text=f"Fahrzeug {vid}")
-            label.pack(side=tk.LEFT)
-            state = veh.getPythonTag("order_state")
-            if state is None:
-                state = "idle"
-            var = tk.StringVar(value=state)
-            self.vehicle_state_vars[veh] = var
-            rb_active = tk.Radiobutton(frame, text="Aufträge bearbeiten", variable=var, value="translate")
-            rb_active.pack(side=tk.LEFT)
-            rb_standby = tk.Radiobutton(frame, text="Standby", variable=var, value="idle")
-            rb_standby.pack(side=tk.LEFT)
-            row += 1
-        update_btn = tk.Button(self.control_win, text="Übernehmen", command=self.update_vehicle_control)
-        update_btn.grid(row=row, column=0, pady=5)
-
-    def update_vehicle_control(self):
-        for veh, var in self.vehicle_state_vars.items():
-            new_state = var.get()
-            veh.setPythonTag("order_state", new_state)
-            print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Zustand auf {new_state} gesetzt.")
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: Test/Test.py
===================================================================
diff --git a/Test/Test.py b/Test/Test.py
deleted file mode 100644
--- a/Test/Test.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,199 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData,
-    GeomNode, GeomVertexWriter, GeomLines, Geom, Vec3
-)
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData,
-    GeomNode, GeomVertexWriter, GeomLines, Geom, Vec3
-)
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.interval.IntervalGlobal import Sequence, Wait, LerpPosInterval, Func, Parallel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Fahrzeuggeschwindigkeit: 1.5 m/s * 5 = 7.5 m/s
-        self.speed = 1.5 * 5
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün)
-        # in einer Linie mit gleichem Abstand.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            # Annahmestation links (rot) bei x = -9
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            # Abgabestation rechts (grün) bei x = 9
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeug initialisieren
-        self.vehicle = self.loader.loadModel("models/box")
-        self.vehicle.setScale(1, 1, 0.5)
-        self.vehicle.setColor(LColor(0, 0, 1, 1))
-        self.vehicle.setPos(0, 0, 0)
-        self.vehicle.reparentTo(self.render)
-
-        self.cargo = None  # Aktuell transportiertes Paket
-        self.start_delivery_cycle()  # Start des ersten Lieferzyklus
-
-    def start_delivery_cycle(self, start_pos=None):
-        """
-        Ablauf dieses Zyklus:
-        1. Das Fahrzeug fährt vom aktuellen Punkt (start_pos) zur ausgewählten Annahmestation.
-        2. Unabhängig davon wird nach 1 Sekunde das Paket (als Würfel) an der Annahmestation erzeugt.
-           (Das Paket erscheint also auch, wenn das Fahrzeug noch nicht da ist.)
-        3. Sobald das Fahrzeug am Annahmestation-Punkt angekommen ist, wird das (evtl. schon
-           vorhandene) Paket als Kind des Fahrzeugs angebracht.
-        4. Anschließend fährt das Fahrzeug zur zufällig gewählten Abgabestation, das Paket wird
-           dort auf den Würfel der Abgabestation gesetzt; nach 1 Sekunde wird es entfernt.
-        5. Der nächste Zyklus startet ab der aktuellen Position (der Abgabestation).
-        """
-        if start_pos is None:
-            start_pos = self.vehicle.getPos()
-
-        # Zufällige Auswahl einer Annahmestation
-        idx = random.randrange(len(self.annahme_stationen))
-        pickup_station = self.annahme_stationen[idx]
-        redPos = pickup_station.getPos()
-        seg1_duration = (redPos - start_pos).length() / self.speed
-
-        # Zufällige Auswahl einer Abgabestation
-        dropoff_station = random.choice(self.abgabe_stationen)
-        self.current_dropoff_station = dropoff_station  # Zum späteren Setzen des Pakets
-        greenPos = dropoff_station.getPos()
-        seg2_duration = (greenPos - redPos).length() / self.speed
-
-        cycle = Sequence(
-            # Parallel: Das Fahrzeug fährt zur Annahmestation und in einer separaten Sequenz
-            # erscheint das Paket an der Station (nach 1 Sekunde), unabhängig vom Fahrzeug.
-            Parallel(
-                LerpPosInterval(self.vehicle, duration=seg1_duration, pos=redPos),
-                Sequence(Wait(1), Func(self.spawn_cargo, redPos))
-            ),
-            # Nachdem das Fahrzeug am Annahmestation-Punkt ist, wird das Paket aufgenommen.
-            Func(self.attach_cargo_to_vehicle),
-            # Fahrt zur Abgabestation
-            LerpPosInterval(self.vehicle, duration=seg2_duration, pos=greenPos),
-            Func(self.drop_cargo),
-            Wait(1),  # Nach 1 Sekunde an der Abgabestation verschwindet das Paket.
-            Func(self.remove_cargo),
-            # Starte den nächsten Zyklus ab der aktuellen Position (Abgabestation)
-            Func(self.start_delivery_cycle, self.vehicle.getPos())
-        )
-        cycle.start()
-
-    def spawn_cargo(self, pos):
-        # Erzeugt ein neues Paket (Würfel) an der angegebenen Position.
-        if self.cargo:
-            self.cargo.removeNode()
-        self.cargo = self.erzeuge_wuerfel(pos.getX(), pos.getY(), pos.getZ(), LColor(1, 1, 0, 1))
-
-    def attach_cargo_to_vehicle(self):
-        # Hängt das Paket als Kind des Fahrzeugs an, damit es mitbewegt wird.
-        self.cargo.wrtReparentTo(self.vehicle)
-        self.cargo.setPos(0, 0, 1)
-
-    def drop_cargo(self):
-        # Setzt das Paket exakt auf den Würfel der Abgabestation (Z-Offset +1).
-        self.cargo.wrtReparentTo(self.render)
-        targetPos = self.current_dropoff_station.getPos() + Vec3(0, 0, 1)
-        self.cargo.setPos(targetPos)
-
-    def remove_cargo(self):
-        # Entfernt das Paket endgültig aus der Szene.
-        if self.cargo:
-            self.cargo.removeNode()
-            self.cargo = None
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-
-        # Horizontale Linien
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        # Vertikale Linien
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        # Erzeugt ein Wireframe-Box-Modell als Station.
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        # Erzeugt einen Würfel (als Paket), etwas über dem Boden positioniert.
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        # Einfaches Beleuchtungssetup: Ambient- und Richtungslicht.
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-# Starte die Simulation
-app = LagerSimulation()
-app.run()
-
Index: Grundmodell/Gm18.py
===================================================================
diff --git a/Grundmodell/Gm18.py b/Grundmodell/Gm18.py
deleted file mode 100644
--- a/Grundmodell/Gm18.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,1485 +0,0 @@
-import random
-import math
-import tkinter as tk  # Für das extra Fenster der Auftragsübersicht
-from tkinter import ttk  # Für die tabellarische Darstellung (Treeview)
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-from direct.task.TaskManagerGlobal import taskMgr
-
-
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5  # Wird in update_vehicle genutzt
-        self.state_timer = 0.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Paketspawning an den Annahmestationen:
-        # Mapping: station (Dummy-Node) -> (Paket, Spawnzeit, Timer Node)
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-        # Neues Attribut: Verknüpfung Fahrzeug -> transportiertes Paket
-        self.cargos = {}
-
-        # NEU: Initialisiere die belegten Annahmestationen
-        self.occupied_pickups = set()  # Oder: [] für eine Liste
-
-        # Graph-Daten (Sim-Zeit, Pakete pro Minute, durchschnittliche Liegedauer)
-        self.graph_data = []
-        self.graph_opened = False
-
-        # Auftragsverwaltung: Speichere alle Aufträge (für die Anzeige) sowie in
-        # einer Queue (Liste) zur sequentiellen Abarbeitung.
-        self.orders = {}         # Für die Anzeige
-        self.orders_queue = []   # Für die Fahrzeugabwicklung (FIFO)
-        self.next_order_id = 1
-
-        # Tkinter-Fenster für Auftragsübersicht
-        self.order_win = None
-        self.order_tree = None
-
-        # Umgebung initialisieren
-        self.draw_origin()
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.create_wall()
-        self.create_annahme_stations()
-        self.create_abgabe_stations()  # Hier wird auch self.abgabe_stations angelegt.
-        self.create_garagen_stations()
-
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # Fahrzeuge in den Garagen erstellen (genau 5 Fahrzeuge)
-        self.create_garage_vehicles()
-
-        # NEU: Auftragssystem für das Testfahrzeug initialisieren
-        # Zustände: "idle", "to_pickup", "wait_pickup", "to_delivery", "deliver"
-        self.first_vehicle_order_state = "idle"
-        self.attached_package = None
-        self.current_order = None  # Der aktuell abgearbeitete Auftrag
-        self.taskMgr.add(self.vehicle_order_task, "VehicleOrderTask")
-
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-        self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    # ---------------------------
-    # SIMULATION UND UI-METHODEN
-    # ---------------------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        # dt jetzt skaliert mit der Simulationsgeschwindigkeit
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    # ---------------------------
-    # METHODEN FÜR RASTER, LICHT, MAUER, URSPRUNG
-    # ---------------------------
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # STATIONSOBJEKTE UND ZUORDNUNG
-    # -----------------------------------
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        """
-        Erzeugt die Annahmestationen und erstellt für jede Station:
-          - Einen weißen Marker zur Orientierung
-          - Einen grünen Punkt (optional)
-          - Eine weiße Linie, an deren Endpunkt ein blauer Marker als Ziel in der "Translate‑Phase" dient
-
-        Zusätzlich wird ein Dictionary self.station_blue_dots aufgebaut, in dem jedem Annahmestations‑Node
-        der zugehörige blaue Marker zugeordnet wird. Außerdem wird für die erste Station die globale Variable
-        self.station_white_direction festgelegt.
-        """
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        self.station_blue_dots = {}
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basisstation (zum Beispiel als Rahmen)
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Erzeuge den weißen Marker als Orientierung
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Erzeuge den grünen Punkt (optional)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zeichne die weiße Linie: Sie beginnt bei center + Vec3(0, 0, -0.5) und verläuft 3 Meter in X‑Richtung.
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Erzeuge den blauen Marker, der als Ziel in der Translate‑Phase dient
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            # Speichere den blauen Marker im Dictionary, sodass er später erzeugt werden kann
-            self.station_blue_dots[station_dummy] = blue_dot
-
-            # Optionale Textanzeige der Stationsnummer
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) – falls benötigt:
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-            # Für die erste Station (oder den ersten relevanten Pickup) setzen wir globale Referenzen,
-            # die in vehicle_order_task benötigt werden.
-            if i == 1:
-                self.blue_dot = blue_dot
-                self.station_green_dot = green_dot
-                # Berechne den Mittelpunkt der weißen Linie als Referenz (optional)
-                self.white_line_center = (start_line + end_line) * 0.5
-                line_vec = end_line - start_line
-                if line_vec.length() != 0:
-                    self.station_white_direction = Vec2(line_vec.getX(), line_vec.getY()).normalized()
-                else:
-                    self.station_white_direction = Vec2(1, 0)  # Fallback-Wert
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        self.abgabe_stations = []  # Liste der Abgabestationen
-        self.abgabe_blue_dots = []  # Liste zum Speichern der blauen Marker für die Abgabe
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basiskonstruktion der Abgabestation
-            node = self.create_abgabe_station(pt)
-            self.abgabe_stations.append(node)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Marker am Zentrum (weiß)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Grüner Punkt: center + Vec3(0, 0, -0.5)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Weiße Linie: Startet bei center + Vec3(0, 0, -0.5)
-            # und verläuft 3 Meter in negativer X-Richtung
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt: wird an der Endposition der Linie erzeugt
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            # Speichere den blauen Marker für spätere Navigation der Abgabestation
-            self.abgabe_blue_dots.append(blue_dot)
-
-            # Anzeige der Stationsnummer (textuell)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) auf der Station
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 3)
-        v5 = pos + Vec3(1, 0, 3)
-        v6 = pos + Vec3(1, 2, 3)
-        v7 = pos + Vec3(0, 2, 3)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 3)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        self.garagen_stations = []
-        self.garagen_parking_points = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            self.garagen_stations.append(pt)
-            # ParkpunktGarage: Verschoben um 0.5 in negativer Y-Richtung:
-            center = pt + Vec3(0.5, 0.5, 1.5)
-            ParkpunktGarage = center + Vec3(0, 0, 0.7)
-            self.garagen_parking_points.append(ParkpunktGarage)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def create_garage_vehicles(self):
-        self.garage_vehicles = []
-        for park in self.garagen_parking_points:
-            # Fahrzeug wird an der jeweiligen Parkposition erzeugt.
-            veh = self.create_vehicle(park_point=park)
-            veh.setH(veh.getH() + 180)
-
-            # Berechnung der Position basierend auf einem Offset-Vektor
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-
-            # Anstatt einen festen Aufschlag zu addieren, erzwinge hier, dass
-            # das Fahrzeug an der Ebene 0 (Bodenraster) steht:
-            newPos.setZ(0)
-
-            veh.setPos(newPos)
-            self.garage_vehicles.append(veh)
-
-            # Optional: Fahrzeugmarker (zur Visualisierung auf dem Boden)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # FAHRZEUGERSTELLUNG (FFZ20-INTEGRATION)
-    # -----------------------------------
-    def create_vehicle(self, park_point=None):
-        # Erzeuge den übergeordneten Fahrzeug-Knoten
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # --------------------------
-        # Chassis erstellen (1 x 0.5 x 1.2, Farbe Rot)
-        # --------------------------
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # --------------------------
-        # Gabel (Fork) erstellen: Zwei Zähne
-        # --------------------------
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-
-        # Speichere den Gabel-Knoten als Python-Tag am Fahrzeug
-        vehicle_node.setPythonTag("fork_node", fork_node)
-
-        # --------------------------
-        # Erzeuge den grünen Referenzmarker (Gabel – grüner Punkt)
-        # --------------------------
-        ls_new = LineSegs()
-        ls_new.setThickness(2.0)
-        ls_new.setColor(1, 1, 1, 1)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_corner_global = fork_node.getPos() + left_corner_local
-        right_corner_global = fork_node.getPos() + right_corner_local
-        ls_new.moveTo(left_corner_global)
-        ls_new.drawTo(right_corner_global)
-        vehicle_node.attachNewNode(ls_new.create())
-        midpoint = (left_corner_global + right_corner_global) * 0.5
-        white_line_vec = right_corner_global - left_corner_global
-        white_line_dir = white_line_vec.normalized() if white_line_vec.length() != 0 else Vec3(0, 0, 0)
-        candidate = Vec3(-white_line_dir.getY(), white_line_dir.getX(), 0)
-        perp_direction = candidate.normalized() if candidate.length() != 0 else Vec3(0, 0, 0)
-        green_point_global = midpoint + perp_direction * 0.5
-
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        # Speichere den grünen Marker ebenfalls als Python-Tag
-        vehicle_node.setPythonTag("fork_green", green_marker_np)
-
-        # --------------------------
-        # Mast und weitere Fahrzeugteile
-        # --------------------------
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-        self.add_diagonals_to_mast(mast_node)
-        intersection = Vec3(0.5, 0.05, 1.0)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-        self.vehicle_cylinder = cylinder_node
-
-        # --------------------------
-        # Fahrzeugpositionierung am Parkpunkt
-        # --------------------------
-        if park_point is None:
-            vehicle_node.setPos(intersection.x, intersection.y, 0)
-        else:
-            vehicle_node.setPos(park_point - vehicle_node.getQuat().xform(intersection))
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        # Verwende die simulative Zeit, die bereits in update_sim_clock hochgezählt wird
-        t = self.sim_clock
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    # -----------------------------------
-    # FEHLENDE METHODEN: Paketspawning, Würfelerzeugung u.a.
-    # -----------------------------------
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Bestimme zufällig eine Abgabestation als Ziel
-        if hasattr(self, "abgabe_stations") and self.abgabe_stations:
-            target_index = random.randint(1, len(self.abgabe_stations))
-        else:
-            target_index = 1
-
-        # Erstelle den Auftrag zur Annahmestation
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def update_order_table(self):
-        """
-        Aktualisiert die Auftragsübersicht in der Tkinter-Tabelle und zeigt in der
-        letzten Spalte den zugewiesenen Fahrzeugnamen (oder "-" falls noch keiner zugeordnet wurde).
-        """
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen (z. B. "annahme_station_3") die Stationsnummer.
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z. B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige in der letzten Spalte den zugewiesenen Fahrzeugnamen an (oder "-" falls noch kein Fahrzeug zugewiesen ist).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END, values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = 5.0  # 5 Sekunden Verzögerung zwischen Spawns
-        for station in self.annahme_stations:
-            # Wenn aktuell kein Paket an der Station ist
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                # Prüfe, ob seit der letzten Entnahme mindestens 5 Sekunden vergangen sind
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0.0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Wir legen hier die Spalten in der gewünschten Reihenfolge an: Auftrags ID, Annahmestation, Ziel, Fahrzeug.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Hole die fahrzeugspezifischen Knoten mittels getPythonTag
-            fork_node = vehicle.getPythonTag("fork_node")
-            fork_green = vehicle.getPythonTag("fork_green")
-
-            # Hole die Position des grünen Markers relativ zum Gabelknoten
-            green_point_pos = fork_green.getPos(fork_node)
-
-            # Reparent das Paket zur Gabel des Fahrzeugs und positioniere es entsprechend
-            package.wrtReparentTo(fork_node)
-            package.setPos(
-                green_point_pos.getX() + 0.5,  # Offset in X-Richtung
-                green_point_pos.getY() - 0.5,  # Offset in Y-Richtung
-                green_point_pos.getZ() + 1  # Z-Offset, sodass das Paket oberhalb liegt
-            )
-
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    from direct.task.TaskManagerGlobal import taskMgr  # Sicherstellen, dass taskMgr verfügbar ist
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden removeCargoTask aufruft,
-            # und übergib dabei das cargo als extra Argument:
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return Task.done
-
-    def select_next_order(self):
-        """
-        Wählt den nächsten (dringendsten) Auftrag anhand folgender Kriterien:
-          - Zuerst: Auftrag mit der höchsten Liegedauer (je länger ein Paket liegt, desto dringlicher)
-          - Bei Gleichstand: Auftrag, bei dem die Entfernung zur Annahmestation des Fahrzeugs am geringsten ist.
-
-        Der ausgewählte Auftrag wird außerdem mit einer Fahrzeugzuordnung (hier "Fahrzeug 1") versehen.
-        """
-        # Filtern aller Aufträge mit dem Status "Wartend"
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        # Berechne für jeden Auftrag die Liegedauer
-        for order in waiting_orders:
-            dwell_time = self.sim_clock - order.get("spawn_time", self.sim_clock)
-            order["dwell_time"] = dwell_time
-
-        # Bestimme den maximalen Liegedauerwert
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01  # Kleine Toleranz zur Berücksichtigung von Rundungsfehlern
-
-        # Finde alle Aufträge, deren Liegedauer nahezu dem Maximum entspricht
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        # Wir nehmen als Referenz das erste Fahrzeug aus der Liste self.garage_vehicles
-        if not self.garage_vehicles:
-            return None
-        vehicle = self.garage_vehicles[0]
-        vehicle_pos = vehicle.getPos(self.render)
-
-        def distance_to_station(order):
-            station = order.get("pickup_station")
-            if station:
-                station_pos = station.getPos(self.render)
-                return (station_pos - vehicle_pos).length()
-            return float('inf')
-
-        # Sortiere die Kandidaten nach dem Abstand der Pickup-Station zum Fahrzeug
-        candidates.sort(key=distance_to_station)
-        chosen_order = candidates[0]
-        chosen_order["vehicle"] = "Fahrzeug 1"  # Hier kannst du ggf. die passende Fahrzeug-ID hinterlegen
-        return chosen_order
-
-    def vehicle_order_task(self, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        if not hasattr(self, 'vehicle_state'):
-            self.vehicle_state = "translate"
-
-        if not self.garage_vehicles:
-            return task.cont
-
-        # Wir nehmen hier vorerst das erste Fahrzeug aus der Garage
-        vehicle = self.garage_vehicles[0]
-
-        # ------------------ Phase 1: Translate ------------------
-        if self.vehicle_state == "translate":
-            if self.current_order is None:
-                next_order = self.select_next_order()
-                if next_order is not None:
-                    self.current_order = next_order
-                    self.current_order["status"] = "In Bearbeitung"
-                    print(f"Auftrag {self.current_order['id']} wird zugewiesen.")
-                else:
-                    print("Kein Auftrag verfügbar – Fallback zum globalen Ziel.")
-            if self.current_order is not None:
-                pickup_station = self.current_order.get("pickup_station")
-                if pickup_station in self.station_blue_dots:
-                    blue_target = self.station_blue_dots[pickup_station].getPos(self.render)
-                else:
-                    blue_target = self.blue_dot.getPos(self.render)
-            else:
-                blue_target = self.blue_dot.getPos(self.render)
-
-            local_mast = Vec3(0.5, 0.05, 1.0)
-            mast_global = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(local_mast)
-            target_xy = Vec2(blue_target.getX(), blue_target.getY())
-            mast_xy = Vec2(mast_global.getX(), mast_global.getY())
-            error_vector = target_xy - mast_xy
-            threshold = 0.05  # 5 cm Toleranz
-            if error_vector.length() > threshold:
-                direction = error_vector.normalized()
-                move_distance = 1.5 * dt
-                current_pos = vehicle.getPos(self.render)
-                new_pos = Vec3(current_pos.getX() + direction.getX() * move_distance,
-                               current_pos.getY() + direction.getY() * move_distance,
-                               0)
-                vehicle.setPos(new_pos)
-            else:
-                local_offset = vehicle.getQuat(self.render).xform(local_mast)
-                exact_pos = Vec3(blue_target.getX() - local_offset.getX(),
-                                 blue_target.getY() - local_offset.getY(),
-                                 0)
-                vehicle.setPos(exact_pos)
-                self.vehicle_state = "rotate"
-
-        # ------------------ Phase 2: Rotate ------------------
-        elif self.vehicle_state == "rotate":
-            desired_angle = math.degrees(math.atan2(self.station_white_direction.getY(),
-                                                    self.station_white_direction.getX()))
-            desired_angle = (desired_angle + 180) % 360
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_angle - current_heading + 180) % 360) - 180
-            kp_heading = 0.5
-            new_heading = current_heading + kp_heading * angle_diff
-            vehicle.setH(new_heading)
-            if abs(angle_diff) < 1.0:
-                self.vehicle_state = "turn_right"
-
-        # ------------------ Phase 3: Turn Right ------------------
-        elif self.vehicle_state == "turn_right":
-            if not hasattr(self, "turn_right_init"):
-                self.turn_right_init = vehicle.getH() % 360
-                self.turn_right_target = (self.turn_right_init + 90) % 360
-                print("Phase 3: Initialisiert. Start Heading =", self.turn_right_init,
-                      "Target Heading =", self.turn_right_target)
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((self.turn_right_target - current_heading + 180) % 360) - 180
-            kp_turn = 0.5
-            turn_rate = kp_turn * angle_diff
-            new_heading = current_heading + turn_rate * dt
-            vehicle.setH(new_heading)
-            print("Phase 3: Aktuelles Heading =", current_heading,
-                  "Winkelabweichung =", angle_diff,
-                  "Neues Heading =", new_heading)
-            if abs(angle_diff) < 1.0:
-                print("Phase 3: Drehung abgeschlossen. Übergang in 'approach'.")
-                self.vehicle_state = "approach"
-                del self.turn_right_init, self.turn_right_target
-
-                # ------------------ [Phase 4: Approach] ------------------
-        elif self.vehicle_state == "approach":
-                if self.current_order is not None:
-                    # Verwende den in self.current_order gespeicherten Pickup-Knoten.
-                    pickup_station = self.current_order.get("pickup_station")
-                    # Berechne den Zielpunkt: Position der Pickup-Station plus Offset:
-                    # 1.2 in X‑Richtung und 1 in Y‑Richtung
-                    target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-                else:
-                    # Fallback: Falls kein Auftrag vorliegt, benutze den global gesetzten green_dot plus Offset
-                    target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-
-                current = vehicle.getPos(self.render)
-                error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-                if error_vec.length() > 0.05:
-                    direction = error_vec.normalized()
-                    move_distance = 1.5 * dt
-                    new_pos = Vec3(
-                        current.getX() + direction.getX() * move_distance,
-                        current.getY() + direction.getY() * move_distance,
-                        target.getZ()
-                    )
-                    vehicle.setPos(new_pos)
-                else:
-                    self.vehicle_state = "pickup"
-
-        # ------------------ Phase 5: Pickup ------------------
-        elif self.vehicle_state == "pickup":
-            # Hier greifen wir auf den fahrzeugspezifischen Gabel-Knoten zu
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            target_z = 1.0  # Höhe der Gabel beim Aufnehmen
-            raise_speed = 0.5
-            if current_z < target_z:
-                fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-            else:
-                if self.current_order is None:
-                    if self.orders_queue:
-                        self.current_order = self.orders_queue.pop(0)
-                    else:
-                        print("Keine verfügbaren Aufträge. Überspringe Pickup-Phase.")
-                        self.vehicle_state = "drive_out"
-                        return task.cont
-                pickup_station = self.current_order["pickup_station"]
-                self.pickup_package(vehicle, pickup_station)
-                self.package_attached = True
-                self.drive_out_start = vehicle.getPos(self.render)
-                self.drive_out_target = self.drive_out_start + vehicle.getQuat(self.render).getForward() * 5.0
-                self.vehicle_state = "drive_out"
-
-        # ------------------ Phase 6: Drive Out ------------------
-        elif self.vehicle_state == "drive_out":
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            if current_z > 0.0:
-                lower_speed = 0.5
-                fork_node.setZ(max(0.0, current_z - lower_speed * dt))
-            current_pos = vehicle.getPos(self.render)
-            diff = self.drive_out_target - current_pos
-            if diff.length() > 0.1:
-                move_distance = 0.5 * dt
-                step = diff.normalized() * move_distance
-                vehicle.setPos(current_pos + step)
-            else:
-                self.vehicle_state = "to_delivery"
-
-        # ------------------ Phase 7: To Delivery ------------------
-        elif self.vehicle_state == "to_delivery":
-            delivery_target_str = self.current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current_pos = vehicle.getPos(self.render)
-            diff = blue_target - current_pos
-            threshold = 0.5  # großzügig
-            move_distance = 1.5 * dt
-            if move_distance > diff.length():
-                vehicle.setPos(blue_target)
-            else:
-                vehicle.setPos(current_pos + diff.normalized() * move_distance)
-            if (blue_target - vehicle.getPos(self.render)).length() <= threshold:
-                print("Phase 7 abgeschlossen: Fahrzeug hat den blauen Punkt der Abgabestation erreicht.")
-                self.vehicle_state = "align_delivery"
-
-        # ------------------ Phase 8: Align Delivery ------------------
-        elif self.vehicle_state == "align_delivery":
-            desired_heading = 90.0
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_heading - current_heading + 180) % 360) - 180
-            print("Phase 8: Align Delivery | Current Heading: {:.2f}°, Desired: {:.2f}°, Diff: {:.2f}°".format(
-                current_heading, desired_heading, angle_diff))
-            fixed_turn_speed = 90.0  # Grad pro Sekunde
-            turn_amount = fixed_turn_speed * dt
-            if abs(angle_diff) < 1.0:
-                vehicle.setH(desired_heading)
-                print("Phase 8 abgeschlossen: Fahrzeug ausgerichtet (Heading = {:.2f}°).".format(desired_heading))
-                self.vehicle_state = "delivery_center"
-            else:
-                if angle_diff > 0:
-                    new_heading = current_heading + turn_amount
-                else:
-                    new_heading = current_heading - turn_amount
-                new_heading %= 360
-                vehicle.setH(new_heading)
-                print("Phase 8: Rotating - New Heading set to {:.2f}°".format(new_heading))
-
-        # ------------------ Phase 9: Delivery Approach ------------------
-        elif self.vehicle_state == "delivery_center":
-            delivery_target_str = self.current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current = vehicle.getPos(self.render)
-            target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-            print("Phase 9: Zielpunkt der Abgabestation =", target_point)
-            error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-            tolerance = 0.05
-            move_distance = 1.5 * dt
-            if error_vec.length() > tolerance:
-                direction = error_vec.normalized()
-                new_pos = Vec3(
-                    current.getX() + direction.getX() * move_distance,
-                    current.getY() + direction.getY() * move_distance,
-                    current.getZ()
-                )
-                vehicle.setPos(new_pos)
-                print("Phase 9: Fahrzeug bewegt sich von", current, "nach", new_pos)
-            else:
-                vehicle.setPos(target_point)
-                print("Phase 9: Fahrzeug hat den Zielpunkt erreicht.")
-                self.vehicle_state = "drop"
-            current_fork_z = vehicle.getPythonTag("fork_node").getZ()
-            if current_fork_z < 1.0:
-                new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-                vehicle.getPythonTag("fork_node").setZ(new_fork_z)
-                print("Phase 9: Gabel wird angehoben (Z =", new_fork_z, ").")
-
-        # ------------------ Phase 10: Dropoff ------------------
-        elif self.vehicle_state == "drop":
-            if self.package_attached:
-                delivery_target_str = self.current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-                self.drop_cargo(vehicle)
-                print("Phase 10: Paket abgesetzt.")
-                self.package_attached = False
-            else:
-                fork_node = vehicle.getPythonTag("fork_node")
-                current_z = fork_node.getZ()
-                if current_z > 0.0:
-                    lower_speed = 0.5
-                    new_z = max(0.0, current_z - lower_speed * dt)
-                    fork_node.setZ(new_z)
-                    print("Phase 10: Gabel wird abgesenkt, aktueller Z-Wert =", new_z)
-                else:
-                    print("Phase 10: Dropoff vollständig abgeschlossen.")
-                    self.vehicle_state = "translate"
-                    self.current_order["status"] = "Erledigt"
-                    self.current_order["delivered_at"] = self.sim_clock
-                    self.current_order = None
-
-        # ------------------ Phase 11: Exit Station and Start Next Order ------------------
-        elif self.vehicle_state == "phase11":
-            if hasattr(self, "last_delivery_marker"):
-                target_point = self.last_delivery_marker
-            else:
-                delivery_target_str = self.current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    target_point = self.abgabe_blue_dots[0].getPos(self.render)
-                print("Phase 11: Zielpunkt (blauer Marker) =", target_point)
-                current_pos = vehicle.getPos(self.render)
-                diff = target_point - current_pos
-                if diff.length() > 0.1:
-                    move_distance = 0.5 * dt
-                    step = diff.normalized() * move_distance
-                    vehicle.setPos(current_pos + step)
-                    print("Phase 11: Fahrzeug fährt aus der Station, neue Position =", current_pos + step)
-                else:
-                    vehicle.setPos(target_point)
-                    print("Phase 11: Fahrzeug hat den blauen Marker erreicht. Nächster Auftrag wird gestartet.")
-                    self.vehicle_state = "next_order"
-        return task.cont
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: KI/KI10.py
===================================================================
diff --git a/KI/KI10.py b/KI/KI10.py
deleted file mode 100644
--- a/KI/KI10.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,310 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode
-)
-# Globaler Clock über ClockObject
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.interval.IntervalGlobal import Sequence, Wait, LerpPosInterval, Func
-from direct.task import Task
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Fahrzeuggeschwindigkeit auf 1,5 m/s gesetzt
-        self.speed = 1.5
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie (gleicher Abstand)
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            # Annahmestation links (rot) bei x = -9
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            # Abgabestation rechts (grün) bei x = 9
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeuge initialisieren – zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}             # Dictionary: Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}   # Dictionary: Fahrzeug -> aktuell gewählte Abgabestation
-
-        # Fahrzeug 1
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-
-        # Fahrzeug 2 – leicht versetzt, damit sich die Modelle nicht überlappen.
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)  # y-Offset von 2 Einheiten
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-
-        # Globaler Pool für alle Pickup‑Pakete:
-        # Schlüssel = Annahmestation, Wert = (Paket, Spawnzeit, Timer-TextNode)
-        self.pickup_packages = {}
-        # Für jede Station wird der Zeitpunkt des letzten Entfernens initialisiert.
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = globalClock.getFrameTime()
-
-        # Reservierungssets:
-        self.occupied_dropoffs = set()  # Für Drop-Offs (bereits vorhanden)
-        self.occupied_pickups = set()    # Für Pickup‑Stationen
-
-        # Starte einen Task, der regelmäßig prüft, ob an einer Annahmestation ein Paket fehlen soll.
-        # Spawnzeit beträgt nun 1 Sekunde.
-        self.taskMgr.doMethodLater(1, self.check_and_spawn_packages, "CheckSpawnPackages")
-        # Task zum Aktualisieren der Timer-Anzeige über den Paketen.
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-
-        # Starte für Fahrzeug 1 den Auftrag sofort...
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-        # ... und für Fahrzeug 2 8 Sekunden später.
-        self.taskMgr.doMethodLater(8, lambda t, veh=self.vehicles[1]:
-                                     self.start_delivery_cycle(veh, veh.getPos()),
-                                     "StartVehicle2")
-
-    def check_and_spawn_packages(self, task):
-        """
-        Überprüft alle Annahmestationen:
-          Falls an einer Station noch kein Paket vorhanden ist und seit dem letzten
-          Entfernen mindestens 1 Sekunde vergangen sind, wird ein Paket erzeugt.
-        """
-        spawn_delay = 1  # 1 Sekunde Wartezeit pro Station
-        current_time = globalClock.getFrameTime()
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if current_time - self.last_removed.get(station, current_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.again
-
-    def spawn_package_at_station(self, station):
-        """
-        Erzeugt ein Paket (als Würfel) an der gegebenen Annahmestation.
-        Das Paket wird mit einem Z-Offset von +1 positioniert. Zusätzlich wird über dem Paket
-        ein TextNode angehängt, der später die Wartezeit anzeigt.
-        """
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = globalClock.getFrameTime()
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        """
-        Aktualisiert in jedem Frame den Text (Wartezeit) aller wartenden Pakete.
-        """
-        current_time = globalClock.getFrameTime()
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = current_time - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        """
-        Liefert für ein einzelnes Fahrzeug folgenden Ablauf:
-          1. Aus dem globalen Pool der Pickup‑Pakete wählt das Fahrzeug das Paket mit der
-             höchsten Wartezeit (also das älteste Paket, gemessen an der Spawnzeit) – sofern
-             die Pickup‑Station nicht reserviert ist.
-          2. Das Fahrzeug reserviert die Pickup‑Station und fährt dorthin, nimmt das Paket auf.
-          3. Anschließend wählt es als Abgabestation zufällig eine aus, die noch nicht reserviert ist,
-             reserviert diese und fährt dorthin.
-          4. Nach 1 Sekunde Wartezeit wird das Paket abgesetzt und beide Reservierungen werden aufgehoben.
-          5. Der nächste Zyklus startet von der aktuellen Position des Fahrzeugs.
-        """
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-
-        if not self.pickup_packages:
-            self.taskMgr.doMethodLater(1,
-                lambda t: self.start_delivery_cycle(vehicle, vehicle.getPos()),
-                "RetryCycle_" + str(id(vehicle)))
-            return
-
-        current_time = globalClock.getFrameTime()
-        # Filtern: nur Pakete, deren Pickup-Station nicht reserviert ist.
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            self.taskMgr.doMethodLater(1,
-                lambda t: self.start_delivery_cycle(vehicle, vehicle.getPos()),
-                "RetryCycle_" + str(id(vehicle)))
-            return
-
-        # Wähle das Paket mit der höchsten Wartezeit.
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        # Reserviere die Pickup‑Station.
-        self.occupied_pickups.add(pickup_station)
-        pickup_pos = pickup_station.getPos()
-        seg1_duration = (pickup_pos - start_pos).length() / self.speed
-
-        # Wähle als Abgabestation nur aus denen, die nicht reserviert sind.
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.occupied_pickups.remove(pickup_station)
-            self.taskMgr.doMethodLater(1,
-                lambda t: self.start_delivery_cycle(vehicle, vehicle.getPos()),
-                "RetryCycle_" + str(id(vehicle)))
-            return
-
-        dropoff_station = random.choice(available_dropoffs)
-        # Reserviere die Abgabestation.
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_pos = dropoff_station.getPos()
-        seg2_duration = (dropoff_pos - pickup_pos).length() / self.speed
-
-        cycle = Sequence(
-            LerpPosInterval(vehicle, duration=seg1_duration, pos=pickup_pos),
-            Func(self.pickup_package, vehicle, pickup_station),
-            LerpPosInterval(vehicle, duration=seg2_duration, pos=dropoff_pos),
-            Func(self.drop_cargo, vehicle),
-            Wait(1),
-            Func(self.remove_cargo, vehicle),
-            Func(self.start_delivery_cycle, vehicle, vehicle.getPos())
-        )
-        cycle.start()
-
-    def pickup_package(self, vehicle, station):
-        """
-        Das Fahrzeug übernimmt an der angegebenen Annahmestation das wartende Paket.
-        Dabei wird der Timer-Text entfernt, der Eintrag aus dem globalen Pool gelöscht,
-        und der Zeitpunkt der Entfernung (last_removed) aktualisiert. Anschließend wird
-        die Reservierung der Pickup‑Station aufgehoben.
-        """
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = globalClock.getFrameTime()
-            # Reservierung der Pickup‑Station aufheben.
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        """
-        Das vom Fahrzeug transportierte Paket wird exakt auf den Würfel der reservierten
-        Abgabestation (Z‑Offset +1) abgesetzt.
-        """
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-
-    def remove_cargo(self, vehicle):
-        """
-        Entfernt das aktuell transportierte Paket des Fahrzeugs aus der Szene
-        und gibt die reservierte Abgabestation wieder frei.
-        """
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        if dropoff_station in self.occupied_dropoffs:
-            self.occupied_dropoffs.remove(dropoff_station)
-            del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        """
-        Erzeugt ein Wireframe-Box-Modell als Station.
-        """
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        """
-        Erzeugt einen Würfel (als Paket), der etwas über dem Boden platziert wird.
-        """
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        """
-        Einfaches Beleuchtungssetup: Ambient- und Richtungslicht.
-        """
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-# Starte die Simulation
-app = LagerSimulation()
-app.run()
Index: Grundmodell Erweitert Split/GES4.py
===================================================================
diff --git a/Grundmodell Erweitert Split/GES4.py b/Grundmodell Erweitert Split/GES4.py
deleted file mode 100644
--- a/Grundmodell Erweitert Split/GES4.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,2052 +0,0 @@
-# Standardbibliothek
-import random
-import math
-import time
-import ctypes
-import multiprocessing
-from multiprocessing import Queue, Process
-from functools import partial
-import tkinter as tk
-from tkinter import ttk
-
-# Drittanbieter
-import matplotlib
-import matplotlib.pyplot as plt
-from PyQt5 import QtWidgets, QtCore
-import pyqtgraph as pg
-
-# Panda3D und Direct (Engine-spezifische Importe)
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.task.TaskManagerGlobal import taskMgr
-from direct.gui.DirectGui import DirectButton, DirectSlider, DirectLabel
-
-from direct.showbase.ShowBase import ShowBase
-from environment_visualization import EnvironmentVisualizer
-
-class LagerSimulation(ShowBase):
-    def __init__(self, graph_queue=None):
-        # Basisinitialisierung (ShowBase, etc.)
-        super().__init__()
-
-        # ------------------------------------------------------------------------
-        # 1. Umgebung aufbauen: Verwende den extrahierten EnvironmentVisualizer
-        # ------------------------------------------------------------------------
-        self.env_viz = EnvironmentVisualizer(self.render, self.loader)
-
-        # Rufe die Methoden des Visualizers auf, um die Umgebung zu erstellen.
-        self.env_viz.draw_origin()
-        self.env_viz.erzeuge_licht()
-        self.env_viz.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.env_viz.create_wall()
-        self.env_viz.create_annahme_stations()
-        self.env_viz.create_abgabe_stations()
-        self.env_viz.create_garagen_stations()
-
-        # Um in anderen Methoden (z. B. für Paket- oder Auftrags-Handling) auf die Stationen
-        # und deren Marker zugreifen zu können, übergeben wir die entsprechenden Listen.
-        self.annahme_stations = self.env_viz.annahme_stations
-        self.station_blue_dots = self.env_viz.station_blue_dots
-        self.abgabe_stations = self.env_viz.abgabe_stations
-        self.abgabe_blue_dots = self.env_viz.abgabe_blue_dots
-        self.garagen_stations = self.env_viz.garagen_stations
-        self.garagen_parking_points = self.env_viz.garagen_parking_points
-
-        # Setze den Pickup-Offset (dieser Vektor wird bei der Steuerung genutzt)
-        self.pickup_offset = Vec3(0.5, -0.5, 0)
-
-        # Falls du weitere Referenzen (wie self.blue_dot, self.station_green_dot) brauchst, ebenfalls setzen.
-        if hasattr(self.env_viz, 'blue_dot'):
-            self.blue_dot = self.env_viz.blue_dot
-        if hasattr(self.env_viz, 'station_green_dot'):
-            self.station_green_dot = self.env_viz.station_green_dot
-
-        # ------------------------------------------------------------------------
-        # 2. Restliche Initialisierung (Simulationsvariablen, UI, Tasks, etc.)
-        # (Der restliche Code bleibt weitgehend unverändert.)
-        # ------------------------------------------------------------------------
-
-        self.paused = False
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5
-
-        # Weitere Attribute, z. B. für KPIs, Paket- und Auftragsverwaltung usw.
-        self.delivered_packages = 0
-        self.pickup_packages = {}
-        self.last_removed = {}
-        self.orders = {}
-        self.orders_queue = []
-        self.next_order_id = 1
-        # (Weitere Initialisierungen kommen hier…)
-        self.cargos = {}
-        # Falls du auch weitere Attribute benötigst, wie beispielsweise eine Liste der belegten Pickup-Stations:
-        self.occupied_pickups = set()
-
-        self.max_overall_wait_time = 0.0  # Maximale Wartezeit der Pakete
-        self.total_dwell_time = 0.0  # Summe aller Liegedauern abgeholter Pakete
-        self.picked_up_count = 0  # Anzahl abgeholter Pakete
-        self.total_delivery_time = 0.0  # Summe aller Lieferzeiten
-        self.total_delivery_count = 0  # Anzahl der Lieferungen
-        self.max_overall_delivery_time = 0.0
-
-        self.graph_queue = None
-        self.graph_data = []
-        self.graph_process = None
-
-        # Beispiel: Initialisierung des Tkinter-Fensters
-        self.tk_root = tk.Tk()
-        self.tk_root.withdraw()
-
-        # Weiterer Code: Kamera, Lichter (falls weiterhin benötigt – ansonsten übernehmen wir vollständig den Visualizer)
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # UI-bezogene Attribute initialisieren:
-        self.order_win = None
-        self.order_tree = None
-        self.graph_queue = None
-        self.graph_data = []
-
-        # TensorFlow-Modell und RL-Agent initialisieren (wie gehabt)
-        try:
-            import tensorflow as tf
-            self.tf_model = tf.keras.models.load_model("mein_model.keras")
-            print("TensorFlow Modell erfolgreich geladen.")
-        except Exception as e:
-            print(f"Fehler beim Laden des TensorFlow Modells: {e}")
-            self.tf_model = None
-
-        state_bins = ((10, 10), (10, 10))
-        action_space = [0, 1, 2]
-        self.rl_agent = RLAgent(state_bins, action_space, learning_rate=0.1, discount_factor=0.9, epsilon=0.2)
-        self.training_data = []  # Trainingsdatenliste
-
-        # Spawn-Einstellungen (Standardwerte)
-        self.package_spawn_delay = 5.0
-        self.package_spawn_distribution = "uniform"
-        # Hier speichern wir die Variablen für die Stationen als Dictionary (Index -> BooleanVar)
-        self.spawn_station_vars = {}
-        # Falls du beispielsweise 10 Annahmestationen hast:
-        for i in range(10):
-            self.spawn_station_vars[i] = tk.BooleanVar(value=False)
-
-        # Fahrzeuge in den Garagen instanziieren:
-        self.create_garage_vehicles()
-        # --- UI-Elemente für Simulationssteuerung ---
-        # Slider für Simulationsgeschwindigkeit
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        self.paused = False
-        # Pause-Knopf neben dem Slider platzieren – z.B. rechts davon.
-        self.pause_button = DirectButton(
-            text="Pause",
-            command=self.toggle_pause,
-            pos=(-0.5, 0, -0.85),  # Leicht links vom Slider
-            scale=0.07
-        )
-
-        # --- Tastenzuordnungen ---
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-        # Taste "c" öffnet das Fahrzeug-Kontrollfenster
-        self.accept("c", self.show_vehicle_control)
-
-        # --- Tasks (TaskMgr) hinzufügen ---
-        self.taskMgr.add(self._tk_update, "tkUpdateTask")
-        self.taskMgr.add(self.update_delivery_timers, "UpdateDeliveryTimersTask")
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClock")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_graph_data, "UpdateGraphDataTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-    # ---------------1. Initialisierung & Simulationssteuerung---------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        self.sim_clock += dt
-        return Task.cont
-
-    def toggle_pause(self):
-        if not self.paused:
-            # Speichern des aktuellen speed_factor, damit wir ihn beim Resume wiederherstellen können
-            self.previous_speed_factor = self.speed_factor
-            self.speed_factor = 0  # Simulation einfrieren: alle dt-basierte Updates ergeben 0
-            self.pause_button['text'] = "Weiter"
-            self.paused = True
-            print("Gesamte Simulation angehalten")
-        else:
-            # Wiederaufnahme der Simulation: speed_factor auf den vorherigen Wert zurücksetzen
-            self.speed_factor = self.previous_speed_factor if hasattr(self, 'previous_speed_factor') else 1.0
-            self.pause_button['text'] = "Pause"
-            self.paused = False
-            print("Simulation läuft wieder")
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        # dt jetzt skaliert mit der Simulationsgeschwindigkeit
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-    # ---------------2. Graphik & UI (GUI-/Tk-/Matplotlib-Funktionen)---------------
-    def open_graph(self):
-        # Starte den Graphprozess per Taste G (nur, wenn er noch nicht läuft)
-        if self.graph_process is None or not self.graph_process.is_alive():
-            from multiprocessing import Queue, Process
-            self.graph_queue = Queue()
-
-            # Sende alle bisher gesammelten Daten in die Queue:
-            for data in self.graph_data:
-                try:
-                    self.graph_queue.put(data, block=False)
-                except Exception:
-                    pass
-
-            from graph_pyqt import graph_process_pyqt
-            self.graph_process = Process(target=graph_process_pyqt, args=(self.graph_queue,))
-            self.graph_process.start()
-            print("Graphprozess gestartet.")
-        else:
-            print("Graphprozess läuft bereits.")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2, self.ax3) = plt.subplots(3, 1, figsize=(8, 9))
-
-        # Erster Plot: Pakete pro Minute
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-
-        # Zweiter Plot: Durchschnittliche Liegedauer
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-
-        # Dritter Plot: Durchschnittliche Lieferzeit
-        self.line3, = self.ax3.plot([], [], marker="o", color="green", label="Durchschnittliche Lieferzeit (s)")
-        self.ax3.set_xlabel("Simulationszeit (s)")
-        self.ax3.set_ylabel("Lieferzeit (s)")
-        self.ax3.set_title("Durchschnittliche Lieferzeit")
-        self.ax3.legend()
-        self.ax3.grid(True)
-
-        plt.show(block=False)
-        # Starte im Tkinter-Hauptloop eine periodische Aktualisierung:
-        self.tk_root.after(500, self.tk_graph_update)  # alle 500ms
-
-    def tk_graph_update(self):
-        # GIL sichern: Gibt einen Statuswert zurück, der später wieder freigegeben wird.
-        gil_state = ctypes.pythonapi.PyGILState_Ensure()
-        try:
-            times = [data[0] for data in self.graph_data]
-            rates = [data[1] for data in self.graph_data]
-            dwell = [data[2] for data in self.graph_data]
-            delivery = [data[3] for data in self.graph_data]
-
-            self.line1.set_data(times, rates)
-            self.ax1.relim()
-            self.ax1.autoscale_view()
-
-            self.line2.set_data(times, dwell)
-            self.ax2.relim()
-            self.ax2.autoscale_view()
-
-            self.line3.set_data(times, delivery)
-            self.ax3.relim()
-            self.ax3.autoscale_view()
-
-            self.fig.canvas.draw_idle()
-            self.fig.canvas.flush_events()
-        finally:
-            ctypes.pythonapi.PyGILState_Release(gil_state)
-
-        # Nächsten Aufruf in 500ms einplanen
-        self.tk_root.after(500, self.tk_graph_update)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-
-        # Bestimme die maximale Liegedauer aktueller Pakete an den Annahmestationen
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-
-        # Lieferzeit-Kennzahlen ermitteln: für Fahrzeuge, die aktuell ein Paket tragen
-        current_delivery_time = 0.0
-        for veh in self.garage_vehicles:
-            if veh.getPythonTag("package_attached"):
-                ds = veh.getPythonTag("delivery_start_time")
-                if ds:
-                    elapsed_delivery = self.sim_clock - ds
-                    current_delivery_time = max(current_delivery_time, elapsed_delivery)
-        avg_delivery_time = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        # Aktualisiere den Info-Label-Text
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s\n"
-            f"Lieferzeit (aktuell): {current_delivery_time:.1f}s\n"
-            f"Lieferzeit (maximal): {self.max_overall_delivery_time:.1f}s\n"
-            f"Durchschn. Lieferzeit: {avg_delivery_time:.1f}s"
-        )
-        return Task.cont
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def update_graph_data(self, task):
-        if self.sim_clock > 0:
-            ppm = self.delivered_packages / (self.sim_clock / 60)
-        else:
-            ppm = 0.0
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        avg_delivery = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        new_data = (self.sim_clock, ppm, avg_dwell, avg_delivery)
-        # Speichere alle Daten ab Simulationsbeginn:
-        self.graph_data.append(new_data)
-
-        # Zusätzlich: Falls der Graphprozess aktiv ist, schicke den neuen Datensatz auch an die Queue
-        if self.graph_queue is not None:
-            try:
-                self.graph_queue.put(new_data, block=False)
-            except Exception:
-                pass
-        return Task.cont
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Hier werden nur die gewünschten Spalten "ID", "Annahmestation", "Ziel" und "Fahrzeug" definiert.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    #-------Fahrzeugsteuerung(Bedienfenster)-------
-    def update_vehicle_control(self):
-        for veh, var in self.vehicle_state_vars.items():
-            new_state = var.get()
-            if new_state == "idle" and veh.getPythonTag("current_order") is not None:
-                veh.setPythonTag("standby_pending", True)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Standby angefordert (Auftrag wird fortgesetzt).")
-            else:
-                veh.setPythonTag("standby_pending", False)
-                veh.setPythonTag("order_state", new_state)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Zustand auf {new_state} gesetzt.")
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-    def update_cable(self, task):
-        # Verwende die simulative Zeit, die bereits in update_sim_clock hochgezählt wird
-        t = self.sim_clock
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    def create_garage_vehicles(self):
-        self.garage_vehicles = []
-        vehicle_id_counter = 1
-        for park in self.garagen_parking_points:
-            veh = self.create_vehicle(park_point=park)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            newPos.setZ(0)
-            veh.setPos(newPos)
-
-            # Fahrzeuge starten im Standby (idle)
-            veh.setPythonTag("current_order", None)
-            veh.setPythonTag("order_state", "idle")
-            veh.setPythonTag("package_attached", False)
-            veh.setPythonTag("vehicle_id", vehicle_id_counter)
-            # Speichere den Parkpunkt als Rückkehrziel
-            veh.setPythonTag("garage_target", park)
-            # Speichere auch das Anfangs-Heading, um es später beim Parken wiederherzustellen.
-            veh.setPythonTag("start_heading", veh.getH())
-            vehicle_id_counter += 1
-
-            self.garage_vehicles.append(veh)
-
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-            # Füge einen Textknoten hinzu, der die Fahrzeugnummer vorne auf dem Fahrzeug anzeigt.
-            # Wir suchen den Mast-Knoten.
-            mast = veh.find("**/mast")
-            if not mast.isEmpty():
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)  # Schwarz
-                tn.setAlign(TextNode.ACenter)
-                text_np = mast.attachNewNode(tn)
-                # Positioniere den Text relativ zum Mast: Wir nutzen den Vektor "intersection"
-                # und versetzen ihn in Z-Richtung um 0.2 Einheiten oberhalb des Zylinders.
-                text_np.setPos(intersection.x, intersection.y, intersection.z + 0.2)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-            else:
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)
-                tn.setAlign(TextNode.ACenter)
-                text_np = veh.attachNewNode(tn)
-                text_np.setPos(0, 1.2, 1.5)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-
-            self.taskMgr.add(partial(self.vehicle_order_task, veh),
-                             f"VehicleOrderTask_{veh.getPythonTag('vehicle_id')}")
-
-    # --------------- Erstellung des Fahrzeugs---------------
-    def create_vehicle(self, park_point=None):
-        # Erzeuge den übergeordneten Fahrzeug-Knoten
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # --------------------------
-        # Chassis erstellen (1 x 0.5 x 1.2, Farbe Rot)
-        # --------------------------
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # --------------------------
-        # Gabel (Fork) erstellen: Zwei Zähne
-        # --------------------------
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        vehicle_node.setPythonTag("fork_node", fork_node)
-
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-
-        # --------------------------
-        # Statt weißer Kante von der Gabel: bereits eingezeichnete grüne Mittellinie verwenden.
-        # In diesem Beispiel nehmen wir an, dass du schon eine „mittlere“ Linie gezeichnet hast.
-        # Zeichne die grüne Mittellinie, z. B. von einem Punkt an der Gabel (als Ausgangspunkt)
-        # bis zu einem Referenzpunkt – hier nutzen wir einen zuvor festgelegten Offset.
-        #
-        # Wir definieren:
-        #   - Den Ausgangspunkt als den grün markierten Punkt, der den mittleren Punkt der Gabel repräsentieren soll.
-        #   - Den Zielpunkt als den Referenzpunkt, der als Idealwert in create_vehicle bestimmt wurde.
-        # In unserem Beispiel berechnen wir den Zielpunkt einmalig aus den lokalen Offsets an der weißen Kante.
-        # (Diese Werte kannst du bei Bedarf anpassen.)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_global = fork_node.getPos(self.render) + left_corner_local
-        right_global = fork_node.getPos(self.render) + right_corner_local
-        # Berechne den idealen (statischen) Mittelpunkt als Referenz – dieser wird nur einmal gesetzt.
-        midpoint_white = (left_global + right_global) * 0.5
-        # Nun lege den grünen Marker so, dass er exakt in der Mitte der Gabel liegt.
-        # Hier entspricht der grüne Punkt der Mittellinie der Gabel.
-        green_point_global = midpoint_white  # Hier wird angenommen, dass der ideale Mittelpunkt gleich dem Referenzpunkt ist.
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        vehicle_node.setPythonTag("fork_green", green_marker_np)
-
-        # Zeichne die grüne Mittellinie.
-        # Als Beispiel: Zeichne eine Linie vom grünen Marker in Richtung +Y (relativ zum Fahrzeug),
-        # weil du den idealen Zustand so festgelegt hast, dass genau diese Linie mit der Station übereinstimmen soll.
-        ls_mid = LineSegs()
-        ls_mid.setThickness(2.0)
-        ls_mid.setColor(0, 1, 0, 1)  # grün
-        # Starte die Linie am grünen Marker.
-        ls_mid.moveTo(green_point_global)
-        # Zeichne beispielsweise eine Linie 1 Einheit lang in +Y-Richtung:
-        ls_mid.drawTo(green_point_global + Vec3(0, 1, 0))
-        fork_center_line = vehicle_node.attachNewNode(ls_mid.create())
-        # Speichere den NodePath der grünen Mittellinie
-        vehicle_node.setPythonTag("fork_center_line", fork_center_line)
-        print("[DEBUG] create_vehicle: Grüne Mittellinie (fork_center_line) gesetzt.")
-
-        # --------------------------
-        # Restliche Fahrzeugteile (Mast, Lenkachse, etc.)
-        # --------------------------
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-        self.add_diagonals_to_mast(mast_node)
-
-        intersection = Vec3(0.5, 0.05, 1.0)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        # --------------------------
-        # Lenkachse erzeugen (Pivot-Node)
-        # --------------------------
-        steering_axis = mast_node.attachNewNode("steering_axis")
-        steering_axis.setPos(0.5, 0.25, -1.2)
-        steering_axis.setH(90)
-        vehicle_node.setPythonTag("steering_axis", steering_axis)
-
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(steering_axis)
-        cylinder_node.setPos(0, 0, 0)
-        self.vehicle_cylinder = steering_axis
-        self.add_steering_arrow(steering_axis, color=(0, 1, 0, 1))
-
-        # --------------------------
-        # Positioniere das Fahrzeug am Parkpunkt
-        # --------------------------
-        if park_point is None:
-            vehicle_node.setPos(0, 0, 0)
-        else:
-            intersection = Vec3(0, 0, 1.0)
-            vehicle_node.setPos(park_point - vehicle_node.getQuat().xform(intersection))
-
-        # ********** Ursprung (Koordinatensystem) am Fahrzeug einzeichnen **********
-        ls_x = LineSegs()
-        ls_x.setThickness(2)
-        ls_x.setColor(LColor(1, 0, 0, 1))
-        ls_x.moveTo(0, 0, 0)
-        ls_x.drawTo(1, 0, 0)
-        vehicle_node.attachNewNode(ls_x.create())
-
-        ls_y = LineSegs()
-        ls_y.setThickness(2)
-        ls_y.setColor(LColor(0, 1, 0, 1))
-        ls_y.moveTo(0, 0, 0)
-        ls_y.drawTo(0, 1, 0)
-        vehicle_node.attachNewNode(ls_y.create())
-
-        ls_z = LineSegs()
-        ls_z.setThickness(2)
-        ls_z.setColor(LColor(0, 0, 1, 1))
-        ls_z.moveTo(0, 0, 0)
-        ls_z.drawTo(0, 0, 1)
-        vehicle_node.attachNewNode(ls_z.create())
-
-        from panda3d.core import TextNode
-        tn_x = TextNode("label_x")
-        tn_x.setText("X")
-        tn_x.setTextColor(1, 0, 0, 1)
-        label_x = vehicle_node.attachNewNode(tn_x)
-        label_x.setScale(0.3)
-        label_x.setPos(2.0, 0, 0)
-
-        tn_y = TextNode("label_y")
-        tn_y.setText("Y")
-        tn_y.setTextColor(0, 1, 0, 1)
-        label_y = vehicle_node.attachNewNode(tn_y)
-        label_y.setScale(0.3)
-        label_y.setPos(0, 2.0, 0)
-
-        tn_z = TextNode("label_z")
-        tn_z.setText("Z")
-        tn_z.setTextColor(0, 0, 1, 1)
-        label_z = vehicle_node.attachNewNode(tn_z)
-        label_z.setScale(0.3)
-        label_z.setPos(0, 0, 2.0)
-
-        return vehicle_node
-
-    def add_steering_arrow(self, steering_axis, color=(0, 1, 0, 1)):
-        """
-        Erzeugt einen Pfeil, der die Vorwärtsrichtung (lokale X-Achse) des Lenkpivots anzeigt.
-        Der Pfeil wird als Kind des übergebenen steering_axis-Node angehängt und passt sich
-        automatisch dessen Rotation an.
-        """
-        arrow_ls = LineSegs()
-        arrow_ls.setThickness(2.0)
-        arrow_ls.setColor(*color)
-
-        # Zeichne eine Linie von (0,0,0) bis (2,0,0) – das ist die Basis des Pfeils
-        arrow_ls.moveTo(0, 0, 0)
-        arrow_ls.drawTo(2, 0, 0)
-
-        # Zeichne den Pfeilkopf: zwei kurze schräge Linien am Ende der Pfeillinie
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, 0.3, 0)
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, -0.3, 0)
-
-        arrow_np = steering_axis.attachNewNode(arrow_ls.create())
-        arrow_np.setPos(0, 0, 0)  # Falls nötig, hier noch zusätzlichen Offset anpassen
-        return arrow_np
-
-    def rotate_around_pivot(self, vehicle, pivot, delta_angle):
-        """
-        Dreht das Fahrzeug (vehicle) um den gegebenen Pivotpunkt (pivot) um delta_angle (in Grad).
-        Dabei wird die Position des Fahrzeugs neu berechnet, sodass es um den Pivot rotiert.
-        """
-        # Aktuelle globale Fahrzeugposition
-        pos = vehicle.getPos(self.render)
-        # Globaler Pivotpunkt
-        pivot_pos = pivot.getPos(self.render)
-        # Berechne den Vektor vom Pivot zum Fahrzeug
-        rel = pos - pivot_pos
-        # Wandle den Drehwinkel in Bogenmaß um
-        rad = math.radians(delta_angle)
-        cos_val = math.cos(rad)
-        sin_val = math.sin(rad)
-        # Drehe den relativen Vektor
-        new_x = rel.getX() * cos_val - rel.getY() * sin_val
-        new_y = rel.getX() * sin_val + rel.getY() * cos_val
-        new_rel = Vec3(new_x, new_y, rel.getZ())
-        # Neue globale Fahrzeugposition
-        new_pos = pivot_pos + new_rel
-        vehicle.setPos(new_pos)
-        # Aktualisiere auch das Heading des Fahrzeugs (aufaddieren des Drehwinkels)
-        vehicle.setH(vehicle.getH() + delta_angle)
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    # ---------------6. Paket- & Auftragsverwaltung---------------
-        # Beispiel einer Methode, die weiterhin auf die extrahierten Umgebungselemente zugreift:
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Je nach gewählter Verteilung kannst du hier Anpassungen vornehmen.
-        # Für den Moment wählen wir einfach zufällig aus allen Abgabestationen,
-        # falls keine spezielle Logik für die Verteilung implementiert ist.
-        target_index = random.randint(1, len(self.abgabe_stations))
-
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def check_and_spawn_packages(self, task):
-        # Verwende den neuen Delay-Wert aus den Einstellungen
-        spawn_delay = self.package_spawn_delay
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-        # Beispiel für eine vorhandene Methode, die auf die Umgebungselemente zugreift:
-    def update_order_table(self):
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen die Stationsnummer (oder verwende "N/A").
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z.B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige den zugewiesenen Fahrzeugnamen an (oder "-" falls noch keiner zugeordnet wurde).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END,
-                                   values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if hasattr(self, 'order_win') and self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    # ---------------7. Cargo-Handling (Pickup, Drop & Timer)---------------
-    def pickup_package(self, vehicle, station):
-        # Falls das Fahrzeug bereits ein Paket trägt, abbrechen.
-        if vehicle.getPythonTag("package_attached"):
-            return
-
-        # Führe den Pickup nur aus, wenn an der Station ein Paket vorhanden ist.
-        if station in self.pickup_packages:
-            # Hole das Paket, den Spawn-Zeitpunkt und den zugehörigen Timer-Knoten.
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            # Entferne den Timer-Knoten, sodass der angezeigte Zähler nicht weiter aktualisiert wird.
-            timer_np.removeNode()
-            # Berechne die Liegedauer (Differenz zwischen aktueller Simulationszeit und Spawn-Zeit).
-            dwell_time = self.sim_clock - spawn_time
-            # Aktualisiere globale Kennzahlen.
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Suche in den Aufträgen nach dem Auftrag, dessen Paket mit diesem Paket übereinstimmt,
-            # und speichere den errechneten Endwert (fixe Liegedauer) sowie den Status.
-            for order_id, order in self.orders.items():
-                if order.get("package") == package:
-                    order["dwell_time"] = dwell_time
-                    order["status"] = "Abgeholt"
-                    break
-
-            # Hole Referenzen zum Gabel-Knoten und zum grünen Marker des Fahrzeugs.
-            fork_node = vehicle.getPythonTag("fork_node")
-            fork_green = vehicle.getPythonTag("fork_green")
-            green_point_pos = fork_green.getPos(fork_node)
-
-            # Übergib das Paket an den Gabel-Knoten (sodass es optisch dem Fahrzeug zugeordnet wird)
-            # und positioniere es relativ zum grünen Marker.
-            package.wrtReparentTo(fork_node)
-            package.setPos(green_point_pos.getX() + 0.5,
-                           green_point_pos.getY() - 0.5,
-                           green_point_pos.getZ() + 1)
-            self.cargos[vehicle] = package
-
-            # Starte den Lieferzeit-Timer: Speichere den Zeitpunkt, an dem das Paket abgeholt wurde,
-            # und hänge einen neuen Timer-Knoten an das Paket.
-            vehicle.setPythonTag("delivery_start_time", self.sim_clock)
-            from panda3d.core import TextNode
-            delivery_timer_text = TextNode("delivery_timer")
-            delivery_timer_text.setText("0.0s")
-            delivery_timer_np = package.attachNewNode(delivery_timer_text)
-            delivery_timer_np.setScale(0.5)
-            delivery_timer_np.setPos(0, 0, 1.2)
-            package.setPythonTag("delivery_timer", delivery_timer_np)
-
-            # Aktualisiere den Zeitpunkt, zu dem an dieser Station zuletzt ein Paket entfernt wurde.
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-
-            # Berechne Lieferzeit:
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start is not None:
-                delivery_time = self.sim_clock - delivery_start
-                self.total_delivery_time += delivery_time
-                self.total_delivery_count += 1
-                self.max_overall_delivery_time = max(self.max_overall_delivery_time, delivery_time)
-                vehicle.clearPythonTag("delivery_start_time")
-
-            # Entferne den Lieferzeit-Timer vom Paket
-            delivery_timer_np = cargo.getPythonTag("delivery_timer")
-            if delivery_timer_np:
-                delivery_timer_np.removeNode()
-
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden das Paket entfernt
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def update_delivery_timers(self, task):
-        for vehicle, package in list(self.cargos.items()):
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start:
-                elapsed_delivery = self.sim_clock - delivery_start
-                delivery_timer_np = package.getPythonTag("delivery_timer")
-                if delivery_timer_np and not delivery_timer_np.isEmpty():
-                    delivery_timer_np.node().setText(f"{elapsed_delivery:.1f}s")
-        return Task.cont
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-
-    # ---------------8. Auftrags-/Fahrzeuglogik---------------
-    def select_next_order(self, vehicle):
-        # Sammle alle Aufträge, die noch "Wartend" sind
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        # Aktualisiere die Dwell-Zeit für jeden Auftrag
-        for order in waiting_orders:
-            order["dwell_time"] = self.sim_clock - order.get("spawn_time", self.sim_clock)
-
-        # Wähle den Auftrag mit der maximalen Dwell-Zeit (evtl. mit etwas Toleranz)
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        # Finde aus den Kandidaten den Auftrag, dessen Pickup-Station (order["pickup_station"])
-        # am nächsten zur aktuellen Fahrzeugposition liegt.
-        vehicle_pos = vehicle.getPos(self.render)
-        candidates.sort(key=lambda order: (order["pickup_station"].getPos(self.render) - vehicle_pos).length())
-        return candidates[0]
-
-    def show_vehicle_control(self):
-        # Falls das Fenster bereits existiert, wiederverwenden
-        if hasattr(self, "control_win") and self.control_win.winfo_exists():
-            self.control_win.deiconify()
-            self.control_win.lift()
-            self.control_win.focus_force()
-            return
-
-        self.control_win = tk.Toplevel(self.tk_root)
-        self.control_win.title("Kontrollfenster")
-        self.control_win.protocol("WM_DELETE_WINDOW", self.control_win.withdraw)
-        self.control_win.attributes("-topmost", True)
-        self.control_win.after(100, lambda: self.control_win.attributes("-topmost", False))
-
-        # Fahrzeugsteuerung: Widgets für jedes Fahrzeug erstellen
-        self.vehicle_state_vars = {}
-        row = 0
-        for veh in self.garage_vehicles:
-            frame = tk.Frame(self.control_win)
-            frame.grid(row=row, column=0, sticky="w", padx=5, pady=2)
-            vid = veh.getPythonTag("vehicle_id")
-            label = tk.Label(frame, text=f"Fahrzeug {vid}")
-            label.pack(side=tk.LEFT)
-            state = veh.getPythonTag("order_state") or "idle"
-            var = tk.StringVar(value=state)
-            self.vehicle_state_vars[veh] = var
-            rb_active = tk.Radiobutton(frame, text="Aufträge bearbeiten", variable=var, value="translate")
-            rb_active.pack(side=tk.LEFT)
-            rb_standby = tk.Radiobutton(frame, text="Standby", variable=var, value="idle")
-            rb_standby.pack(side=tk.LEFT)
-            row += 1
-
-        update_btn = tk.Button(self.control_win, text="Übernehmen", command=self.update_vehicle_control)
-        update_btn.grid(row=row, column=0, pady=5)
-        row += 1
-
-        # Spawn-Einstellungen im gleichen Fenster (ohne Dropdown zur Verteilungswahl)
-        spawn_frame = tk.LabelFrame(self.control_win, text="Spawn Einstellungen", padx=5, pady=5)
-        spawn_frame.grid(row=row, column=0, sticky="w", padx=5, pady=5)
-
-        # Eingabe der Spawnverzögerung
-        tk.Label(spawn_frame, text="Spawnverzögerung (Sekunden):").grid(row=0, column=0, sticky="w")
-        self.spawn_delay_var = tk.DoubleVar(value=self.package_spawn_delay)
-        delay_entry = tk.Entry(spawn_frame, textvariable=self.spawn_delay_var, width=6)
-        delay_entry.grid(row=0, column=1, sticky="w")
-
-        # Auswahl der Annahmestationen (anstatt eines Dropdowns zur Verteilungswahl)
-        tk.Label(spawn_frame, text="Annahmestationen:").grid(row=1, column=0, sticky="w", pady=(5, 0))
-        stations_frame = tk.Frame(spawn_frame)
-        stations_frame.grid(row=2, column=0, columnspan=2, sticky="w")
-        for i in range(min(10, len(self.annahme_stations))):
-            cb = tk.Checkbutton(stations_frame, text=f"Annahmestation {i + 1}",
-                                variable=self.spawn_station_vars[i])
-            cb.pack(anchor="w")
-
-        def apply_spawn_from_control():
-            self.package_spawn_delay = self.spawn_delay_var.get()
-            selected = []
-            for i, var in self.spawn_station_vars.items():
-                if var.get():
-                    selected.append(self.annahme_stations[i])
-            self.package_spawn_stations = selected
-            print(
-                f"Spawn Einstellungen übernommen: Delay={self.package_spawn_delay}s, "
-                f"Stations: {[i + 1 for i, var in self.spawn_station_vars.items() if var.get()]}"
-            )
-            # Spawne nur an Stationen, an denen noch kein Paket existiert:
-            for station in self.package_spawn_stations:
-                if station not in self.pickup_packages:
-                    self.spawn_package_at_station(station)
-
-        apply_btn = tk.Button(
-            spawn_frame,
-            text="Einstellungen übernehmen und spawnen",
-            command=apply_spawn_from_control
-        )
-        apply_btn.grid(row=3, column=0, columnspan=2, pady=5)
-
-    def show_spawn_control(self):
-        spawn_win = tk.Toplevel(self.tk_root)
-        spawn_win.title("Paketspawn Einstellungen")
-
-        # Eingabefeld für Spawnverzögerung
-        tk.Label(spawn_win, text="Spawnverzögerung (Sekunden):").pack(pady=2)
-        delay_entry = tk.Entry(spawn_win)
-        delay_entry.insert(0, str(self.package_spawn_delay))
-        delay_entry.pack(pady=2)
-
-        # (Dropdown für Spawn-Verteilung wurde entfernt)
-
-        # Checkbuttons für die Auswahl der Annahmestationen
-        tk.Label(spawn_win, text="Annahmestationen auswählen (1-10):").pack(pady=2)
-        stations_frame = tk.Frame(spawn_win)
-        stations_frame.pack(pady=2)
-
-        station_vars = {}
-        for idx, station in enumerate(self.annahme_stations):
-            var = tk.BooleanVar(value=False)
-            station_label = f"Annahmestation {idx + 1}"
-            cb = tk.Checkbutton(stations_frame, text=station_label, variable=var)
-            cb.pack(anchor="w")
-            station_vars[idx] = var
-
-        def apply_spawn_settings():
-            try:
-                new_delay = float(delay_entry.get())
-            except ValueError:
-                new_delay = self.package_spawn_delay
-            new_stations = []
-            for idx, var in station_vars.items():
-                if var.get():
-                    new_stations.append(self.annahme_stations[idx])
-
-            self.package_spawn_delay = new_delay
-            self.package_spawn_stations = new_stations
-
-            print(f"Spawn-Einstellungen aktualisiert: Delay={new_delay}s, "
-                  f"Stationen: {[f'Annahmestation {idx + 1}' for idx, var in station_vars.items() if var.get()]}")
-            # Spawne nur dort Pakete, wo noch kein Paket vorhanden ist:
-            for station in self.package_spawn_stations:
-                if station not in self.pickup_packages:
-                    self.spawn_package_at_station(station)
-
-            spawn_win.destroy()
-
-        tk.Button(spawn_win, text="Einstellungen speichern", command=apply_spawn_settings).pack(pady=5)
-
-    def vehicle_order_task(self, vehicle, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-
-        # Frame-Zähler einbauen, um die Frequenz der Modellinferenz zu reduzieren
-        frame_count = vehicle.getPythonTag("frame_count")
-        if frame_count is None:
-            frame_count = 0
-        frame_count += 1
-        vehicle.setPythonTag("frame_count", frame_count)
-
-        # Sensordatenerfassung
-        sensor_data = self.collect_sensor_data(vehicle)
-        import numpy as np
-        # Führe die Modellinferenz nur alle 10 Frames durch, um den Hauptthread zu entlasten
-        if self.tf_model is not None and (frame_count % 10 == 0):
-            input_data = sensor_data.reshape(1, sensor_data.shape[0], sensor_data.shape[1], 1)
-            prediction = self.tf_model.predict(input_data)
-            model_delta_angle = prediction[0][0]
-            print(f"[TF] Modell-Korrektur: {model_delta_angle:.2f}°")
-        else:
-            model_delta_angle = 0.0
-            if self.tf_model is not None:
-                print(f"[TF] Modell-Korrektur übersprungen (Frame Count: {frame_count})")
-            else:
-                print("[TF] Kein Modell vorhanden, Modell-Korrektur wird übersprungen.")
-
-        # Berechne den idealen Korrekturwert (unverändert)
-        ideal_correction = self.compute_ideal_steering_correction(vehicle)
-        print(f"[IDEAL] Ideal berechneter Korrekturwinkel: {ideal_correction:.2f}°")
-
-        # Logge Trainingsdaten nur in der 'translate'-Phase
-        state = vehicle.getPythonTag("order_state")
-        if state == "translate":
-            self.log_training_sample(sensor_data, ideal_correction)
-
-        # Führe die zustandsabhängige Logik aus
-        if state == "translate":
-            self.handle_translate_phase(vehicle, dt)
-        elif state == "rotate":
-            self.handle_rotate_phase(vehicle, dt)
-        elif state == "approach":
-            self.handle_approach_phase(vehicle, dt)
-        elif state == "pickup":
-            self.handle_pickup_phase(vehicle, dt)
-        elif state == "drive_out":
-            self.handle_drive_out_phase(vehicle, dt)
-        elif state == "to_delivery":
-            self.handle_to_delivery_phase(vehicle, dt)
-        elif state == "align_delivery":
-            self.handle_align_delivery_phase(vehicle, dt)
-        elif state == "delivery_center":
-            self.handle_delivery_center_phase(vehicle, dt)
-        elif state == "drop":
-            self.handle_drop_phase(vehicle, dt)
-        elif state == "phase11":
-            self.handle_phase11(vehicle, dt)
-        elif state == "return_to_garage":
-            self.handle_return_to_garage_phase(vehicle, dt)
-        else:
-            print(f"Unbekannter Zustand: {state}")
-
-        return Task.cont
-
-    # -------------------- Handler für einzelne Phasen --------------------
-
-    def handle_translate_phase(self, vehicle, dt):
-        # --- Zusätzlicher Safety-Zweig in der Translate-Phase ---
-        # (1) Zuerst: Falls ein Fahrzeug auf das Ziel (Pickup-Station) wartet, soll gewartet werden.
-        current_order = vehicle.getPythonTag("current_order")
-        station_occupied = False
-        if current_order is not None and "pickup_station" in current_order:
-            pickup_station = current_order["pickup_station"]
-            if self.is_station_occupied(pickup_station, exclude_vehicle=vehicle):
-                station_occupied = True
-                print(
-                    f"[WARTEN] Station {pickup_station.getName()} belegt. Fahrzeug {vehicle.getPythonTag('vehicle_id')} wartet.")
-
-        # (2) Festlegen der Basisgeschwindigkeit:
-        base_speed = 1.5 if not station_occupied else 0.0
-
-        # (3) Kollisionsvermeidung: Passe die Geschwindigkeit an, wenn andere Fahrzeuge in der Nähe sind.
-        adjusted_speed = self.collision_avoidance_adjustment(vehicle, base_speed)
-
-        # --- Rest der originalen Translate-Logik ---
-        # Falls kein Auftrag zugeordnet, versuche einen neuen Auftrag zu wählen.
-        if current_order is None:
-            next_order = self.select_next_order(vehicle)
-            if next_order is not None:
-                next_order["status"] = "In Bearbeitung"
-                next_order["vehicle"] = f"Fahrzeug {vehicle.getPythonTag('vehicle_id')}"
-                vehicle.setPythonTag("current_order", next_order)
-                print(f"Auftrag {next_order['id']} wird zugewiesen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}.")
-            current_order = vehicle.getPythonTag("current_order")
-
-        # Bestimme das Ziel: Zum Beispiel den blauen Marker der Pickup-Station.
-        if current_order is not None:
-            pickup_station = current_order.get("pickup_station")
-            if pickup_station in self.station_blue_dots:
-                target = self.station_blue_dots[pickup_station].getPos(self.render)
-            else:
-                target = self.blue_dot.getPos(self.render)
-        else:
-            target = self.blue_dot.getPos(self.render)
-
-        current_pos = vehicle.getPos(self.render)
-        pivot = vehicle.getPythonTag("steering_axis")
-
-        # Berechne den Offset-Punkt, von dem aus das Fahrzeug navigiert.
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        import math
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-        heading_error = desired_heading_rad - current_heading_rad
-        while heading_error > math.pi:
-            heading_error -= 2 * math.pi
-        while heading_error < -math.pi:
-            heading_error += 2 * math.pi
-
-        # Berechne den Drehwinkel (gilt für die Korrektur) – normale Drehung.
-        gain = 1.0
-        max_delta = gain * dt
-        delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-        self.rotate_around_pivot(vehicle, pivot, math.degrees(delta_heading_rad))
-
-        # Jetzt Vorwärtsbewegung: Verwende dafür die angepasste Geschwindigkeit.
-        global_hpr = pivot.getNetTransform().getHpr()
-        new_heading_rad = math.radians(global_hpr.getX())
-        new_x = current_pos.getX() + adjusted_speed * math.cos(new_heading_rad) * dt
-        new_y = current_pos.getY() + adjusted_speed * math.sin(new_heading_rad) * dt
-        new_pos = Vec3(new_x, new_y, 0)
-        vehicle.setPos(new_pos)
-
-        # Wenn das Fahrzeug nahe genug am Ziel ist, wechsle den Zustand in die Rotationsphase.
-        new_offset_pos = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        if (target - new_offset_pos).length() < 0.1:
-            vehicle.setPythonTag("order_state", "rotate")
-
-        return Task.cont
-
-    def handle_rotate_phase(self, vehicle, dt):
-        import math
-        from panda3d.core import Vec3
-
-        # 1. Hole den grünen Referenzpunkt (fork_green) der Gabel.
-        fork_green = vehicle.getPythonTag("fork_green")
-        if not fork_green or fork_green.isEmpty():
-            print("[DEBUG] handle_rotate_phase: Kein fork_green gefunden!")
-            return
-
-        # 2. Hole den aktuellen Auftrag und die zugehörige Pickup-Station.
-        current_order = vehicle.getPythonTag("current_order")
-        if not current_order or "pickup_station" not in current_order:
-            print("[DEBUG] handle_rotate_phase: Kein aktueller Auftrag oder Station gefunden!")
-            return
-        station = current_order["pickup_station"]
-
-        # Hole den Referenzpunkt der Station (white_center) und den Richtungsvektor (white_direction)
-        white_center = station.getPythonTag("white_center")
-        if white_center is None:
-            print("[DEBUG] handle_rotate_phase: Kein white_center in der Station gefunden!")
-            return
-        target = white_center  # Ziel: Mittelpunkt der weißen Linie
-
-        # 3. Berechne den Drehpunkt des Fahrzeugs.
-        pivot = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-
-        # 4. Falls sich der pivot nahe am Ziel befindet, final: Setze die exakte Ausrichtung.
-        distance = (target - pivot).length()
-        stop_threshold = 0.5  # Schwellenwert, evtl. an Modelldimensionen anpassen
-        if distance < stop_threshold:
-            desired_vector = target - pivot
-            desired_angle = math.degrees(math.atan2(desired_vector.getY(), desired_vector.getX())) + 90
-            desired_angle %= 360
-            vehicle.setH(self.render, desired_angle)
-            print(f"[DEBUG] final step: Fahrzeugheading auf {desired_angle:.2f}° gesetzt.")
-
-            # Final: Richte den grünen Richtungspfeil ("fork_center_line") exakt aus.
-            white_direction = station.getPythonTag("white_direction")
-            if white_direction is not None:
-                desired_arrow_angle = math.degrees(math.atan2(white_direction.getY(), white_direction.getX()))
-                arrow_relative = (desired_arrow_angle - desired_angle + 180) % 360 - 180
-                fork_center_line = vehicle.getPythonTag("fork_center_line")
-                if fork_center_line:
-                    fork_center_line.setH(arrow_relative)
-                    print(f"[DEBUG] final step: Grüner Pfeil auf relativen Winkel {arrow_relative:.2f}° gesetzt.")
-            # Hier ändern wir den Zustand in 'approach' statt "next_phase"
-            vehicle.setPythonTag("order_state", "approach")
-            return
-
-        # 5. Andernfalls: Berechne den gewünschten globalen Winkel (inklusive +90°-Offset)
-        desired_vector = target - pivot
-        desired_angle = math.degrees(math.atan2(desired_vector.getY(), desired_vector.getX())) + 90
-        desired_angle %= 360
-
-        # 6. Ermittle den aktuellen Fahrzeugheading in Weltkoordinaten und berechne die Winkelabweichung.
-        current_heading = vehicle.getH(self.render)
-        angle_diff = (desired_angle - current_heading + 180) % 360 - 180
-
-        if abs(angle_diff) < 2.0:
-            vehicle.setH(self.render, desired_angle)
-            white_direction = station.getPythonTag("white_direction")
-            if white_direction is not None:
-                desired_arrow_angle = math.degrees(math.atan2(white_direction.getY(), white_direction.getX()))
-                arrow_relative = (desired_arrow_angle - desired_angle + 180) % 360 - 180
-                fork_center_line = vehicle.getPythonTag("fork_center_line")
-                if fork_center_line:
-                    fork_center_line.setH(arrow_relative)
-                    print(f"[DEBUG] fine alignment: Grüner Pfeil auf {arrow_relative:.2f}° gesetzt.")
-            # Ändere auch hier sofort den Zustand in "approach"
-            vehicle.setPythonTag("order_state", "approach")
-            return
-
-        # 7. Begrenze die Drehung pro Frame (z.B. 20,9° pro Sekunde)
-        max_rotation_speed = 20.9  # Grad pro Sekunde
-        max_delta = max_rotation_speed * dt
-        delta_angle = max(-max_delta, min(max_delta, angle_diff))
-
-        # 8. Drehe das Fahrzeug schrittweise um delta_angle
-        temp_pivot = self.render.attachNewNode("temp_pivot")
-        temp_pivot.setPos(pivot)
-        self.rotate_around_pivot(vehicle, temp_pivot, delta_angle)
-        temp_pivot.removeNode()
-
-        print(f"[DEBUG] rotating: Gedreht um {delta_angle:.2f}°; Restliche Differenz: {angle_diff - delta_angle:.2f}°")
-
-    def handle_approach_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None:
-            pickup_station = current_order.get("pickup_station")
-            target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-        else:
-            target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-        current = vehicle.getPos(self.render)
-        error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-        if error_vec.length() > 0.05:
-            direction = error_vec.normalized()
-            move_distance = 1.5 * dt
-            new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                           current.getY() + direction.getY() * move_distance, target.getZ())
-            vehicle.setPos(new_pos)
-        else:
-            vehicle.setPos(target)
-            vehicle.setPythonTag("order_state", "pickup")
-
-    def handle_pickup_phase(self, vehicle, dt):
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        target_z = 1.0
-        raise_speed = 0.5
-        if current_z < target_z:
-            fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-        else:
-            if vehicle.getPythonTag("current_order") is None:
-                if self.orders_queue:
-                    vehicle.setPythonTag("current_order", self.orders_queue.pop(0))
-                else:
-                    print(
-                        f"Keine verfügbaren Aufträge für Fahrzeug {vehicle.getPythonTag('vehicle_id')}. Überspringe Pickup-Phase.")
-                    vehicle.setPythonTag("order_state", "drive_out")
-                    return
-            if not vehicle.getPythonTag("package_attached"):
-                pickup_station = vehicle.getPythonTag("current_order")["pickup_station"]
-                self.pickup_package(vehicle, pickup_station)
-                vehicle.setPythonTag("package_attached", True)
-            if vehicle.getPythonTag("drive_out_target") is None:
-                vehicle.setPythonTag("drive_out_target",
-                                     vehicle.getPos(self.render) + vehicle.getQuat(self.render).getForward() * 5.0)
-            vehicle.setPythonTag("order_state", "drive_out")
-
-    def handle_drive_out_phase(self, vehicle, dt):
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        if current_z > 0:
-            lower_speed = 0.5
-            fork_node.setZ(max(0, current_z - lower_speed * dt))
-        current_pos = vehicle.getPos(self.render)
-        drive_out_target = vehicle.getPythonTag("drive_out_target")
-        if drive_out_target is None:
-            drive_out_target = current_pos + vehicle.getQuat(self.render).getForward() * 5.0
-            vehicle.setPythonTag("drive_out_target", drive_out_target)
-        diff = drive_out_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            vehicle.setPythonTag("order_state", "to_delivery")
-            vehicle.setPythonTag("drive_out_target", None)
-
-    def handle_to_delivery_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is None:
-            return Task.cont
-
-        # Bestimme den Zielpunkt der Abgabestation:
-        delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-        try:
-            target_index = int(delivery_target_str.split()[-1])
-        except ValueError:
-            target_index = 1
-        if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-            target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-        else:
-            target = self.abgabe_blue_dots[0].getPos(self.render)
-
-        # Prüfe, ob die Abgabestation bereits durch ein Fahrzeug,
-        # das aktuell ein Paket abgibt oder in der Drop-Phase ist, besetzt ist.
-        if self.is_delivery_station_occupied(target, exclude_vehicle=vehicle, occupancy_threshold=1.0):
-            print(f"[WARTEN] Abgabestation belegt. Fahrzeug {vehicle.getPythonTag('vehicle_id')} wartet.")
-            return Task.cont  # Das Fahrzeug setzt keine Bewegung fort
-
-        # Falls die Abgabestation frei ist, folgt der übliche Bewegungs- und Drehvorgang:
-        current_pos = vehicle.getPos(self.render)
-        pivot = vehicle.getPythonTag("steering_axis")
-        import math
-        desired_heading_rad = math.atan2(target.getY() - current_pos.getY(),
-                                         target.getX() - current_pos.getX())
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-        heading_error = desired_heading_rad - current_heading_rad
-        while heading_error > math.pi:
-            heading_error -= 2 * math.pi
-        while heading_error < -math.pi:
-            heading_error += 2 * math.pi
-        gain = 1.0
-        max_delta = gain * dt
-        delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-        self.rotate_around_pivot(vehicle, pivot, math.degrees(delta_heading_rad))
-
-        # Vorwärtsbewegung:
-        new_heading_rad = math.radians(pivot.getNetTransform().getHpr().getX())
-        speed = 1.5  # Basisgeschwindigkeit
-        new_x = current_pos.getX() + speed * math.cos(new_heading_rad) * dt
-        new_y = current_pos.getY() + speed * math.sin(new_heading_rad) * dt
-        new_pos = Vec3(new_x, new_y, 0)
-        vehicle.setPos(new_pos)
-
-        # Falls das Fahrzeug nahe genug am Ziel ist, wechsele den Zustand:
-        if (target - new_pos).length() < 0.5:
-            print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat die Abgabestation erreicht.")
-            vehicle.setPythonTag("order_state", "align_delivery")
-
-        return Task.cont
-
-    def handle_align_delivery_phase(self, vehicle, dt):
-        desired_heading = 90.0
-        current_heading = vehicle.getH() % 360
-        angle_diff = ((desired_heading - current_heading + 180) % 360) - 180
-        print(
-            f"Phase 8: Align Delivery | Fahrzeug {vehicle.getPythonTag('vehicle_id')}: Current {current_heading:.2f}°, Desired {desired_heading:.2f}°, Diff {angle_diff:.2f}°")
-        fixed_turn_speed = 90.0
-        turn_amount = fixed_turn_speed * dt
-        if abs(angle_diff) < 1.0:
-            vehicle.setH(desired_heading)
-            print(
-                f"Phase 8 abgeschlossen: Fahrzeug {vehicle.getPythonTag('vehicle_id')} ausgerichtet (Heading = {desired_heading:.2f}°).")
-            vehicle.setPythonTag("order_state", "delivery_center")
-        else:
-            new_heading = current_heading + (turn_amount if angle_diff > 0 else -turn_amount)
-            new_heading %= 360
-            vehicle.setH(new_heading)
-            print(f"Phase 8: Rotating - Fahrzeug {vehicle.getPythonTag('vehicle_id')} New Heading: {new_heading:.2f}°")
-
-    def handle_delivery_center_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is None:
-            return
-        delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-        try:
-            target_index = int(delivery_target_str.split()[-1])
-        except ValueError:
-            target_index = 1
-        if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-            blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-        else:
-            blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-        current = vehicle.getPos(self.render)
-        target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-        print(f"Phase 9: Zielpunkt der Abgabestation für Fahrzeug {vehicle.getPythonTag('vehicle_id')}: {target_point}")
-        error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-        tolerance = 0.05
-        move_distance = 1.5 * dt
-        if error_vec.length() > tolerance:
-            direction = error_vec.normalized()
-            new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                           current.getY() + direction.getY() * move_distance, current.getZ())
-            vehicle.setPos(new_pos)
-            print(f"Phase 9: Fahrzeug {vehicle.getPythonTag('vehicle_id')} bewegt sich von {current} nach {new_pos}")
-        else:
-            vehicle.setPos(target_point)
-            print(f"Phase 9: Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den Zielpunkt erreicht.")
-            vehicle.setPythonTag("order_state", "drop")
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_fork_z = fork_node.getZ()
-        if current_fork_z < 1.0:
-            new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-            fork_node.setZ(new_fork_z)
-            print(
-                f"Phase 9: Gabel wird angehoben für Fahrzeug {vehicle.getPythonTag('vehicle_id')} (Z = {new_fork_z}).")
-
-    def handle_drop_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if vehicle.getPythonTag("package_attached"):
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            # (Bei Bedarf kann man hier noch Zielpositionen abfragen.)
-            self.drop_cargo(vehicle)
-            print(f"Phase 10: Paket abgesetzt für Fahrzeug {vehicle.getPythonTag('vehicle_id')}")
-            vehicle.setPythonTag("package_attached", False)
-        else:
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            if current_z > 0:
-                lower_speed = 0.5
-                new_z = max(0, current_z - lower_speed * dt)
-                fork_node.setZ(new_z)
-                print(
-                    f"Phase 10: Gabel wird abgesenkt für Fahrzeug {vehicle.getPythonTag('vehicle_id')}, aktueller Z-Wert: {new_z}")
-            else:
-                print(f"Phase 10: Dropoff abgeschlossen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}")
-                if vehicle.getPythonTag("standby_pending"):
-                    vehicle.setPythonTag("order_state", "return_to_garage")
-                    print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} kehrt zur Garage zurück (Standby).")
-                else:
-                    vehicle.setPythonTag("order_state", "translate")
-                current_order["status"] = "Abgegeben"
-                current_order["delivered_at"] = self.sim_clock
-                vehicle.clearPythonTag("current_order")
-
-    def handle_phase11(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if vehicle.getPythonTag("last_delivery_marker") is not None:
-            target_point = vehicle.getPythonTag("last_delivery_marker")
-        else:
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                target_point = self.abgabe_blue_dots[0].getPos(self.render)
-        print(f"Phase 11: Zielpunkt (blauer Marker) für Fahrzeug {vehicle.getPythonTag('vehicle_id')}: {target_point}")
-        current_pos = vehicle.getPos(self.render)
-        diff = target_point - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            vehicle.setPos(new_pos)
-            print(
-                f"Phase 11: Fahrzeug {vehicle.getPythonTag('vehicle_id')} fährt aus der Station, neue Position: {new_pos}")
-        else:
-            vehicle.setPos(target_point)
-            print(
-                f"Phase 11: Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den blauen Marker erreicht. Nächster Auftrag wird gestartet.")
-            vehicle.setPythonTag("order_state", "next_order")
-
-    def handle_return_to_garage_phase(self, vehicle, dt):
-        garage_target = vehicle.getPythonTag("garage_target")
-        if garage_target is None:
-            garage_target = self.garagen_parking_points[0]
-        current_pos = vehicle.getPos(self.render)
-        diff = garage_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 1.0 * dt
-            new_pos = current_pos + diff.normalized() * move_distance
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            if vehicle.hasPythonTag("start_heading"):
-                vehicle.setH(vehicle.getPythonTag("start_heading"))
-            vehicle.setPythonTag("order_state", "idle")
-            vehicle.setPythonTag("standby_pending", False)
-            print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} ist in der Garage (Standby).")
-
-    def collect_sensor_data(self, vehicle, sensor_range=5, grid_resolution=0.5):
-        """
-        Erzeugt ein einfaches 2D-Occupancy-Grid, das den Bereich um das Fahrzeug simuliert.
-
-        Parameter:
-          sensor_range: Radius (in Welt-Einheiten) um das Fahrzeug.
-          grid_resolution: Größe der einzelnen Zellen im Grid.
-
-        Rückgabe:
-          Ein NumPy-Array (2D) mit 0 (frei) als Platzhalter.
-        """
-        import numpy as np
-        grid_size = int((sensor_range * 2) / grid_resolution)
-        sensor_grid = np.zeros((grid_size, grid_size))
-        # --- Hier kannst du später echte Kollisionsabfragen oder Ray-Casting integrieren ---
-        return sensor_grid
-
-    def compute_ideal_steering_correction(self, vehicle):
-        """
-        Berechnet einen idealen Korrekturwinkel (in Grad) für die Navigation in der 'translate'-Phase.
-        Es wird ein vereinfachtes Modell genutzt, das den Unterschied zwischen dem gewünschten und dem aktuellen
-        Heading (über die Fahrzeug-Steuerachse) ermittelt.
-        """
-        import math
-
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None and "pickup_station" in current_order:
-            pickup_station = current_order["pickup_station"]
-            if pickup_station in self.station_blue_dots:
-                target = self.station_blue_dots[pickup_station].getPos(self.render)
-            else:
-                target = self.blue_dot.getPos(self.render)
-        else:
-            target = self.blue_dot.getPos(self.render)
-
-        current_pos = vehicle.getPos(self.render)
-        # Bestimme einen Offset-Punkt, basierend auf der bereits existierenden pickup_offset
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        # Berechne den gewünschten Heading-Winkel (in Radiant): Richtung von offset_pos zu target
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-
-        # Hole den aktuellen Heading-Wert vom Steuerachsen-Node (pivot)
-        pivot = vehicle.getPythonTag("steering_axis")
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-
-        ideal_correction_rad = desired_heading_rad - current_heading_rad
-        # Winkelbereich anpassen [-pi, pi]
-        while ideal_correction_rad > math.pi:
-            ideal_correction_rad -= 2 * math.pi
-        while ideal_correction_rad < -math.pi:
-            ideal_correction_rad += 2 * math.pi
-
-        return math.degrees(ideal_correction_rad)
-
-    def log_training_sample(self, sensor_data, ideal_angle):
-        """
-        Speichert ein Trainingssample bestehend aus den gesammelten Sensorwerten und dem idealen Korrekturwinkel.
-        """
-        self.training_data.append((sensor_data.copy(), ideal_angle))
-        # Optional: Gib eine Debug-Ausgabe aus, um das Logging zu überwachen.
-        print(
-            f"[LOG] Trainingssample gespeichert: Ideal Correction = {ideal_angle:.2f}°, Sensor Shape = {sensor_data.shape}")
-
-    def apply_safety_rules(self, vehicle, sensor_data, model_delta_angle, ideal_correction):
-        """
-        Kombiniert den vom Modell (model_delta_angle) und den ideal berechneten Korrekturwert (ideal_correction)
-        nur dann mit einem festen Sicherheitswert, wenn die Sensordaten einen kritischen Occupancy-Level anzeigen.
-
-        Falls der Occupancy-Level niedrig ist, wird ausschließlich der ideal vorhandene Korrekturwert verwendet.
-        """
-        import numpy as np
-        # Beispiel: Untersuche die mittlere Zeile des sensor_data-Grids als Indikator für frontale Hindernisse
-        middle_row = sensor_data[sensor_data.shape[0] // 2]
-        occupancy_level = np.sum(middle_row)
-
-        # Definiere einen kritischen Schwellenwert (diesen Wert ggf. anpassen)
-        threshold = 1.0
-
-        if occupancy_level > threshold:
-            print(
-                f"[RULE] Kritischer Occupancy-Level = {occupancy_level:.2f} erkannt. Sicherheitskorrektur wird angewendet.")
-            # Hier legen wir fest, dass in kritischen Situationen der Sicherheitswert stärker gewichtet wird.
-            safety_correction = 15.0  # z. B. 15° als feste Korrektur (Wert anpassen)
-            # Gewichteter Ansatz: Sicherheitskorrektur dominiert, während ein kleiner Anteil des idealen Wertes einfließt.
-            final_angle = 0.7 * safety_correction + 0.3 * ideal_correction
-        else:
-            # Wenn kein kritischer Wert vorliegt, einfach den ideal berechneten Korrekturwert verwenden.
-            final_angle = ideal_correction
-
-        return final_angle
-
-    def collision_avoidance_adjustment(self, current_vehicle, base_speed, safe_distance=3.0):
-        current_pos = current_vehicle.getPos(self.render)
-        adjusted_speed = base_speed
-        # Berechne einen Basisfaktor (z.B. basierend auf Abstand zu anderen Fahrzeugen):
-        for veh in self.garage_vehicles:
-            if veh == current_vehicle:
-                continue
-            other_pos = veh.getPos(self.render)
-            distance = (current_pos - other_pos).length()
-            if distance < safe_distance:
-                factor = (distance / safe_distance) ** 2
-                candidate_speed = base_speed * factor
-                if candidate_speed < adjusted_speed:
-                    adjusted_speed = candidate_speed
-
-        # Hier integrieren wir den RL-Ausdruck:
-        # Nehme als Zustandsvektor bspw. [min_distance_to_others, current_speed]
-        min_distance = min(
-            [(current_pos - v.getPos(self.render)).length() for v in self.garage_vehicles if v != current_vehicle])
-        current_speed = self.current_speed  # oder eine entsprechende Eigenschaft des Fahrzeugs
-        state = [min_distance, current_speed]
-
-        # Angenommen, du hast für jedes Fahrzeug einen eigenen RL-Agenten (oder einen globalen)
-        action = self.rl_agent.select_action(state)
-        # Definiere, wie Aktion in einen zusätzlichen Bremsfaktor übersetzt wird:
-        # Beispiel: Aktion 0: kein zusätzlicher Bremsfaktor, 1: 20% Reduktion, 2: 50% Reduktion
-        action_to_factor = {0: 1.0, 1: 0.8, 2: 0.5}
-        braking_factor = action_to_factor.get(action, 1.0)
-        adjusted_speed *= braking_factor
-
-        return adjusted_speed
-
-    def is_station_occupied(self, station, exclude_vehicle=None, occupancy_threshold=1.0):
-        """
-        Prüft, ob sich bereits ein Fahrzeug an der gegebenen Station (z. B. Pickup‑Station)
-        befindet. Dabei wird als Zielpunkt zumeist der blaue Marker genutzt, der der Station
-        zugeordnet ist. Das Fahrzeug exclude_vehicle (z. B. das aktuell agierende Fahrzeug)
-        wird dabei nicht berücksichtigt.
-        """
-        # Falls ein blauer Marker vorhanden ist, nutze dessen Position als Zielort:
-        if hasattr(self, 'station_blue_dots') and station in self.station_blue_dots:
-            station_pos = self.station_blue_dots[station].getPos(self.render)
-        else:
-            station_pos = station.getPos(self.render)
-        for veh in self.garage_vehicles:
-            if veh == exclude_vehicle:
-                continue
-            if (veh.getPos(self.render) - station_pos).length() < occupancy_threshold:
-                return True
-        return False
-
-    def is_delivery_station_occupied(self, target_pos, exclude_vehicle=None, occupancy_threshold=1.0):
-        """
-        Prüft, ob sich ein Fahrzeug in der Nähe der Abgabestation (target_pos) befindet,
-        welches in einer Lieferphase (z. B. drop, delivery_center oder align_delivery) ist oder noch ein Paket
-        transportiert (package_attached = True). Das Fahrzeug exclude_vehicle (z. B. das aktuell anfahrende Fahrzeug)
-        wird dabei nicht berücksichtigt.
-        """
-        for veh in self.garage_vehicles:
-            if veh == exclude_vehicle:
-                continue
-            # Hole den aktuellen Zustand und ob ein Paket noch angebracht ist.
-            state = veh.getPythonTag("order_state")
-            package_attached = veh.getPythonTag("package_attached")
-            if state in ["drop", "delivery_center", "align_delivery"] or package_attached:
-                if (veh.getPos(self.render) - target_pos).length() < occupancy_threshold:
-                    return True
-        return False
-
-    def check_collisions(self):
-        collision_threshold = 1.0  # z. B. wenn Fahrzeuge näher als 1 Einheit sind
-        collisions = []
-        for i in range(len(self.garage_vehicles)):
-            veh1 = self.garage_vehicles[i]
-            pos1 = veh1.getPos(self.render)
-            for j in range(i + 1, len(self.garage_vehicles)):
-                veh2 = self.garage_vehicles[j]
-                pos2 = veh2.getPos(self.render)
-                if (pos1 - pos2).length() < collision_threshold:
-                    collisions.append((veh1, veh2))
-        return collisions
-
-    def update_rl_on_collisions(self):
-        collisions = self.check_collisions()
-        for veh1, veh2 in collisions:
-            # Für jedes beteiligte Fahrzeug:
-            for veh in (veh1, veh2):
-                # Erstelle einen Zustandsvektor – analog zum, der in collision_avoidance_adjustment verwendet wird.
-                current_pos = veh.getPos(self.render)
-                min_distance = min([(current_pos - v.getPos(self.render)).length()
-                                    for v in self.garage_vehicles if v != veh])
-                current_speed = self.current_speed  # oder fahrzeugspezifisch
-                state = [min_distance, current_speed]
-                # Nehme an, die letzte von deinem Agenten gewählte Aktion ist gespeichert (das könntest du in einem PythonTag ablegen)
-                last_action = veh.getPythonTag("last_braking_action")
-
-                # Definiere den negativen Reward
-                reward = -10
-                # Erfasse den nächsten Zustand (nach Entfernen des Kollisionsereignisses oder nach einer kurzen Verzögerung)
-                next_state = state  # In einem echten Setup wäre hier der nächste gemessene Zustand
-                self.rl_agent.update(state, last_action, reward, next_state)
-                print(f"RL-Update für Fahrzeug {veh.getPythonTag('vehicle_id')}: Kollisionsreward {reward} vergeben.")
-
-import random
-import numpy as np
-
-class RLAgent:
-    def __init__(self, state_bins, action_space, learning_rate=0.1, discount_factor=0.9, epsilon=0.2):
-        """
-        state_bins: Tuple oder Liste, um kontinuierliche Zustände zu diskretisieren (z.B. (max_distance, num_bins))
-        action_space: Liste diskreter Aktionen (z.B. [0, 1, 2] --> 0: keine Bremsung, 1: leicht, 2: stark)
-        """
-        self.state_bins = state_bins
-        self.action_space = action_space
-        self.lr = learning_rate
-        self.gamma = discount_factor
-        self.epsilon = epsilon
-        # Initialisiere Q-Tabelle als Dictionary: key: (discretisierter_state), value: Liste von Q-Werten pro Aktion
-        self.q_table = {}
-
-    def discretize_state(self, state):
-        """
-        Nimmt einen Zustandsvektor (z.B. [distance, speed]) und gibt einen diskreten Zustand zurück.
-        Hier ein Beispiel: Falls state[0] = Abstand und state[1] = Geschwindigkeit.
-        """
-        # Beispiel: Wir nehmen an, dass state_bins = ((max_distance, num_bins), (max_speed, num_bins))
-        discrete_state = []
-        for i, (max_val, bins) in enumerate(self.state_bins):
-            # Begrenze state[i] um max_val:
-            val = min(state[i], max_val)
-            bin_size = max_val / bins
-            discrete_state.append(int(val // bin_size))
-        return tuple(discrete_state)
-
-    def select_action(self, state):
-        discrete_state = self.discretize_state(state)
-        if discrete_state not in self.q_table:
-            self.q_table[discrete_state] = [0.0 for _ in self.action_space]
-        # Epsilon-greedy Auswahl:
-        if random.random() < self.epsilon:
-            return random.choice(self.action_space)
-        else:
-            q_values = self.q_table[discrete_state]
-            return self.action_space[np.argmax(q_values)]
-
-    def update(self, state, action, reward, next_state):
-        s = self.discretize_state(state)
-        s_next = self.discretize_state(next_state)
-        if s not in self.q_table:
-            self.q_table[s] = [0.0 for _ in self.action_space]
-        if s_next not in self.q_table:
-            self.q_table[s_next] = [0.0 for _ in self.action_space]
-        a_index = self.action_space.index(action)
-        # Q-Learning Update-Regel:
-        best_next = max(self.q_table[s_next])
-        self.q_table[s][a_index] += self.lr * (reward + self.gamma * best_next - self.q_table[s][a_index])
-
-
-if __name__ == "__main__":
-    # Wichtig: setze auf Windows die Startmethode auf "spawn"
-    multiprocessing.set_start_method('spawn')
-
-    # Erzeuge eine Queue, auch wenn sie später eventuell neu erstellt wird, wenn "G" gedrückt wird.
-    graph_q = Queue()
-    app = LagerSimulation(graph_q)
-    app.run()
-
-    # Beim Schließen der Simulation den Graphprozess ggf. beenden
-    if app.graph_process is not None:
-        app.graph_process.terminate()
-        app.graph_process.join()
\ No newline at end of file
Index: FFZ/FFZ21.py
===================================================================
diff --git a/FFZ/FFZ21.py b/FFZ/FFZ21.py
deleted file mode 100644
--- a/FFZ/FFZ21.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,562 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    LineSegs,
-    Vec3,
-    NodePath
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import math
-import random  # für zufällige Hindernisse
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5  # Standardgeschwindigkeit in m/s
-
-        # Kameraeinstellungen (Fahrtrichtung: entlang der Y-Achse)
-        self.cam.setPos(0, -30, 10)
-        self.cam.lookAt(0, 0, 0)
-
-        # Licht und Raster erstellen
-        self.setup_light()
-        self.create_grid(center_extent=10, cell_size=0.1)
-
-        # Hindernisse erzeugen und speichern
-        self.create_random_obstacles(obstacle_count=10)
-
-        # Fahrzeug erstellen (Chassis, Gabel, Mast, etc.)
-        self.vehicle = self.create_vehicle()
-
-        # Regler für die Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Laufzeitanzeige
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom via Mausrad
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Update-Tasks
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        # Der Fahrzeug-Task enthält nun das Bremsen und das Ausweichen.
-        self.taskMgr.add(self.update_vehicle, "UpdateVehicleTask")
-        # Optional: Task für Gabel-Animation
-        # self.taskMgr.add(self.update_cable, "UpdateCableTask")
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        pos = self.vehicle.getPos()
-        current_heading = self.vehicle.getH()
-
-        # Berechne die aktuelle Vorwärtsrichtung (in der XY-Ebene)
-        forward = self.vehicle.getQuat().getForward()
-        forward.setZ(0)
-        if forward.length() != 0:
-            forward.normalize()
-
-        # ------------ Hindernisvermeidung mittels "Lidar" -------------
-        avoidance_vector = Vec3(0, 0, 0)
-        detection_radius = 5.0  # Erfassungsreichweite des Lidar-Sensors
-        avoidance_strength = 2.0  # Multiplikator für einen stärkeren repulsiven Einfluss
-
-        for obs in self.obstacles:
-            obs_pos = obs.getPos()
-            delta = obs_pos - pos
-            delta.setZ(0)
-            distance = delta.length()
-            # Nur Hindernisse berücksichtigen, die vor dem Fahrzeug liegen
-            if distance < detection_radius and delta.dot(forward) > 0:
-                weight = (detection_radius - distance) / detection_radius
-                repulsion = (pos - obs_pos).normalized() * weight * avoidance_strength
-                avoidance_vector += repulsion
-
-        # Kombination: Standardvorwärts plus repulsive Komponente
-        desired_direction = forward + avoidance_vector
-        # Falls sich beide Vektoren nahezu aufheben (z. B. wenn ein Hindernis direkt vor dem Fahrzeug liegt),
-        # wähle eine zusätzliche Ausweichrichtung (z. B. ein Schwenken nach rechts).
-        if desired_direction.length() < 0.001:
-            desired_direction = forward + Vec3(0.5, 0, 0)
-        desired_direction.normalize()
-
-        # Bestimme den gewünschten Heading (0° entspricht der Y-Achse)
-        desired_heading = math.degrees(math.atan2(desired_direction.getX(), desired_direction.getY()))
-
-        # Berechne den kleinsten Drehwinkel (normalisiert zwischen -180° und 180°)
-        angle_diff = (desired_heading - current_heading + 180) % 360 - 180
-        turn_rate = 90.0  # Maximale Drehgeschwindigkeit (Grad/s)
-        max_turn = turn_rate * dt
-        angle_change = max(-max_turn, min(max_turn, angle_diff))
-        new_heading = current_heading + angle_change
-        self.vehicle.setH(new_heading)
-
-        # Neuberechnung der Vorwärtsrichtung nach Drehung
-        new_forward = self.vehicle.getQuat().getForward()
-        new_forward.setZ(0)
-        if new_forward.length() != 0:
-            new_forward.normalize()
-
-        # ------------ Brems-Logik ------------
-        default_speed = 1.5    # Normale Fahrgeschwindigkeit (m/s)
-        brake_distance = 2.0   # Ab diesem Abstand wird abgebremst
-        min_distance = float('inf')
-        for obs in self.obstacles:
-            obs_pos = obs.getPos()
-            delta = obs_pos - pos
-            delta.setZ(0)
-            # Berücksichtige nur Hindernisse vor dem Fahrzeug (im Bereich der aktuellen Fahrtrichtung)
-            if delta.dot(new_forward) > 0:
-                d = delta.length()
-                if d < min_distance:
-                    min_distance = d
-        if min_distance == float('inf'):
-            target_speed = default_speed
-        elif min_distance < brake_distance:
-            target_speed = default_speed * (min_distance / brake_distance)
-        else:
-            target_speed = default_speed
-
-        # Sanfte Geschwindigkeitsanpassung (Beschleunigen bzw. Bremsen)
-        acc_rate = 2.0  # m/s²
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        # Aktualisiere die Fahrzeugposition
-        new_pos = pos + new_forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    def create_random_obstacles(self, obstacle_count=10):
-        """
-        Erzeugt zufällig platzierte Hindernisse im vorderen Bereich der Simulation.
-        Die erstellten Hindernisse werden in self.obstacles gespeichert, sodass der "Lidar"
-        diese erkennen kann.
-        """
-        self.obstacles = []
-        for i in range(obstacle_count):
-            # Zufällige Größe zwischen 0.5 und 1.5 (Breite, Tiefe, Höhe)
-            width = random.uniform(0.5, 1.5)
-            depth = random.uniform(0.5, 1.5)
-            height = random.uniform(0.5, 1.5)
-            # Zufällige Position: X zwischen -8 und 8, Y zwischen 10 und 50
-            x_pos = random.uniform(-8, 8)
-            y_pos = random.uniform(10, 50)
-            # Erstelle eine Box als Hindernis (dunkles Grau)
-            obstacle = self.create_box(width, depth, height, (0.3, 0.3, 0.3, 1))
-            obstacle_np = self.render.attachNewNode(obstacle)
-            obstacle_np.setPos(x_pos, y_pos, 0)
-            self.obstacles.append(obstacle_np)
-        print(f"{obstacle_count} zufällige Hindernisse erzeugt.")
-
-    def create_grid(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            x += cell_size
-
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        grid_np = self.render.attachNewNode(node)
-        grid_np.setColor(0.7, 0.7, 0.7, 1)
-        return grid_np
-
-    def setup_light(self):
-        ambient_light = AmbientLight("ambient_light")
-        ambient_light.setColor((0.5, 0.5, 0.5, 1))
-        ambient_np = self.render.attachNewNode(ambient_light)
-        self.render.setLight(ambient_np)
-
-        directional_light = DirectionalLight("directional_light")
-        directional_light.setColor((1, 1, 1, 1))
-        directional_np = self.render.attachNewNode(directional_light)
-        directional_np.setPos(10, -10, 10)
-        self.render.setLight(directional_np)
-
-    def create_vehicle(self):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Fahrmodul (Chassis): 1 x 0.5 x 1.2 (Rot)
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-
-        # Schwarze Kanten zum Fahrmodul
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # Gabelmodul (Fork): Zwei Zähne (je 0.2 x 1.2 x 0.1)
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-        self.fork_node = fork_node
-
-        # Zeichne Linie, die die äußersten Ecken des hinteren Endes der Zähne verbindet
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_corner_global = fork_node.getPos() + left_corner_local
-        right_corner_global = fork_node.getPos() + right_corner_local
-
-        ls_new = LineSegs()
-        ls_new.setThickness(2.0)
-        ls_new.setColor(1, 1, 1, 1)
-        ls_new.moveTo(left_corner_global)
-        ls_new.drawTo(right_corner_global)
-        vehicle_node.attachNewNode(ls_new.create())
-
-        # Zusätzliche Linie: von der Mitte senkrecht in Fahrtrichtung
-        midpoint = (left_corner_global + right_corner_global) * 0.5
-        white_line_vec = right_corner_global - left_corner_global
-        if white_line_vec.length() != 0:
-            white_line_dir = white_line_vec.normalized()
-        else:
-            white_line_dir = Vec3(0, 0, 0)
-        candidate = Vec3(-white_line_dir.getY(), white_line_dir.getX(), 0)
-        vehicle_pos = vehicle_node.getPos()
-        if candidate.dot(vehicle_pos - midpoint) < 0:
-            candidate = -candidate
-        if candidate.length() != 0:
-            perp_direction = candidate.normalized()
-        else:
-            perp_direction = Vec3(0, 0, 0)
-        line_length = 1.0
-        line_end = midpoint + perp_direction * line_length
-
-        ls_mid = LineSegs()
-        ls_mid.setThickness(2.0)
-        ls_mid.setColor(1, 1, 1, 1)
-        ls_mid.moveTo(midpoint)
-        ls_mid.drawTo(line_end)
-        vehicle_node.attachNewNode(ls_mid.create())
-
-        # Grüner Marker 0.5 m vom Schnittpunkt entlang der senkrechten Richtung
-        green_point_global = midpoint + perp_direction * 0.5
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.05 / 2, 0.05 / 2, 0.05 / 2))
-
-        # Restlicher Fahrzeugaufbau (Mast, Diagonalen, etc.)
-        mast_node = vehicle_node.attachNewNode("mast")
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-
-        self.add_diagonals_to_mast(mast_node)
-        intersection = Vec3(0.5, 0.05, 1.0)
-
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        lidar_center = Vec3(intersection.x, intersection.y, -1)
-        self.add_lidar_circle(mast_node, lidar_center, 2)
-
-        # Positioniere den Fahrzeugknoten so, dass dessen X- und Y-Koordinaten dem Schnittpunkt entsprechen
-        vehicle_node.setPos(intersection.x, intersection.y, 0)
-        # Anfangsrichtung: entlang der Y-Achse
-        vehicle_node.setH(0)
-
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)  # Orange
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)  # Grün
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        # Top center
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        # Top circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        # Bottom center
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        # Bottom circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        # Top fan
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        # Bottom fan
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        # Side faces
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        # Unterseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        # Oberseite
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        # Vorderseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        # Rückseite
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        # Linke Seite
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        # Rechte Seite
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        # Unterkante
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        # Oberkante
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        # Vertikale Kanten
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: Grundmodell Erweitert Split/GES3.py
===================================================================
diff --git a/Grundmodell Erweitert Split/GES3.py b/Grundmodell Erweitert Split/GES3.py
deleted file mode 100644
--- a/Grundmodell Erweitert Split/GES3.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,2052 +0,0 @@
-# Standardbibliothek
-import random
-import math
-import time
-import ctypes
-import multiprocessing
-from multiprocessing import Queue, Process
-from functools import partial
-import tkinter as tk
-from tkinter import ttk
-
-# Drittanbieter
-import matplotlib
-import matplotlib.pyplot as plt
-from PyQt5 import QtWidgets, QtCore
-import pyqtgraph as pg
-
-# Panda3D und Direct (Engine-spezifische Importe)
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.task.TaskManagerGlobal import taskMgr
-from direct.gui.DirectGui import DirectButton, DirectSlider, DirectLabel
-
-from direct.showbase.ShowBase import ShowBase
-from environment_visualization import EnvironmentVisualizer
-
-class LagerSimulation(ShowBase):
-    def __init__(self, graph_queue=None):
-        # Basisinitialisierung (ShowBase, etc.)
-        super().__init__()
-
-        # ------------------------------------------------------------------------
-        # 1. Umgebung aufbauen: Verwende den extrahierten EnvironmentVisualizer
-        # ------------------------------------------------------------------------
-        self.env_viz = EnvironmentVisualizer(self.render, self.loader)
-
-        # Rufe die Methoden des Visualizers auf, um die Umgebung zu erstellen.
-        self.env_viz.draw_origin()
-        self.env_viz.erzeuge_licht()
-        self.env_viz.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.env_viz.create_wall()
-        self.env_viz.create_annahme_stations()
-        self.env_viz.create_abgabe_stations()
-        self.env_viz.create_garagen_stations()
-
-        # Um in anderen Methoden (z. B. für Paket- oder Auftrags-Handling) auf die Stationen
-        # und deren Marker zugreifen zu können, übergeben wir die entsprechenden Listen.
-        self.annahme_stations = self.env_viz.annahme_stations
-        self.station_blue_dots = self.env_viz.station_blue_dots
-        self.abgabe_stations = self.env_viz.abgabe_stations
-        self.abgabe_blue_dots = self.env_viz.abgabe_blue_dots
-        self.garagen_stations = self.env_viz.garagen_stations
-        self.garagen_parking_points = self.env_viz.garagen_parking_points
-
-        # Setze den Pickup-Offset (dieser Vektor wird bei der Steuerung genutzt)
-        self.pickup_offset = Vec3(0.5, -0.5, 0)
-
-        # Falls du weitere Referenzen (wie self.blue_dot, self.station_green_dot) brauchst, ebenfalls setzen.
-        if hasattr(self.env_viz, 'blue_dot'):
-            self.blue_dot = self.env_viz.blue_dot
-        if hasattr(self.env_viz, 'station_green_dot'):
-            self.station_green_dot = self.env_viz.station_green_dot
-
-        # ------------------------------------------------------------------------
-        # 2. Restliche Initialisierung (Simulationsvariablen, UI, Tasks, etc.)
-        # (Der restliche Code bleibt weitgehend unverändert.)
-        # ------------------------------------------------------------------------
-
-        self.paused = False
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5
-
-        # Weitere Attribute, z. B. für KPIs, Paket- und Auftragsverwaltung usw.
-        self.delivered_packages = 0
-        self.pickup_packages = {}
-        self.last_removed = {}
-        self.orders = {}
-        self.orders_queue = []
-        self.next_order_id = 1
-        # (Weitere Initialisierungen kommen hier…)
-        self.cargos = {}
-        # Falls du auch weitere Attribute benötigst, wie beispielsweise eine Liste der belegten Pickup-Stations:
-        self.occupied_pickups = set()
-
-        self.max_overall_wait_time = 0.0  # Maximale Wartezeit der Pakete
-        self.total_dwell_time = 0.0  # Summe aller Liegedauern abgeholter Pakete
-        self.picked_up_count = 0  # Anzahl abgeholter Pakete
-        self.total_delivery_time = 0.0  # Summe aller Lieferzeiten
-        self.total_delivery_count = 0  # Anzahl der Lieferungen
-        self.max_overall_delivery_time = 0.0
-
-        self.graph_queue = None
-        self.graph_data = []
-        self.graph_process = None
-
-        # Beispiel: Initialisierung des Tkinter-Fensters
-        self.tk_root = tk.Tk()
-        self.tk_root.withdraw()
-
-        # Weiterer Code: Kamera, Lichter (falls weiterhin benötigt – ansonsten übernehmen wir vollständig den Visualizer)
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # UI-bezogene Attribute initialisieren:
-        self.order_win = None
-        self.order_tree = None
-        self.graph_queue = None
-        self.graph_data = []
-
-        # TensorFlow-Modell und RL-Agent initialisieren (wie gehabt)
-        try:
-            import tensorflow as tf
-            self.tf_model = tf.keras.models.load_model("mein_model.keras")
-            print("TensorFlow Modell erfolgreich geladen.")
-        except Exception as e:
-            print(f"Fehler beim Laden des TensorFlow Modells: {e}")
-            self.tf_model = None
-
-        state_bins = ((10, 10), (10, 10))
-        action_space = [0, 1, 2]
-        self.rl_agent = RLAgent(state_bins, action_space, learning_rate=0.1, discount_factor=0.9, epsilon=0.2)
-        self.training_data = []  # Trainingsdatenliste
-
-        # Spawn-Einstellungen (Standardwerte)
-        self.package_spawn_delay = 5.0
-        self.package_spawn_distribution = "uniform"
-        # Hier speichern wir die Variablen für die Stationen als Dictionary (Index -> BooleanVar)
-        self.spawn_station_vars = {}
-        # Falls du beispielsweise 10 Annahmestationen hast:
-        for i in range(10):
-            self.spawn_station_vars[i] = tk.BooleanVar(value=False)
-
-        # Fahrzeuge in den Garagen instanziieren:
-        self.create_garage_vehicles()
-        # --- UI-Elemente für Simulationssteuerung ---
-        # Slider für Simulationsgeschwindigkeit
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        self.paused = False
-        # Pause-Knopf neben dem Slider platzieren – z.B. rechts davon.
-        self.pause_button = DirectButton(
-            text="Pause",
-            command=self.toggle_pause,
-            pos=(-0.5, 0, -0.85),  # Leicht links vom Slider
-            scale=0.07
-        )
-
-        # --- Tastenzuordnungen ---
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-        # Taste "c" öffnet das Fahrzeug-Kontrollfenster
-        self.accept("c", self.show_vehicle_control)
-
-        # --- Tasks (TaskMgr) hinzufügen ---
-        self.taskMgr.add(self._tk_update, "tkUpdateTask")
-        self.taskMgr.add(self.update_delivery_timers, "UpdateDeliveryTimersTask")
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClock")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_graph_data, "UpdateGraphDataTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-    # ---------------1. Initialisierung & Simulationssteuerung---------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        self.sim_clock += dt
-        return Task.cont
-
-    def toggle_pause(self):
-        if not self.paused:
-            # Speichern des aktuellen speed_factor, damit wir ihn beim Resume wiederherstellen können
-            self.previous_speed_factor = self.speed_factor
-            self.speed_factor = 0  # Simulation einfrieren: alle dt-basierte Updates ergeben 0
-            self.pause_button['text'] = "Weiter"
-            self.paused = True
-            print("Gesamte Simulation angehalten")
-        else:
-            # Wiederaufnahme der Simulation: speed_factor auf den vorherigen Wert zurücksetzen
-            self.speed_factor = self.previous_speed_factor if hasattr(self, 'previous_speed_factor') else 1.0
-            self.pause_button['text'] = "Pause"
-            self.paused = False
-            print("Simulation läuft wieder")
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        # dt jetzt skaliert mit der Simulationsgeschwindigkeit
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-    # ---------------2. Graphik & UI (GUI-/Tk-/Matplotlib-Funktionen)---------------
-    def open_graph(self):
-        # Starte den Graphprozess per Taste G (nur, wenn er noch nicht läuft)
-        if self.graph_process is None or not self.graph_process.is_alive():
-            from multiprocessing import Queue, Process
-            self.graph_queue = Queue()
-
-            # Sende alle bisher gesammelten Daten in die Queue:
-            for data in self.graph_data:
-                try:
-                    self.graph_queue.put(data, block=False)
-                except Exception:
-                    pass
-
-            from graph_pyqt import graph_process_pyqt
-            self.graph_process = Process(target=graph_process_pyqt, args=(self.graph_queue,))
-            self.graph_process.start()
-            print("Graphprozess gestartet.")
-        else:
-            print("Graphprozess läuft bereits.")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2, self.ax3) = plt.subplots(3, 1, figsize=(8, 9))
-
-        # Erster Plot: Pakete pro Minute
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-
-        # Zweiter Plot: Durchschnittliche Liegedauer
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-
-        # Dritter Plot: Durchschnittliche Lieferzeit
-        self.line3, = self.ax3.plot([], [], marker="o", color="green", label="Durchschnittliche Lieferzeit (s)")
-        self.ax3.set_xlabel("Simulationszeit (s)")
-        self.ax3.set_ylabel("Lieferzeit (s)")
-        self.ax3.set_title("Durchschnittliche Lieferzeit")
-        self.ax3.legend()
-        self.ax3.grid(True)
-
-        plt.show(block=False)
-        # Starte im Tkinter-Hauptloop eine periodische Aktualisierung:
-        self.tk_root.after(500, self.tk_graph_update)  # alle 500ms
-
-    def tk_graph_update(self):
-        # GIL sichern: Gibt einen Statuswert zurück, der später wieder freigegeben wird.
-        gil_state = ctypes.pythonapi.PyGILState_Ensure()
-        try:
-            times = [data[0] for data in self.graph_data]
-            rates = [data[1] for data in self.graph_data]
-            dwell = [data[2] for data in self.graph_data]
-            delivery = [data[3] for data in self.graph_data]
-
-            self.line1.set_data(times, rates)
-            self.ax1.relim()
-            self.ax1.autoscale_view()
-
-            self.line2.set_data(times, dwell)
-            self.ax2.relim()
-            self.ax2.autoscale_view()
-
-            self.line3.set_data(times, delivery)
-            self.ax3.relim()
-            self.ax3.autoscale_view()
-
-            self.fig.canvas.draw_idle()
-            self.fig.canvas.flush_events()
-        finally:
-            ctypes.pythonapi.PyGILState_Release(gil_state)
-
-        # Nächsten Aufruf in 500ms einplanen
-        self.tk_root.after(500, self.tk_graph_update)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-
-        # Bestimme die maximale Liegedauer aktueller Pakete an den Annahmestationen
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-
-        # Lieferzeit-Kennzahlen ermitteln: für Fahrzeuge, die aktuell ein Paket tragen
-        current_delivery_time = 0.0
-        for veh in self.garage_vehicles:
-            if veh.getPythonTag("package_attached"):
-                ds = veh.getPythonTag("delivery_start_time")
-                if ds:
-                    elapsed_delivery = self.sim_clock - ds
-                    current_delivery_time = max(current_delivery_time, elapsed_delivery)
-        avg_delivery_time = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        # Aktualisiere den Info-Label-Text
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s\n"
-            f"Lieferzeit (aktuell): {current_delivery_time:.1f}s\n"
-            f"Lieferzeit (maximal): {self.max_overall_delivery_time:.1f}s\n"
-            f"Durchschn. Lieferzeit: {avg_delivery_time:.1f}s"
-        )
-        return Task.cont
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def update_graph_data(self, task):
-        if self.sim_clock > 0:
-            ppm = self.delivered_packages / (self.sim_clock / 60)
-        else:
-            ppm = 0.0
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        avg_delivery = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        new_data = (self.sim_clock, ppm, avg_dwell, avg_delivery)
-        # Speichere alle Daten ab Simulationsbeginn:
-        self.graph_data.append(new_data)
-
-        # Zusätzlich: Falls der Graphprozess aktiv ist, schicke den neuen Datensatz auch an die Queue
-        if self.graph_queue is not None:
-            try:
-                self.graph_queue.put(new_data, block=False)
-            except Exception:
-                pass
-        return Task.cont
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Hier werden nur die gewünschten Spalten "ID", "Annahmestation", "Ziel" und "Fahrzeug" definiert.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    #-------Fahrzeugsteuerung(Bedienfenster)-------
-    def update_vehicle_control(self):
-        for veh, var in self.vehicle_state_vars.items():
-            new_state = var.get()
-            if new_state == "idle" and veh.getPythonTag("current_order") is not None:
-                veh.setPythonTag("standby_pending", True)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Standby angefordert (Auftrag wird fortgesetzt).")
-            else:
-                veh.setPythonTag("standby_pending", False)
-                veh.setPythonTag("order_state", new_state)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Zustand auf {new_state} gesetzt.")
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-    def update_cable(self, task):
-        # Verwende die simulative Zeit, die bereits in update_sim_clock hochgezählt wird
-        t = self.sim_clock
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    def create_garage_vehicles(self):
-        self.garage_vehicles = []
-        vehicle_id_counter = 1
-        for park in self.garagen_parking_points:
-            veh = self.create_vehicle(park_point=park)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            newPos.setZ(0)
-            veh.setPos(newPos)
-
-            # Fahrzeuge starten im Standby (idle)
-            veh.setPythonTag("current_order", None)
-            veh.setPythonTag("order_state", "idle")
-            veh.setPythonTag("package_attached", False)
-            veh.setPythonTag("vehicle_id", vehicle_id_counter)
-            # Speichere den Parkpunkt als Rückkehrziel
-            veh.setPythonTag("garage_target", park)
-            # Speichere auch das Anfangs-Heading, um es später beim Parken wiederherzustellen.
-            veh.setPythonTag("start_heading", veh.getH())
-            vehicle_id_counter += 1
-
-            self.garage_vehicles.append(veh)
-
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-            # Füge einen Textknoten hinzu, der die Fahrzeugnummer vorne auf dem Fahrzeug anzeigt.
-            # Wir suchen den Mast-Knoten.
-            mast = veh.find("**/mast")
-            if not mast.isEmpty():
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)  # Schwarz
-                tn.setAlign(TextNode.ACenter)
-                text_np = mast.attachNewNode(tn)
-                # Positioniere den Text relativ zum Mast: Wir nutzen den Vektor "intersection"
-                # und versetzen ihn in Z-Richtung um 0.2 Einheiten oberhalb des Zylinders.
-                text_np.setPos(intersection.x, intersection.y, intersection.z + 0.2)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-            else:
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)
-                tn.setAlign(TextNode.ACenter)
-                text_np = veh.attachNewNode(tn)
-                text_np.setPos(0, 1.2, 1.5)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-
-            self.taskMgr.add(partial(self.vehicle_order_task, veh),
-                             f"VehicleOrderTask_{veh.getPythonTag('vehicle_id')}")
-
-    # --------------- Erstellung des Fahrzeugs---------------
-    def create_vehicle(self, park_point=None):
-        # Erzeuge den übergeordneten Fahrzeug-Knoten
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # --------------------------
-        # Chassis erstellen (1 x 0.5 x 1.2, Farbe Rot)
-        # --------------------------
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # --------------------------
-        # Gabel (Fork) erstellen: Zwei Zähne
-        # --------------------------
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        vehicle_node.setPythonTag("fork_node", fork_node)
-
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-
-        # --------------------------
-        # Statt weißer Kante von der Gabel: bereits eingezeichnete grüne Mittellinie verwenden.
-        # In diesem Beispiel nehmen wir an, dass du schon eine „mittlere“ Linie gezeichnet hast.
-        # Zeichne die grüne Mittellinie, z. B. von einem Punkt an der Gabel (als Ausgangspunkt)
-        # bis zu einem Referenzpunkt – hier nutzen wir einen zuvor festgelegten Offset.
-        #
-        # Wir definieren:
-        #   - Den Ausgangspunkt als den grün markierten Punkt, der den mittleren Punkt der Gabel repräsentieren soll.
-        #   - Den Zielpunkt als den Referenzpunkt, der als Idealwert in create_vehicle bestimmt wurde.
-        # In unserem Beispiel berechnen wir den Zielpunkt einmalig aus den lokalen Offsets an der weißen Kante.
-        # (Diese Werte kannst du bei Bedarf anpassen.)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_global = fork_node.getPos(self.render) + left_corner_local
-        right_global = fork_node.getPos(self.render) + right_corner_local
-        # Berechne den idealen (statischen) Mittelpunkt als Referenz – dieser wird nur einmal gesetzt.
-        midpoint_white = (left_global + right_global) * 0.5
-        # Nun lege den grünen Marker so, dass er exakt in der Mitte der Gabel liegt.
-        # Hier entspricht der grüne Punkt der Mittellinie der Gabel.
-        green_point_global = midpoint_white  # Hier wird angenommen, dass der ideale Mittelpunkt gleich dem Referenzpunkt ist.
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        vehicle_node.setPythonTag("fork_green", green_marker_np)
-
-        # Zeichne die grüne Mittellinie.
-        # Als Beispiel: Zeichne eine Linie vom grünen Marker in Richtung +Y (relativ zum Fahrzeug),
-        # weil du den idealen Zustand so festgelegt hast, dass genau diese Linie mit der Station übereinstimmen soll.
-        ls_mid = LineSegs()
-        ls_mid.setThickness(2.0)
-        ls_mid.setColor(0, 1, 0, 1)  # grün
-        # Starte die Linie am grünen Marker.
-        ls_mid.moveTo(green_point_global)
-        # Zeichne beispielsweise eine Linie 1 Einheit lang in +Y-Richtung:
-        ls_mid.drawTo(green_point_global + Vec3(0, 1, 0))
-        fork_center_line = vehicle_node.attachNewNode(ls_mid.create())
-        # Speichere den NodePath der grünen Mittellinie
-        vehicle_node.setPythonTag("fork_center_line", fork_center_line)
-        print("[DEBUG] create_vehicle: Grüne Mittellinie (fork_center_line) gesetzt.")
-
-        # --------------------------
-        # Restliche Fahrzeugteile (Mast, Lenkachse, etc.)
-        # --------------------------
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-        self.add_diagonals_to_mast(mast_node)
-
-        intersection = Vec3(0.5, 0.05, 1.0)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        # --------------------------
-        # Lenkachse erzeugen (Pivot-Node)
-        # --------------------------
-        steering_axis = mast_node.attachNewNode("steering_axis")
-        steering_axis.setPos(0.5, 0.25, -1.2)
-        steering_axis.setH(90)
-        vehicle_node.setPythonTag("steering_axis", steering_axis)
-
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(steering_axis)
-        cylinder_node.setPos(0, 0, 0)
-        self.vehicle_cylinder = steering_axis
-        self.add_steering_arrow(steering_axis, color=(0, 1, 0, 1))
-
-        # --------------------------
-        # Positioniere das Fahrzeug am Parkpunkt
-        # --------------------------
-        if park_point is None:
-            vehicle_node.setPos(0, 0, 0)
-        else:
-            intersection = Vec3(0, 0, 1.0)
-            vehicle_node.setPos(park_point - vehicle_node.getQuat().xform(intersection))
-
-        # ********** Ursprung (Koordinatensystem) am Fahrzeug einzeichnen **********
-        ls_x = LineSegs()
-        ls_x.setThickness(2)
-        ls_x.setColor(LColor(1, 0, 0, 1))
-        ls_x.moveTo(0, 0, 0)
-        ls_x.drawTo(1, 0, 0)
-        vehicle_node.attachNewNode(ls_x.create())
-
-        ls_y = LineSegs()
-        ls_y.setThickness(2)
-        ls_y.setColor(LColor(0, 1, 0, 1))
-        ls_y.moveTo(0, 0, 0)
-        ls_y.drawTo(0, 1, 0)
-        vehicle_node.attachNewNode(ls_y.create())
-
-        ls_z = LineSegs()
-        ls_z.setThickness(2)
-        ls_z.setColor(LColor(0, 0, 1, 1))
-        ls_z.moveTo(0, 0, 0)
-        ls_z.drawTo(0, 0, 1)
-        vehicle_node.attachNewNode(ls_z.create())
-
-        from panda3d.core import TextNode
-        tn_x = TextNode("label_x")
-        tn_x.setText("X")
-        tn_x.setTextColor(1, 0, 0, 1)
-        label_x = vehicle_node.attachNewNode(tn_x)
-        label_x.setScale(0.3)
-        label_x.setPos(2.0, 0, 0)
-
-        tn_y = TextNode("label_y")
-        tn_y.setText("Y")
-        tn_y.setTextColor(0, 1, 0, 1)
-        label_y = vehicle_node.attachNewNode(tn_y)
-        label_y.setScale(0.3)
-        label_y.setPos(0, 2.0, 0)
-
-        tn_z = TextNode("label_z")
-        tn_z.setText("Z")
-        tn_z.setTextColor(0, 0, 1, 1)
-        label_z = vehicle_node.attachNewNode(tn_z)
-        label_z.setScale(0.3)
-        label_z.setPos(0, 0, 2.0)
-
-        return vehicle_node
-
-    def add_steering_arrow(self, steering_axis, color=(0, 1, 0, 1)):
-        """
-        Erzeugt einen Pfeil, der die Vorwärtsrichtung (lokale X-Achse) des Lenkpivots anzeigt.
-        Der Pfeil wird als Kind des übergebenen steering_axis-Node angehängt und passt sich
-        automatisch dessen Rotation an.
-        """
-        arrow_ls = LineSegs()
-        arrow_ls.setThickness(2.0)
-        arrow_ls.setColor(*color)
-
-        # Zeichne eine Linie von (0,0,0) bis (2,0,0) – das ist die Basis des Pfeils
-        arrow_ls.moveTo(0, 0, 0)
-        arrow_ls.drawTo(2, 0, 0)
-
-        # Zeichne den Pfeilkopf: zwei kurze schräge Linien am Ende der Pfeillinie
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, 0.3, 0)
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, -0.3, 0)
-
-        arrow_np = steering_axis.attachNewNode(arrow_ls.create())
-        arrow_np.setPos(0, 0, 0)  # Falls nötig, hier noch zusätzlichen Offset anpassen
-        return arrow_np
-
-    def rotate_around_pivot(self, vehicle, pivot, delta_angle):
-        """
-        Dreht das Fahrzeug (vehicle) um den gegebenen Pivotpunkt (pivot) um delta_angle (in Grad).
-        Dabei wird die Position des Fahrzeugs neu berechnet, sodass es um den Pivot rotiert.
-        """
-        # Aktuelle globale Fahrzeugposition
-        pos = vehicle.getPos(self.render)
-        # Globaler Pivotpunkt
-        pivot_pos = pivot.getPos(self.render)
-        # Berechne den Vektor vom Pivot zum Fahrzeug
-        rel = pos - pivot_pos
-        # Wandle den Drehwinkel in Bogenmaß um
-        rad = math.radians(delta_angle)
-        cos_val = math.cos(rad)
-        sin_val = math.sin(rad)
-        # Drehe den relativen Vektor
-        new_x = rel.getX() * cos_val - rel.getY() * sin_val
-        new_y = rel.getX() * sin_val + rel.getY() * cos_val
-        new_rel = Vec3(new_x, new_y, rel.getZ())
-        # Neue globale Fahrzeugposition
-        new_pos = pivot_pos + new_rel
-        vehicle.setPos(new_pos)
-        # Aktualisiere auch das Heading des Fahrzeugs (aufaddieren des Drehwinkels)
-        vehicle.setH(vehicle.getH() + delta_angle)
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    # ---------------6. Paket- & Auftragsverwaltung---------------
-        # Beispiel einer Methode, die weiterhin auf die extrahierten Umgebungselemente zugreift:
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Je nach gewählter Verteilung kannst du hier Anpassungen vornehmen.
-        # Für den Moment wählen wir einfach zufällig aus allen Abgabestationen,
-        # falls keine spezielle Logik für die Verteilung implementiert ist.
-        target_index = random.randint(1, len(self.abgabe_stations))
-
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def check_and_spawn_packages(self, task):
-        # Verwende den neuen Delay-Wert aus den Einstellungen
-        spawn_delay = self.package_spawn_delay
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-        # Beispiel für eine vorhandene Methode, die auf die Umgebungselemente zugreift:
-    def update_order_table(self):
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen die Stationsnummer (oder verwende "N/A").
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z.B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige den zugewiesenen Fahrzeugnamen an (oder "-" falls noch keiner zugeordnet wurde).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END,
-                                   values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if hasattr(self, 'order_win') and self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    # ---------------7. Cargo-Handling (Pickup, Drop & Timer)---------------
-    def pickup_package(self, vehicle, station):
-        # Falls das Fahrzeug bereits ein Paket trägt, abbrechen.
-        if vehicle.getPythonTag("package_attached"):
-            return
-
-        # Führe den Pickup nur aus, wenn an der Station ein Paket vorhanden ist.
-        if station in self.pickup_packages:
-            # Hole das Paket, den Spawn-Zeitpunkt und den zugehörigen Timer-Knoten.
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            # Entferne den Timer-Knoten, sodass der angezeigte Zähler nicht weiter aktualisiert wird.
-            timer_np.removeNode()
-            # Berechne die Liegedauer (Differenz zwischen aktueller Simulationszeit und Spawn-Zeit).
-            dwell_time = self.sim_clock - spawn_time
-            # Aktualisiere globale Kennzahlen.
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Suche in den Aufträgen nach dem Auftrag, dessen Paket mit diesem Paket übereinstimmt,
-            # und speichere den errechneten Endwert (fixe Liegedauer) sowie den Status.
-            for order_id, order in self.orders.items():
-                if order.get("package") == package:
-                    order["dwell_time"] = dwell_time
-                    order["status"] = "Abgeholt"
-                    break
-
-            # Hole Referenzen zum Gabel-Knoten und zum grünen Marker des Fahrzeugs.
-            fork_node = vehicle.getPythonTag("fork_node")
-            fork_green = vehicle.getPythonTag("fork_green")
-            green_point_pos = fork_green.getPos(fork_node)
-
-            # Übergib das Paket an den Gabel-Knoten (sodass es optisch dem Fahrzeug zugeordnet wird)
-            # und positioniere es relativ zum grünen Marker.
-            package.wrtReparentTo(fork_node)
-            package.setPos(green_point_pos.getX() + 0.5,
-                           green_point_pos.getY() - 0.5,
-                           green_point_pos.getZ() + 1)
-            self.cargos[vehicle] = package
-
-            # Starte den Lieferzeit-Timer: Speichere den Zeitpunkt, an dem das Paket abgeholt wurde,
-            # und hänge einen neuen Timer-Knoten an das Paket.
-            vehicle.setPythonTag("delivery_start_time", self.sim_clock)
-            from panda3d.core import TextNode
-            delivery_timer_text = TextNode("delivery_timer")
-            delivery_timer_text.setText("0.0s")
-            delivery_timer_np = package.attachNewNode(delivery_timer_text)
-            delivery_timer_np.setScale(0.5)
-            delivery_timer_np.setPos(0, 0, 1.2)
-            package.setPythonTag("delivery_timer", delivery_timer_np)
-
-            # Aktualisiere den Zeitpunkt, zu dem an dieser Station zuletzt ein Paket entfernt wurde.
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-
-            # Berechne Lieferzeit:
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start is not None:
-                delivery_time = self.sim_clock - delivery_start
-                self.total_delivery_time += delivery_time
-                self.total_delivery_count += 1
-                self.max_overall_delivery_time = max(self.max_overall_delivery_time, delivery_time)
-                vehicle.clearPythonTag("delivery_start_time")
-
-            # Entferne den Lieferzeit-Timer vom Paket
-            delivery_timer_np = cargo.getPythonTag("delivery_timer")
-            if delivery_timer_np:
-                delivery_timer_np.removeNode()
-
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden das Paket entfernt
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def update_delivery_timers(self, task):
-        for vehicle, package in list(self.cargos.items()):
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start:
-                elapsed_delivery = self.sim_clock - delivery_start
-                delivery_timer_np = package.getPythonTag("delivery_timer")
-                if delivery_timer_np and not delivery_timer_np.isEmpty():
-                    delivery_timer_np.node().setText(f"{elapsed_delivery:.1f}s")
-        return Task.cont
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-
-    # ---------------8. Auftrags-/Fahrzeuglogik---------------
-    def select_next_order(self, vehicle):
-        # Sammle alle Aufträge, die noch "Wartend" sind
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        # Aktualisiere die Dwell-Zeit für jeden Auftrag
-        for order in waiting_orders:
-            order["dwell_time"] = self.sim_clock - order.get("spawn_time", self.sim_clock)
-
-        # Wähle den Auftrag mit der maximalen Dwell-Zeit (evtl. mit etwas Toleranz)
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        # Finde aus den Kandidaten den Auftrag, dessen Pickup-Station (order["pickup_station"])
-        # am nächsten zur aktuellen Fahrzeugposition liegt.
-        vehicle_pos = vehicle.getPos(self.render)
-        candidates.sort(key=lambda order: (order["pickup_station"].getPos(self.render) - vehicle_pos).length())
-        return candidates[0]
-
-    def show_vehicle_control(self):
-        # Falls das Fenster bereits existiert, wiederverwenden
-        if hasattr(self, "control_win") and self.control_win.winfo_exists():
-            self.control_win.deiconify()
-            self.control_win.lift()
-            self.control_win.focus_force()
-            return
-
-        self.control_win = tk.Toplevel(self.tk_root)
-        self.control_win.title("Kontrollfenster")
-        self.control_win.protocol("WM_DELETE_WINDOW", self.control_win.withdraw)
-        self.control_win.attributes("-topmost", True)
-        self.control_win.after(100, lambda: self.control_win.attributes("-topmost", False))
-
-        # Fahrzeugsteuerung: Widgets für jedes Fahrzeug erstellen
-        self.vehicle_state_vars = {}
-        row = 0
-        for veh in self.garage_vehicles:
-            frame = tk.Frame(self.control_win)
-            frame.grid(row=row, column=0, sticky="w", padx=5, pady=2)
-            vid = veh.getPythonTag("vehicle_id")
-            label = tk.Label(frame, text=f"Fahrzeug {vid}")
-            label.pack(side=tk.LEFT)
-            state = veh.getPythonTag("order_state") or "idle"
-            var = tk.StringVar(value=state)
-            self.vehicle_state_vars[veh] = var
-            rb_active = tk.Radiobutton(frame, text="Aufträge bearbeiten", variable=var, value="translate")
-            rb_active.pack(side=tk.LEFT)
-            rb_standby = tk.Radiobutton(frame, text="Standby", variable=var, value="idle")
-            rb_standby.pack(side=tk.LEFT)
-            row += 1
-
-        update_btn = tk.Button(self.control_win, text="Übernehmen", command=self.update_vehicle_control)
-        update_btn.grid(row=row, column=0, pady=5)
-        row += 1
-
-        # Spawn-Einstellungen im gleichen Fenster (ohne Dropdown zur Verteilungswahl)
-        spawn_frame = tk.LabelFrame(self.control_win, text="Spawn Einstellungen", padx=5, pady=5)
-        spawn_frame.grid(row=row, column=0, sticky="w", padx=5, pady=5)
-
-        # Eingabe der Spawnverzögerung
-        tk.Label(spawn_frame, text="Spawnverzögerung (Sekunden):").grid(row=0, column=0, sticky="w")
-        self.spawn_delay_var = tk.DoubleVar(value=self.package_spawn_delay)
-        delay_entry = tk.Entry(spawn_frame, textvariable=self.spawn_delay_var, width=6)
-        delay_entry.grid(row=0, column=1, sticky="w")
-
-        # Auswahl der Annahmestationen (anstatt eines Dropdowns zur Verteilungswahl)
-        tk.Label(spawn_frame, text="Annahmestationen:").grid(row=1, column=0, sticky="w", pady=(5, 0))
-        stations_frame = tk.Frame(spawn_frame)
-        stations_frame.grid(row=2, column=0, columnspan=2, sticky="w")
-        for i in range(min(10, len(self.annahme_stations))):
-            cb = tk.Checkbutton(stations_frame, text=f"Annahmestation {i + 1}",
-                                variable=self.spawn_station_vars[i])
-            cb.pack(anchor="w")
-
-        def apply_spawn_from_control():
-            self.package_spawn_delay = self.spawn_delay_var.get()
-            selected = []
-            for i, var in self.spawn_station_vars.items():
-                if var.get():
-                    selected.append(self.annahme_stations[i])
-            self.package_spawn_stations = selected
-            print(
-                f"Spawn Einstellungen übernommen: Delay={self.package_spawn_delay}s, "
-                f"Stations: {[i + 1 for i, var in self.spawn_station_vars.items() if var.get()]}"
-            )
-            # Spawne nur an Stationen, an denen noch kein Paket existiert:
-            for station in self.package_spawn_stations:
-                if station not in self.pickup_packages:
-                    self.spawn_package_at_station(station)
-
-        apply_btn = tk.Button(
-            spawn_frame,
-            text="Einstellungen übernehmen und spawnen",
-            command=apply_spawn_from_control
-        )
-        apply_btn.grid(row=3, column=0, columnspan=2, pady=5)
-
-    def show_spawn_control(self):
-        spawn_win = tk.Toplevel(self.tk_root)
-        spawn_win.title("Paketspawn Einstellungen")
-
-        # Eingabefeld für Spawnverzögerung
-        tk.Label(spawn_win, text="Spawnverzögerung (Sekunden):").pack(pady=2)
-        delay_entry = tk.Entry(spawn_win)
-        delay_entry.insert(0, str(self.package_spawn_delay))
-        delay_entry.pack(pady=2)
-
-        # (Dropdown für Spawn-Verteilung wurde entfernt)
-
-        # Checkbuttons für die Auswahl der Annahmestationen
-        tk.Label(spawn_win, text="Annahmestationen auswählen (1-10):").pack(pady=2)
-        stations_frame = tk.Frame(spawn_win)
-        stations_frame.pack(pady=2)
-
-        station_vars = {}
-        for idx, station in enumerate(self.annahme_stations):
-            var = tk.BooleanVar(value=False)
-            station_label = f"Annahmestation {idx + 1}"
-            cb = tk.Checkbutton(stations_frame, text=station_label, variable=var)
-            cb.pack(anchor="w")
-            station_vars[idx] = var
-
-        def apply_spawn_settings():
-            try:
-                new_delay = float(delay_entry.get())
-            except ValueError:
-                new_delay = self.package_spawn_delay
-            new_stations = []
-            for idx, var in station_vars.items():
-                if var.get():
-                    new_stations.append(self.annahme_stations[idx])
-
-            self.package_spawn_delay = new_delay
-            self.package_spawn_stations = new_stations
-
-            print(f"Spawn-Einstellungen aktualisiert: Delay={new_delay}s, "
-                  f"Stationen: {[f'Annahmestation {idx + 1}' for idx, var in station_vars.items() if var.get()]}")
-            # Spawne nur dort Pakete, wo noch kein Paket vorhanden ist:
-            for station in self.package_spawn_stations:
-                if station not in self.pickup_packages:
-                    self.spawn_package_at_station(station)
-
-            spawn_win.destroy()
-
-        tk.Button(spawn_win, text="Einstellungen speichern", command=apply_spawn_settings).pack(pady=5)
-
-    def vehicle_order_task(self, vehicle, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-
-        # Frame-Zähler einbauen, um die Frequenz der Modellinferenz zu reduzieren
-        frame_count = vehicle.getPythonTag("frame_count")
-        if frame_count is None:
-            frame_count = 0
-        frame_count += 1
-        vehicle.setPythonTag("frame_count", frame_count)
-
-        # Sensordatenerfassung
-        sensor_data = self.collect_sensor_data(vehicle)
-        import numpy as np
-        # Führe die Modellinferenz nur alle 10 Frames durch, um den Hauptthread zu entlasten
-        if self.tf_model is not None and (frame_count % 10 == 0):
-            input_data = sensor_data.reshape(1, sensor_data.shape[0], sensor_data.shape[1], 1)
-            prediction = self.tf_model.predict(input_data)
-            model_delta_angle = prediction[0][0]
-            print(f"[TF] Modell-Korrektur: {model_delta_angle:.2f}°")
-        else:
-            model_delta_angle = 0.0
-            if self.tf_model is not None:
-                print(f"[TF] Modell-Korrektur übersprungen (Frame Count: {frame_count})")
-            else:
-                print("[TF] Kein Modell vorhanden, Modell-Korrektur wird übersprungen.")
-
-        # Berechne den idealen Korrekturwert (unverändert)
-        ideal_correction = self.compute_ideal_steering_correction(vehicle)
-        print(f"[IDEAL] Ideal berechneter Korrekturwinkel: {ideal_correction:.2f}°")
-
-        # Logge Trainingsdaten nur in der 'translate'-Phase
-        state = vehicle.getPythonTag("order_state")
-        if state == "translate":
-            self.log_training_sample(sensor_data, ideal_correction)
-
-        # Führe die zustandsabhängige Logik aus
-        if state == "translate":
-            self.handle_translate_phase(vehicle, dt)
-        elif state == "rotate":
-            self.handle_rotate_phase(vehicle, dt)
-        elif state == "approach":
-            self.handle_approach_phase(vehicle, dt)
-        elif state == "pickup":
-            self.handle_pickup_phase(vehicle, dt)
-        elif state == "drive_out":
-            self.handle_drive_out_phase(vehicle, dt)
-        elif state == "to_delivery":
-            self.handle_to_delivery_phase(vehicle, dt)
-        elif state == "align_delivery":
-            self.handle_align_delivery_phase(vehicle, dt)
-        elif state == "delivery_center":
-            self.handle_delivery_center_phase(vehicle, dt)
-        elif state == "drop":
-            self.handle_drop_phase(vehicle, dt)
-        elif state == "phase11":
-            self.handle_phase11(vehicle, dt)
-        elif state == "return_to_garage":
-            self.handle_return_to_garage_phase(vehicle, dt)
-        else:
-            print(f"Unbekannter Zustand: {state}")
-
-        return Task.cont
-
-    # -------------------- Handler für einzelne Phasen --------------------
-
-    def handle_translate_phase(self, vehicle, dt):
-        # --- Zusätzlicher Safety-Zweig in der Translate-Phase ---
-        # (1) Zuerst: Falls ein Fahrzeug auf das Ziel (Pickup-Station) wartet, soll gewartet werden.
-        current_order = vehicle.getPythonTag("current_order")
-        station_occupied = False
-        if current_order is not None and "pickup_station" in current_order:
-            pickup_station = current_order["pickup_station"]
-            if self.is_station_occupied(pickup_station, exclude_vehicle=vehicle):
-                station_occupied = True
-                print(
-                    f"[WARTEN] Station {pickup_station.getName()} belegt. Fahrzeug {vehicle.getPythonTag('vehicle_id')} wartet.")
-
-        # (2) Festlegen der Basisgeschwindigkeit:
-        base_speed = 1.5 if not station_occupied else 0.0
-
-        # (3) Kollisionsvermeidung: Passe die Geschwindigkeit an, wenn andere Fahrzeuge in der Nähe sind.
-        adjusted_speed = self.collision_avoidance_adjustment(vehicle, base_speed)
-
-        # --- Rest der originalen Translate-Logik ---
-        # Falls kein Auftrag zugeordnet, versuche einen neuen Auftrag zu wählen.
-        if current_order is None:
-            next_order = self.select_next_order(vehicle)
-            if next_order is not None:
-                next_order["status"] = "In Bearbeitung"
-                next_order["vehicle"] = f"Fahrzeug {vehicle.getPythonTag('vehicle_id')}"
-                vehicle.setPythonTag("current_order", next_order)
-                print(f"Auftrag {next_order['id']} wird zugewiesen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}.")
-            current_order = vehicle.getPythonTag("current_order")
-
-        # Bestimme das Ziel: Zum Beispiel den blauen Marker der Pickup-Station.
-        if current_order is not None:
-            pickup_station = current_order.get("pickup_station")
-            if pickup_station in self.station_blue_dots:
-                target = self.station_blue_dots[pickup_station].getPos(self.render)
-            else:
-                target = self.blue_dot.getPos(self.render)
-        else:
-            target = self.blue_dot.getPos(self.render)
-
-        current_pos = vehicle.getPos(self.render)
-        pivot = vehicle.getPythonTag("steering_axis")
-
-        # Berechne den Offset-Punkt, von dem aus das Fahrzeug navigiert.
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        import math
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-        heading_error = desired_heading_rad - current_heading_rad
-        while heading_error > math.pi:
-            heading_error -= 2 * math.pi
-        while heading_error < -math.pi:
-            heading_error += 2 * math.pi
-
-        # Berechne den Drehwinkel (gilt für die Korrektur) – normale Drehung.
-        gain = 1.0
-        max_delta = gain * dt
-        delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-        self.rotate_around_pivot(vehicle, pivot, math.degrees(delta_heading_rad))
-
-        # Jetzt Vorwärtsbewegung: Verwende dafür die angepasste Geschwindigkeit.
-        global_hpr = pivot.getNetTransform().getHpr()
-        new_heading_rad = math.radians(global_hpr.getX())
-        new_x = current_pos.getX() + adjusted_speed * math.cos(new_heading_rad) * dt
-        new_y = current_pos.getY() + adjusted_speed * math.sin(new_heading_rad) * dt
-        new_pos = Vec3(new_x, new_y, 0)
-        vehicle.setPos(new_pos)
-
-        # Wenn das Fahrzeug nahe genug am Ziel ist, wechsle den Zustand in die Rotationsphase.
-        new_offset_pos = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        if (target - new_offset_pos).length() < 0.1:
-            vehicle.setPythonTag("order_state", "rotate")
-
-        return Task.cont
-
-    def handle_rotate_phase(self, vehicle, dt):
-        import math
-        from panda3d.core import Vec3
-
-        # 1. Hole den grünen Referenzpunkt (fork_green) der Gabel.
-        fork_green = vehicle.getPythonTag("fork_green")
-        if not fork_green or fork_green.isEmpty():
-            print("[DEBUG] handle_rotate_phase: Kein fork_green gefunden!")
-            return
-
-        # 2. Hole den aktuellen Auftrag und die zugehörige Pickup-Station.
-        current_order = vehicle.getPythonTag("current_order")
-        if not current_order or "pickup_station" not in current_order:
-            print("[DEBUG] handle_rotate_phase: Kein aktueller Auftrag oder Station gefunden!")
-            return
-        station = current_order["pickup_station"]
-
-        # Hole den Referenzpunkt der Station (white_center) und den Richtungsvektor (white_direction)
-        white_center = station.getPythonTag("white_center")
-        if white_center is None:
-            print("[DEBUG] handle_rotate_phase: Kein white_center in der Station gefunden!")
-            return
-        target = white_center  # Ziel: Mittelpunkt der weißen Linie
-
-        # 3. Berechne den Drehpunkt des Fahrzeugs.
-        pivot = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-
-        # 4. Falls sich der pivot nahe am Ziel befindet, final: Setze die exakte Ausrichtung.
-        distance = (target - pivot).length()
-        stop_threshold = 0.5  # Schwellenwert, evtl. an Modelldimensionen anpassen
-        if distance < stop_threshold:
-            desired_vector = target - pivot
-            desired_angle = math.degrees(math.atan2(desired_vector.getY(), desired_vector.getX())) + 90
-            desired_angle %= 360
-            vehicle.setH(self.render, desired_angle)
-            print(f"[DEBUG] final step: Fahrzeugheading auf {desired_angle:.2f}° gesetzt.")
-
-            # Final: Richte den grünen Richtungspfeil ("fork_center_line") exakt aus.
-            white_direction = station.getPythonTag("white_direction")
-            if white_direction is not None:
-                desired_arrow_angle = math.degrees(math.atan2(white_direction.getY(), white_direction.getX()))
-                arrow_relative = (desired_arrow_angle - desired_angle + 180) % 360 - 180
-                fork_center_line = vehicle.getPythonTag("fork_center_line")
-                if fork_center_line:
-                    fork_center_line.setH(arrow_relative)
-                    print(f"[DEBUG] final step: Grüner Pfeil auf relativen Winkel {arrow_relative:.2f}° gesetzt.")
-            # Hier ändern wir den Zustand in 'approach' statt "next_phase"
-            vehicle.setPythonTag("order_state", "approach")
-            return
-
-        # 5. Andernfalls: Berechne den gewünschten globalen Winkel (inklusive +90°-Offset)
-        desired_vector = target - pivot
-        desired_angle = math.degrees(math.atan2(desired_vector.getY(), desired_vector.getX())) + 90
-        desired_angle %= 360
-
-        # 6. Ermittle den aktuellen Fahrzeugheading in Weltkoordinaten und berechne die Winkelabweichung.
-        current_heading = vehicle.getH(self.render)
-        angle_diff = (desired_angle - current_heading + 180) % 360 - 180
-
-        if abs(angle_diff) < 2.0:
-            vehicle.setH(self.render, desired_angle)
-            white_direction = station.getPythonTag("white_direction")
-            if white_direction is not None:
-                desired_arrow_angle = math.degrees(math.atan2(white_direction.getY(), white_direction.getX()))
-                arrow_relative = (desired_arrow_angle - desired_angle + 180) % 360 - 180
-                fork_center_line = vehicle.getPythonTag("fork_center_line")
-                if fork_center_line:
-                    fork_center_line.setH(arrow_relative)
-                    print(f"[DEBUG] fine alignment: Grüner Pfeil auf {arrow_relative:.2f}° gesetzt.")
-            # Ändere auch hier sofort den Zustand in "approach"
-            vehicle.setPythonTag("order_state", "approach")
-            return
-
-        # 7. Begrenze die Drehung pro Frame (z.B. 20,9° pro Sekunde)
-        max_rotation_speed = 20.9  # Grad pro Sekunde
-        max_delta = max_rotation_speed * dt
-        delta_angle = max(-max_delta, min(max_delta, angle_diff))
-
-        # 8. Drehe das Fahrzeug schrittweise um delta_angle
-        temp_pivot = self.render.attachNewNode("temp_pivot")
-        temp_pivot.setPos(pivot)
-        self.rotate_around_pivot(vehicle, temp_pivot, delta_angle)
-        temp_pivot.removeNode()
-
-        print(f"[DEBUG] rotating: Gedreht um {delta_angle:.2f}°; Restliche Differenz: {angle_diff - delta_angle:.2f}°")
-
-    def handle_approach_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None:
-            pickup_station = current_order.get("pickup_station")
-            target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-        else:
-            target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-        current = vehicle.getPos(self.render)
-        error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-        if error_vec.length() > 0.05:
-            direction = error_vec.normalized()
-            move_distance = 1.5 * dt
-            new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                           current.getY() + direction.getY() * move_distance, target.getZ())
-            vehicle.setPos(new_pos)
-        else:
-            vehicle.setPos(target)
-            vehicle.setPythonTag("order_state", "pickup")
-
-    def handle_pickup_phase(self, vehicle, dt):
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        target_z = 1.0
-        raise_speed = 0.5
-        if current_z < target_z:
-            fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-        else:
-            if vehicle.getPythonTag("current_order") is None:
-                if self.orders_queue:
-                    vehicle.setPythonTag("current_order", self.orders_queue.pop(0))
-                else:
-                    print(
-                        f"Keine verfügbaren Aufträge für Fahrzeug {vehicle.getPythonTag('vehicle_id')}. Überspringe Pickup-Phase.")
-                    vehicle.setPythonTag("order_state", "drive_out")
-                    return
-            if not vehicle.getPythonTag("package_attached"):
-                pickup_station = vehicle.getPythonTag("current_order")["pickup_station"]
-                self.pickup_package(vehicle, pickup_station)
-                vehicle.setPythonTag("package_attached", True)
-            if vehicle.getPythonTag("drive_out_target") is None:
-                vehicle.setPythonTag("drive_out_target",
-                                     vehicle.getPos(self.render) + vehicle.getQuat(self.render).getForward() * 5.0)
-            vehicle.setPythonTag("order_state", "drive_out")
-
-    def handle_drive_out_phase(self, vehicle, dt):
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        if current_z > 0:
-            lower_speed = 0.5
-            fork_node.setZ(max(0, current_z - lower_speed * dt))
-        current_pos = vehicle.getPos(self.render)
-        drive_out_target = vehicle.getPythonTag("drive_out_target")
-        if drive_out_target is None:
-            drive_out_target = current_pos + vehicle.getQuat(self.render).getForward() * 5.0
-            vehicle.setPythonTag("drive_out_target", drive_out_target)
-        diff = drive_out_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            vehicle.setPythonTag("order_state", "to_delivery")
-            vehicle.setPythonTag("drive_out_target", None)
-
-    def handle_to_delivery_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is None:
-            return Task.cont
-
-        # Bestimme den Zielpunkt der Abgabestation:
-        delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-        try:
-            target_index = int(delivery_target_str.split()[-1])
-        except ValueError:
-            target_index = 1
-        if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-            target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-        else:
-            target = self.abgabe_blue_dots[0].getPos(self.render)
-
-        # Prüfe, ob die Abgabestation bereits durch ein Fahrzeug,
-        # das aktuell ein Paket abgibt oder in der Drop-Phase ist, besetzt ist.
-        if self.is_delivery_station_occupied(target, exclude_vehicle=vehicle, occupancy_threshold=1.0):
-            print(f"[WARTEN] Abgabestation belegt. Fahrzeug {vehicle.getPythonTag('vehicle_id')} wartet.")
-            return Task.cont  # Das Fahrzeug setzt keine Bewegung fort
-
-        # Falls die Abgabestation frei ist, folgt der übliche Bewegungs- und Drehvorgang:
-        current_pos = vehicle.getPos(self.render)
-        pivot = vehicle.getPythonTag("steering_axis")
-        import math
-        desired_heading_rad = math.atan2(target.getY() - current_pos.getY(),
-                                         target.getX() - current_pos.getX())
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-        heading_error = desired_heading_rad - current_heading_rad
-        while heading_error > math.pi:
-            heading_error -= 2 * math.pi
-        while heading_error < -math.pi:
-            heading_error += 2 * math.pi
-        gain = 1.0
-        max_delta = gain * dt
-        delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-        self.rotate_around_pivot(vehicle, pivot, math.degrees(delta_heading_rad))
-
-        # Vorwärtsbewegung:
-        new_heading_rad = math.radians(pivot.getNetTransform().getHpr().getX())
-        speed = 1.5  # Basisgeschwindigkeit
-        new_x = current_pos.getX() + speed * math.cos(new_heading_rad) * dt
-        new_y = current_pos.getY() + speed * math.sin(new_heading_rad) * dt
-        new_pos = Vec3(new_x, new_y, 0)
-        vehicle.setPos(new_pos)
-
-        # Falls das Fahrzeug nahe genug am Ziel ist, wechsele den Zustand:
-        if (target - new_pos).length() < 0.5:
-            print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat die Abgabestation erreicht.")
-            vehicle.setPythonTag("order_state", "align_delivery")
-
-        return Task.cont
-
-    def handle_align_delivery_phase(self, vehicle, dt):
-        desired_heading = 90.0
-        current_heading = vehicle.getH() % 360
-        angle_diff = ((desired_heading - current_heading + 180) % 360) - 180
-        print(
-            f"Phase 8: Align Delivery | Fahrzeug {vehicle.getPythonTag('vehicle_id')}: Current {current_heading:.2f}°, Desired {desired_heading:.2f}°, Diff {angle_diff:.2f}°")
-        fixed_turn_speed = 90.0
-        turn_amount = fixed_turn_speed * dt
-        if abs(angle_diff) < 1.0:
-            vehicle.setH(desired_heading)
-            print(
-                f"Phase 8 abgeschlossen: Fahrzeug {vehicle.getPythonTag('vehicle_id')} ausgerichtet (Heading = {desired_heading:.2f}°).")
-            vehicle.setPythonTag("order_state", "delivery_center")
-        else:
-            new_heading = current_heading + (turn_amount if angle_diff > 0 else -turn_amount)
-            new_heading %= 360
-            vehicle.setH(new_heading)
-            print(f"Phase 8: Rotating - Fahrzeug {vehicle.getPythonTag('vehicle_id')} New Heading: {new_heading:.2f}°")
-
-    def handle_delivery_center_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is None:
-            return
-        delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-        try:
-            target_index = int(delivery_target_str.split()[-1])
-        except ValueError:
-            target_index = 1
-        if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-            blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-        else:
-            blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-        current = vehicle.getPos(self.render)
-        target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-        print(f"Phase 9: Zielpunkt der Abgabestation für Fahrzeug {vehicle.getPythonTag('vehicle_id')}: {target_point}")
-        error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-        tolerance = 0.05
-        move_distance = 1.5 * dt
-        if error_vec.length() > tolerance:
-            direction = error_vec.normalized()
-            new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                           current.getY() + direction.getY() * move_distance, current.getZ())
-            vehicle.setPos(new_pos)
-            print(f"Phase 9: Fahrzeug {vehicle.getPythonTag('vehicle_id')} bewegt sich von {current} nach {new_pos}")
-        else:
-            vehicle.setPos(target_point)
-            print(f"Phase 9: Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den Zielpunkt erreicht.")
-            vehicle.setPythonTag("order_state", "drop")
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_fork_z = fork_node.getZ()
-        if current_fork_z < 1.0:
-            new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-            fork_node.setZ(new_fork_z)
-            print(
-                f"Phase 9: Gabel wird angehoben für Fahrzeug {vehicle.getPythonTag('vehicle_id')} (Z = {new_fork_z}).")
-
-    def handle_drop_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if vehicle.getPythonTag("package_attached"):
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            # (Bei Bedarf kann man hier noch Zielpositionen abfragen.)
-            self.drop_cargo(vehicle)
-            print(f"Phase 10: Paket abgesetzt für Fahrzeug {vehicle.getPythonTag('vehicle_id')}")
-            vehicle.setPythonTag("package_attached", False)
-        else:
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            if current_z > 0:
-                lower_speed = 0.5
-                new_z = max(0, current_z - lower_speed * dt)
-                fork_node.setZ(new_z)
-                print(
-                    f"Phase 10: Gabel wird abgesenkt für Fahrzeug {vehicle.getPythonTag('vehicle_id')}, aktueller Z-Wert: {new_z}")
-            else:
-                print(f"Phase 10: Dropoff abgeschlossen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}")
-                if vehicle.getPythonTag("standby_pending"):
-                    vehicle.setPythonTag("order_state", "return_to_garage")
-                    print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} kehrt zur Garage zurück (Standby).")
-                else:
-                    vehicle.setPythonTag("order_state", "translate")
-                current_order["status"] = "Abgegeben"
-                current_order["delivered_at"] = self.sim_clock
-                vehicle.clearPythonTag("current_order")
-
-    def handle_phase11(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if vehicle.getPythonTag("last_delivery_marker") is not None:
-            target_point = vehicle.getPythonTag("last_delivery_marker")
-        else:
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                target_point = self.abgabe_blue_dots[0].getPos(self.render)
-        print(f"Phase 11: Zielpunkt (blauer Marker) für Fahrzeug {vehicle.getPythonTag('vehicle_id')}: {target_point}")
-        current_pos = vehicle.getPos(self.render)
-        diff = target_point - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            vehicle.setPos(new_pos)
-            print(
-                f"Phase 11: Fahrzeug {vehicle.getPythonTag('vehicle_id')} fährt aus der Station, neue Position: {new_pos}")
-        else:
-            vehicle.setPos(target_point)
-            print(
-                f"Phase 11: Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den blauen Marker erreicht. Nächster Auftrag wird gestartet.")
-            vehicle.setPythonTag("order_state", "next_order")
-
-    def handle_return_to_garage_phase(self, vehicle, dt):
-        garage_target = vehicle.getPythonTag("garage_target")
-        if garage_target is None:
-            garage_target = self.garagen_parking_points[0]
-        current_pos = vehicle.getPos(self.render)
-        diff = garage_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 1.0 * dt
-            new_pos = current_pos + diff.normalized() * move_distance
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            if vehicle.hasPythonTag("start_heading"):
-                vehicle.setH(vehicle.getPythonTag("start_heading"))
-            vehicle.setPythonTag("order_state", "idle")
-            vehicle.setPythonTag("standby_pending", False)
-            print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} ist in der Garage (Standby).")
-
-    def collect_sensor_data(self, vehicle, sensor_range=5, grid_resolution=0.5):
-        """
-        Erzeugt ein einfaches 2D-Occupancy-Grid, das den Bereich um das Fahrzeug simuliert.
-
-        Parameter:
-          sensor_range: Radius (in Welt-Einheiten) um das Fahrzeug.
-          grid_resolution: Größe der einzelnen Zellen im Grid.
-
-        Rückgabe:
-          Ein NumPy-Array (2D) mit 0 (frei) als Platzhalter.
-        """
-        import numpy as np
-        grid_size = int((sensor_range * 2) / grid_resolution)
-        sensor_grid = np.zeros((grid_size, grid_size))
-        # --- Hier kannst du später echte Kollisionsabfragen oder Ray-Casting integrieren ---
-        return sensor_grid
-
-    def compute_ideal_steering_correction(self, vehicle):
-        """
-        Berechnet einen idealen Korrekturwinkel (in Grad) für die Navigation in der 'translate'-Phase.
-        Es wird ein vereinfachtes Modell genutzt, das den Unterschied zwischen dem gewünschten und dem aktuellen
-        Heading (über die Fahrzeug-Steuerachse) ermittelt.
-        """
-        import math
-
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None and "pickup_station" in current_order:
-            pickup_station = current_order["pickup_station"]
-            if pickup_station in self.station_blue_dots:
-                target = self.station_blue_dots[pickup_station].getPos(self.render)
-            else:
-                target = self.blue_dot.getPos(self.render)
-        else:
-            target = self.blue_dot.getPos(self.render)
-
-        current_pos = vehicle.getPos(self.render)
-        # Bestimme einen Offset-Punkt, basierend auf der bereits existierenden pickup_offset
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        # Berechne den gewünschten Heading-Winkel (in Radiant): Richtung von offset_pos zu target
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-
-        # Hole den aktuellen Heading-Wert vom Steuerachsen-Node (pivot)
-        pivot = vehicle.getPythonTag("steering_axis")
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-
-        ideal_correction_rad = desired_heading_rad - current_heading_rad
-        # Winkelbereich anpassen [-pi, pi]
-        while ideal_correction_rad > math.pi:
-            ideal_correction_rad -= 2 * math.pi
-        while ideal_correction_rad < -math.pi:
-            ideal_correction_rad += 2 * math.pi
-
-        return math.degrees(ideal_correction_rad)
-
-    def log_training_sample(self, sensor_data, ideal_angle):
-        """
-        Speichert ein Trainingssample bestehend aus den gesammelten Sensorwerten und dem idealen Korrekturwinkel.
-        """
-        self.training_data.append((sensor_data.copy(), ideal_angle))
-        # Optional: Gib eine Debug-Ausgabe aus, um das Logging zu überwachen.
-        print(
-            f"[LOG] Trainingssample gespeichert: Ideal Correction = {ideal_angle:.2f}°, Sensor Shape = {sensor_data.shape}")
-
-    def apply_safety_rules(self, vehicle, sensor_data, model_delta_angle, ideal_correction):
-        """
-        Kombiniert den vom Modell (model_delta_angle) und den ideal berechneten Korrekturwert (ideal_correction)
-        nur dann mit einem festen Sicherheitswert, wenn die Sensordaten einen kritischen Occupancy-Level anzeigen.
-
-        Falls der Occupancy-Level niedrig ist, wird ausschließlich der ideal vorhandene Korrekturwert verwendet.
-        """
-        import numpy as np
-        # Beispiel: Untersuche die mittlere Zeile des sensor_data-Grids als Indikator für frontale Hindernisse
-        middle_row = sensor_data[sensor_data.shape[0] // 2]
-        occupancy_level = np.sum(middle_row)
-
-        # Definiere einen kritischen Schwellenwert (diesen Wert ggf. anpassen)
-        threshold = 1.0
-
-        if occupancy_level > threshold:
-            print(
-                f"[RULE] Kritischer Occupancy-Level = {occupancy_level:.2f} erkannt. Sicherheitskorrektur wird angewendet.")
-            # Hier legen wir fest, dass in kritischen Situationen der Sicherheitswert stärker gewichtet wird.
-            safety_correction = 15.0  # z. B. 15° als feste Korrektur (Wert anpassen)
-            # Gewichteter Ansatz: Sicherheitskorrektur dominiert, während ein kleiner Anteil des idealen Wertes einfließt.
-            final_angle = 0.7 * safety_correction + 0.3 * ideal_correction
-        else:
-            # Wenn kein kritischer Wert vorliegt, einfach den ideal berechneten Korrekturwert verwenden.
-            final_angle = ideal_correction
-
-        return final_angle
-
-    def collision_avoidance_adjustment(self, current_vehicle, base_speed, safe_distance=3.0):
-        current_pos = current_vehicle.getPos(self.render)
-        adjusted_speed = base_speed
-        # Berechne einen Basisfaktor (z.B. basierend auf Abstand zu anderen Fahrzeugen):
-        for veh in self.garage_vehicles:
-            if veh == current_vehicle:
-                continue
-            other_pos = veh.getPos(self.render)
-            distance = (current_pos - other_pos).length()
-            if distance < safe_distance:
-                factor = (distance / safe_distance) ** 2
-                candidate_speed = base_speed * factor
-                if candidate_speed < adjusted_speed:
-                    adjusted_speed = candidate_speed
-
-        # Hier integrieren wir den RL-Ausdruck:
-        # Nehme als Zustandsvektor bspw. [min_distance_to_others, current_speed]
-        min_distance = min(
-            [(current_pos - v.getPos(self.render)).length() for v in self.garage_vehicles if v != current_vehicle])
-        current_speed = self.current_speed  # oder eine entsprechende Eigenschaft des Fahrzeugs
-        state = [min_distance, current_speed]
-
-        # Angenommen, du hast für jedes Fahrzeug einen eigenen RL-Agenten (oder einen globalen)
-        action = self.rl_agent.select_action(state)
-        # Definiere, wie Aktion in einen zusätzlichen Bremsfaktor übersetzt wird:
-        # Beispiel: Aktion 0: kein zusätzlicher Bremsfaktor, 1: 20% Reduktion, 2: 50% Reduktion
-        action_to_factor = {0: 1.0, 1: 0.8, 2: 0.5}
-        braking_factor = action_to_factor.get(action, 1.0)
-        adjusted_speed *= braking_factor
-
-        return adjusted_speed
-
-    def is_station_occupied(self, station, exclude_vehicle=None, occupancy_threshold=1.0):
-        """
-        Prüft, ob sich bereits ein Fahrzeug an der gegebenen Station (z. B. Pickup‑Station)
-        befindet. Dabei wird als Zielpunkt zumeist der blaue Marker genutzt, der der Station
-        zugeordnet ist. Das Fahrzeug exclude_vehicle (z. B. das aktuell agierende Fahrzeug)
-        wird dabei nicht berücksichtigt.
-        """
-        # Falls ein blauer Marker vorhanden ist, nutze dessen Position als Zielort:
-        if hasattr(self, 'station_blue_dots') and station in self.station_blue_dots:
-            station_pos = self.station_blue_dots[station].getPos(self.render)
-        else:
-            station_pos = station.getPos(self.render)
-        for veh in self.garage_vehicles:
-            if veh == exclude_vehicle:
-                continue
-            if (veh.getPos(self.render) - station_pos).length() < occupancy_threshold:
-                return True
-        return False
-
-    def is_delivery_station_occupied(self, target_pos, exclude_vehicle=None, occupancy_threshold=1.0):
-        """
-        Prüft, ob sich ein Fahrzeug in der Nähe der Abgabestation (target_pos) befindet,
-        welches in einer Lieferphase (z. B. drop, delivery_center oder align_delivery) ist oder noch ein Paket
-        transportiert (package_attached = True). Das Fahrzeug exclude_vehicle (z. B. das aktuell anfahrende Fahrzeug)
-        wird dabei nicht berücksichtigt.
-        """
-        for veh in self.garage_vehicles:
-            if veh == exclude_vehicle:
-                continue
-            # Hole den aktuellen Zustand und ob ein Paket noch angebracht ist.
-            state = veh.getPythonTag("order_state")
-            package_attached = veh.getPythonTag("package_attached")
-            if state in ["drop", "delivery_center", "align_delivery"] or package_attached:
-                if (veh.getPos(self.render) - target_pos).length() < occupancy_threshold:
-                    return True
-        return False
-
-    def check_collisions(self):
-        collision_threshold = 1.0  # z. B. wenn Fahrzeuge näher als 1 Einheit sind
-        collisions = []
-        for i in range(len(self.garage_vehicles)):
-            veh1 = self.garage_vehicles[i]
-            pos1 = veh1.getPos(self.render)
-            for j in range(i + 1, len(self.garage_vehicles)):
-                veh2 = self.garage_vehicles[j]
-                pos2 = veh2.getPos(self.render)
-                if (pos1 - pos2).length() < collision_threshold:
-                    collisions.append((veh1, veh2))
-        return collisions
-
-    def update_rl_on_collisions(self):
-        collisions = self.check_collisions()
-        for veh1, veh2 in collisions:
-            # Für jedes beteiligte Fahrzeug:
-            for veh in (veh1, veh2):
-                # Erstelle einen Zustandsvektor – analog zum, der in collision_avoidance_adjustment verwendet wird.
-                current_pos = veh.getPos(self.render)
-                min_distance = min([(current_pos - v.getPos(self.render)).length()
-                                    for v in self.garage_vehicles if v != veh])
-                current_speed = self.current_speed  # oder fahrzeugspezifisch
-                state = [min_distance, current_speed]
-                # Nehme an, die letzte von deinem Agenten gewählte Aktion ist gespeichert (das könntest du in einem PythonTag ablegen)
-                last_action = veh.getPythonTag("last_braking_action")
-
-                # Definiere den negativen Reward
-                reward = -10
-                # Erfasse den nächsten Zustand (nach Entfernen des Kollisionsereignisses oder nach einer kurzen Verzögerung)
-                next_state = state  # In einem echten Setup wäre hier der nächste gemessene Zustand
-                self.rl_agent.update(state, last_action, reward, next_state)
-                print(f"RL-Update für Fahrzeug {veh.getPythonTag('vehicle_id')}: Kollisionsreward {reward} vergeben.")
-
-import random
-import numpy as np
-
-class RLAgent:
-    def __init__(self, state_bins, action_space, learning_rate=0.1, discount_factor=0.9, epsilon=0.2):
-        """
-        state_bins: Tuple oder Liste, um kontinuierliche Zustände zu diskretisieren (z.B. (max_distance, num_bins))
-        action_space: Liste diskreter Aktionen (z.B. [0, 1, 2] --> 0: keine Bremsung, 1: leicht, 2: stark)
-        """
-        self.state_bins = state_bins
-        self.action_space = action_space
-        self.lr = learning_rate
-        self.gamma = discount_factor
-        self.epsilon = epsilon
-        # Initialisiere Q-Tabelle als Dictionary: key: (discretisierter_state), value: Liste von Q-Werten pro Aktion
-        self.q_table = {}
-
-    def discretize_state(self, state):
-        """
-        Nimmt einen Zustandsvektor (z.B. [distance, speed]) und gibt einen diskreten Zustand zurück.
-        Hier ein Beispiel: Falls state[0] = Abstand und state[1] = Geschwindigkeit.
-        """
-        # Beispiel: Wir nehmen an, dass state_bins = ((max_distance, num_bins), (max_speed, num_bins))
-        discrete_state = []
-        for i, (max_val, bins) in enumerate(self.state_bins):
-            # Begrenze state[i] um max_val:
-            val = min(state[i], max_val)
-            bin_size = max_val / bins
-            discrete_state.append(int(val // bin_size))
-        return tuple(discrete_state)
-
-    def select_action(self, state):
-        discrete_state = self.discretize_state(state)
-        if discrete_state not in self.q_table:
-            self.q_table[discrete_state] = [0.0 for _ in self.action_space]
-        # Epsilon-greedy Auswahl:
-        if random.random() < self.epsilon:
-            return random.choice(self.action_space)
-        else:
-            q_values = self.q_table[discrete_state]
-            return self.action_space[np.argmax(q_values)]
-
-    def update(self, state, action, reward, next_state):
-        s = self.discretize_state(state)
-        s_next = self.discretize_state(next_state)
-        if s not in self.q_table:
-            self.q_table[s] = [0.0 for _ in self.action_space]
-        if s_next not in self.q_table:
-            self.q_table[s_next] = [0.0 for _ in self.action_space]
-        a_index = self.action_space.index(action)
-        # Q-Learning Update-Regel:
-        best_next = max(self.q_table[s_next])
-        self.q_table[s][a_index] += self.lr * (reward + self.gamma * best_next - self.q_table[s][a_index])
-
-
-if __name__ == "__main__":
-    # Wichtig: setze auf Windows die Startmethode auf "spawn"
-    multiprocessing.set_start_method('spawn')
-
-    # Erzeuge eine Queue, auch wenn sie später eventuell neu erstellt wird, wenn "G" gedrückt wird.
-    graph_q = Queue()
-    app = LagerSimulation(graph_q)
-    app.run()
-
-    # Beim Schließen der Simulation den Graphprozess ggf. beenden
-    if app.graph_process is not None:
-        app.graph_process.terminate()
-        app.graph_process.join()
\ No newline at end of file
Index: KI/KI33.py
===================================================================
diff --git a/KI/KI33.py b/KI/KI33.py
deleted file mode 100644
--- a/KI/KI33.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,572 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Matplotlib zum Plotten importieren
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs,
-    CardMaker
-)
-
-# Wir nutzen globalClock für dt.
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit & Zeitskalierungsfaktor
-        self.base_speed = 1.5
-        self.speed_factor = 1.0
-
-        # Simulationszeitticker & Statistik
-        self.sim_clock = 0.0
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        self.sim_start_real = globalClock.getFrameTime()
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Zeichne für jede Annahmestation den Align-Punkt (2 m in positive X-Richtung)
-        for station in self.annahme_stationen:
-            station_pos = station.getPos()
-            ls_pickup = LineSegs()
-            ls_pickup.setThickness(3.0)
-            ls_pickup.setColor(LColor(1, 1, 1, 1))
-            ls_pickup.moveTo(station_pos)
-            ls_pickup.drawTo(station_pos + Vec3(2, 0, 0))
-            self.render.attachNewNode(ls_pickup.create())
-
-        # Zeichne für jede Abgabestation den Align-Punkt (2 m in negative X-Richtung)
-        for station in self.abgabe_stationen:
-            station_pos = station.getPos()
-            ls_dropoff = LineSegs()
-            ls_dropoff.setThickness(3.0)
-            ls_dropoff.setColor(LColor(1, 1, 1, 1))
-            ls_dropoff.moveTo(station_pos)
-            ls_dropoff.drawTo(station_pos + Vec3(-2, 0, 0))
-            self.render.attachNewNode(ls_dropoff.create())
-
-        # --- Anfahrstationen (Startstationen) für die Fahrzeuge ---
-        # Diese Stationen sollen bei Y = 15 nebeneinander mit 4 Meter Abstand in X-Richtung liegen.
-        self.anfahrstationen = []
-        num_departure = 2  # Zwei Stationen, da auch zu Beginn nur 2 Fahrzeuge genutzt werden sollen.
-        spacing_departure = 4.0
-        start_x = -spacing_departure * (num_departure - 1) / 2  # Bei 2 Stationen: start_x = -2.
-        for i in range(num_departure):
-            pos = Vec3(start_x + i * spacing_departure, 15, 0)
-            station = self.erzeuge_gitterbox(pos.getX(), pos.getY(), pos.getZ(), LColor(0.8, 0.8, 0, 1))
-            self.anfahrstationen.append(station)
-
-        # Fahrzeuge erstellen, jeweils eines pro Anfahrstation
-        self.vehicles = []
-        self.cargos = {}              # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}    # Fahrzeug -> zugewiesene Dropoff-Station
-        for i, start_station in enumerate(self.anfahrstationen):
-            vehicle = self.loader.loadModel("models/box")
-            vehicle.setScale(1, 1, 0.5)
-            # Optional: Unterschiedliche Farben, hier abwechselnd blau und leicht dunkler Blau
-            if i % 2 == 0:
-                vehicle.setColor(LColor(0, 0, 1, 1))
-            else:
-                vehicle.setColor(LColor(0, 0, 0.8, 1))
-            vehicle.setPos(start_station.getPos())
-            vehicle.reparentTo(self.render)
-            self.vehicles.append(vehicle)
-            self.add_center_marker(vehicle)
-            self.add_offset_circle(vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Reste der Pick-up-/Drop-off-Logik
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Erfassung von Daten für Graphen (einmal pro Simulationssekunde)
-        self.graph_data = []
-        self.taskMgr.doMethodLater(1, self.record_graph_data, "RecordGraphDataTask")
-
-        # Graphen öffnen per Taste "G" (nach Schließen wieder möglich)
-        self.graph_opened = False
-        self.accept("g", self.open_graph)
-
-        # Zoom-Funktionalität: Mit Mausrad hereinz- bzw. herauszoomen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_lidar_status, "UpdateLidarStatusTask")
-
-        # Liefervorgang starten (Pickup-Phase) für jedes Fahrzeug
-        for vehicle in self.vehicles:
-            self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def zoom_in(self):
-        # Hereinzoomen: Field-of-View (FOV) verkleinern (nicht unter 10°)
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        # Herauszoomen: FOV vergrößern (nicht über 100°)
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschn. Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def record_graph_data(self, task):
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0
-        self.graph_data.append((self.sim_clock, delivered_per_minute, avg_dwell_time))
-        return Task.again
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def add_offset_circle(self, vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5, num_segments=32):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        for i in range(num_segments + 1):
-            angle = 2 * math.pi * i / num_segments
-            x = circle_radius * math.cos(angle)
-            y = circle_radius * math.sin(angle)
-            if i == 0:
-                ls.moveTo(x, y, 0)
-            else:
-                ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        circle_np = vehicle.attachNewNode(circle_geom)
-        circle_np.setPos(offset)
-        vehicle.setPythonTag("lidar_circle", circle_np)
-
-    def draw_coordinate_axes(self, axis_length=5):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(1, 0, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        ls.setColor(0, 1, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        ls.setColor(0, 0, 1, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), (1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), (0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), (0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def update_lidar_status(self, task):
-        sensor_threshold = 3.0
-        for vehicle in self.vehicles:
-            if vehicle.hasPythonTag("lidar_circle"):
-                lidar_circle = vehicle.getPythonTag("lidar_circle")
-                pos = vehicle.getPos(self.render)
-                collision = False
-                avoidance_vec = Vec3(0, 0, 0)
-                for other in self.vehicles:
-                    if other is not vehicle:
-                        pos_other = other.getPos(self.render)
-                        diff = pos - pos_other
-                        if diff.length() < sensor_threshold:
-                            collision = True
-                            if diff.length() > 0:
-                                avoidance_vec += diff.normalized() * (sensor_threshold - diff.length())
-                if collision:
-                    lidar_circle.setColor(LColor(1, 0, 0, 1))
-                    vehicle.setPythonTag("avoidance", avoidance_vec)
-                    vehicle.setPythonTag("speed_multiplier", 0.5)
-                else:
-                    lidar_circle.setColor(LColor(0, 1, 0, 1))
-                    vehicle.setPythonTag("avoidance", Vec3(0, 0, 0))
-                    vehicle.setPythonTag("speed_multiplier", 1.0)
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-        current_wait_text = (
-            f"Liegedauer (aktuell): {current_max_wait_time:.1f}s"
-            if current_max_wait_time > 0 else "Kein Paket an Annahmestation"
-        )
-        maximal_wait_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted_time}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-            f"{current_wait_text}\n"
-            f"{maximal_wait_text}\n"
-            f"Liegedauer (Durchschnitt): {avg_dwell_time:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(
-            station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1)
-        )
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            to_target = target - current_pos
-            distance = to_target.length()
-            multiplier = (vehicle.getPythonTag("speed_multiplier")
-                          if vehicle.hasPythonTag("speed_multiplier") else 1.0)
-            effective_speed = self.base_speed * self.speed_factor * multiplier
-            step_distance = effective_speed * dt
-            if distance <= step_distance:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-            avoidance = (vehicle.getPythonTag("avoidance")
-                         if vehicle.hasPythonTag("avoidance") else Vec3(0, 0, 0))
-            if avoidance.length() > 0.001:
-                combined = to_target.normalized() + avoidance.normalized() * 0.5
-                combined.normalize()
-                new_direction = combined
-            else:
-                new_direction = to_target.normalized()
-            vehicle.setPos(current_pos + new_direction * step_distance)
-            return Task.cont
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        pickup_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        self.move_vehicle_to(vehicle, pickup_align,
-            lambda: self.move_vehicle_to(
-                vehicle,
-                pickup_station.getPos(),
-                lambda: self.after_pickup(vehicle, pickup_station)
-            )
-        )
-
-    def after_pickup(self, vehicle, pickup_station):
-        self.pickup_package(vehicle, pickup_station)
-        self.depart_from_pickup(vehicle, pickup_station,
-            lambda: self.start_dropoff_phase(vehicle)
-        )
-
-    def depart_from_pickup(self, vehicle, pickup_station, callback):
-        departure_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        departure_target = pickup_station.getPos() + Vec3(4, 0, 0)
-        self.move_vehicle_to(vehicle, departure_align,
-            lambda: self.move_vehicle_to(vehicle, departure_target, callback)
-        )
-
-    def start_dropoff_phase(self, vehicle):
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.start_dropoff_phase(vehicle)
-            return
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-        self.move_vehicle_to(vehicle, dropoff_align,
-            lambda: self.move_vehicle_to(vehicle, dropoff_station.getPos(),
-                lambda: self.after_dropoff(vehicle)
-            )
-        )
-
-    def after_dropoff(self, vehicle):
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        self.drop_cargo(vehicle)
-        self.remove_cargo(vehicle, remove_dropoff=True)
-        if dropoff_station is not None:
-            departure_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-            departure_target = dropoff_station.getPos() + Vec3(-4, 0, 0)
-            self.move_vehicle_to(vehicle, departure_align,
-                lambda: self.move_vehicle_to(vehicle, departure_target,
-                    lambda: self.start_delivery_cycle(vehicle, departure_target)
-                )
-            )
-        else:
-            self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle, remove_dropoff=True):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        if remove_dropoff:
-            dropoff_station = self.current_dropoffs.get(vehicle)
-            if dropoff_station in self.occupied_dropoffs:
-                self.occupied_dropoffs.remove(dropoff_station)
-            if vehicle in self.current_dropoffs:
-                del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices+1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices+1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z+1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
Index: TestFFZ/TestFFZ8.py
===================================================================
diff --git a/TestFFZ/TestFFZ8.py b/TestFFZ/TestFFZ8.py
deleted file mode 100644
--- a/TestFFZ/TestFFZ8.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,556 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs,
-    CardMaker
-)
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-# Globaler Clock (wird für die Zeitberechnung genutzt)
-globalClock = ClockObject.getGlobalClock()
-
-
-# =============================================================================
-# Klasse: SimulationSurface
-# =============================================================================
-class SimulationSurface(ShowBase):
-    def __init__(self):
-        super().__init__()
-        # Basisparameter und Statistik
-        self.base_speed = 1.5  # Maximalgeschwindigkeit (m/s)
-        self.speed_factor = 1.0
-        self.sim_clock = 0.0
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-        self.sim_start_real = globalClock.getFrameTime()
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        # Umgebung, Stationen, UI, Tasks & Graph aufbauen
-        self.setup_environment()
-        self.setup_stations()
-        self.setup_UI()
-        self.setup_tasks()
-        self.setup_graph()
-
-        # Mausevents (Zoom)
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-    def setup_environment(self):
-        self.erzeuge_licht()
-        self.boden = self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-    def setup_stations(self):
-        # Erzeuge Pickup-Station (bei x = -9) und Drop-Station (bei x = 9, y = 4)
-        self.pickup_station = self.erzeuge_gitterbox(-9, 0, 0, LColor(1, 0, 0, 1))
-        self.drop_station = self.erzeuge_gitterbox(9, 4, 0, LColor(0, 1, 0, 1))
-
-        # Zeichne Align-Punkte zur besseren Orientierung an der Pickup-Station
-        ls1 = LineSegs()
-        ls1.setThickness(3.0)
-        ls1.setColor(LColor(1, 1, 1, 1))
-        p1 = self.pickup_station.getPos(self.render)
-        ls1.moveTo(p1)
-        ls1.drawTo(p1 + Vec3(2, 0, 0))
-        self.render.attachNewNode(ls1.create())
-
-        # Parallele Linie bei der Pickup-Station (1 Einheit Offset in Y-Richtung)
-        ls1_parallel = LineSegs()
-        ls1_parallel.setThickness(3.0)
-        ls1_parallel.setColor(LColor(1, 1, 1, 1))
-        ls1_parallel.moveTo(p1 + Vec3(0, 1, 0))
-        ls1_parallel.drawTo(p1 + Vec3(2, 0, 0) + Vec3(0, 1, 0))
-        self.render.attachNewNode(ls1_parallel.create())
-
-        # Zeichne Align-Punkte zur besseren Orientierung an der Drop-Station
-        ls2 = LineSegs()
-        ls2.setThickness(3.0)
-        ls2.setColor(LColor(1, 1, 1, 1))
-        p2 = self.drop_station.getPos(self.render)
-        ls2.moveTo(p2)
-        ls2.drawTo(p2 + Vec3(-2, 0, 0))
-        self.render.attachNewNode(ls2.create())
-
-        # Parallele Linie bei der Drop-Station (1 Einheit Offset in Y-Richtung)
-        ls2_parallel = LineSegs()
-        ls2_parallel.setThickness(3.0)
-        ls2_parallel.setColor(LColor(1, 1, 1, 1))
-        ls2_parallel.moveTo(p2 + Vec3(0, 1, 0))
-        ls2_parallel.drawTo(p2 + Vec3(-2, 0, 0) + Vec3(0, 1, 0))
-        self.render.attachNewNode(ls2_parallel.create())
-
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-    def setup_UI(self):
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-    def setup_tasks(self):
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-
-    def setup_graph(self):
-        self.graph_opened = False
-        self.accept("g", self.open_graph)
-        self.graph_data = []
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in [self.pickup_station, self.drop_station]:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            current_max = max(current_max, elapsed)
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        current_text = f"Liegedauer (aktuell): {current_max:.1f}s" if current_max > 0 else "Kein Paket"
-        maximal_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-        avg_val = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        delivered = self.delivered_packages
-        ppm = delivered / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\nAbgegebene Pakete: {delivered}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n{current_text}\n{maximal_text}\n"
-            f"Durchschn. Liegedauer: {avg_val:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n = 0
-        mi = -center_extent - 0.5
-        ma = center_extent + 0.5
-        y = mi
-        while y <= ma:
-            writer.addData3(mi, y, 0)
-            writer.addData3(ma, y, 0)
-            lines.addVertices(n, n + 1)
-            n += 2
-            y += cell_size
-        x = mi
-        while x <= ma:
-            writer.addData3(x, mi, 0)
-            writer.addData3(x, ma, 0)
-            lines.addVertices(n, n + 1)
-            n += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        box = self.loader.loadModel("models/box")
-        box.setScale(1, 1, 1)
-        box.setPos(x, y, z)
-        box.setColor(farbe)
-        box.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        box.reparentTo(self.render)
-        return box
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        cube = self.loader.loadModel("models/box")
-        cube.setScale(1, 1, 1)
-        cube.setPos(x, y, z + 1)
-        cube.setColor(farbe)
-        cube.reparentTo(self.render)
-        return cube
-
-    def draw_coordinate_axes(self, axis_length=5):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), LColor(1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), LColor(0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), LColor(0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        curr = lens.getFov()[0]
-        new = max(10, curr - 5)
-        lens.setFov(new)
-        print(f"Zoom In: FOV von {curr} auf {new}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        curr = lens.getFov()[0]
-        new = min(100, curr + 5)
-        lens.setFov(new)
-        print(f"Zoom Out: FOV von {curr} auf {new}")
-
-
-# =============================================================================
-# Klasse: VehicleController
-# =============================================================================
-class VehicleController:
-    def __init__(self, surface: SimulationSurface):
-        self.surface = surface
-        self.vehicles = []  # Liste aller Fahrzeuge
-        self.cargos = {}  # Ordnet Fahrzeugen aktuell mitgeführte Pakete zu
-        self.current_dropoffs = {}
-        self.create_vehicles()
-
-    def create_vehicles(self):
-        # Es wird nur ein Fahrzeug erstellt, das an der Pickup-Station startet.
-        start_position = self.surface.pickup_station.getPos()
-        vehicle = self.surface.loader.loadModel("models/box")
-        vehicle.setScale(1, 1, 0.5)
-        vehicle.setColor(LColor(0, 0, 1, 1))
-        vehicle.setPos(start_position)
-        vehicle.reparentTo(self.surface.render)
-        vehicle.setPythonTag("role", "pickup_to_dropoff")
-        vehicle.setPythonTag("phase", "pickup")  # Fährt auf die Station zu
-        vehicle.setPythonTag("speed", 0.0)  # Startet aus dem Stand
-        self.add_center_marker(vehicle)
-        # Hinzufügen des zusätzlichen Markers: 1 Einheit in Y-Richtung vom Mittelpunkt
-        self.add_additional_marker(vehicle)
-        self.attach_lidar_sensor(vehicle, offset=Vec3(0.5, 0.5, 0), radius=2.5)
-        self.vehicles.append(vehicle)
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        marker = self.surface.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def add_additional_marker(self, vehicle, scale=0.2):
-        marker = self.surface.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(0, 1, 1, 1))  # Farbe (hier Cyan) – anpassbar
-        marker.reparentTo(vehicle)
-        # Positioniere den Marker 1 Einheit in Y-Richtung vom Mittelpunkt
-        marker.setPos(0, 1, 0.01)
-
-    def attach_lidar_sensor(self, vehicle, offset=Vec3(0.5, 0.5, 0), radius=2.5):
-        sensor_np = vehicle.attachNewNode("lidar_sensor")
-        sensor_np.setPos(offset)
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 1, 0, 1))
-        segments = 64
-        ls.moveTo(radius * math.cos(0), radius * math.sin(0), 0)
-        for i in range(1, segments + 1):
-            angle = (2 * math.pi * i) / segments
-            x = radius * math.cos(angle)
-            y = radius * math.sin(angle)
-            ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        sensor_np.attachNewNode(circle_geom)
-
-    def get_source_target(self, vehicle):
-        role = vehicle.getPythonTag("role")
-        if role == "pickup_to_dropoff":
-            return self.surface.pickup_station, self.surface.drop_station
-        else:
-            return self.surface.drop_station, self.surface.pickup_station
-
-    def compute_avoidance_vector(self, vehicle):
-        """
-        Berechnet einen Abstoßungsvektor basierend auf der Position aller anderen Fahrzeuge.
-        Je näher ein anderes Fahrzeug ist, desto stärker wirkt der Abstoßungseffekt.
-        """
-        avoidance = Vec3(0, 0, 0)
-        sensor_center = vehicle.getPos(self.surface.render) + Vec3(0.5, 0.5, 0)
-        detection_radius = 2.5  # Sensor-Radius
-        for other in self.vehicles:
-            if other is vehicle:
-                continue
-            other_center = other.getPos(self.surface.render)
-            diff = sensor_center - other_center
-            distance = diff.length()
-            if distance < detection_radius and distance > 0:
-                avoidance += diff.normalized() * (detection_radius - distance)
-        return avoidance
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        max_speed = 1.5
-        accel = 2.5
-        decel = 2.5
-
-        def move_task(task):
-            dt_real = globalClock.getDt()
-            dt = dt_real * self.surface.speed_factor
-
-            pos = vehicle.getPos()
-            to_target = target - pos
-            distance = to_target.length()
-
-            if distance < 0.05:
-                vehicle.setPos(target)
-                on_complete()
-                vehicle.setPythonTag("speed", 0.0)
-                return Task.done
-
-            current_speed = vehicle.getPythonTag("speed")
-
-            # Bei der "deliver"-Phase: Bei Dwell-Delay vor dem Weiterfahren bleiben.
-            if vehicle.getPythonTag("phase") == "deliver":
-                departure_ready_time = vehicle.getPythonTag("departure_ready_time")
-                if self.surface.sim_clock < departure_ready_time:
-                    vehicle.setPythonTag("speed", 0.0)
-                    return Task.cont
-
-            # Berechne den Abstoßungsvektor basierend auf dem Lidar.
-            avoidance_vector = self.compute_avoidance_vector(vehicle)
-            avoidance_weight = 1.0  # Feinjustierbar.
-            if avoidance_vector.length() > 0:
-                desired_direction = (
-                            to_target.normalized() + avoidance_vector.normalized() * avoidance_weight).normalized()
-            else:
-                desired_direction = to_target.normalized()
-
-            # Effektive Bremskraft berechnen
-            effective_decel = decel
-            if avoidance_vector.length() > 0.1:
-                effective_decel *= 1.5
-            if distance < 1.0:
-                effective_decel *= 2
-
-            # Standard-Beschleunigungs-/Bremslogik
-            if distance <= (current_speed ** 2) / (2 * effective_decel):
-                new_speed = max(current_speed - effective_decel * dt, 0)
-            else:
-                new_speed = min(current_speed + accel * dt, max_speed)
-
-            # Prüfung, ob sich das Fahrzeug in einer Station befindet:
-            station_region_radius = 2.0
-            is_station_phase = False
-            if (target - self.surface.pickup_station.getPos()).length() < 0.1 or (
-                    target - self.surface.drop_station.getPos()).length() < 0.1:
-                if (pos - target).length() < station_region_radius:
-                    is_station_phase = True
-            if not is_station_phase and vehicle.hasPythonTag("departure_station"):
-                departure_station = vehicle.getPythonTag("departure_station")
-                if (pos - departure_station.getPos()).length() < station_region_radius:
-                    is_station_phase = True
-
-            if is_station_phase:
-                new_speed = 0.5
-
-            movement = desired_direction * new_speed * dt
-            vehicle.setPos(pos + movement)
-            vehicle.setPythonTag("speed", new_speed)
-            return Task.cont
-
-        self.surface.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        vehicle.setPythonTag("job_start", self.surface.sim_clock)
-        vehicle.setPythonTag("phase", "pickup")
-        source, target = self.get_source_target(vehicle)
-        if source not in self.surface.pickup_packages:
-            self.surface.spawn_package_at_station(source)
-        self.move_vehicle_to(vehicle, source.getPos(), lambda: self.after_pickup(vehicle, source, target))
-
-    def after_pickup(self, vehicle, source, target):
-        self.pickup_package(vehicle, source)
-        vehicle.setPythonTag("phase", "deliver")
-        vehicle.setPythonTag("departure_station", source)
-        dwell_delay = 1.0
-        vehicle.setPythonTag("departure_ready_time", self.surface.sim_clock + dwell_delay)
-        self.move_vehicle_to(vehicle, target.getPos(), lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        self.drop_cargo(vehicle)
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, source):
-        if source in self.surface.pickup_packages:
-            package, spawn_time, timer_np = self.surface.pickup_packages.pop(source)
-            timer_np.removeNode()
-            dwell = self.surface.sim_clock - spawn_time
-            self.surface.total_dwell_time += dwell
-            self.surface.picked_up_count += 1
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.surface.last_removed[source] = self.surface.sim_clock
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.surface.render)
-            _, target = self.get_source_target(vehicle)
-            targetPos = target.getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.surface.delivered_packages += 1
-
-    def remove_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-
-
-# =============================================================================
-# Hauptprogramm
-# =============================================================================
-if __name__ == "__main__":
-    surface = SimulationSurface()
-    vehicle_controller = VehicleController(surface)
-    for vehicle in vehicle_controller.vehicles:
-        vehicle_controller.start_delivery_cycle(vehicle, vehicle.getPos())
-    surface.run()
Index: KI/KI21.py
===================================================================
diff --git a/KI/KI21.py b/KI/KI21.py
deleted file mode 100644
--- a/KI/KI21.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,411 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs
-)
-
-# Wir nutzen globalClock für dt
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit
-        self.base_speed = 1.5
-        # Zeitskalierungsfaktor
-        self.speed_factor = 1.0
-        # Simulationszeitticker in simulierten Sekunden
-        self.sim_clock = 0.0
-        # Zähler der abgegebenen Pakete
-        self.delivered_packages = 0
-        # Speichert die über die gesamte Simulation maximal erreichte Liegedauer eines Paketes
-        self.max_overall_wait_time = 0.0
-
-        # Zeitpunkt des Simulationsstarts (reale Zeit)
-        self.sim_start_real = globalClock.getFrameTime()
-
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erstelle 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeuge initialisieren – zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}           # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {} # Fahrzeug -> aktuell reservierte Abgabestation
-
-        # Fahrzeug 1: startet sofort
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-        # Markiere den Fahrzeugmittelpunkt ( weißer Punkt )
-        self.add_center_marker(vehicle1)
-        # Setze einen zusätzlichen Marker – hier einen Kreis (Radius 1,5 m)
-        # relativ zum Fahrzeugmittelpunkt (Offset 0,5 in x und 0,5 in y)
-        self.add_offset_circle(vehicle1, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Fahrzeug 2: startet 8 simulierte Sekunden später
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)  # y-Offset von 2 Einheiten
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-        self.add_center_marker(vehicle2)
-        self.add_offset_circle(vehicle2, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Globaler Pool für Pickup-Pakete und Zeitstempel (in simulierten Sekunden)
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider zur Anpassung des Zeitskalierungsfaktors
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Info-Anzeige
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tasks
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_vehicle2_start, "CheckVehicle2StartTask")
-
-        # Starte Liefervorgänge
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-        # Fahrzeug 2 startet, sobald 8 simulierte Sekunden erreicht sind (via Task)
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        """
-        Fügt dem Fahrzeug einen weißen Punkt als Markierung des Fahrzeugmittelpunkts hinzu.
-        """
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def add_offset_circle(self, vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5, num_segments=32):
-        """
-        Zeichnet einen Kreis (360°) als Visualisierung, der als zusätzlicher Marker fungiert.
-        Der Kreis wird relativ zum Fahrzeug (als Kindknoten) positioniert – sein Ursprung liegt
-        durch den Offset bei (0.5, 0.5, 0.01) relativ zum Fahrzeug-Pivot.
-        Der Kreis hat einen Radius von 1,5 m.
-        """
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 1, 1, 1))  # Weiß
-        for i in range(num_segments + 1):
-            angle = 2 * math.pi * i / num_segments
-            x = circle_radius * math.cos(angle)
-            y = circle_radius * math.sin(angle)
-            if i == 0:
-                ls.moveTo(x, y, 0)
-            else:
-                ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        circle_np = vehicle.attachNewNode(circle_geom)
-        circle_np.setPos(offset)
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-
-        if current_max_wait_time > 0:
-            current_wait_text = f"Liegedauer (aktuell): {current_max_wait_time:.1f}s"
-        else:
-            current_wait_text = "Kein Paket an Annahmestation"
-
-        maximal_wait_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-
-        if self.sim_clock > 0:
-            delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0)
-        else:
-            delivered_per_minute = 0
-
-        self.info_label['text'] = (f"Laufzeit: {formatted_time}\n"
-                                   f"Abgegebene Pakete: {self.delivered_packages}\n"
-                                   f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-                                   f"{current_wait_text}\n"
-                                   f"{maximal_wait_text}")
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def check_vehicle2_start(self, task):
-        if self.sim_clock >= 8.0 and not hasattr(self, 'vehicle2_started'):
-            self.vehicle2_started = True
-            self.start_delivery_cycle(self.vehicles[1], self.vehicles[1].getPos())
-            return Task.done
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(
-            station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1)
-        )
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            direction = target - current_pos
-            distance = direction.length()
-            step = (self.base_speed * self.speed_factor) * dt
-            if distance <= step:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-            else:
-                vehicle.setPos(current_pos + direction.normalized() * step)
-                return Task.cont
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        pickup_pos = pickup_station.getPos()
-
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.occupied_pickups.remove(pickup_station)
-            def wait_for_dropoff(task):
-                if any(ds not in self.occupied_dropoffs for ds in self.abgabe_stationen):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_for_dropoff, f"WaitDropoff_{id(vehicle)}")
-            return
-
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_pos = dropoff_station.getPos()
-
-        self.move_vehicle_to(vehicle, pickup_pos, lambda: self.after_pickup(vehicle, pickup_station, dropoff_pos))
-
-    def after_pickup(self, vehicle, pickup_station, dropoff_pos):
-        self.pickup_package(vehicle, pickup_station)
-        self.move_vehicle_to(vehicle, dropoff_pos, lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        self.drop_cargo(vehicle)
-        start_wait = self.sim_clock
-        def wait_task(task):
-            if self.sim_clock - start_wait >= self.sim_time(1):
-                self.finish_cycle(vehicle)
-                return Task.done
-            return Task.cont
-        self.taskMgr.add(wait_task, f"WaitAfterDrop_{id(vehicle)}")
-
-    def finish_cycle(self, vehicle):
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        if dropoff_station in self.occupied_dropoffs:
-            self.occupied_dropoffs.remove(dropoff_station)
-            del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
Index: Grundmodell Erweitert Split/GES9.py
===================================================================
diff --git a/Grundmodell Erweitert Split/GES9.py b/Grundmodell Erweitert Split/GES9.py
deleted file mode 100644
--- a/Grundmodell Erweitert Split/GES9.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,2366 +0,0 @@
-# Standardbibliothek
-import random
-import math
-import time
-import ctypes
-import multiprocessing
-from multiprocessing import Queue, Process
-from functools import partial
-import tkinter as tk
-from tkinter import ttk
-
-# Drittanbieter
-import matplotlib
-import matplotlib.pyplot as plt
-from PyQt5 import QtWidgets, QtCore
-import pyqtgraph as pg
-
-# Panda3D und Direct (Engine-spezifische Importe)
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.task import Task
-from direct.task.TaskManagerGlobal import taskMgr
-from direct.gui.DirectGui import DirectButton, DirectSlider, DirectLabel
-
-from direct.showbase.ShowBase import ShowBase
-from environment_visualization import EnvironmentVisualizer
-
-class LagerSimulation(ShowBase):
-    def __init__(self, graph_queue=None):
-        # Basisinitialisierung (ShowBase, etc.)
-        super().__init__()
-
-        # ------------------------------------------------------------------------
-        # 1. Umgebung aufbauen: Verwende den extrahierten EnvironmentVisualizer
-        # ------------------------------------------------------------------------
-        self.env_viz = EnvironmentVisualizer(self.render, self.loader)
-
-        # Rufe die Methoden des Visualizers auf, um die Umgebung zu erstellen.
-        self.env_viz.draw_origin()
-        self.env_viz.erzeuge_licht()
-        self.env_viz.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.env_viz.create_wall()
-        self.env_viz.create_annahme_stations()
-        self.env_viz.create_abgabe_stations()
-        self.env_viz.create_garagen_stations()
-
-        # Um in anderen Methoden (z. B. für Paket- oder Auftrags-Handling) auf die Stationen
-        # und deren Marker zugreifen zu können, übergeben wir die entsprechenden Listen.
-        self.annahme_stations = self.env_viz.annahme_stations
-        self.station_blue_dots = self.env_viz.station_blue_dots
-        self.abgabe_stations = self.env_viz.abgabe_stations
-        self.abgabe_blue_dots = self.env_viz.abgabe_blue_dots
-        self.garagen_stations = self.env_viz.garagen_stations
-        self.garagen_parking_points = self.env_viz.garagen_parking_points
-
-        # Verbindungslinien
-        #self.env_viz.connect_annahme_abgabe_blue_dots(color=LColor(1, 1, 1, 1), thickness=2.0)
-
-
-        #self.env_viz.connect_garagen_blue_dots(line_color=LColor(1, 1, 1, 1), thickness=2.0, text_color=LColor(0, 0, 1, 1))
-        #self.env_viz.connect_annahme_stations(color=LColor(1, 1, 1, 1), thickness=2.0)
-        #self.env_viz.connect_abgabe_stations(color=LColor(1, 1, 1, 1), thickness=2.0)
-
-        # Erzeuge den fixierten blauen Punkt (wird nur einmal erzeugt)
-        #self.fixed_blue_dot = self.env_viz.create_fixed_blue_dot()
-        # Erstelle die Verbindungslinie, die den blauen Marker der 10. Abgabestation mit dem fixierten Punkt verbindet
-        #self.fixed_connection_line = self.env_viz.create_fixed_connection_line()
-        # Erzeuge die Verbindungslinie von dem fixierten Punkt zur 5. Garage.
-        #self.garage5_connection_line = self.env_viz.create_garage5_connection_line()
-
-        #self.first_garage_to_10_annahme_connection = self.env_viz.create_connection_line_first_garage_to_10_annahme()
-
-        #self.yellow_station_points = self.env_viz.create_yellow_station_points(offset=3.0, scale=0.1)
-        #self.yellow_abgabe_points = self.env_viz.create_yellow_abgabe_points(offset=3.0, scale=0.1)
-        #self.yellow_garage_points = self.env_viz.create_yellow_garage_points(offset=3.0, scale=0.1)
-
-        self.pickup_offset = Vec3(0.5, -0.5, 0)
-
-        # Falls du weitere Referenzen (wie self.blue_dot, self.station_green_dot) brauchst, ebenfalls setzen.
-        if hasattr(self.env_viz, 'blue_dot'):
-            self.blue_dot = self.env_viz.blue_dot
-        if hasattr(self.env_viz, 'station_green_dot'):
-            self.station_green_dot = self.env_viz.station_green_dot
-
-        # ------------------------------------------------------------------------
-        # 2. Restliche Initialisierung (Simulationsvariablen, UI, Tasks, etc.)
-        # (Der restliche Code bleibt weitgehend unverändert.)
-        # ------------------------------------------------------------------------
-
-        self.paused = False
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5
-
-        # Weitere Attribute, z. B. für KPIs, Paket- und Auftragsverwaltung usw.
-        self.delivered_packages = 0
-        self.pickup_packages = {}
-        self.last_removed = {}
-        self.orders = {}
-        self.orders_queue = []
-        self.next_order_id = 1
-        # (Weitere Initialisierungen kommen hier…)
-        self.cargos = {}
-        # Falls du auch weitere Attribute benötigst, wie beispielsweise eine Liste der belegten Pickup-Stations:
-        self.occupied_pickups = set()
-
-        self.max_overall_wait_time = 0.0  # Maximale Wartezeit der Pakete
-        self.total_dwell_time = 0.0  # Summe aller Liegedauern abgeholter Pakete
-        self.picked_up_count = 0  # Anzahl abgeholter Pakete
-        self.total_delivery_time = 0.0  # Summe aller Lieferzeiten
-        self.total_delivery_count = 0  # Anzahl der Lieferungen
-        self.max_overall_delivery_time = 0.0
-
-        self.graph_queue = None
-        self.graph_data = []
-        self.graph_process = None
-
-        # Beispiel: Initialisierung des Tkinter-Fensters
-        self.tk_root = tk.Tk()
-        self.tk_root.withdraw()
-
-        # Weiterer Code: Kamera, Lichter (falls weiterhin benötigt – ansonsten übernehmen wir vollständig den Visualizer)
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # UI-bezogene Attribute initialisieren:
-        self.order_win = None
-        self.order_tree = None
-        self.graph_queue = None
-        self.graph_data = []
-
-        # TensorFlow-Modell und RL-Agent initialisieren (wie gehabt)
-        try:
-            import tensorflow as tf
-            self.tf_model = tf.keras.models.load_model("mein_model.keras")
-            print("TensorFlow Modell erfolgreich geladen.")
-        except Exception as e:
-            print(f"Fehler beim Laden des TensorFlow Modells: {e}")
-            self.tf_model = None
-
-        state_bins = ((10, 10), (10, 10))
-        action_space = [0, 1, 2]
-        self.rl_agent = RLAgent(state_bins, action_space, learning_rate=0.1, discount_factor=0.9, epsilon=0.2)
-        self.training_data = []  # Trainingsdatenliste
-
-        # Spawn-Einstellungen (Standardwerte)
-        self.package_spawn_delay = 5.0
-        self.package_spawn_distribution = "uniform"
-        # Hier speichern wir die Variablen für die Stationen als Dictionary (Index -> BooleanVar)
-        self.spawn_station_vars = {}
-        # Falls du beispielsweise 10 Annahmestationen hast:
-        for i in range(10):
-            self.spawn_station_vars[i] = tk.BooleanVar(value=False)
-
-        # Fahrzeuge in den Garagen instanziieren:
-        self.create_garage_vehicles()
-        # --- UI-Elemente für Simulationssteuerung ---
-        # Slider für Simulationsgeschwindigkeit
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        self.paused = False
-        # Pause-Knopf neben dem Slider platzieren – z.B. rechts davon.
-        self.pause_button = DirectButton(
-            text="Pause",
-            command=self.toggle_pause,
-            pos=(-0.5, 0, -0.85),  # Leicht links vom Slider
-            scale=0.07
-        )
-        self.taskMgr.add(self.update_rl_on_collisions, "CollisionUpdateTask")
-
-        # --- Tastenzuordnungen ---
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-        # Taste "c" öffnet das Fahrzeug-Kontrollfenster
-        self.accept("c", self.show_vehicle_control)
-
-        # --- Tasks (TaskMgr) hinzufügen ---
-        self.taskMgr.add(self._tk_update, "tkUpdateTask")
-        self.taskMgr.add(self.update_delivery_timers, "UpdateDeliveryTimersTask")
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClock")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_graph_data, "UpdateGraphDataTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-    # ---------------1. Initialisierung & Simulationssteuerung---------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        self.sim_clock += dt
-        return Task.cont
-
-    def toggle_pause(self):
-        if not self.paused:
-            # Speichern des aktuellen speed_factor, damit wir ihn beim Resume wiederherstellen können
-            self.previous_speed_factor = self.speed_factor
-            self.speed_factor = 0  # Simulation einfrieren: alle dt-basierte Updates ergeben 0
-            self.pause_button['text'] = "Weiter"
-            self.paused = True
-            print("Gesamte Simulation angehalten")
-        else:
-            # Wiederaufnahme der Simulation: speed_factor auf den vorherigen Wert zurücksetzen
-            self.speed_factor = self.previous_speed_factor if hasattr(self, 'previous_speed_factor') else 1.0
-            self.pause_button['text'] = "Pause"
-            self.paused = False
-            print("Simulation läuft wieder")
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-
-    def update_vehicle(self, task):
-        # dt jetzt skaliert mit der Simulationsgeschwindigkeit
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-    # ---------------2. Graphik & UI (GUI-/Tk-/Matplotlib-Funktionen)---------------
-    def open_graph(self):
-        # Starte den Graphprozess per Taste G (nur, wenn er noch nicht läuft)
-        if self.graph_process is None or not self.graph_process.is_alive():
-            from multiprocessing import Queue, Process
-            self.graph_queue = Queue()
-
-            # Sende alle bisher gesammelten Daten in die Queue:
-            for data in self.graph_data:
-                try:
-                    self.graph_queue.put(data, block=False)
-                except Exception:
-                    pass
-
-            from graph_pyqt import graph_process_pyqt
-            self.graph_process = Process(target=graph_process_pyqt, args=(self.graph_queue,))
-            self.graph_process.start()
-
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2, self.ax3) = plt.subplots(3, 1, figsize=(8, 9))
-
-        # Erster Plot: Pakete pro Minute
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-
-        # Zweiter Plot: Durchschnittliche Liegedauer
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-
-        # Dritter Plot: Durchschnittliche Lieferzeit
-        self.line3, = self.ax3.plot([], [], marker="o", color="green", label="Durchschnittliche Lieferzeit (s)")
-        self.ax3.set_xlabel("Simulationszeit (s)")
-        self.ax3.set_ylabel("Lieferzeit (s)")
-        self.ax3.set_title("Durchschnittliche Lieferzeit")
-        self.ax3.legend()
-        self.ax3.grid(True)
-
-        plt.show(block=False)
-        # Starte im Tkinter-Hauptloop eine periodische Aktualisierung:
-        self.tk_root.after(500, self.tk_graph_update)  # alle 500ms
-
-    def tk_graph_update(self):
-        # GIL sichern: Gibt einen Statuswert zurück, der später wieder freigegeben wird.
-        gil_state = ctypes.pythonapi.PyGILState_Ensure()
-        try:
-            times = [data[0] for data in self.graph_data]
-            rates = [data[1] for data in self.graph_data]
-            dwell = [data[2] for data in self.graph_data]
-            delivery = [data[3] for data in self.graph_data]
-
-            self.line1.set_data(times, rates)
-            self.ax1.relim()
-            self.ax1.autoscale_view()
-
-            self.line2.set_data(times, dwell)
-            self.ax2.relim()
-            self.ax2.autoscale_view()
-
-            self.line3.set_data(times, delivery)
-            self.ax3.relim()
-            self.ax3.autoscale_view()
-
-            self.fig.canvas.draw_idle()
-            self.fig.canvas.flush_events()
-        finally:
-            ctypes.pythonapi.PyGILState_Release(gil_state)
-
-        # Nächsten Aufruf in 500ms einplanen
-        self.tk_root.after(500, self.tk_graph_update)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-
-        # Bestimme die maximale Liegedauer aktueller Pakete an den Annahmestationen
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-
-        # Lieferzeit-Kennzahlen ermitteln: für Fahrzeuge, die aktuell ein Paket tragen
-        current_delivery_time = 0.0
-        for veh in self.garage_vehicles:
-            if veh.getPythonTag("package_attached"):
-                ds = veh.getPythonTag("delivery_start_time")
-                if ds:
-                    elapsed_delivery = self.sim_clock - ds
-                    current_delivery_time = max(current_delivery_time, elapsed_delivery)
-        avg_delivery_time = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        # Aktualisiere den Info-Label-Text
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s\n"
-            f"Lieferzeit (aktuell): {current_delivery_time:.1f}s\n"
-            f"Lieferzeit (maximal): {self.max_overall_delivery_time:.1f}s\n"
-            f"Durchschn. Lieferzeit: {avg_delivery_time:.1f}s"
-        )
-        return Task.cont
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def update_graph_data(self, task):
-        if self.sim_clock > 0:
-            ppm = self.delivered_packages / (self.sim_clock / 60)
-        else:
-            ppm = 0.0
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        avg_delivery = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        standard_data = (self.sim_clock, ppm, avg_dwell, avg_delivery)
-        self.graph_data.append(standard_data)
-
-        # Sende die Standarddaten an die Queue
-        if self.graph_queue is not None:
-            try:
-                self.graph_queue.put(standard_data, block=False)
-            except Exception:
-                pass
-
-        # Erzeuge zusätzlich Fahrzeug-Rating-Daten.
-        # Hier als Beispiel: Zufällige Bewertungen für 5 Fahrzeuge;
-        # in deinem System müsstest du diese Werte natürlich aus deinen Messungen oder Berechnungen ableiten.
-        vehicle_ratings = [random.uniform(0, 100) for _ in range(5)]
-        rating_data = (self.sim_clock, *vehicle_ratings)
-
-        # Sende die Rating-Daten
-        if self.graph_queue is not None:
-            try:
-                self.graph_queue.put(rating_data, block=False)
-            except Exception:
-                pass
-
-        return Task.cont
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Hier werden nur die gewünschten Spalten "ID", "Annahmestation", "Ziel" und "Fahrzeug" definiert.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    #-------Fahrzeugsteuerung(Bedienfenster)-------
-    def update_vehicle_control(self):
-        for veh, var in self.vehicle_state_vars.items():
-            new_state = var.get()
-            if new_state == "idle" and veh.getPythonTag("current_order") is not None:
-                veh.setPythonTag("standby_pending", True)
-            else:
-                veh.setPythonTag("standby_pending", False)
-                veh.setPythonTag("order_state", new_state)
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-    def update_cable(self, task):
-        # Verwende die simulative Zeit, die bereits in update_sim_clock hochgezählt wird
-        t = self.sim_clock
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    def create_garage_vehicles(self):
-        self.garage_vehicles = []
-        vehicle_id_counter = 1
-        for park in self.garagen_parking_points:
-            veh = self.create_vehicle(park_point=park)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            newPos.setZ(0)
-            veh.setPos(newPos)
-
-            # Fahrzeuge starten im Standby (idle)
-            veh.setPythonTag("current_order", None)
-            veh.setPythonTag("order_state", "idle")
-            veh.setPythonTag("package_attached", False)
-            veh.setPythonTag("vehicle_id", vehicle_id_counter)
-            # Speichere den Parkpunkt als Rückkehrziel
-            veh.setPythonTag("garage_target", park)
-            # Speichere auch das Anfangs-Heading, um es später beim Parken wiederherzustellen.
-            veh.setPythonTag("start_heading", veh.getH())
-            vehicle_id_counter += 1
-
-            self.garage_vehicles.append(veh)
-
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-            # Füge einen Textknoten hinzu, der die Fahrzeugnummer vorne auf dem Fahrzeug anzeigt.
-            # Wir suchen den Mast-Knoten.
-            mast = veh.find("**/mast")
-            if not mast.isEmpty():
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)  # Schwarz
-                tn.setAlign(TextNode.ACenter)
-                text_np = mast.attachNewNode(tn)
-                # Positioniere den Text relativ zum Mast: Wir nutzen den Vektor "intersection"
-                # und versetzen ihn in Z-Richtung um 0.2 Einheiten oberhalb des Zylinders.
-                text_np.setPos(intersection.x, intersection.y, intersection.z + 0.2)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-            else:
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)
-                tn.setAlign(TextNode.ACenter)
-                text_np = veh.attachNewNode(tn)
-                text_np.setPos(0, 1.2, 1.5)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-
-            self.taskMgr.add(partial(self.vehicle_order_task, veh),
-                             f"VehicleOrderTask_{veh.getPythonTag('vehicle_id')}")
-
-    # --------------- Erstellung des Fahrzeugs---------------
-    def create_vehicle(self, park_point=None):
-        # Erzeuge den übergeordneten Fahrzeug-Knoten
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # --------------------------
-        # Chassis erstellen (1 x 0.5 x 1.2, Farbe Rot)
-        # --------------------------
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # --------------------------
-        # Gabel (Fork) erstellen: Zwei Zähne
-        # --------------------------
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        vehicle_node.setPythonTag("fork_node", fork_node)
-
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-
-        # --------------------------
-        # Statt weißer Kante von der Gabel: bereits eingezeichnete grüne Mittellinie verwenden.
-        # In diesem Beispiel nehmen wir an, dass du schon eine „mittlere“ Linie gezeichnet hast.
-        # Zeichne die grüne Mittellinie, z. B. von einem Punkt an der Gabel (als Ausgangspunkt)
-        # bis zu einem Referenzpunkt – hier nutzen wir einen zuvor festgelegten Offset.
-        #
-        # Wir definieren:
-        #   - Den Ausgangspunkt als den grün markierten Punkt, der den mittleren Punkt der Gabel repräsentieren soll.
-        #   - Den Zielpunkt als den Referenzpunkt, der als Idealwert in create_vehicle bestimmt wurde.
-        # In unserem Beispiel berechnen wir den Zielpunkt einmalig aus den lokalen Offsets an der weißen Kante.
-        # (Diese Werte kannst du bei Bedarf anpassen.)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_global = fork_node.getPos(self.render) + left_corner_local
-        right_global = fork_node.getPos(self.render) + right_corner_local
-        # Berechne den idealen (statischen) Mittelpunkt als Referenz – dieser wird nur einmal gesetzt.
-        midpoint_white = (left_global + right_global) * 0.5
-        # Nun lege den grünen Marker so, dass er exakt in der Mitte der Gabel liegt.
-        # Hier entspricht der grüne Punkt der Mittellinie der Gabel.
-        green_point_global = midpoint_white  # Hier wird angenommen, dass der ideale Mittelpunkt gleich dem Referenzpunkt ist.
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        vehicle_node.setPythonTag("fork_green", green_marker_np)
-
-        # Zeichne die grüne Mittellinie.
-        # Als Beispiel: Zeichne eine Linie vom grünen Marker in Richtung +Y (relativ zum Fahrzeug),
-        # weil du den idealen Zustand so festgelegt hast, dass genau diese Linie mit der Station übereinstimmen soll.
-        ls_mid = LineSegs()
-        ls_mid.setThickness(2.0)
-        ls_mid.setColor(0, 1, 0, 1)  # grün
-        # Starte die Linie am grünen Marker.
-        ls_mid.moveTo(green_point_global)
-        # Zeichne beispielsweise eine Linie 1 Einheit lang in +Y-Richtung:
-        ls_mid.drawTo(green_point_global + Vec3(0, 1, 0))
-        fork_center_line = vehicle_node.attachNewNode(ls_mid.create())
-        # Speichere den NodePath der grünen Mittellinie
-        vehicle_node.setPythonTag("fork_center_line", fork_center_line)
-
-        # --------------------------
-        # Restliche Fahrzeugteile (Mast, Lenkachse, etc.)
-        # --------------------------
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-        self.add_diagonals_to_mast(mast_node)
-
-        intersection = Vec3(0.5, 0.05, 1.0)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        # --------------------------
-        # Lenkachse erzeugen (Pivot-Node)
-        # --------------------------
-        steering_axis = mast_node.attachNewNode("steering_axis")
-        steering_axis.setPos(0.5, 0.25, -1.2)
-        steering_axis.setH(90)
-        vehicle_node.setPythonTag("steering_axis", steering_axis)
-
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(steering_axis)
-        cylinder_node.setPos(0, 0, 0)
-        self.vehicle_cylinder = steering_axis
-        self.add_steering_arrow(steering_axis, color=(0, 1, 0, 1))
-
-        # --------------------------
-        # Positioniere das Fahrzeug am Parkpunkt
-        # --------------------------
-        if park_point is None:
-            vehicle_node.setPos(0, 0, 0)
-        else:
-            intersection = Vec3(0, 0, 1.0)
-            vehicle_node.setPos(park_point - vehicle_node.getQuat().xform(intersection))
-
-        # ********** Ursprung (Koordinatensystem) am Fahrzeug einzeichnen **********
-        ls_x = LineSegs()
-        ls_x.setThickness(2)
-        ls_x.setColor(LColor(1, 0, 0, 1))
-        ls_x.moveTo(0, 0, 0)
-        ls_x.drawTo(1, 0, 0)
-        vehicle_node.attachNewNode(ls_x.create())
-
-        ls_y = LineSegs()
-        ls_y.setThickness(2)
-        ls_y.setColor(LColor(0, 1, 0, 1))
-        ls_y.moveTo(0, 0, 0)
-        ls_y.drawTo(0, 1, 0)
-        vehicle_node.attachNewNode(ls_y.create())
-
-        ls_z = LineSegs()
-        ls_z.setThickness(2)
-        ls_z.setColor(LColor(0, 0, 1, 1))
-        ls_z.moveTo(0, 0, 0)
-        ls_z.drawTo(0, 0, 1)
-        vehicle_node.attachNewNode(ls_z.create())
-
-        from panda3d.core import TextNode
-        tn_x = TextNode("label_x")
-        tn_x.setText("X")
-        tn_x.setTextColor(1, 0, 0, 1)
-        label_x = vehicle_node.attachNewNode(tn_x)
-        label_x.setScale(0.3)
-        label_x.setPos(2.0, 0, 0)
-
-        tn_y = TextNode("label_y")
-        tn_y.setText("Y")
-        tn_y.setTextColor(0, 1, 0, 1)
-        label_y = vehicle_node.attachNewNode(tn_y)
-        label_y.setScale(0.3)
-        label_y.setPos(0, 2.0, 0)
-
-        tn_z = TextNode("label_z")
-        tn_z.setText("Z")
-        tn_z.setTextColor(0, 0, 1, 1)
-        label_z = vehicle_node.attachNewNode(tn_z)
-        label_z.setScale(0.3)
-        label_z.setPos(0, 0, 2.0)
-
-        return vehicle_node
-
-    def add_steering_arrow(self, steering_axis, color=(0, 1, 0, 1)):
-        """
-        Erzeugt einen Pfeil, der die Vorwärtsrichtung (lokale X-Achse) des Lenkpivots anzeigt.
-        Der Pfeil wird als Kind des übergebenen steering_axis-Node angehängt und passt sich
-        automatisch dessen Rotation an.
-        """
-        arrow_ls = LineSegs()
-        arrow_ls.setThickness(2.0)
-        arrow_ls.setColor(*color)
-
-        # Zeichne eine Linie von (0,0,0) bis (2,0,0) – das ist die Basis des Pfeils
-        arrow_ls.moveTo(0, 0, 0)
-        arrow_ls.drawTo(2, 0, 0)
-
-        # Zeichne den Pfeilkopf: zwei kurze schräge Linien am Ende der Pfeillinie
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, 0.3, 0)
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, -0.3, 0)
-
-        arrow_np = steering_axis.attachNewNode(arrow_ls.create())
-        arrow_np.setPos(0, 0, 0)  # Falls nötig, hier noch zusätzlichen Offset anpassen
-        return arrow_np
-
-    def rotate_around_pivot(self, vehicle, pivot, delta_angle):
-        """
-        Dreht das Fahrzeug (vehicle) um den gegebenen Pivotpunkt (pivot) um delta_angle (in Grad).
-        Dabei wird die Position des Fahrzeugs neu berechnet, sodass es um den Pivot rotiert.
-        """
-        # Aktuelle globale Fahrzeugposition
-        pos = vehicle.getPos(self.render)
-        # Globaler Pivotpunkt
-        pivot_pos = pivot.getPos(self.render)
-        # Berechne den Vektor vom Pivot zum Fahrzeug
-        rel = pos - pivot_pos
-        # Wandle den Drehwinkel in Bogenmaß um
-        rad = math.radians(delta_angle)
-        cos_val = math.cos(rad)
-        sin_val = math.sin(rad)
-        # Drehe den relativen Vektor
-        new_x = rel.getX() * cos_val - rel.getY() * sin_val
-        new_y = rel.getX() * sin_val + rel.getY() * cos_val
-        new_rel = Vec3(new_x, new_y, rel.getZ())
-        # Neue globale Fahrzeugposition
-        new_pos = pivot_pos + new_rel
-        vehicle.setPos(new_pos)
-        # Aktualisiere auch das Heading des Fahrzeugs (aufaddieren des Drehwinkels)
-        vehicle.setH(vehicle.getH() + delta_angle)
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    # ---------------6. Paket- & Auftragsverwaltung---------------
-        # Beispiel einer Methode, die weiterhin auf die extrahierten Umgebungselemente zugreift:
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Je nach gewählter Verteilung kannst du hier Anpassungen vornehmen.
-        # Für den Moment wählen wir einfach zufällig aus allen Abgabestationen,
-        # falls keine spezielle Logik für die Verteilung implementiert ist.
-        target_index = random.randint(1, len(self.abgabe_stations))
-
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def check_and_spawn_packages(self, task):
-        # Verwende den neuen Delay-Wert aus den Einstellungen
-        spawn_delay = self.package_spawn_delay
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-        # Beispiel für eine vorhandene Methode, die auf die Umgebungselemente zugreift:
-    def update_order_table(self):
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen die Stationsnummer (oder verwende "N/A").
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z.B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige den zugewiesenen Fahrzeugnamen an (oder "-" falls noch keiner zugeordnet wurde).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END,
-                                   values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if hasattr(self, 'order_win') and self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                break
-
-    # ---------------7. Cargo-Handling (Pickup, Drop & Timer)---------------
-    def pickup_package(self, vehicle, station):
-        # Falls das Fahrzeug bereits ein Paket trägt, abbrechen.
-        if vehicle.getPythonTag("package_attached"):
-            return
-
-        # Führe den Pickup nur aus, wenn an der Station ein Paket vorhanden ist.
-        if station in self.pickup_packages:
-            # Hole das Paket, den Spawn-Zeitpunkt und den zugehörigen Timer-Knoten.
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            # Entferne den Timer-Knoten, sodass der angezeigte Zähler nicht weiter aktualisiert wird.
-            timer_np.removeNode()
-            # Berechne die Liegedauer (Differenz zwischen aktueller Simulationszeit und Spawn-Zeit).
-            dwell_time = self.sim_clock - spawn_time
-            # Aktualisiere globale Kennzahlen.
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Suche in den Aufträgen nach dem Auftrag, dessen Paket mit diesem Paket übereinstimmt,
-            # und speichere den errechneten Endwert (fixe Liegedauer) sowie den Status.
-            for order_id, order in self.orders.items():
-                if order.get("package") == package:
-                    order["dwell_time"] = dwell_time
-                    order["status"] = "Abgeholt"
-                    break
-
-            # Hole Referenzen zum Gabel-Knoten und zum grünen Marker des Fahrzeugs.
-            fork_node = vehicle.getPythonTag("fork_node")
-            fork_green = vehicle.getPythonTag("fork_green")
-            green_point_pos = fork_green.getPos(fork_node)
-
-            # Übergib das Paket an den Gabel-Knoten (sodass es optisch dem Fahrzeug zugeordnet wird)
-            # und positioniere es relativ zum grünen Marker.
-            package.wrtReparentTo(fork_node)
-            package.setPos(green_point_pos.getX() + 0.5,
-                           green_point_pos.getY() + 0,
-                           green_point_pos.getZ() + 1)
-            self.cargos[vehicle] = package
-
-            # Starte den Lieferzeit-Timer: Speichere den Zeitpunkt, an dem das Paket abgeholt wurde,
-            # und hänge einen neuen Timer-Knoten an das Paket.
-            vehicle.setPythonTag("delivery_start_time", self.sim_clock)
-            from panda3d.core import TextNode
-            delivery_timer_text = TextNode("delivery_timer")
-            delivery_timer_text.setText("0.0s")
-            delivery_timer_np = package.attachNewNode(delivery_timer_text)
-            delivery_timer_np.setScale(0.5)
-            delivery_timer_np.setPos(0, 0, 1.2)
-            package.setPythonTag("delivery_timer", delivery_timer_np)
-
-            # Aktualisiere den Zeitpunkt, zu dem an dieser Station zuletzt ein Paket entfernt wurde.
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-
-            # Berechne Lieferzeit:
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start is not None:
-                delivery_time = self.sim_clock - delivery_start
-                self.total_delivery_time += delivery_time
-                self.total_delivery_count += 1
-                self.max_overall_delivery_time = max(self.max_overall_delivery_time, delivery_time)
-                vehicle.clearPythonTag("delivery_start_time")
-
-            # Entferne den Lieferzeit-Timer vom Paket
-            delivery_timer_np = cargo.getPythonTag("delivery_timer")
-            if delivery_timer_np:
-                delivery_timer_np.removeNode()
-
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden das Paket entfernt
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def update_delivery_timers(self, task):
-        for vehicle, package in list(self.cargos.items()):
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start:
-                elapsed_delivery = self.sim_clock - delivery_start
-                delivery_timer_np = package.getPythonTag("delivery_timer")
-                if delivery_timer_np and not delivery_timer_np.isEmpty():
-                    delivery_timer_np.node().setText(f"{elapsed_delivery:.1f}s")
-        return Task.cont
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-
-    # ---------------8. Auftrags-/Fahrzeuglogik---------------
-    def select_next_order(self, vehicle):
-        # Sammle alle Aufträge, die noch "Wartend" sind
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        # Aktualisiere die Dwell-Zeit für jeden Auftrag
-        for order in waiting_orders:
-            order["dwell_time"] = self.sim_clock - order.get("spawn_time", self.sim_clock)
-
-        # Wähle den Auftrag mit der maximalen Dwell-Zeit (evtl. mit etwas Toleranz)
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        # Finde aus den Kandidaten den Auftrag, dessen Pickup-Station (order["pickup_station"])
-        # am nächsten zur aktuellen Fahrzeugposition liegt.
-        vehicle_pos = vehicle.getPos(self.render)
-        candidates.sort(key=lambda order: (order["pickup_station"].getPos(self.render) - vehicle_pos).length())
-        return candidates[0]
-
-    def show_vehicle_control(self):
-        # Falls das Fenster bereits existiert, wiederverwenden
-        if hasattr(self, "control_win") and self.control_win.winfo_exists():
-            self.control_win.deiconify()
-            self.control_win.lift()
-            self.control_win.focus_force()
-            return
-
-        self.control_win = tk.Toplevel(self.tk_root)
-        self.control_win.title("Kontrollfenster")
-        self.control_win.protocol("WM_DELETE_WINDOW", self.control_win.withdraw)
-        self.control_win.attributes("-topmost", True)
-        self.control_win.after(100, lambda: self.control_win.attributes("-topmost", False))
-
-        # ---------------- Fahrzeugsteuerung ----------------
-        # Zunächst einen Button einfügen, der ALLE Fahrzeuge auf "Aufträge bearbeiten" setzt.
-        all_vehicles_btn = tk.Button(
-            self.control_win,
-            text="Alle Fahrzeuge auf 'Aufträge bearbeiten' setzen",
-            command=lambda: [self.vehicle_state_vars[veh].set("translate") for veh in self.garage_vehicles]
-        )
-        all_vehicles_btn.grid(row=0, column=0, sticky="w", padx=5, pady=5)
-
-        # Nun die einzelnen Fahrzeugzeilen – starte ab Zeile 1
-        self.vehicle_state_vars = {}
-        row = 1
-        for veh in self.garage_vehicles:
-            frame = tk.Frame(self.control_win)
-            frame.grid(row=row, column=0, sticky="w", padx=5, pady=2)
-            vid = veh.getPythonTag("vehicle_id")
-            label = tk.Label(frame, text=f"Fahrzeug {vid}")
-            label.pack(side=tk.LEFT)
-            state = veh.getPythonTag("order_state") or "idle"
-            var = tk.StringVar(value=state)
-            self.vehicle_state_vars[veh] = var
-            rb_active = tk.Radiobutton(frame, text="Aufträge bearbeiten", variable=var, value="translate")
-            rb_active.pack(side=tk.LEFT)
-            rb_standby = tk.Radiobutton(frame, text="Standby", variable=var, value="idle")
-            rb_standby.pack(side=tk.LEFT)
-            row += 1
-
-        update_btn = tk.Button(self.control_win, text="Übernehmen", command=self.update_vehicle_control)
-        update_btn.grid(row=row, column=0, pady=5)
-        row += 1
-
-        # ---------------- Spawn-Einstellungen ----------------
-        spawn_frame = tk.LabelFrame(self.control_win, text="Spawn Einstellungen", padx=5, pady=5)
-        spawn_frame.grid(row=row, column=0, sticky="w", padx=5, pady=5)
-
-        # Eingabe der Spawnverzögerung
-        tk.Label(spawn_frame, text="Spawnverzögerung (Sekunden):").grid(row=0, column=0, sticky="w")
-        self.spawn_delay_var = tk.DoubleVar(value=self.package_spawn_delay)
-        delay_entry = tk.Entry(spawn_frame, textvariable=self.spawn_delay_var, width=6)
-        delay_entry.grid(row=0, column=1, sticky="w")
-
-        # Direkt in diesem Spawn-Feld: Button, der alle Annahmestationen auswählt
-        btn_select_all_stations = tk.Button(
-            spawn_frame,
-            text="Alle Annahmestationen auswählen",
-            command=lambda: [self.spawn_station_vars[i].set(True) for i in self.spawn_station_vars]
-        )
-        btn_select_all_stations.grid(row=0, column=2, padx=5)
-
-        # Auswahl der Annahmestationen (Checkbuttons)
-        tk.Label(spawn_frame, text="Annahmestationen:").grid(row=1, column=0, sticky="w", pady=(5, 0))
-        stations_frame = tk.Frame(spawn_frame)
-        stations_frame.grid(row=2, column=0, columnspan=3, sticky="w")
-        for i in range(min(10, len(self.annahme_stations))):
-            cb = tk.Checkbutton(stations_frame, text=f"Annahmestation {i + 1}",
-                                variable=self.spawn_station_vars[i])
-            cb.pack(anchor="w")
-
-        def apply_spawn_from_control():
-            self.package_spawn_delay = self.spawn_delay_var.get()
-            selected = []
-            for i, var in self.spawn_station_vars.items():
-                if var.get():
-                    selected.append(self.annahme_stations[i])
-            self.package_spawn_stations = selected
-            # Spawne nur an Stationen, an denen noch kein Paket existiert:
-            for station in self.package_spawn_stations:
-                if station not in self.pickup_packages:
-                    self.spawn_package_at_station(station)
-            # Option: spawn_win schließen oder offen lassen
-            # self.control_win.withdraw()
-
-        apply_btn = tk.Button(
-            spawn_frame,
-            text="Einstellungen übernehmen und spawnen",
-            command=apply_spawn_from_control
-        )
-        apply_btn.grid(row=3, column=0, columnspan=3, pady=5)
-
-    def show_spawn_control(self):
-        spawn_win = tk.Toplevel(self.tk_root)
-        spawn_win.title("Paketspawn Einstellungen")
-
-        # Eingabefeld für Spawnverzögerung
-        tk.Label(spawn_win, text="Spawnverzögerung (Sekunden):").pack(pady=2)
-        delay_entry = tk.Entry(spawn_win)
-        delay_entry.insert(0, str(self.package_spawn_delay))
-        delay_entry.pack(pady=2)
-
-        # (Dropdown für Spawn-Verteilung wurde entfernt)
-
-        # Checkbuttons für die Auswahl der Annahmestationen
-        tk.Label(spawn_win, text="Annahmestationen auswählen (1-10):").pack(pady=2)
-        stations_frame = tk.Frame(spawn_win)
-        stations_frame.pack(pady=2)
-
-        station_vars = {}
-        for idx, station in enumerate(self.annahme_stations):
-            var = tk.BooleanVar(value=False)
-            station_label = f"Annahmestation {idx + 1}"
-            cb = tk.Checkbutton(stations_frame, text=station_label, variable=var)
-            cb.pack(anchor="w")
-            station_vars[idx] = var
-
-        def apply_spawn_settings():
-            try:
-                new_delay = float(delay_entry.get())
-            except ValueError:
-                new_delay = self.package_spawn_delay
-            new_stations = []
-            for idx, var in station_vars.items():
-                if var.get():
-                    new_stations.append(self.annahme_stations[idx])
-
-            self.package_spawn_delay = new_delay
-            self.package_spawn_stations = new_stations
-
-            # Spawne nur dort Pakete, wo noch kein Paket vorhanden ist:
-            for station in self.package_spawn_stations:
-                if station not in self.pickup_packages:
-                    self.spawn_package_at_station(station)
-
-            spawn_win.destroy()
-
-        tk.Button(spawn_win, text="Einstellungen speichern", command=apply_spawn_settings).pack(pady=5)
-
-    def vehicle_in_collision(self, vehicle):
-        """
-        Prüft, ob das angegebene Fahrzeug in einer Kollision mit einem anderen Fahrzeug liegt.
-        Verwendet dafür die bereits vorhandene Methode check_collisions.
-        """
-        collisions = self.check_collisions()
-        for pair in collisions:
-            if vehicle in pair:
-                return True
-        return False
-
-    import concurrent.futures
-    import numpy as np
-
-    def vehicle_order_task(self, vehicle, task):
-        import numpy as np  # NumPy importieren, damit np bekannt ist
-
-        # Skalierter Zeitschritt
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        state = vehicle.getPythonTag("order_state")
-        if state is None or state == "idle":
-            return task.cont
-
-        # Frame-Zähler zur Frequenzsteuerung
-        frame_count = vehicle.getPythonTag("frame_count") or 0
-        frame_count += 1
-        vehicle.setPythonTag("frame_count", frame_count)
-
-        model_delta_angle = 0.0
-        # Führe die Modellinferenz nur alle 30 Frames aus.
-        if self.tf_model is not None and (frame_count % 30 == 0):
-            sensor_data = self.collect_sensor_data(vehicle)
-            # Sicherstellen, dass sensor_data die Form (20,20,1) hat:
-            if sensor_data.ndim == 2:
-                sensor_data = np.expand_dims(sensor_data, axis=-1)
-            if sensor_data.ndim == 3:
-                input_data = np.expand_dims(sensor_data, axis=0)  # Form: (1,20,20,1)
-            elif sensor_data.ndim == 4:
-                input_data = sensor_data
-            else:
-                raise ValueError("Unbekannte Eingabeform – es werden Daten der Form (20,20,1) erwartet.")
-
-            # Asynchroner Aufruf der Inferenz: Erstelle (einmal) einen ThreadPoolExecutor, falls noch nicht vorhanden.
-            if not hasattr(self, "tf_executor"):
-                import concurrent.futures
-                self.tf_executor = concurrent.futures.ThreadPoolExecutor(max_workers=4)
-
-            if not vehicle.hasPythonTag("tf_future"):
-                future = self.tf_executor.submit(self.tf_model.predict, input_data)
-                vehicle.setPythonTag("tf_future", future)
-            else:
-                future = vehicle.getPythonTag("tf_future")
-                if future.done():
-                    try:
-                        result = future.result()
-                        model_delta_angle = result[0][0]
-                    except Exception:
-                        model_delta_angle = 0.0
-                    vehicle.clearPythonTag("tf_future")
-                else:
-                    model_delta_angle = 0.0
-
-        # Berechne den idealen Korrekturwinkel
-        ideal_correction = self.compute_ideal_steering_correction(vehicle)
-
-        if state == "translate" and (frame_count % 30 == 0):
-            sensor_data = self.collect_sensor_data(vehicle)
-            self.log_training_sample(sensor_data, ideal_correction)
-
-        # Aufruf zustandsabhängiger Handler
-        if state == "translate":
-            self.handle_translate_phase(vehicle, dt)
-        elif state == "rotate":
-            self.handle_rotate_phase(vehicle, dt)
-        elif state == "approach":
-            self.handle_approach_phase(vehicle, dt)
-        elif state == "pickup":
-            self.handle_pickup_phase(vehicle, dt)
-        elif state == "drive_out":
-            self.handle_drive_out_phase(vehicle, dt)
-        elif state == "to_delivery":
-            self.handle_to_delivery_phase(vehicle, dt)
-        elif state == "align_delivery":
-            self.handle_align_delivery_phase(vehicle, dt)
-        elif state == "delivery_center":
-            self.handle_delivery_center_phase(vehicle, dt)
-        elif state == "drop":
-            self.handle_drop_phase(vehicle, dt)
-        elif state == "delivery_exit":
-            self.handle_drive_out_phase_delivery(vehicle, dt)
-        elif state == "return_to_garage":
-            self.handle_return_to_garage_phase(vehicle, dt)
-        else:
-            vehicle.setPythonTag("order_state", "translate")
-
-        # Kollisionsprüfung: Nur alle 2 Frames ausführen.
-        if frame_count % 2 == 0:
-            colliding = False
-            collision_duration = 0.0
-            for pair in self.check_collisions():
-                if vehicle in pair:
-                    colliding = True
-                    if not vehicle.hasPythonTag("collision_start_time"):
-                        vehicle.setPythonTag("collision_start_time", self.sim_clock)
-                    else:
-                        collision_duration = self.sim_clock - vehicle.getPythonTag("collision_start_time")
-                    break
-            if not colliding and vehicle.hasPythonTag("collision_start_time"):
-                vehicle.clearPythonTag("collision_start_time")
-
-            if not colliding or collision_duration < 0.1:
-                rating = 10
-                avoidance_angle = 0.0
-            elif collision_duration < 0.3:
-                rating = -10
-                avoidance_angle = self.compute_avoidance_angle(vehicle)
-            elif collision_duration < 1.0:
-                rating = -15
-                avoidance_angle = self.compute_avoidance_angle(vehicle)
-            else:
-                rating = -20
-                avoidance_angle = self.compute_avoidance_angle(vehicle)
-
-            if colliding:
-                ideal_correction += avoidance_angle
-                adjusted_speed = self.collision_avoidance_adjustment(vehicle, base_speed=1.5)
-            else:
-                adjusted_speed = 1.5
-
-            if self.graph_queue is not None:
-                try:
-                    self.graph_queue.put(("rating", vehicle.getPythonTag("vehicle_id"), self.sim_clock, rating),
-                                         block=False)
-                except Exception:
-                    pass
-
-        # Begrenze die Fahrzeugposition auf das Spielfeld.
-        pos = vehicle.getPos(self.render)
-        min_x, max_x = -68, 68
-        min_y, max_y = -68, 68
-        vehicle.setPos(
-            max(min_x, min(pos.getX(), max_x)),
-            max(min_y, min(pos.getY(), max_y)),
-            pos.getZ()
-        )
-
-        return task.cont
-
-    # -------------------- Handler für einzelne Phasen --------------------
-
-    def handle_translate_phase(self, vehicle, dt):
-        import math
-        from panda3d.core import Vec3
-        current_order = vehicle.getPythonTag("current_order")
-        station_occupied = False
-        if current_order is not None and "pickup_station" in current_order:
-            pickup_station = current_order["pickup_station"]
-            occupant = pickup_station.getPythonTag("occupied_by")
-            if occupant is None:
-                pickup_station.setPythonTag("occupied_by", vehicle)
-
-            elif occupant != vehicle:
-                station_occupied = True
-        base_speed = 1.5 if not station_occupied else 0.0
-        adjusted_speed = self.collision_avoidance_adjustment(vehicle, base_speed)
-        if current_order is None:
-            next_order = self.select_next_order(vehicle)
-            if next_order is not None:
-                next_order["status"] = "In Bearbeitung"
-                next_order["vehicle"] = f"Fahrzeug {vehicle.getPythonTag('vehicle_id')}"
-                vehicle.setPythonTag("current_order", next_order)
-            current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None:
-            pickup_station = current_order.get("pickup_station")
-            if pickup_station in self.station_blue_dots:
-                target = self.station_blue_dots[pickup_station].getPos(self.render)
-            else:
-                target = self.blue_dot.getPos(self.render)
-        else:
-            target = self.blue_dot.getPos(self.render)
-        current_pos = vehicle.getPos(self.render)
-        pivot = vehicle.getPythonTag("steering_axis")
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-        heading_error = desired_heading_rad - current_heading_rad
-        while heading_error > math.pi:
-            heading_error -= 2 * math.pi
-        while heading_error < -math.pi:
-            heading_error += 2 * math.pi
-        gain = 1.0
-        max_delta = gain * dt
-        delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-        self.rotate_around_pivot(vehicle, pivot, math.degrees(delta_heading_rad))
-        global_hpr = pivot.getNetTransform().getHpr()
-        new_heading_rad = math.radians(global_hpr.getX())
-        new_x = current_pos.getX() + adjusted_speed * math.cos(new_heading_rad) * dt
-        new_y = current_pos.getY() + adjusted_speed * math.sin(new_heading_rad) * dt
-        new_pos = Vec3(new_x, new_y, 0)
-        vehicle.setPos(new_pos)
-        new_offset_pos = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        if (target - new_offset_pos).length() < 0.1:
-            vehicle.setPythonTag("order_state", "rotate")
-        return Task.cont
-
-    def handle_rotate_phase(self, vehicle, dt):
-        import math
-        from panda3d.core import Vec3  # Nur Vec3 importieren, Task nicht
-
-        # 1. Hole den grünen Referenzpunkt (fork_green) der Gabel.
-        fork_green = vehicle.getPythonTag("fork_green")
-        if not fork_green or fork_green.isEmpty():
-            return Task.cont
-
-        # 2. Hole den aktuellen Auftrag und die zugehörige Pickup-Station.
-        current_order = vehicle.getPythonTag("current_order")
-        if not current_order or "pickup_station" not in current_order:
-            return Task.cont
-        station = current_order["pickup_station"]
-
-        # Hole den Referenzpunkt der Station (white_center) und prüfe auf den Richtungsvektor (optional)
-        white_center = station.getPythonTag("white_center")
-        if white_center is None:
-            return Task.cont
-        target = white_center  # Das Ziel ist der Mittelpunkt der weißen Linie
-
-        # 3. Berechne den Drehpunkt des Fahrzeugs.
-        pivot = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-
-        # 4. Wenn der Abstand vom Pivot zum Ziel sehr gering ist, setze die exakte Ausrichtung.
-        distance = (target - pivot).length()
-        stop_threshold = 0.5  # Schwellenwert – je nach Modelldimension anpassen
-        if distance < stop_threshold:
-            desired_vector = target - pivot
-            desired_angle = (math.degrees(math.atan2(desired_vector.getY(), desired_vector.getX())) + 90) % 360
-            vehicle.setH(self.render, desired_angle)
-            # Richte den grünen Richtungspfeil (fork_center_line) aus, falls vorhanden.
-            white_direction = station.getPythonTag("white_direction")
-            if white_direction is not None:
-                desired_arrow_angle = math.degrees(math.atan2(white_direction.getY(), white_direction.getX()))
-                arrow_relative = (desired_arrow_angle - desired_angle + 180) % 360 - 180
-                fork_center_line = vehicle.getPythonTag("fork_center_line")
-                if fork_center_line:
-                    fork_center_line.setH(arrow_relative)
-            vehicle.setPythonTag("order_state", "approach")
-            return Task.cont
-
-        # 5. Berechne den gewünschten globalen Winkel vom Pivot zum Ziel (inklusive +90°-Offset).
-        desired_vector = target - pivot
-        desired_angle = (math.degrees(math.atan2(desired_vector.getY(), desired_vector.getX())) + 90) % 360
-
-        # 6. Ermittle den aktuellen Fahrzeugheading in Weltkoordinaten und berechne die Differenz.
-        current_heading = vehicle.getH(self.render)
-        angle_diff = (desired_angle - current_heading + 180) % 360 - 180
-
-        if abs(angle_diff) < 2.0:
-            vehicle.setH(self.render, desired_angle)
-            white_direction = station.getPythonTag("white_direction")
-            if white_direction is not None:
-                desired_arrow_angle = math.degrees(math.atan2(white_direction.getY(), white_direction.getX()))
-                arrow_relative = (desired_arrow_angle - desired_angle + 180) % 360 - 180
-                fork_center_line = vehicle.getPythonTag("fork_center_line")
-                if fork_center_line:
-                    fork_center_line.setH(arrow_relative)
-            vehicle.setPythonTag("order_state", "approach")
-            return Task.cont
-
-        # 7. Begrenze den Drehwinkel pro Frame.
-        max_rotation_speed = 20.9  # Grad pro Sekunde
-        max_delta = max_rotation_speed * dt
-        delta_angle = max(-max_delta, min(max_delta, angle_diff))
-
-        # 8. Drehe das Fahrzeug schrittweise um delta_angle über einen temporären Pivot.
-        temp_pivot = self.render.attachNewNode("temp_pivot")
-        temp_pivot.setPos(pivot)
-        self.rotate_around_pivot(vehicle, temp_pivot, delta_angle)
-        temp_pivot.removeNode()
-
-        return Task.cont
-
-    def handle_approach_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None:
-            pickup_station = current_order.get("pickup_station")
-            target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-        else:
-            target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-        current = vehicle.getPos(self.render)
-        error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-        if error_vec.length() > 0.05:
-            direction = error_vec.normalized()
-            move_distance = 1.5 * dt
-            new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                           current.getY() + direction.getY() * move_distance, target.getZ())
-            vehicle.setPos(new_pos)
-        else:
-            vehicle.setPos(target)
-            vehicle.setPythonTag("order_state", "pickup")
-
-    def handle_pickup_phase(self, vehicle, dt):
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        target_z = 1.0
-        raise_speed = 0.5
-        if current_z < target_z:
-            fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-        else:
-            if vehicle.getPythonTag("current_order") is None:
-                if self.orders_queue:
-                    vehicle.setPythonTag("current_order", self.orders_queue.pop(0))
-                else:
-                    vehicle.setPythonTag("order_state", "drive_out")
-                    return
-            if not vehicle.getPythonTag("package_attached"):
-                pickup_station = vehicle.getPythonTag("current_order")["pickup_station"]
-                self.pickup_package(vehicle, pickup_station)
-                vehicle.setPythonTag("package_attached", True)
-            if vehicle.getPythonTag("drive_out_target") is None:
-                vehicle.setPythonTag("drive_out_target",
-                                     vehicle.getPos(self.render) + vehicle.getQuat(self.render).getForward() * 5.0)
-            vehicle.setPythonTag("order_state", "drive_out")
-
-    def handle_drive_out_phase(self, vehicle, dt):
-        from panda3d.core import Vec3
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        if current_z > 0:
-            lower_speed = 0.5
-            fork_node.setZ(max(0, current_z - lower_speed * dt))
-        current_pos = vehicle.getPos(self.render)
-        drive_out_target = vehicle.getPythonTag("drive_out_target")
-        if drive_out_target is None:
-            drive_out_target = current_pos + vehicle.getQuat(self.render).getForward() * 5.0
-            vehicle.setPythonTag("drive_out_target", drive_out_target)
-        diff = drive_out_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            # Sobald das Fahrzeug seinen Drive-Out erreicht hat, geben wir den Lock an der Pickup-Station frei
-            current_order = vehicle.getPythonTag("current_order")
-            if current_order is not None and "pickup_station" in current_order:
-                pickup_station = current_order["pickup_station"]
-                # Ersetze clearPythonTag durch setPythonTag(..., None) für die Freigabe
-                pickup_station.setPythonTag("occupied_by", None)
-            vehicle.setPythonTag("order_state", "to_delivery")
-            vehicle.setPythonTag("drive_out_target", None)
-        return Task.cont
-
-    def handle_to_delivery_phase(self, vehicle, dt):
-        import math
-        from panda3d.core import Vec3
-
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is None:
-            return Task.cont
-
-        # Bestimme den Zielindex aus dem String (z.B. "Abgabestation 3")
-        try:
-            target_index = int(current_order.get("ziel", "Abgabestation 1").split()[-1])
-        except Exception:
-            target_index = 1
-
-        # Statt direkt die Position abzufragen, verweisen wir auf den gesamten NodePath
-        if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-            delivery_station = self.abgabe_blue_dots[target_index - 1]
-        else:
-            delivery_station = self.abgabe_blue_dots[0]
-
-        # Jetzt holen wir die Position vom NodePath
-        target = delivery_station.getPos(self.render)
-        current_pos = vehicle.getPos(self.render)
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-
-        # Prüfe, ob an der Abgabestation bereits ein Fahrzeug blockiert:
-        if self.is_delivery_station_occupied(delivery_station, exclude_vehicle=vehicle):
-            return Task.cont
-
-        # Berechne den gewünschten Basiswinkel vom Offset-Punkt zum Ziel.
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-        pivot = vehicle.getPythonTag("steering_axis")
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-        heading_error = desired_heading_rad - current_heading_rad
-        while heading_error > math.pi:
-            heading_error -= 2 * math.pi
-        while heading_error < -math.pi:
-            heading_error += 2 * math.pi
-
-        gain = 1.0
-        max_delta = gain * dt
-        delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-        self.rotate_around_pivot(vehicle, pivot, math.degrees(delta_heading_rad))
-
-        global_hpr = pivot.getNetTransform().getHpr()
-        new_heading_rad = math.radians(global_hpr.getX())
-        adjusted_speed = self.collision_avoidance_adjustment(vehicle, base_speed=1.5)
-        new_x = current_pos.getX() + adjusted_speed * math.cos(new_heading_rad) * dt
-        new_y = current_pos.getY() + adjusted_speed * math.sin(new_heading_rad) * dt
-        new_pos = Vec3(new_x, new_y, current_pos.getZ())
-        vehicle.setPos(new_pos)
-
-        new_offset_pos = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        if (target - new_offset_pos).length() < 0.1:
-            vehicle.setPythonTag("order_state", "align_delivery")
-        return Task.cont
-
-    def handle_align_delivery_phase(self, vehicle, dt):
-        import math
-        from panda3d.core import Vec3
-
-        # 1. Ermittle den Basiszielwinkel aus der weißen Linie der Abgabestation.
-        try:
-            base_target_heading = self.abgabe_white_line.getH(self.render) % 360
-        except Exception as e:
-            base_target_heading = 90.0
-
-        # 2. Berechne den gewünschten Endwinkel.
-        # Ursprünglich wurde desired_heading so gesetzt:
-        #    (base_target_heading + 90 + 180) % 360
-        # Um 90° mehr gegen den Uhrzeigersinn zu drehen, addieren wir zusätzlich 90°:
-        desired_heading = (base_target_heading + 90 + 180 + 90) % 360
-        # Das entspricht (base_target_heading + 360) % 360, also einfach:
-        desired_heading = base_target_heading % 360
-
-        # 3. Berechne den Pivot-Punkt so wie in handle_rotate_phase,
-        # damit das Fahrzeug auf der Stelle rotiert.
-        pivot = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-
-        # 4. Ermittle den aktuellen globalen Heading des Fahrzeugs.
-        current_heading = vehicle.getH(self.render) % 360
-
-        # 5. Berechne den minimalen Winkelunterschied (normiert auf [-180, 180]).
-        error = (desired_heading - current_heading + 180) % 360 - 180
-
-
-        # 6. Wenn der Fehler sehr klein ist (< 1°), setze den Endwinkel und wechsle in den nächsten Zustand.
-        if abs(error) < 1.0:
-            vehicle.setH(self.render, desired_heading)
-            vehicle.setPythonTag("order_state", "delivery_center")
-            return Task.cont
-
-        # 7. Begrenze den Drehschritt basierend auf einer maximalen Drehgeschwindigkeit.
-        turn_speed = 90.0  # Grad pro Sekunde
-        max_turn = turn_speed * dt
-        turn_angle = max(-max_turn, min(max_turn, error))
-
-        # 8. Rotiere das Fahrzeug schrittweise um turn_angle mit Hilfe eines temporären Pivots.
-        temp_pivot = self.render.attachNewNode("temp_pivot")
-        temp_pivot.setPos(pivot)
-        self.rotate_around_pivot(vehicle, temp_pivot, turn_angle)
-        temp_pivot.removeNode()
-
-        return Task.cont
-
-    def handle_delivery_center_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is None:
-            return
-        delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-        try:
-            target_index = int(delivery_target_str.split()[-1])
-        except ValueError:
-            target_index = 1
-        if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-            blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-        else:
-            blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-        current = vehicle.getPos(self.render)
-        target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-        error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-        tolerance = 0.05
-        move_distance = 1.5 * dt
-        if error_vec.length() > tolerance:
-            direction = error_vec.normalized()
-            new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                           current.getY() + direction.getY() * move_distance, current.getZ())
-            vehicle.setPos(new_pos)
-        else:
-            vehicle.setPos(target_point)
-            vehicle.setPythonTag("order_state", "drop")
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_fork_z = fork_node.getZ()
-        if current_fork_z < 1.0:
-            new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-            fork_node.setZ(new_fork_z)
-
-    def handle_drop_phase(self, vehicle, dt):
-        # Falls das Fahrzeug ein Paket trägt, wird dieses abgesetzt.
-        if vehicle.getPythonTag("package_attached"):
-            self.drop_cargo(vehicle)
-            vehicle.setPythonTag("package_attached", False)
-        else:
-            # Falls die Gabel noch abgesenkt werden muss:
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            if current_z > 0:
-                lower_speed = 0.5
-                fork_node.setZ(max(0, current_z - lower_speed * dt))
-
-        # Setze den Zustand nun auf "delivery_exit", damit das Fahrzeug aus dem Lieferbereich herausfährt.
-        vehicle.setPythonTag("order_state", "delivery_exit")
-        # Optional: den Auftrag als "Abgegeben" markieren und löschen.
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None:
-            current_order["status"] = "Abgegeben"
-            current_order["delivered_at"] = self.sim_clock
-        vehicle.clearPythonTag("current_order")
-
-        return Task.cont
-
-    def handle_drive_out_phase_delivery(self, vehicle, dt):
-        from panda3d.core import Vec3
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        if current_z > 0:
-            lower_speed = 0.5
-            fork_node.setZ(max(0, current_z - lower_speed * dt))
-        current_pos = vehicle.getPos(self.render)
-        drive_out_target = vehicle.getPythonTag("drive_out_target")
-        if drive_out_target is None:
-            drive_out_target = current_pos + vehicle.getQuat(self.render).getForward() * 5.0
-            vehicle.setPythonTag("drive_out_target", drive_out_target)
-        diff = drive_out_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            # Sobald das Fahrzeug seinen Drive-Out im Lieferbereich erreicht hat, geben wir den Lock frei
-            current_order = vehicle.getPythonTag("current_order")
-            if current_order is not None:
-                try:
-                    target_index = int(current_order.get("ziel", "Abgabestation 1").split()[-1])
-                except Exception:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_stations):
-                    delivery_station = self.abgabe_stations[target_index - 1]
-                else:
-                    delivery_station = self.abgabe_stations[0]
-                # Freigabe des Locks an der Delivery-Station
-                delivery_station.setPythonTag("occupied_by", None)
-            vehicle.setPythonTag("order_state", "translate")
-            vehicle.setPythonTag("drive_out_target", None)
-        return Task.cont
-
-    def handle_phase11(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if vehicle.getPythonTag("last_delivery_marker") is not None:
-            target_point = vehicle.getPythonTag("last_delivery_marker")
-        else:
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                target_point = self.abgabe_blue_dots[0].getPos(self.render)
-        current_pos = vehicle.getPos(self.render)
-        diff = target_point - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            vehicle.setPos(new_pos)
-        else:
-            vehicle.setPos(target_point)
-            vehicle.setPythonTag("order_state", "next_order")
-
-    def handle_return_to_garage_phase(self, vehicle, dt):
-        garage_target = vehicle.getPythonTag("garage_target")
-        if garage_target is None:
-            garage_target = self.garagen_parking_points[0]
-        current_pos = vehicle.getPos(self.render)
-        diff = garage_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 1.0 * dt
-            new_pos = current_pos + diff.normalized() * move_distance
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            if vehicle.hasPythonTag("start_heading"):
-                vehicle.setH(vehicle.getPythonTag("start_heading"))
-            vehicle.setPythonTag("order_state", "idle")
-            vehicle.setPythonTag("standby_pending", False)
-
-    def collect_sensor_data(self, vehicle, sensor_range=5, grid_resolution=0.5):
-        """
-        Erzeugt ein einfaches 2D-Occupancy-Grid, das den Bereich um das Fahrzeug simuliert.
-
-        Parameter:
-          sensor_range: Radius (in Welt-Einheiten) um das Fahrzeug.
-          grid_resolution: Größe der einzelnen Zellen im Grid.
-
-        Rückgabe:
-          Ein NumPy-Array (2D) mit 0 (frei) als Platzhalter.
-        """
-        import numpy as np
-        grid_size = int((sensor_range * 2) / grid_resolution)
-        sensor_grid = np.zeros((grid_size, grid_size))
-        # --- Hier kannst du später echte Kollisionsabfragen oder Ray-Casting integrieren ---
-        return sensor_grid
-
-    def compute_ideal_steering_correction(self, vehicle):
-        """
-        Berechnet einen idealen Korrekturwinkel (in Grad) für die Navigation in der 'translate'-Phase.
-        Es wird ein vereinfachtes Modell genutzt, das den Unterschied zwischen dem gewünschten und dem aktuellen
-        Heading (über die Fahrzeug-Steuerachse) ermittelt.
-        """
-        import math
-
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None and "pickup_station" in current_order:
-            pickup_station = current_order["pickup_station"]
-            if pickup_station in self.station_blue_dots:
-                target = self.station_blue_dots[pickup_station].getPos(self.render)
-            else:
-                target = self.blue_dot.getPos(self.render)
-        else:
-            target = self.blue_dot.getPos(self.render)
-
-        current_pos = vehicle.getPos(self.render)
-        # Bestimme einen Offset-Punkt, basierend auf der bereits existierenden pickup_offset
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        # Berechne den gewünschten Heading-Winkel (in Radiant): Richtung von offset_pos zu target
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-
-        # Hole den aktuellen Heading-Wert vom Steuerachsen-Node (pivot)
-        pivot = vehicle.getPythonTag("steering_axis")
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-
-        ideal_correction_rad = desired_heading_rad - current_heading_rad
-        # Winkelbereich anpassen [-pi, pi]
-        while ideal_correction_rad > math.pi:
-            ideal_correction_rad -= 2 * math.pi
-        while ideal_correction_rad < -math.pi:
-            ideal_correction_rad += 2 * math.pi
-
-        return math.degrees(ideal_correction_rad)
-
-    def compute_avoidance_angle(self, current_vehicle, safe_distance=3.0):
-        """
-        Berechnet einen zusätzlichen Ausweichwinkel (in Grad) basierend auf den
-        Positionen anderer Fahrzeuge. Fahrzeuge, die sehr nah sind, sollen einen
-        höheren Einfluss haben. Der Rückgabewert wird mit einem Gewichtungsfaktor
-        multipliziert, sodass der Ausweichimpuls moderat bleibt.
-        """
-        import math
-        from panda3d.core import Vec2
-
-        current_pos = current_vehicle.getPos(self.render)
-        avoidance_vector = Vec2(0, 0)
-
-        # Schleife über alle Fahrzeuge (außer dem eigenen)
-        for other in self.garage_vehicles:
-            if other == current_vehicle:
-                continue
-            other_pos = other.getPos(self.render)
-            diff = Vec2(current_pos.getX() - other_pos.getX(),
-                        current_pos.getY() - other_pos.getY())
-            dist = diff.length()
-            if dist > 0 and dist < safe_distance:
-                # Je näher das Fahrzeug, desto größer der Einfluss (gewichtete Summe)
-                weight = (safe_distance - dist) / safe_distance
-                avoidance_vector += diff.normalized() * weight
-
-        # Falls kein Fahrzeug in der Nähe ist, wird kein Ausweichwinkel angewendet.
-        if avoidance_vector.length() == 0:
-            return 0.0
-
-        # Berechne den Winkel, den der resultierende Ausweichvektor vorgibt.
-        avoidance_angle = math.degrees(math.atan2(avoidance_vector.getY(), avoidance_vector.getX()))
-        # Mit einem Faktor abschwächen, um den Einfluss zu mildern.
-        weight_factor = 0.5  # Passe diesen Faktor bei Bedarf an (0 = kein Ausweichen, 1 = voll)
-        return avoidance_angle * weight_factor
-
-    def log_training_sample(self, sensor_data, ideal_angle):
-        """
-        Speichert ein Trainingssample bestehend aus den gesammelten Sensorwerten und dem idealen Korrekturwinkel.
-        """
-        self.training_data.append((sensor_data.copy(), ideal_angle))
-        # Optional: Gib eine Debug-Ausgabe aus, um das Logging zu überwachen.
-
-    def apply_safety_rules(self, vehicle, sensor_data, model_delta_angle, ideal_correction):
-        """
-        Kombiniert den vom Modell (model_delta_angle) und den ideal berechneten Korrekturwert (ideal_correction)
-        nur dann mit einem festen Sicherheitswert, wenn die Sensordaten einen kritischen Occupancy-Level anzeigen.
-
-        Falls der Occupancy-Level niedrig ist, wird ausschließlich der ideal vorhandene Korrekturwert verwendet.
-        """
-        import numpy as np
-        # Beispiel: Untersuche die mittlere Zeile des sensor_data-Grids als Indikator für frontale Hindernisse
-        middle_row = sensor_data[sensor_data.shape[0] // 2]
-        occupancy_level = np.sum(middle_row)
-
-        # Definiere einen kritischen Schwellenwert (diesen Wert ggf. anpassen)
-        threshold = 1.0
-
-        if occupancy_level > threshold:
-            # Hier legen wir fest, dass in kritischen Situationen der Sicherheitswert stärker gewichtet wird.
-            safety_correction = 15.0  # z. B. 15° als feste Korrektur (Wert anpassen)
-            # Gewichteter Ansatz: Sicherheitskorrektur dominiert, während ein kleiner Anteil des idealen Wertes einfließt.
-            final_angle = 0.7 * safety_correction + 0.3 * ideal_correction
-        else:
-            # Wenn kein kritischer Wert vorliegt, einfach den ideal berechneten Korrekturwert verwenden.
-            final_angle = ideal_correction
-
-        return final_angle
-
-    def collision_avoidance_adjustment(self, current_vehicle, base_speed, safe_distance=3.0):
-        """
-        Berechnet eine angepasste Geschwindigkeit für ein Fahrzeug (current_vehicle), sodass
-        dessen Basisgeschwindigkeit (base_speed) entsprechend reduziert wird, wenn andere Fahrzeuge
-        in der Nähe sind. Wenn der Abstand zu einem anderen Fahrzeug unter 1 Einheit liegt, wird
-        die Geschwindigkeit auf 0 gesetzt.
-
-        Parameter:
-          current_vehicle: Das Fahrzeug, dessen Geschwindigkeit angepasst werden soll.
-          base_speed: Die Basisgeschwindigkeit (ohne Kollisionseffekt).
-          safe_distance: Der Abstand, unterhalb dessen Fahrzeuge ihre Geschwindigkeit reduzieren.
-
-        Rückgabe:
-          Die angepasste Geschwindigkeit.
-        """
-        current_pos = current_vehicle.getPos(self.render)
-        adjusted_speed = base_speed
-        for veh in self.garage_vehicles:
-            if veh == current_vehicle:
-                continue
-            other_pos = veh.getPos(self.render)
-            distance = (current_pos - other_pos).length()
-            if distance < safe_distance:
-                # Wenn Fahrzeuge extrem nahe kommen, wird die Geschwindigkeit auf 0 gesetzt.
-                if distance < 1.0:
-                    candidate_speed = 0.0
-                else:
-                    # Lineare Reduktion: Je näher das Fahrzeug, desto geringer die erlaubte Geschwindigkeit.
-                    candidate_speed = base_speed * (distance / safe_distance)
-                # Wähle den minimalen Wert
-                if candidate_speed < adjusted_speed:
-                    adjusted_speed = candidate_speed
-        return adjusted_speed
-
-    def check_collisions(self):
-        """
-        Prüft, ob Fahrzeuge in Kollisionsnähe liegen.
-        Der Schwellenwert wurde von 1.0 auf 1.5 erhöht, um den tatsächlichen Fahrzeugumfang (statt nur den Ursprung) besser abzubilden.
-        """
-        collision_threshold = 1.5  # Kann bei Bedarf weiter angepasst werden
-        collisions = []
-        for i in range(len(self.garage_vehicles)):
-            veh1 = self.garage_vehicles[i]
-            pos1 = veh1.getPos(self.render)
-            for j in range(i + 1, len(self.garage_vehicles)):
-                veh2 = self.garage_vehicles[j]
-                pos2 = veh2.getPos(self.render)
-                distance = (pos1 - pos2).length()
-                if distance < collision_threshold:
-                    collisions.append((veh1, veh2))
-        return collisions
-
-    def update_rl_on_collisions(self, task):
-        """
-        Diese Methode wird regelmäßig (als Task) aufgerufen und:
-          - Ermittelt alle kollidierenden Fahrzeugpaare über check_collisions().
-          - Baut für jedes Paar in self.collision_start_times die Kollisionsdauer auf.
-          - Falls eine Kollision länger als 5.0 Sekunden anhält, wird der Zustand der beteiligten Fahrzeuge auf "drive_out" gesetzt.
-        """
-        collisions = self.check_collisions()
-        current_time = self.sim_clock
-
-        if not hasattr(self, "collision_start_times"):
-            self.collision_start_times = {}
-
-        current_collision_keys = set()
-        for veh1, veh2 in collisions:
-            key = frozenset({veh1, veh2})
-            current_collision_keys.add(key)
-            if key not in self.collision_start_times:
-                self.collision_start_times[key] = current_time
-            else:
-                duration = current_time - self.collision_start_times[key]
-                # Eine „lang anhaltende“ Kollision (über 5 Sekunden) löst das Aufgeben der Fahrtrichtung aus.
-                if duration > 5.0:
-                    if veh1.getPythonTag("order_state") != "drive_out":
-                        veh1.setPythonTag("order_state", "drive_out")
-                    if veh2.getPythonTag("order_state") != "drive_out":
-                        veh2.setPythonTag("order_state", "drive_out")
-                    if key in self.collision_start_times:
-                        del self.collision_start_times[key]
-
-        # Entferne veraltete Einträge, die nicht mehr kollidieren
-        keys_to_remove = [key for key in self.collision_start_times if key not in current_collision_keys]
-        for key in keys_to_remove:
-            del self.collision_start_times[key]
-
-        return task.cont
-
-    def is_station_occupied(self, station, exclude_vehicle=None, occupancy_threshold=5.0):
-        """
-        Prüft, ob eine Annahmestation momentan belegt ist oder sich in einer 10-Sekunden-Cooldown-Periode befindet,
-        in der die Station für neue Fahrzeuge gesperrt ist. Zusätzlich wird überprüft, ob ein Fahrzeug in einem Umkreis
-        von weniger als 5 Metern zur Station steht.
-        """
-        cooldown_time = 10.0  # Wartezeit in Sekunden
-
-        # 1. Cooldown-Check: Falls an der Station vor Kurzem (innerhalb von 10 Sekunden) ein Fahrzeug gegangen ist.
-        release_time = station.getPythonTag("release_time")
-        if release_time is not None and (self.sim_clock - release_time) < cooldown_time:
-            return True
-
-        # 2. Explizit gesetzter Belegungs-Tag:
-        occupant = station.getPythonTag("occupied_by")
-        if occupant is not None and occupant != exclude_vehicle:
-            return True
-
-        # 3. Fallback: Überprüfe, ob ein Fahrzeug, das die Station als Pickup nutzt, aktuell aktiv ist oder
-        #    ob sich ein Fahrzeug in unmittelbarer Nähe (weniger als occupancy_threshold, hier 5 Meter) befindet.
-        if hasattr(self, 'station_blue_dots') and station in self.station_blue_dots:
-            station_pos = self.station_blue_dots[station].getPos(self.render)
-        else:
-            station_pos = station.getPos(self.render)
-
-        for veh in self.garage_vehicles:
-            if veh == exclude_vehicle:
-                continue
-
-            # Falls das Fahrzeug diese Station als Pickup-Station im Auftrag hat und in einer aktiven Phase ist:
-            current_order = veh.getPythonTag("current_order")
-            if current_order is not None and current_order.get("pickup_station") == station:
-                order_state = veh.getPythonTag("order_state")
-                if order_state not in ["to_delivery", "idle", "next_order"]:
-                    return True
-
-            # Überprüfe, ob sich ein Fahrzeug in einem Abstand von weniger als 5 Metern zur Station befindet.
-            if (veh.getPos(self.render) - station_pos).length() < occupancy_threshold:
-                return True
-
-        return False
-
-    def is_delivery_station_occupied(self, station, exclude_vehicle=None, occupancy_threshold=5.0):
-        """
-        Prüft, ob eine Abgabestation momentan belegt oder noch innerhalb der 10-Sekunden-Cooldown-Periode ist,
-        oder ob sich ein Fahrzeug näher als 5 Meter zur Station befindet.
-        """
-        cooldown_time = 10.0  # Wartezeit in Sekunden
-
-        release_time = station.getPythonTag("release_time")
-        if release_time is not None and (self.sim_clock - release_time) < cooldown_time:
-            return True
-
-        occupant = station.getPythonTag("occupied_by")
-        if occupant is not None and occupant != exclude_vehicle:
-            return True
-
-        station_pos = station.getPos(self.render)
-        for veh in self.garage_vehicles:
-            if veh == exclude_vehicle:
-                continue
-            if (veh.getPos(self.render) - station_pos).length() < occupancy_threshold:
-                return True
-
-        return False
-
-    def compute_collision_duration(self, vehicle):
-        """
-        Berechnet für das angegebene Fahrzeug den maximalen Kollisionszeitraum,
-        basierend auf den in self.collision_start_times gespeicherten Kollisionspaaren.
-        Gibt 0 zurück, wenn das Fahrzeug in keinem Kollisionsereignis beteiligt ist.
-        """
-        durations = []
-        if not hasattr(self, "collision_start_times"):
-            return 0
-        current_time = self.sim_clock
-        for pair, start_time in self.collision_start_times.items():
-            if vehicle in pair:
-                durations.append(current_time - start_time)
-        if durations:
-            return max(durations)
-        return 0
-
-class RLAgent:
-    def __init__(self, state_bins, action_space, learning_rate=0.1, discount_factor=0.9, epsilon=0.2):
-        """
-        state_bins: Tuple oder Liste, um kontinuierliche Zustände zu diskretisieren (z.B. (max_distance, num_bins))
-        action_space: Liste diskreter Aktionen (z.B. [0, 1, 2] --> 0: keine Bremsung, 1: leicht, 2: stark)
-        """
-        self.state_bins = state_bins
-        self.action_space = action_space
-        self.lr = learning_rate
-        self.gamma = discount_factor
-        self.epsilon = epsilon
-        # Initialisiere Q-Tabelle als Dictionary: key: (discretisierter_state), value: Liste von Q-Werten pro Aktion
-        self.q_table = {}
-
-    def discretize_state(self, state):
-        """
-        Nimmt einen Zustandsvektor (z.B. [distance, speed]) und gibt einen diskreten Zustand zurück.
-        Hier ein Beispiel: Falls state[0] = Abstand und state[1] = Geschwindigkeit.
-        """
-        # Beispiel: Wir nehmen an, dass state_bins = ((max_distance, num_bins), (max_speed, num_bins))
-        discrete_state = []
-        for i, (max_val, bins) in enumerate(self.state_bins):
-            # Begrenze state[i] um max_val:
-            val = min(state[i], max_val)
-            bin_size = max_val / bins
-            discrete_state.append(int(val // bin_size))
-        return tuple(discrete_state)
-
-    def select_action(self, state):
-        discrete_state = self.discretize_state(state)
-        if discrete_state not in self.q_table:
-            self.q_table[discrete_state] = [0.0 for _ in self.action_space]
-        # Epsilon-greedy Auswahl:
-        if random.random() < self.epsilon:
-            return random.choice(self.action_space)
-        else:
-            q_values = self.q_table[discrete_state]
-            return self.action_space[np.argmax(q_values)]
-
-    def update(self, state, action, reward, next_state):
-        s = self.discretize_state(state)
-        s_next = self.discretize_state(next_state)
-        if s not in self.q_table:
-            self.q_table[s] = [0.0 for _ in self.action_space]
-        if s_next not in self.q_table:
-            self.q_table[s_next] = [0.0 for _ in self.action_space]
-        a_index = self.action_space.index(action)
-        # Q-Learning Update-Regel:
-        best_next = max(self.q_table[s_next])
-        self.q_table[s][a_index] += self.lr * (reward + self.gamma * best_next - self.q_table[s][a_index])
-
-    def preprocess_input_data(input_data):
-        """
-        Transformiert die Eingabedaten von der Form (batch_size, 20, 20, 1)
-        in einen Tensor der Form (batch_size, 10).
-
-        Vorgehen:
-          1. Jedes Beispiel (20x20x1) wird zunächst zu einem Vektor der Länge 400
-             abgeflacht.
-          2. Dieser Vektor wird in 10 gleich lange Blöcke (je 40 Werte) unterteilt.
-          3. Aus jedem Block wird der Mittelwert berechnet – das Ergebnis ist ein 10-dimensionaler Vektor.
-
-        Parameter:
-          • input_data: NumPy-Array mit Shape (batch_size, 20, 20, 1)
-
-        Rückgabe:
-          • NumPy-Array der Shape (batch_size, 10)
-        """
-        batch_size = input_data.shape[0]
-        # Abflachen jedes Bildes (20*20=400)
-        flattened = input_data.reshape(batch_size, -1)  # Shape: (batch_size, 400)
-        # Neuformen in Blöcke der Größe 40: Shape (batch_size, 10, 40)
-        reshaped = flattened.reshape(batch_size, 10, -1)
-        # Mittelwert je Block berechnen -> Ergebnis: (batch_size, 10)
-        features = np.mean(reshaped, axis=2)
-        return features
-
-    import numpy as np
-
-    def predict_vehicle_rating(self, input_data):
-        """
-        Diese Methode nimmt den Eingabetensor in der Form
-          (batch_size, 20, 20, 1)
-        und transformiert ihn in einen Tensor der Form
-          (batch_size, 10)
-        – indem jedes Beispiel ersteinmal abgeflacht und in 10 gleiche Blöcke (je 40 Werte)
-        unterteilt wird; der Mittelwert jedes Blocks wird als repräsentatives Feature
-        verwendet.
-
-        Anschließend wird der vorverarbeitete Tensor an das Keras‑Modell übergeben,
-        sodass der ValueError aufgrund inkompatibler Eingabeformen nicht mehr auftritt.
-
-        Vorgehen:
-          1. Abflachen jedes Beispiels von (20, 20, 1) zu einem Vektor der Länge 400.
-          2. Neuformen des 400-dimensionalen Vektors in (10, 40).
-          3. Berechnung des Mittelwerts in jeder der 10 Gruppen (Block), wodurch ein
-             10-dimensionaler Vektor entsteht.
-
-        Parameter:
-          • input_data: NumPy‑Array, erwartet die Form (batch_size, 20, 20, 1)
-
-        Rückgabe:
-          • prediction: Das Ergebnis von self.tf_model.predict() auf den vorverarbeiteten
-            Daten (Form (batch_size, 10))
-        """
-        # Schritt 1: Bestimme die Batch-Größe und flache die Bilder ab.
-        batch_size = input_data.shape[0]
-        flattened = input_data.reshape(batch_size, -1)  # Resultat: (batch_size, 400)
-
-        # Schritt 2: Unterteile den 400-dimensionalen Vektor in 10 Blöcke (je 40 Werte).
-        reshaped = flattened.reshape(batch_size, 10, 40)  # (batch_size, 10, 40)
-
-        # Schritt 3: Berechne den Mittelwert jedes Blocks (entsteht ein Vektor der Länge 10).
-        processed_data = np.mean(reshaped, axis=2)  # (batch_size, 10)
-
-        # Übergabe der vorverarbeiteten Daten an das Modell.
-        prediction = self.tf_model.predict(processed_data)
-        return prediction
-
-
-if __name__ == "__main__":
-    # Wichtig: setze auf Windows die Startmethode auf "spawn"
-    multiprocessing.set_start_method('spawn')
-
-    # Erzeuge eine Queue, auch wenn sie später eventuell neu erstellt wird, wenn "G" gedrückt wird.
-    graph_q = Queue()
-    app = LagerSimulation(graph_q)
-    app.run()
-
-    # Beim Schließen der Simulation den Graphprozess ggf. beenden
-    if app.graph_process is not None:
-        app.graph_process.terminate()
-        app.graph_process.join()
\ No newline at end of file
Index: KI/KI28.py
===================================================================
diff --git a/KI/KI28.py b/KI/KI28.py
deleted file mode 100644
--- a/KI/KI28.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,502 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs
-)
-
-# Wir nutzen globalClock für dt.
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit
-        self.base_speed = 1.5
-        # Zeitskalierungsfaktor
-        self.speed_factor = 1.0
-        # Simulationszeitticker (simulierte Sekunden)
-        self.sim_clock = 0.0
-        # Zähler der abgegebenen Pakete
-        self.delivered_packages = 0
-        # Maximale Liegedauer (über die gesamte Simulation)
-        self.max_overall_wait_time = 0.0
-        # Gesamte Liegedauer und Zähler für Durchschnittsberechnung
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        self.sim_start_real = globalClock.getFrameTime()
-
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-        # Erstelle 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Zeichne für jede Annahmestation den Align-Punkt (2m in positive X-Richtung).
-        for station in self.annahme_stationen:
-            station_pos = station.getPos()
-            ls_pickup = LineSegs()
-            ls_pickup.setThickness(3.0)
-            ls_pickup.setColor(LColor(1, 1, 1, 1))
-            ls_pickup.moveTo(station_pos)
-            ls_pickup.drawTo(station_pos + Vec3(2, 0, 0))
-            self.render.attachNewNode(ls_pickup.create())
-
-        # Zeichne für jede Abgabestation den Align-Punkt (2m in negative X-Richtung).
-        for station in self.abgabe_stationen:
-            station_pos = station.getPos()
-            ls_dropoff = LineSegs()
-            ls_dropoff.setThickness(3.0)
-            ls_dropoff.setColor(LColor(1, 1, 1, 1))
-            ls_dropoff.moveTo(station_pos)
-            ls_dropoff.drawTo(station_pos + Vec3(-2, 0, 0))
-            self.render.attachNewNode(ls_dropoff.create())
-
-        # Fahrzeuge initialisieren.
-        self.vehicles = []
-        self.cargos = {}              # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}    # Fahrzeug -> zugewiesene Dropoff-Station
-
-        # Fahrzeug 1
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-        self.add_center_marker(vehicle1)
-        self.add_offset_circle(vehicle1, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Fahrzeug 2 (später gestartet)
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-        self.add_center_marker(vehicle2)
-        self.add_offset_circle(vehicle2, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Aufgaben
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_vehicle2_start, "CheckVehicle2StartTask")
-        self.taskMgr.add(self.update_lidar_status, "UpdateLidarStatusTask")
-
-        # Liefervorgang starten (Pickup-Phase)
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-
-    # --- Funktion zum Setzen des Fahrzeugmittelpunkt-Markiers ---
-    def add_center_marker(self, vehicle, scale=0.2):
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    # --- Funktion zum Zeichnen des Lidar-Kreises ---
-    def add_offset_circle(self, vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5, num_segments=32):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        for i in range(num_segments + 1):
-            angle = 2 * math.pi * i / num_segments
-            x = circle_radius * math.cos(angle)
-            y = circle_radius * math.sin(angle)
-            if i == 0:
-                ls.moveTo(x, y, 0)
-            else:
-                ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        circle_np = vehicle.attachNewNode(circle_geom)
-        circle_np.setPos(offset)
-        vehicle.setPythonTag("lidar_circle", circle_np)
-
-    # --- Funktion zum Zeichnen von Koordinatensystemen ---
-    def draw_coordinate_axes(self, axis_length=5):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(1, 0, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        ls.setColor(0, 1, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        ls.setColor(0, 0, 1, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), (1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), (0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), (0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def update_lidar_status(self, task):
-        sensor_threshold = 3.0
-        for vehicle in self.vehicles:
-            if vehicle.hasPythonTag("lidar_circle"):
-                lidar_circle = vehicle.getPythonTag("lidar_circle")
-                pos = vehicle.getPos(self.render)
-                collision = False
-                avoidance_vec = Vec3(0, 0, 0)
-                for other in self.vehicles:
-                    if other is not vehicle:
-                        pos_other = other.getPos(self.render)
-                        diff = pos - pos_other
-                        if diff.length() < sensor_threshold:
-                            collision = True
-                            if diff.length() > 0:
-                                avoidance_vec += diff.normalized()*(sensor_threshold-diff.length())
-                if collision:
-                    lidar_circle.setColor(LColor(1, 0, 0, 1))
-                    vehicle.setPythonTag("avoidance", avoidance_vec)
-                    vehicle.setPythonTag("speed_multiplier", 0.5)
-                else:
-                    lidar_circle.setColor(LColor(0, 1, 0, 1))
-                    vehicle.setPythonTag("avoidance", Vec3(0, 0, 0))
-                    vehicle.setPythonTag("speed_multiplier", 1.0)
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-        current_wait_text = (f"Liegedauer (aktuell): {current_max_wait_time:.1f}s"
-                             if current_max_wait_time > 0 else "Kein Paket an Annahmestation")
-        maximal_wait_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        delivered_per_minute = self.delivered_packages / (self.sim_clock/60.0) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted_time}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-            f"{current_wait_text}\n"
-            f"{maximal_wait_text}\n"
-            f"Liegedauer (Durchschnitt): {avg_dwell_time:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def check_vehicle2_start(self, task):
-        if self.sim_clock >= 8.0 and not hasattr(self, 'vehicle2_started'):
-            self.vehicle2_started = True
-            self.start_delivery_cycle(self.vehicles[1], self.vehicles[1].getPos())
-            return Task.done
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(
-            station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1)
-        )
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            to_target = target - current_pos
-            distance = to_target.length()
-            multiplier = vehicle.getPythonTag("speed_multiplier") if vehicle.hasPythonTag("speed_multiplier") else 1.0
-            effective_speed = self.base_speed * self.speed_factor * multiplier
-            step_distance = effective_speed * dt
-            if distance <= step_distance:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-            avoidance = vehicle.getPythonTag("avoidance") if vehicle.hasPythonTag("avoidance") else Vec3(0,0,0)
-            if avoidance.length() > 0.001:
-                combined = to_target.normalized() + avoidance.normalized() * 0.5
-                combined.normalize()
-                new_direction = combined
-            else:
-                new_direction = to_target.normalized()
-            vehicle.setPos(current_pos + new_direction * step_distance)
-            return Task.cont
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    # --- Pickup-Phase ---
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        # Für Pickup: zuerst zum Align-Punkt (auf der Linie) und dann zur Stationsmitte.
-        pickup_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        self.move_vehicle_to(vehicle, pickup_align,
-            lambda: self.move_vehicle_to(
-                vehicle,
-                pickup_station.getPos(),
-                lambda: self.after_pickup(vehicle, pickup_station)
-            )
-        )
-
-    def after_pickup(self, vehicle, pickup_station):
-        self.pickup_package(vehicle, pickup_station)
-        # Departiere jetzt von der Pickup-Stationsmitte (analog zur Dropoff-Abfahrt)
-        self.depart_from_pickup(vehicle, pickup_station,
-            lambda: self.start_dropoff_phase(vehicle)
-        )
-
-    def depart_from_pickup(self, vehicle, pickup_station, callback):
-        # Bei Pickup-Stations gibt die Linie in positive X-Richtung vor.
-        departure_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        departure_target = pickup_station.getPos() + Vec3(4, 0, 0)
-        self.move_vehicle_to(vehicle, departure_align,
-            lambda: self.move_vehicle_to(vehicle, departure_target, callback)
-        )
-
-    # --- Dropoff-Phase (Fahrzeug mit Fracht) ---
-    def start_dropoff_phase(self, vehicle):
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.start_dropoff_phase(vehicle)
-            return
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        # Für Dropoff: zuerst zum Align-Punkt (negative X-Richtung) und dann zur Stationsmitte.
-        dropoff_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-        self.move_vehicle_to(vehicle, dropoff_align,
-            lambda: self.move_vehicle_to(vehicle, dropoff_station.getPos(),
-                lambda: self.after_dropoff(vehicle)
-            )
-        )
-
-    def after_dropoff(self, vehicle):
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        self.drop_cargo(vehicle)
-        self.remove_cargo(vehicle, remove_dropoff=True)
-        if dropoff_station is not None:
-            departure_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-            departure_target = dropoff_station.getPos() + Vec3(-4, 0, 0)
-            self.move_vehicle_to(vehicle, departure_align,
-                lambda: self.move_vehicle_to(vehicle, departure_target,
-                    lambda: self.start_delivery_cycle(vehicle, departure_target)
-                )
-            )
-        else:
-            self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle, remove_dropoff=True):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        if remove_dropoff:
-            dropoff_station = self.current_dropoffs.get(vehicle)
-            if dropoff_station in self.occupied_dropoffs:
-                self.occupied_dropoffs.remove(dropoff_station)
-            if vehicle in self.current_dropoffs:
-                del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent-0.5, center_extent+0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices+1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices+1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z+1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5,0.5,0.5,1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1,1,1,1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10,-10,10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
Index: Grundmodell/Gm23.py
===================================================================
diff --git a/Grundmodell/Gm23.py b/Grundmodell/Gm23.py
deleted file mode 100644
--- a/Grundmodell/Gm23.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,1612 +0,0 @@
-import random
-import math
-import tkinter as tk  # Für das extra Fenster der Auftragsübersicht
-from tkinter import ttk  # Für die tabellarische Darstellung (Treeview)
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-from direct.task.TaskManagerGlobal import taskMgr
-
-
-from functools import partial
-
-
-
-
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        self.tk_root = tk.Tk()
-        self.tk_root.withdraw()
-
-        self.taskMgr.add(self._tk_update, "tkUpdateTask")
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5  # Wird in update_vehicle genutzt
-        self.state_timer = 0.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Paketspawning an den Annahmestationen:
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-        # Fahrzeug-spezifische Zuordnung: Fahrzeug -> transportiertes Paket
-        self.cargos = {}
-
-        # NEU: Initialisiere die belegten Annahmestationen
-        self.occupied_pickups = set()  # Oder: [] für eine Liste
-
-        # Graph-Daten (Sim-Zeit, Pakete pro Minute, durchschnittliche Liegedauer)
-        self.graph_data = []
-        self.graph_opened = False
-
-        # Auftragsverwaltung: Speichere alle Aufträge (für die Anzeige) sowie in
-        # einer Queue (Liste) zur sequentiellen Abarbeitung.
-        self.orders = {}
-        self.orders_queue = []
-        self.next_order_id = 1
-
-        # Tkinter-Fenster für Auftragsübersicht
-        self.order_win = None
-        self.order_tree = None
-
-        # Umgebung initialisieren
-        self.draw_origin()
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.create_wall()
-        self.create_annahme_stations()
-        self.create_abgabe_stations()  # Hier wird auch self.abgabe_stations angelegt.
-        self.create_garagen_stations()
-
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # Fahrzeuge in den Garagen erstellen (genau 5 Fahrzeuge)
-        self.create_garage_vehicles()
-
-        # NEU: Testvariablen
-        self.first_vehicle_order_state = "idle"
-        self.attached_package = None
-        self.current_order = None  # wird durch Fahrzeuge individuell genutzt
-
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tastenzuordnungen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-        # Taste C öffnet das Fahrzeug-Kontrollfenster
-        self.accept("c", self.show_vehicle_control)
-
-        # Task-Manager
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-        self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    # ---------------------------
-    # SIMULATION UND UI-METHODEN
-    # ---------------------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        # dt jetzt skaliert mit der Simulationsgeschwindigkeit
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    # ---------------------------
-    # METHODEN FÜR RASTER, LICHT, MAUER, URSPRUNG
-    # ---------------------------
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # STATIONSOBJEKTE UND ZUORDNUNG
-    # -----------------------------------
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        """
-        Erzeugt die Annahmestationen und erstellt für jede Station:
-          - Einen weißen Marker zur Orientierung
-          - Einen grünen Punkt (optional)
-          - Eine weiße Linie, an deren Endpunkt ein blauer Marker als Ziel in der "Translate‑Phase" dient
-
-        Zusätzlich wird ein Dictionary self.station_blue_dots aufgebaut, in dem jedem Annahmestations‑Node
-        der zugehörige blaue Marker zugeordnet wird. Außerdem wird für die erste Station die globale Variable
-        self.station_white_direction festgelegt.
-        """
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        self.station_blue_dots = {}
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basisstation (zum Beispiel als Rahmen)
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Erzeuge den weißen Marker als Orientierung
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Erzeuge den grünen Punkt (optional)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zeichne die weiße Linie: Sie beginnt bei center + Vec3(0, 0, -0.5) und verläuft 3 Meter in X‑Richtung.
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Erzeuge den blauen Marker, der als Ziel in der Translate‑Phase dient
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            # Speichere den blauen Marker im Dictionary, sodass er später erzeugt werden kann
-            self.station_blue_dots[station_dummy] = blue_dot
-
-            # Optionale Textanzeige der Stationsnummer
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) – falls benötigt:
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-            # Für die erste Station (oder den ersten relevanten Pickup) setzen wir globale Referenzen,
-            # die in vehicle_order_task benötigt werden.
-            if i == 1:
-                self.blue_dot = blue_dot
-                self.station_green_dot = green_dot
-                # Berechne den Mittelpunkt der weißen Linie als Referenz (optional)
-                self.white_line_center = (start_line + end_line) * 0.5
-                line_vec = end_line - start_line
-                if line_vec.length() != 0:
-                    self.station_white_direction = Vec2(line_vec.getX(), line_vec.getY()).normalized()
-                else:
-                    self.station_white_direction = Vec2(1, 0)  # Fallback-Wert
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        self.abgabe_stations = []  # Liste der Abgabestationen
-        self.abgabe_blue_dots = []  # Liste zum Speichern der blauen Marker für die Abgabe
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basiskonstruktion der Abgabestation
-            node = self.create_abgabe_station(pt)
-            self.abgabe_stations.append(node)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Marker am Zentrum (weiß)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Grüner Punkt: center + Vec3(0, 0, -0.5)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Weiße Linie: Startet bei center + Vec3(0, 0, -0.5)
-            # und verläuft 3 Meter in negativer X-Richtung
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt: wird an der Endposition der Linie erzeugt
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            # Speichere den blauen Marker für spätere Navigation der Abgabestation
-            self.abgabe_blue_dots.append(blue_dot)
-
-            # Anzeige der Stationsnummer (textuell)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) auf der Station
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 3)
-        v5 = pos + Vec3(1, 0, 3)
-        v6 = pos + Vec3(1, 2, 3)
-        v7 = pos + Vec3(0, 2, 3)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 3)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        self.garagen_stations = []
-        self.garagen_parking_points = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            self.garagen_stations.append(pt)
-            # ParkpunktGarage: Verschoben um 0.5 in negativer Y-Richtung:
-            center = pt + Vec3(0.5, 0.5, 1.5)
-            ParkpunktGarage = center + Vec3(0, 0, 0.7)
-            self.garagen_parking_points.append(ParkpunktGarage)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def create_garage_vehicles(self):
-        self.garage_vehicles = []
-        vehicle_id_counter = 1
-        for park in self.garagen_parking_points:
-            veh = self.create_vehicle(park_point=park)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            newPos.setZ(0)
-            veh.setPos(newPos)
-
-            # Fahrzeuge starten im Standby (idle)
-            veh.setPythonTag("current_order", None)
-            veh.setPythonTag("order_state", "idle")
-            veh.setPythonTag("package_attached", False)
-            veh.setPythonTag("vehicle_id", vehicle_id_counter)
-            # Speichere den Parkpunkt als Rückkehrziel
-            veh.setPythonTag("garage_target", park)
-            # Speichere auch das Anfangs-Heading, um es später beim Parken wiederherzustellen.
-            veh.setPythonTag("start_heading", veh.getH())
-            vehicle_id_counter += 1
-
-            self.garage_vehicles.append(veh)
-
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-            # Füge einen Textknoten hinzu, der die Fahrzeugnummer vorne auf dem Fahrzeug anzeigt.
-            # Wir suchen den Mast-Knoten.
-            mast = veh.find("**/mast")
-            if not mast.isEmpty():
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)  # Schwarz
-                tn.setAlign(TextNode.ACenter)
-                text_np = mast.attachNewNode(tn)
-                # Positioniere den Text relativ zum Mast: Wir nutzen den Vektor "intersection"
-                # und versetzen ihn in Z-Richtung um 0.2 Einheiten oberhalb des Zylinders.
-                text_np.setPos(intersection.x, intersection.y, intersection.z + 0.2)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-            else:
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)
-                tn.setAlign(TextNode.ACenter)
-                text_np = veh.attachNewNode(tn)
-                text_np.setPos(0, 1.2, 1.5)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-
-            self.taskMgr.add(partial(self.vehicle_order_task, veh),
-                             f"VehicleOrderTask_{veh.getPythonTag('vehicle_id')}")
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # FAHRZEUGERSTELLUNG (FFZ20-INTEGRATION)
-    # -----------------------------------
-    def create_vehicle(self, park_point=None):
-        # Erzeuge den übergeordneten Fahrzeug-Knoten
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # --------------------------
-        # Chassis erstellen (1 x 0.5 x 1.2, Farbe Rot)
-        # --------------------------
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # --------------------------
-        # Gabel (Fork) erstellen: Zwei Zähne
-        # --------------------------
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-
-        # Speichere den Gabel-Knoten als Python-Tag am Fahrzeug
-        vehicle_node.setPythonTag("fork_node", fork_node)
-
-        # --------------------------
-        # Erzeuge den grünen Referenzmarker (Gabel – grüner Punkt)
-        # --------------------------
-        ls_new = LineSegs()
-        ls_new.setThickness(2.0)
-        ls_new.setColor(1, 1, 1, 1)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_corner_global = fork_node.getPos() + left_corner_local
-        right_corner_global = fork_node.getPos() + right_corner_local
-        ls_new.moveTo(left_corner_global)
-        ls_new.drawTo(right_corner_global)
-        vehicle_node.attachNewNode(ls_new.create())
-        midpoint = (left_corner_global + right_corner_global) * 0.5
-        white_line_vec = right_corner_global - left_corner_global
-        white_line_dir = white_line_vec.normalized() if white_line_vec.length() != 0 else Vec3(0, 0, 0)
-        candidate = Vec3(-white_line_dir.getY(), white_line_dir.getX(), 0)
-        perp_direction = candidate.normalized() if candidate.length() != 0 else Vec3(0, 0, 0)
-        green_point_global = midpoint + perp_direction * 0.5
-
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        # Speichere den grünen Marker ebenfalls als Python-Tag
-        vehicle_node.setPythonTag("fork_green", green_marker_np)
-
-        # --------------------------
-        # Mast und weitere Fahrzeugteile
-        # --------------------------
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-        self.add_diagonals_to_mast(mast_node)
-        intersection = Vec3(0.5, 0.05, 1.0)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-        self.vehicle_cylinder = cylinder_node
-
-        # --------------------------
-        # Fahrzeugpositionierung am Parkpunkt
-        # --------------------------
-        if park_point is None:
-            vehicle_node.setPos(intersection.x, intersection.y, 0)
-        else:
-            vehicle_node.setPos(park_point - vehicle_node.getQuat().xform(intersection))
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        # Verwende die simulative Zeit, die bereits in update_sim_clock hochgezählt wird
-        t = self.sim_clock
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    # -----------------------------------
-    # FEHLENDE METHODEN: Paketspawning, Würfelerzeugung u.a.
-    # -----------------------------------
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Bestimme zufällig eine Abgabestation als Ziel
-        if hasattr(self, "abgabe_stations") and self.abgabe_stations:
-            target_index = random.randint(1, len(self.abgabe_stations))
-        else:
-            target_index = 1
-
-        # Erstelle den Auftrag zur Annahmestation
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def update_order_table(self):
-        """
-        Aktualisiert die Auftragsübersicht in der Tkinter-Tabelle und zeigt in der
-        letzten Spalte den zugewiesenen Fahrzeugnamen (oder "-" falls noch keiner zugeordnet wurde).
-        """
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen (z. B. "annahme_station_3") die Stationsnummer.
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z. B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige in der letzten Spalte den zugewiesenen Fahrzeugnamen an (oder "-" falls noch kein Fahrzeug zugewiesen ist).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END, values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = 5.0  # 5 Sekunden Verzögerung zwischen Spawns
-        for station in self.annahme_stations:
-            # Wenn aktuell kein Paket an der Station ist
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                # Prüfe, ob seit der letzten Entnahme mindestens 5 Sekunden vergangen sind
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0.0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Wir legen hier die Spalten in der gewünschten Reihenfolge an: Auftrags ID, Annahmestation, Ziel, Fahrzeug.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    def pickup_package(self, vehicle, station):
-        # Wenn bereits ein Paket vorhanden ist, dann abbrechen.
-        if vehicle.getPythonTag("package_attached"):
-            return
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            fork_node = vehicle.getPythonTag("fork_node")
-            fork_green = vehicle.getPythonTag("fork_green")
-            green_point_pos = fork_green.getPos(fork_node)
-
-            package.wrtReparentTo(fork_node)
-            package.setPos(green_point_pos.getX() + 0.5,
-                           green_point_pos.getY() - 0.5,
-                           green_point_pos.getZ() + 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    from direct.task.TaskManagerGlobal import taskMgr  # Sicherstellen, dass taskMgr verfügbar ist
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden removeCargoTask aufruft,
-            # und übergib dabei das cargo als extra Argument:
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return Task.done
-
-    def select_next_order(self, vehicle):
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        for order in waiting_orders:
-            dwell_time = self.sim_clock - order.get("spawn_time", self.sim_clock)
-            order["dwell_time"] = dwell_time
-
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        vehicle_pos = vehicle.getPos(self.render)
-
-        def distance_to_station(order):
-            station = order.get("pickup_station")
-            if station:
-                station_pos = station.getPos(self.render)
-                return (station_pos - vehicle_pos).length()
-            return float('inf')
-
-        candidates.sort(key=distance_to_station)
-        chosen_order = candidates[0]
-        chosen_order["vehicle"] = f"Fahrzeug {vehicle.getPythonTag('vehicle_id')}"
-        return chosen_order
-
-    def vehicle_order_task(self, vehicle, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-
-        # Wenn das Fahrzeug im "idle"-Zustand steht, soll es nichts tun.
-        if vehicle.getPythonTag("order_state") == "idle":
-            return task.cont
-
-        state = vehicle.getPythonTag("order_state")
-        current_order = vehicle.getPythonTag("current_order")
-
-        # ------------------ Phase 1: Translate ------------------
-        if state == "translate":
-            if current_order is None:
-                next_order = self.select_next_order(vehicle)
-                if next_order is not None:
-                    vehicle.setPythonTag("current_order", next_order)
-                    next_order["status"] = "In Bearbeitung"
-                    print(
-                        f"Auftrag {next_order['id']} wird zugewiesen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}.")
-                else:
-                    print("Kein Auftrag verfügbar – Fallback zum globalen Ziel.")
-            current_order = vehicle.getPythonTag("current_order")
-            if current_order is not None:
-                pickup_station = current_order.get("pickup_station")
-                if pickup_station in self.station_blue_dots:
-                    blue_target = self.station_blue_dots[pickup_station].getPos(self.render)
-                else:
-                    blue_target = self.blue_dot.getPos(self.render)
-            else:
-                blue_target = self.blue_dot.getPos(self.render)
-            local_mast = Vec3(0.5, 0.05, 1.0)
-            mast_global = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(local_mast)
-            target_xy = Vec2(blue_target.getX(), blue_target.getY())
-            mast_xy = Vec2(mast_global.getX(), mast_global.getY())
-            error_vector = target_xy - mast_xy
-            threshold = 0.05
-            if error_vector.length() > threshold:
-                direction = error_vector.normalized()
-                move_distance = 1.5 * dt
-                current_pos = vehicle.getPos(self.render)
-                new_pos = Vec3(current_pos.getX() + direction.getX() * move_distance,
-                               current_pos.getY() + direction.getY() * move_distance, 0)
-                vehicle.setPos(new_pos)
-            else:
-                local_offset = vehicle.getQuat(self.render).xform(local_mast)
-                exact_pos = Vec3(blue_target.getX() - local_offset.getX(),
-                                 blue_target.getY() - local_offset.getY(), 0)
-                vehicle.setPos(exact_pos)
-                vehicle.setPythonTag("order_state", "rotate")
-
-        # ------------------ Phase 2: Rotate ------------------
-        elif state == "rotate":
-            desired_angle = math.degrees(math.atan2(self.station_white_direction.getY(),
-                                                    self.station_white_direction.getX()))
-            desired_angle = (desired_angle + 180) % 360
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_angle - current_heading + 180) % 360) - 180
-            kp_heading = 0.5
-            new_heading = current_heading + kp_heading * angle_diff
-            vehicle.setH(new_heading)
-            if abs(angle_diff) < 1.0:
-                vehicle.setPythonTag("order_state", "turn_right")
-
-        # ------------------ Phase 3: Turn Right ------------------
-        elif state == "turn_right":
-            if vehicle.getPythonTag("turn_right_init") is None:
-                vehicle.setPythonTag("turn_right_init", vehicle.getH() % 360)
-                vehicle.setPythonTag("turn_right_target", (vehicle.getPythonTag("turn_right_init") + 90) % 360)
-                print("Phase 3: Initialisiert für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "Start Heading =", vehicle.getPythonTag("turn_right_init"),
-                      "Target Heading =", vehicle.getPythonTag("turn_right_target"))
-            current_heading = vehicle.getH() % 360
-            turn_right_target = vehicle.getPythonTag("turn_right_target")
-            angle_diff = ((turn_right_target - current_heading + 180) % 360) - 180
-            kp_turn = 0.5
-            turn_rate = kp_turn * angle_diff
-            new_heading = current_heading + turn_rate * dt
-            vehicle.setH(new_heading)
-            print("Phase 3: Fahrzeug", vehicle.getPythonTag("vehicle_id"), "- Aktuelles Heading =", current_heading,
-                  "Winkelabweichung =", angle_diff, "Neues Heading =", new_heading)
-            if abs(angle_diff) < 1.0:
-                print("Phase 3: Drehung abgeschlossen für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      ". Übergang in 'approach'.")
-                vehicle.setPythonTag("order_state", "approach")
-                vehicle.clearPythonTag("turn_right_init")
-                vehicle.clearPythonTag("turn_right_target")
-
-        # ------------------ Phase 4: Approach ------------------
-        elif state == "approach":
-            if current_order is not None:
-                pickup_station = current_order.get("pickup_station")
-                target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-            else:
-                target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-            current = vehicle.getPos(self.render)
-            error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-            if error_vec.length() > 0.05:
-                direction = error_vec.normalized()
-                move_distance = 1.5 * dt
-                new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                               current.getY() + direction.getY() * move_distance, target.getZ())
-                vehicle.setPos(new_pos)
-            else:
-                vehicle.setPos(target)
-                vehicle.setPythonTag("order_state", "pickup")
-
-        # ------------------ Phase 5: Pickup ------------------
-        elif state == "pickup":
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            target_z = 1.0
-            raise_speed = 0.5
-            if current_z < target_z:
-                fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-            else:
-                if current_order is None:
-                    if self.orders_queue:
-                        vehicle.setPythonTag("current_order", self.orders_queue.pop(0))
-                    else:
-                        print("Keine verfügbaren Aufträge für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                              ". Überspringe Pickup-Phase.")
-                        vehicle.setPythonTag("order_state", "drive_out")
-                        return task.cont
-                # Nur wenn noch kein Paket am Fahrzeug befestigt ist:
-                if not vehicle.getPythonTag("package_attached"):
-                    pickup_station = vehicle.getPythonTag("current_order")["pickup_station"]
-                    self.pickup_package(vehicle, pickup_station)
-                    vehicle.setPythonTag("package_attached", True)
-                # Setze drive_out_target, falls noch nicht vorhanden
-                if vehicle.getPythonTag("drive_out_target") is None:
-                    vehicle.setPythonTag("drive_out_target",
-                                         vehicle.getPos(self.render) + vehicle.getQuat(self.render).getForward() * 5.0)
-                vehicle.setPythonTag("order_state", "drive_out")
-
-        # ------------------ Phase 6: Drive Out ------------------
-        elif state == "drive_out":
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            if current_z > 0.0:
-                lower_speed = 0.5
-                fork_node.setZ(max(0.0, current_z - lower_speed * dt))
-            current_pos = vehicle.getPos(self.render)
-            drive_out_target = vehicle.getPythonTag("drive_out_target")
-            if drive_out_target is None:
-                drive_out_target = current_pos + vehicle.getQuat(self.render).getForward() * 5.0
-                vehicle.setPythonTag("drive_out_target", drive_out_target)
-            diff = drive_out_target - current_pos
-            if diff.length() > 0.1:
-                move_distance = 0.5 * dt
-                step = diff.normalized() * move_distance
-                new_pos = current_pos + step
-                new_pos.setZ(0)  # Sicherstellen, dass das Fahrzeug auf dem Boden bleibt
-                vehicle.setPos(new_pos)
-            else:
-                vehicle.setPythonTag("order_state", "to_delivery")
-                vehicle.setPythonTag("drive_out_target", None)
-
-        # ------------------ Phase 7: To Delivery ------------------
-        elif state == "to_delivery":
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current_pos = vehicle.getPos(self.render)
-            diff = blue_target - current_pos
-            threshold = 0.5
-            move_distance = 1.5 * dt
-            if move_distance > diff.length():
-                vehicle.setPos(blue_target)
-            else:
-                vehicle.setPos(current_pos + diff.normalized() * move_distance)
-            if (blue_target - vehicle.getPos(self.render)).length() <= threshold:
-                print("Phase 7 abgeschlossen: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "hat den blauen Punkt der Abgabestation erreicht.")
-                vehicle.setPythonTag("order_state", "align_delivery")
-
-        # ------------------ Phase 8: Align Delivery ------------------
-        elif state == "align_delivery":
-            desired_heading = 90.0
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_heading - current_heading + 180) % 360) - 180
-            print("Phase 8: Align Delivery | Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                  "Current Heading: {:.2f}°, Desired: {:.2f}°, Diff: {:.2f}°".format(current_heading, desired_heading,
-                                                                                     angle_diff))
-            fixed_turn_speed = 90.0
-            turn_amount = fixed_turn_speed * dt
-            if abs(angle_diff) < 1.0:
-                vehicle.setH(desired_heading)
-                print("Phase 8 abgeschlossen: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "ausgerichtet (Heading = {:.2f}°).".format(desired_heading))
-                vehicle.setPythonTag("order_state", "delivery_center")
-            else:
-                if angle_diff > 0:
-                    new_heading = current_heading + turn_amount
-                else:
-                    new_heading = current_heading - turn_amount
-                new_heading %= 360
-                vehicle.setH(new_heading)
-                print("Phase 8: Rotating - Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "New Heading set to {:.2f}°".format(new_heading))
-
-        # ------------------ Phase 9: Delivery Approach ------------------
-        elif state == "delivery_center":
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current = vehicle.getPos(self.render)
-            target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-            print("Phase 9: Zielpunkt der Abgabestation für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                  "=", target_point)
-            error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-            tolerance = 0.05
-            move_distance = 1.5 * dt
-            if error_vec.length() > tolerance:
-                direction = error_vec.normalized()
-                new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                               current.getY() + direction.getY() * move_distance, current.getZ())
-                vehicle.setPos(new_pos)
-                print("Phase 9: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "bewegt sich von", current, "nach", new_pos)
-            else:
-                vehicle.setPos(target_point)
-                print("Phase 9: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "hat den Zielpunkt erreicht.")
-                vehicle.setPythonTag("order_state", "drop")
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_fork_z = fork_node.getZ()
-            if current_fork_z < 1.0:
-                new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-                fork_node.setZ(new_fork_z)
-                print("Phase 9: Gabel wird angehoben für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "(Z =", new_fork_z, ").")
-
-        # ------------------ Phase 10: Dropoff ------------------
-        elif state == "drop":
-            if vehicle.getPythonTag("package_attached"):
-                delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-                self.drop_cargo(vehicle)
-                print("Phase 10: Paket abgesetzt für Fahrzeug", vehicle.getPythonTag("vehicle_id"))
-                vehicle.setPythonTag("package_attached", False)
-            else:
-                fork_node = vehicle.getPythonTag("fork_node")
-                current_z = fork_node.getZ()
-                if current_z > 0.0:
-                    lower_speed = 0.5
-                    new_z = max(0.0, current_z - lower_speed * dt)
-                    fork_node.setZ(new_z)
-                    print("Phase 10: Gabel wird abgesenkt für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          ", aktueller Z-Wert =", new_z)
-                else:
-                    print("Phase 10: Dropoff vollständig abgeschlossen für Fahrzeug",
-                          vehicle.getPythonTag("vehicle_id"))
-                    # Prüfe, ob Standby angefordert wurde:
-                    if vehicle.getPythonTag("standby_pending"):
-                        vehicle.setPythonTag("order_state", "return_to_garage")
-                        print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} kehrt zur Garage zurück (Standby).")
-                    else:
-                        vehicle.setPythonTag("order_state", "translate")
-                    current_order["status"] = "Abgegeben"
-                    current_order["delivered_at"] = self.sim_clock
-                    vehicle.setPythonTag("current_order", None)
-
-        # ------------------ Neue Phase: Return to Garage (Standby) ------------------
-        elif state == "return_to_garage":
-            garage_target = vehicle.getPythonTag("garage_target")
-            if garage_target is None:
-                garage_target = self.garagen_parking_points[0]
-            current_pos = vehicle.getPos(self.render)
-            diff = garage_target - current_pos
-            if diff.length() > 0.1:
-                move_distance = 1.0 * dt
-                new_pos = current_pos + diff.normalized() * move_distance
-                new_pos.setZ(0)  # Sicherstellen, dass das Fahrzeug am Boden bleibt.
-                vehicle.setPos(new_pos)
-            else:
-                # Setze das Ausgangs-Heading wieder zurück
-                if vehicle.hasPythonTag("start_heading"):
-                    vehicle.setH(vehicle.getPythonTag("start_heading"))
-                vehicle.setPythonTag("order_state", "idle")
-                vehicle.setPythonTag("standby_pending", False)
-                print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} ist in der Garage (Standby).")
-
-        # ------------------ Phase 11: Exit Station and Start Next Order ------------------
-        elif state == "phase11":
-            if vehicle.getPythonTag("last_delivery_marker") is not None:
-                target_point = vehicle.getPythonTag("last_delivery_marker")
-            else:
-                delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    target_point = self.abgabe_blue_dots[0].getPos(self.render)
-                print("Phase 11: Zielpunkt (blauer Marker) für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "=", target_point)
-                current_pos = vehicle.getPos(self.render)
-                diff = target_point - current_pos
-                if diff.length() > 0.1:
-                    move_distance = 0.5 * dt
-                    step = diff.normalized() * move_distance
-                    vehicle.setPos(current_pos + step)
-                    print("Phase 11: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          "fährt aus der Station, neue Position =", current_pos + step)
-                else:
-                    vehicle.setPos(target_point)
-                    print("Phase 11: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          "hat den blauen Marker erreicht. Nächster Auftrag wird gestartet.")
-                    vehicle.setPythonTag("order_state", "next_order")
-
-        return task.cont
-
-    # Neue Methode: Kontrollfenster zur Fahrzeugsteuerung
-    def show_vehicle_control(self):
-        # Falls das Kontrollfenster bereits existiert, aktualisiere die Radiobuttons und bringe es in den Vordergrund.
-        if hasattr(self, "control_win") and self.control_win.winfo_exists():
-            for veh, var in self.vehicle_state_vars.items():
-                current_state = veh.getPythonTag("order_state")
-                if current_state is None:
-                    current_state = "idle"
-                var.set(current_state)
-            self.control_win.deiconify()
-            self.control_win.lift()
-            self.control_win.focus_force()
-            return
-
-        # Erstelle das Kontrollfenster als Toplevel des persistierenden tk_root.
-        self.control_win = tk.Toplevel(self.tk_root)
-        self.control_win.title("Fahrzeugsteuerung")
-        # Beim Schließen soll das Fenster nicht zerstört, sondern nur versteckt werden.
-        self.control_win.protocol("WM_DELETE_WINDOW", self.control_win.withdraw)
-        # Stelle sicher, dass das Fenster initial oben ist.
-        self.control_win.attributes("-topmost", True)
-        self.control_win.after(100, lambda: self.control_win.attributes("-topmost", False))
-
-        self.vehicle_state_vars = {}
-        row = 0
-        for veh in self.garage_vehicles:
-            frame = tk.Frame(self.control_win)
-            frame.grid(row=row, column=0, sticky="w", padx=5, pady=2)
-            vid = veh.getPythonTag("vehicle_id")
-            label = tk.Label(frame, text=f"Fahrzeug {vid}")
-            label.pack(side=tk.LEFT)
-            state = veh.getPythonTag("order_state")
-            if state is None:
-                state = "idle"
-            var = tk.StringVar(value=state)
-            self.vehicle_state_vars[veh] = var
-            rb_active = tk.Radiobutton(frame, text="Aufträge bearbeiten", variable=var, value="translate")
-            rb_active.pack(side=tk.LEFT)
-            rb_standby = tk.Radiobutton(frame, text="Standby", variable=var, value="idle")
-            rb_standby.pack(side=tk.LEFT)
-            row += 1
-        update_btn = tk.Button(self.control_win, text="Übernehmen", command=self.update_vehicle_control)
-        update_btn.grid(row=row, column=0, pady=5)
-
-    def update_vehicle_control(self):
-        for veh, var in self.vehicle_state_vars.items():
-            new_state = var.get()
-            if new_state == "idle" and veh.getPythonTag("current_order") is not None:
-                veh.setPythonTag("standby_pending", True)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Standby angefordert (Auftrag wird fortgesetzt).")
-            else:
-                veh.setPythonTag("standby_pending", False)
-                veh.setPythonTag("order_state", new_state)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Zustand auf {new_state} gesetzt.")
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: Grundmodell/Gm10.py
===================================================================
diff --git a/Grundmodell/Gm10.py b/Grundmodell/Gm10.py
deleted file mode 100644
--- a/Grundmodell/Gm10.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,667 +0,0 @@
-import random
-import math
-import tkinter as tk              # Für das extra Fenster der Auftragsübersicht
-from tkinter import ttk          # Für die tabellarische Darstellung (Treeview)
-import matplotlib.pyplot as plt   # Für interaktive Graphen
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Für Paketspawning an den Annahmestationen:
-        # Mapping: station (Dummy-Node) -> (Paket, Spawnzeit, Timer Node)
-        self.pickup_packages = {}
-        # Hier wird gespeichert, wann zuletzt ein Paket entfernt wurde
-        self.last_removed = {}
-
-        # Für Graph-Daten (z. B. Pakete pro Minute) und Aufträge
-        self.graph_data = []  # Tupel: (Sim-Zeit, Pakete pro Minute, Durchschnittliche Liegedauer)
-        self.graph_opened = False
-
-        # Auftragsverwaltung: Jeder aktiv gespawnte Auftrag wird in diesem Dictionary abgelegt.
-        # Schlüssel: Station-Dummy, Wert: { "id": ..., "status": ..., "ziel": ... }
-        self.orders = {}
-        self.next_order_id = 1
-
-        # Tkinter-Fenster für die Auftragsübersicht (wird bei Bedarf erzeugt)
-        self.order_win = None
-        self.order_tree = None
-
-        # Ursprung (Koordinatenachsen)
-        self.draw_origin()
-
-        # Kameraeinstellungen: Das ganze Feld soll gut sichtbar sein.
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # Licht und Bodenraster
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-
-        # Erzeuge die Mauer (das umschließende Rechteck)
-        self.create_wall()
-
-        # Erzeuge Stationen
-        self.create_annahme_stations()
-        self.create_abgabe_stations()
-        self.create_garagen_stations()
-
-        # Setze auf ALLE Annahmestationen Pakete (und erstelle damit Aufträge)
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tastaturbindungen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)  # Öffnet das Auftragsfenster
-        self.accept("d", self.deliver_first_order)  # Simuliert die Abgabe (Lieferung) eines Auftrags
-
-        # Tasks
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-        self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # Annahmestationen
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, 0.5))
-            green_dot.reparentTo(self.render)
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, 0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            # Erstelle einen Auftrag für dieses Paket
-            order = {
-                "id": self.next_order_id,
-                "status": "Wartend",
-                "ziel": f"Abgabestation {random.randint(1, 10)}"
-            }
-            self.orders[station_dummy] = order
-            self.next_order_id += 1
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-    # Abgabestationen
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_abgabe_station(pt)
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, 0.5))
-            green_dot.reparentTo(self.render)
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, 0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    # Garagenstationen
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        # Die Garagenseiten sollen nun bis zum Dach (global z = 2.5) verlängert werden:
-        v4 = pos + Vec3(0, 0, 2.5)
-        v5 = pos + Vec3(1, 0, 2.5)
-        v6 = pos + Vec3(1, 2, 2.5)
-        v7 = pos + Vec3(0, 2, 2.5)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        # Rahmen im Dachbereich anpassen (von 0 bis 1)
-        cm.setFrame(0, 1, 0, 1)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        # Das Dach erhält einen globalen Z-Wert von 2.5
-        roof.setPos(pos.x, pos.y, 2.5)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            # "ParkpunktGarage" bleibt unverändert:
-            center = pt + Vec3(0.5, 1, 2.2)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        cube = self.loader.loadModel("models/box")
-        cube.setScale(1, 1, 1)
-        cube.setPos(x, y, z + 1)
-        cube.setColor(farbe)
-        cube.reparentTo(self.render)
-        return cube
-
-    def check_and_spawn_packages(self, task):
-        # Wenn an einer Station kein Paket vorhanden ist, erscheint nach 10 s (Simulationszeit) ein neues.
-        spawn_delay = self.sim_time(10)
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-        # Erstelle einen Auftrag für dieses Paket
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {random.randint(1, 10)}"
-        }
-        self.orders[station] = order
-        self.next_order_id += 1
-
-    def update_package_timers(self, task):
-        # Aktualisiere nur den angezeigten Timer (Pakete bleiben erhalten)
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            elapsed = self.sim_clock - spawn_time
-            timer_np.node().setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor != 0 else t
-
-    def update_order_status(self, task):
-        # Entferne Aufträge mit Status "Abgegeben", deren Abgabezeitpunkt älter als 2 s ist
-        for station, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[station]
-        # Aktualisiere das Auftragsfenster, falls es geöffnet ist
-        if self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def deliver_first_order(self):
-        # Simuliere die Lieferung des ersten Auftrags, der noch den Status "Wartend" hat
-        for station, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        import matplotlib.pyplot as plt
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")  # korrigiert: set_title anstatt setTitle
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")  # korrigiert: set_title statt setTitle
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        import matplotlib.pyplot as plt
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-    # Neue Funktion: Auftragsübersicht in einem separaten Fenster (als Tabelle) anzeigen
-    def show_order_list(self):
-        # Wenn das Fenster noch nicht existiert, erstelle es.
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            # Beim Schließen wird das Fenster nur versteckt.
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            self.order_tree = ttk.Treeview(self.order_win, columns=("ID", "Status", "Ziel"), show="headings", height=15)
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Status", text="Status")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Status", width=100, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            # Falls das Fenster bereits existiert, zeige es an.
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-    def update_order_table(self):
-        # Lösche alle vorhandenen Zeilen im Treeview
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-        # Füge alle aktuellen Aufträge hinzu
-        for order in self.orders.values():
-            self.order_tree.insert("", tk.END, values=(order["id"], order["status"], order["ziel"]))
-        self.order_win.update()
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: KI/KI32.py
===================================================================
diff --git a/KI/KI32.py b/KI/KI32.py
deleted file mode 100644
--- a/KI/KI32.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,583 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Matplotlib zum Plotten importieren
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs,
-    CardMaker
-)
-
-# Wir nutzen globalClock für dt.
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit & Zeitskalierungsfaktor
-        self.base_speed = 1.5
-        self.speed_factor = 1.0
-
-        # Simulationszeitticker & Statistik
-        self.sim_clock = 0.0
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        self.sim_start_real = globalClock.getFrameTime()
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Zeichne für jede Annahmestation den Align-Punkt (2 m in positive X-Richtung)
-        for station in self.annahme_stationen:
-            station_pos = station.getPos()
-            ls_pickup = LineSegs()
-            ls_pickup.setThickness(3.0)
-            ls_pickup.setColor(LColor(1, 1, 1, 1))
-            ls_pickup.moveTo(station_pos)
-            ls_pickup.drawTo(station_pos + Vec3(2, 0, 0))
-            self.render.attachNewNode(ls_pickup.create())
-
-        # Zeichne für jede Abgabestation den Align-Punkt (2 m in negative X-Richtung)
-        for station in self.abgabe_stationen:
-            station_pos = station.getPos()
-            ls_dropoff = LineSegs()
-            ls_dropoff.setThickness(3.0)
-            ls_dropoff.setColor(LColor(1, 1, 1, 1))
-            ls_dropoff.moveTo(station_pos)
-            ls_dropoff.drawTo(station_pos + Vec3(-2, 0, 0))
-            self.render.attachNewNode(ls_dropoff.create())
-
-        # --- Anfahrstationen (Startstationen) für die Fahrzeuge ---
-        # Diese werden bei Y = 15 nebeneinander mit 2 Meter Abstand in X-Richtung positioniert.
-        self.anfahrstationen = []
-        num_departure = 2  # Für zwei Fahrzeuge
-        spacing_departure = 2.0
-        start_x = -spacing_departure * (num_departure - 1) / 2  # z.B. -1 für 2 Fahrzeuge
-        for i in range(num_departure):
-            pos = Vec3(start_x + i * spacing_departure, 15, 0)
-            station = self.erzeuge_gitterbox(pos.getX(), pos.getY(), pos.getZ(), LColor(0.8, 0.8, 0, 1))
-            self.anfahrstationen.append(station)
-
-        # Fahrzeuge initialisieren und von den Anfahrstationen starten
-        self.vehicles = []
-        self.cargos = {}              # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}    # Fahrzeug -> zugewiesene Dropoff-Station
-
-        # Fahrzeug 1 startet von der ersten Anfahrstation
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(self.anfahrstationen[0].getPos())
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-        self.add_center_marker(vehicle1)
-        self.add_offset_circle(vehicle1, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Fahrzeug 2 startet von der zweiten Anfahrstation
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(self.anfahrstationen[1].getPos())
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-        self.add_center_marker(vehicle2)
-        self.add_offset_circle(vehicle2, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Erfassung von Daten für Graphen (einmal pro Simulationssekunde)
-        self.graph_data = []
-        self.taskMgr.doMethodLater(1, self.record_graph_data, "RecordGraphDataTask")
-
-        # Graphen öffnen per Taste "G" (nach Schließen wieder möglich)
-        self.graph_opened = False
-        self.accept("g", self.open_graph)
-
-        # Zoom-Funktionalität: Mit Mausrad hereinz- bzw. herauszoomen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_vehicle2_start, "CheckVehicle2StartTask")
-        self.taskMgr.add(self.update_lidar_status, "UpdateLidarStatusTask")
-
-        # Liefervorgang starten (Pickup-Phase)
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-
-    def zoom_in(self):
-        # Hereinzoomen: Field-of-View (FOV) verkleinern (nicht unter 10°)
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        # Herauszoomen: FOV vergrößern (nicht über 100°)
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschn. Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def record_graph_data(self, task):
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0
-        self.graph_data.append((self.sim_clock, delivered_per_minute, avg_dwell_time))
-        return Task.again
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def add_offset_circle(self, vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5, num_segments=32):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        for i in range(num_segments + 1):
-            angle = 2 * math.pi * i / num_segments
-            x = circle_radius * math.cos(angle)
-            y = circle_radius * math.sin(angle)
-            if i == 0:
-                ls.moveTo(x, y, 0)
-            else:
-                ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        circle_np = vehicle.attachNewNode(circle_geom)
-        circle_np.setPos(offset)
-        vehicle.setPythonTag("lidar_circle", circle_np)
-
-    def draw_coordinate_axes(self, axis_length=5):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(1, 0, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        ls.setColor(0, 1, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        ls.setColor(0, 0, 1, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), (1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), (0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), (0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def update_lidar_status(self, task):
-        sensor_threshold = 3.0
-        for vehicle in self.vehicles:
-            if vehicle.hasPythonTag("lidar_circle"):
-                lidar_circle = vehicle.getPythonTag("lidar_circle")
-                pos = vehicle.getPos(self.render)
-                collision = False
-                avoidance_vec = Vec3(0, 0, 0)
-                for other in self.vehicles:
-                    if other is not vehicle:
-                        pos_other = other.getPos(self.render)
-                        diff = pos - pos_other
-                        if diff.length() < sensor_threshold:
-                            collision = True
-                            if diff.length() > 0:
-                                avoidance_vec += diff.normalized() * (sensor_threshold - diff.length())
-                if collision:
-                    lidar_circle.setColor(LColor(1, 0, 0, 1))
-                    vehicle.setPythonTag("avoidance", avoidance_vec)
-                    vehicle.setPythonTag("speed_multiplier", 0.5)
-                else:
-                    lidar_circle.setColor(LColor(0, 1, 0, 1))
-                    vehicle.setPythonTag("avoidance", Vec3(0, 0, 0))
-                    vehicle.setPythonTag("speed_multiplier", 1.0)
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-        current_wait_text = (
-            f"Liegedauer (aktuell): {current_max_wait_time:.1f}s"
-            if current_max_wait_time > 0 else "Kein Paket an Annahmestation"
-        )
-        maximal_wait_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted_time}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-            f"{current_wait_text}\n"
-            f"{maximal_wait_text}\n"
-            f"Liegedauer (Durchschnitt): {avg_dwell_time:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def check_vehicle2_start(self, task):
-        if self.sim_clock >= 8.0 and not hasattr(self, 'vehicle2_started'):
-            self.vehicle2_started = True
-            self.start_delivery_cycle(self.vehicles[1], self.vehicles[1].getPos())
-            return Task.done
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(
-            station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1)
-        )
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            to_target = target - current_pos
-            distance = to_target.length()
-            multiplier = vehicle.getPythonTag("speed_multiplier") if vehicle.hasPythonTag("speed_multiplier") else 1.0
-            effective_speed = self.base_speed * self.speed_factor * multiplier
-            step_distance = effective_speed * dt
-            if distance <= step_distance:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-            avoidance = vehicle.getPythonTag("avoidance") if vehicle.hasPythonTag("avoidance") else Vec3(0, 0, 0)
-            if avoidance.length() > 0.001:
-                combined = to_target.normalized() + avoidance.normalized() * 0.5
-                combined.normalize()
-                new_direction = combined
-            else:
-                new_direction = to_target.normalized()
-            vehicle.setPos(current_pos + new_direction * step_distance)
-            return Task.cont
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        pickup_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        self.move_vehicle_to(vehicle, pickup_align,
-            lambda: self.move_vehicle_to(
-                vehicle,
-                pickup_station.getPos(),
-                lambda: self.after_pickup(vehicle, pickup_station)
-            )
-        )
-
-    def after_pickup(self, vehicle, pickup_station):
-        self.pickup_package(vehicle, pickup_station)
-        self.depart_from_pickup(vehicle, pickup_station,
-            lambda: self.start_dropoff_phase(vehicle)
-        )
-
-    def depart_from_pickup(self, vehicle, pickup_station, callback):
-        departure_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        departure_target = pickup_station.getPos() + Vec3(4, 0, 0)
-        self.move_vehicle_to(vehicle, departure_align,
-            lambda: self.move_vehicle_to(vehicle, departure_target, callback)
-        )
-
-    def start_dropoff_phase(self, vehicle):
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.start_dropoff_phase(vehicle)
-            return
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-        self.move_vehicle_to(vehicle, dropoff_align,
-            lambda: self.move_vehicle_to(vehicle, dropoff_station.getPos(),
-                lambda: self.after_dropoff(vehicle)
-            )
-        )
-
-    def after_dropoff(self, vehicle):
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        self.drop_cargo(vehicle)
-        self.remove_cargo(vehicle, remove_dropoff=True)
-        if dropoff_station is not None:
-            departure_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-            departure_target = dropoff_station.getPos() + Vec3(-4, 0, 0)
-            self.move_vehicle_to(vehicle, departure_align,
-                lambda: self.move_vehicle_to(vehicle, departure_target,
-                    lambda: self.start_delivery_cycle(vehicle, departure_target)
-                )
-            )
-        else:
-            self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle, remove_dropoff=True):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        if remove_dropoff:
-            dropoff_station = self.current_dropoffs.get(vehicle)
-            if dropoff_station in self.occupied_dropoffs:
-                self.occupied_dropoffs.remove(dropoff_station)
-            if vehicle in self.current_dropoffs:
-                del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices+1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices+1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z+1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
Index: Grundmodell/Gm2.py
===================================================================
diff --git a/Grundmodell/Gm2.py b/Grundmodell/Gm2.py
deleted file mode 100644
--- a/Grundmodell/Gm2.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,579 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Für das Paketspawning an den Annahmestationen
-        self.pickup_packages = {}  # station (NodePath) -> (Paket, Spawnzeit, Timer Node)
-        self.last_removed = {}  # station -> Zeitpunkt der letzten Entfernung
-
-        # Für Graph-Daten und Steuerung
-        self.graph_data = []  # Tupel: (Sim-Zeit, Pakete pro Minute, Durchschnittliche Liegedauer)
-        self.graph_opened = False
-
-        # Ursprung (Koordinatenachsen)
-        self.draw_origin()
-
-        # Kameraeinstellungen: Das ganze Feld soll gut sichtbar sein.
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # Licht und Bodenraster erzeugen
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-
-        # Erzeuge die Mauer (das umschließende Rechteck)
-        self.create_wall()
-
-        # Erzeuge Annahme-, Abgabe- und Garagenstationen
-        self.create_annahme_stations()
-        self.create_abgabe_stations()
-        self.create_garagen_stations()
-
-        # UI: Slider und Info-Anzeige zur Simulationssteuerung
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktion: Mit dem Mausrad hereinz- bzw. herauszoomen.
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        # Graph in extra Fenster per Taste "g" öffnen
-        self.accept("g", self.open_graph)
-
-        # Tasks: Aktualisierung der Simulationszeit, Info-Anzeige, Paketspawning, Paket-Timer und Graph-Daten
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-
-        # Bestimme aktuelle maximale Liegedauer aller wartenden Pakete
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        # X-Achse (rot)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        # Y-Achse (grün)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        # Z-Achse (blau)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # Original Funktion: Annahme-Station (ohne Z-Verschiebung)
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_annahme_station(pt)
-            # Dummy-Node als Referenz für das Paketspawning
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-            # Ursprünglicher Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Zusätzlicher grüner Punkt: 0.5 in positive Z-Richtung vom Mittelpunkt
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, 0.5))
-            green_dot.reparentTo(self.render)
-
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            # Dekorative Kreuze hinzufügen
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-    # Original Funktion: Abgabestation (ohne Z-Verschiebung)
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_abgabe_station(pt)
-            # Ursprünglicher Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Zusätzlicher grüner Punkt: 0.5 in positive Z-Richtung vom Mittelpunkt
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, 0.5))
-            green_dot.reparentTo(self.render)
-
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            # Dekorative Kreuze hinzufügen
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 2)
-        v5 = pos + Vec3(1, 0, 2)
-        v6 = pos + Vec3(1, 2, 2)
-        v7 = pos + Vec3(0, 2, 2)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        # Dekorative Kreuze auf geschlossenen Seiten (nicht auf dem Dach)
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 2)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            center = pt + Vec3(0.5, 1, 1)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    # Methoden für Paketspawning und Timer
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        cube = self.loader.loadModel("models/box")
-        cube.setScale(1, 1, 1)
-        cube.setPos(x, y, z + 1)
-        cube.setColor(farbe)
-        cube.reparentTo(self.render)
-        return cube
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)  # 1 Sekunde Simulationszeit
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-    def update_package_timers(self, task):
-        to_remove = []
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            elapsed = self.sim_clock - spawn_time
-            timer_np.node().setText(f"{elapsed:.1f}s")
-            # Wenn das Paket zu lange an der Station liegt (z. B. 5s), entferne es und aktualisiere Kennzahlen.
-            if elapsed >= 5.0:
-                package.removeNode()
-                self.total_dwell_time += elapsed
-                self.picked_up_count += 1
-                self.delivered_packages += 1
-                to_remove.append(station)
-        for station in to_remove:
-            if station in self.pickup_packages:
-                del self.pickup_packages[station]
-            self.last_removed[station] = self.sim_clock
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor != 0 else t
-
-    # Methoden für graphische Darstellung der Kennzahlen
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.setTitle("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.setTitle("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: KI/KI16.py
===================================================================
diff --git a/KI/KI16.py b/KI/KI16.py
deleted file mode 100644
--- a/KI/KI16.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,380 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode
-)
-
-# Wir nutzen globalClock für dt
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit bleibt konstant: 1.5 m/s.
-        self.base_speed = 1.5
-        # Der Multiplikator (speed_factor) steuert den Zeitskalierungsfaktor.
-        # Startwert 1.0 => normale Simulation.
-        self.speed_factor = 1.0
-
-        # Eigener Simulationszeitticker (in simulierten Sekunden)
-        self.sim_clock = 0.0
-        # Zähler der abgegebenen Pakete
-        self.delivered_packages = 0
-
-        # Zeitpunkt des Simulationsstart (reale Zeit)
-        self.sim_start_real = globalClock.getFrameTime()
-
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeuge initialisieren – zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}  # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}  # Fahrzeug -> aktuell reservierte Abgabestation
-
-        # Fahrzeug 1: startet sofort
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-
-        # Fahrzeug 2: startet 8 simulierte Sekunden später
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)  # y-Offset von 2 Einheiten
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-
-        # Globaler Pool für Pickup-Pakete und Zeitstempel (in simulierten Sekunden)
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider zur Anpassung des Multiplikators (Zeitskalierung)
-        # Wertebereich: 0.1 bis 10, Startwert: 1.0
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Info-Anzeige rechts: Laufzeit der Simulation, Summe abgegebener Pakete und Kennzahl des am längsten wartenden Pakets
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tasks:
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_vehicle2_start, "CheckVehicle2StartTask")
-
-        # Fahrzeug 1 startet den Liefervorgang sofort
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-        # Fahrzeug 2 startet, sobald 8 simulierte Sekunden erreicht sind (über Task)
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        # Erhöhe die interne Simulationszeit um dt * speed_factor.
-        # Höherer Faktor => Simulation läuft schneller (mehr simulierte Sekunden pro realer Sekunde)
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        max_wait_time = 0
-        max_wait_package = None
-
-        # Berechne die maximale Wartezeit aller Pakete an den Annahmestationen
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > max_wait_time:
-                max_wait_time = elapsed
-                max_wait_package = package
-
-        if max_wait_package:
-            max_wait_text = f"Paket mit höchster Wartezeit: {max_wait_time:.1f}s"
-        else:
-            max_wait_text = "Kein Paket an Annahmestation"
-
-        self.info_label['text'] = (f"Laufzeit: {self.sim_clock:.1f} s\n"
-                                   f"Abgegebene Pakete: {self.delivered_packages}\n"
-                                   f"{max_wait_text}")
-        return Task.cont
-
-    def sim_time(self, t):
-        """
-        Skalierung eines Basiszeitwerts t (in Sekunden) anhand des Multiplikators.
-        Wir verwenden hier die Formel: t / speed_factor.
-        Dadurch wird bei einem kleineren Faktor (z. B. 0.1) t größer (Simulation wird verlangsamt),
-        und bei einem höheren Faktor (z. B. 10) t kleiner (Simulation beschleunigt).
-        """
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def check_vehicle2_start(self, task):
-        """
-        Überprüft kontinuierlich, ob 8 simulierte Sekunden vergangen sind.
-        Sobald self.sim_clock >= 8, wird Fahrzeug 2 gestartet.
-        """
-        if self.sim_clock >= 8.0 and not hasattr(self, 'vehicle2_started'):
-            self.vehicle2_started = True
-            self.start_delivery_cycle(self.vehicles[1], self.vehicles[1].getPos())
-            return Task.done
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        # Basiswartezeit von 1 simulierten Sekunde:
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            direction = target - current_pos
-            distance = direction.length()
-            # Effektiver Schritt = (base_speed * speed_factor) * dt.
-            # Höherer Multiplikator => Fahrzeuge bewegen sich in realer Zeit schneller.
-            step = (self.base_speed * self.speed_factor) * dt
-            if distance <= step:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-            else:
-                vehicle.setPos(current_pos + direction.normalized() * step)
-                return Task.cont
-
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        pickup_pos = pickup_station.getPos()
-
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.occupied_pickups.remove(pickup_station)
-
-            def wait_for_dropoff(task):
-                if any(ds not in self.occupied_dropoffs for ds in self.abgabe_stationen):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_dropoff, f"WaitDropoff_{id(vehicle)}")
-            return
-
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_pos = dropoff_station.getPos()
-
-        self.move_vehicle_to(vehicle, pickup_pos, lambda: self.after_pickup(vehicle, pickup_station, dropoff_pos))
-
-    def after_pickup(self, vehicle, pickup_station, dropoff_pos):
-        self.pickup_package(vehicle, pickup_station)
-        self.move_vehicle_to(vehicle, dropoff_pos, lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        self.drop_cargo(vehicle)
-        start_wait = self.sim_clock
-
-        def wait_task(task):
-            if self.sim_clock - start_wait >= self.sim_time(1):
-                self.finish_cycle(vehicle)
-                return Task.done
-            return Task.cont
-
-        self.taskMgr.add(wait_task, f"WaitAfterDrop_{id(vehicle)}")
-
-    def finish_cycle(self, vehicle):
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        if dropoff_station in self.occupied_dropoffs:
-            self.occupied_dropoffs.remove(dropoff_station)
-            del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
Index: KI/KI40.py
===================================================================
diff --git a/KI/KI40.py b/KI/KI40.py
deleted file mode 100644
--- a/KI/KI40.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,184 +0,0 @@
-from panda3d.core import loadPrcFileData
-# Setze Konfigurationswerte, damit ein Fenster erzeugt wird
-loadPrcFileData("", "window-type onscreen")
-loadPrcFileData("", "win-size 800 600")
-loadPrcFileData("", "window-title Lager Simulation")
-
-import random
-import math
-import matplotlib.pyplot as plt  # Matplotlib zum Plotten importieren
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs,
-    CardMaker, AmbientLight, DirectionalLight
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-from panda3d.ai import AIBehaviors   # Import für AIBehaviors
-
-# globalClock zur Berechnung von dt
-globalClock = ClockObject.getGlobalClock()
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basis-Parameter
-        self.base_speed = 1.5  # m/s
-        self.speed_factor = 1.0
-        self.max_steering_rate = 90  # Grad pro Sekunde
-        self.acceleration = 2.5  # m/s²
-        self.braking_deceleration = -2.5  # m/s²
-
-        # Statistiken
-        self.sim_clock = 0.0
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        self.sim_start_real = globalClock.getFrameTime()
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-        # Erzeuge Stationen
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # (Zeichne Align-Punkte, Anfahrstationen etc.)
-        # ... [Die übrigen Zeichnungs- und Setup-Methoden bleiben hier unverändert] ...
-
-        # Anfahrstationen für Fahrzeuge
-        self.anfahrstationen = []
-        num_departure = 2
-        spacing_departure = 4.0
-        start_x = -spacing_departure * (num_departure - 1) / 2
-        for i in range(num_departure):
-            pos = Vec3(start_x + i * spacing_departure, 15, 0)
-            station = self.erzeuge_gitterbox(pos.getX(), pos.getY(), pos.getZ(), LColor(0.8, 0.8, 0, 1))
-            self.anfahrstationen.append(station)
-
-        # Fahrzeuge erstellen und mit AI ausstatten
-        self.vehicles = []
-        self.cargos = {}
-        self.current_dropoffs = {}
-        for i, start_station in enumerate(self.anfahrstationen):
-            vehicle = self.loader.loadModel("models/box")
-            vehicle.setScale(2, 1, 0.5)
-            if i % 2 == 0:
-                vehicle.setColor(LColor(0, 0, 1, 1))
-            else:
-                vehicle.setColor(LColor(0, 0, 0.8, 1))
-            vehicle.setPos(start_station.getPos())
-            vehicle.reparentTo(self.render)
-            vehicle.setPythonTag("current_speed", 0.0)
-            vehicle.setH(0)
-            vehicle.setPythonTag("phase", "pickup")
-            # Marker und AI setzen:
-            self.add_center_marker(vehicle)
-            self.add_front_marker(vehicle)
-            self.add_y_marker(vehicle)
-            self.add_alignment_marker(vehicle)
-            self.add_offset_circle(vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-            self.setup_ai_for_vehicle(vehicle)  # AI-Behaviors initialisieren
-            self.vehicles.append(vehicle)
-
-        # Restliche Logik, GUI, Tasks etc.
-        # ... [Die übrigen Methoden zur Logik (Pickup/Dropoff, Slider, etc.) bleiben unverändert] ...
-
-        # Starte den Liefervorgang gestaffelt
-        for i, vehicle in enumerate(self.vehicles):
-            self.taskMgr.doMethodLater(i * 0.5,
-                                       lambda task, v=vehicle: self.start_delivery_cycle(v, v.getPos()),
-                                       f"StartDeliveryCycleTask_{i}")
-
-    def setup_ai_for_vehicle(self, vehicle):
-        # Initialisiert AIBehaviors für das Fahrzeug (Parameter anpassen, falls nötig)
-        ai_behaviors = AIBehaviors(vehicle, 10.0, self.base_speed, 1.0)
-        vehicle.setPythonTag("ai_behaviors", ai_behaviors)
-
-    # Die restlichen Methoden (zoom_in, zoom_out, open_graph etc.) bleiben unverändert
-    # ...
-    # Beispiel: move_vehicle_to mithilfe von AIBehaviors:
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        ai_behaviors = vehicle.getPythonTag("ai_behaviors")
-        if ai_behaviors is None:
-            print("Kein AI-Behaviors-Objekt vorhanden, verwende manuelle Navigation.")
-            # Fallback (nicht implementiert, da hier ausschließlich AI-Navigation genutzt wird)
-            return
-        # Starte den Pfadfindungs-Behavior
-        ai_behaviors.pathFindTo(target)
-        def check_arrival(task):
-            if (target - vehicle.getPos()).length() < 0.5:
-                ai_behaviors.clearBehaviors()
-                on_complete()
-                return Task.done
-            return Task.cont
-        self.taskMgr.add(check_arrival, f"check_arrival_{id(vehicle)}")
-
-    # Die übrigen Methoden (update_sim_clock, add_center_marker, etc.) kommen hierher
-    # ...
-
-    # Beispiel für eine einfache Lichtquelle:
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-    # Beispiel für Bodenraster:
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    # Weitere Methoden zur Logik, Markierung, Alignment, etc. folgen hier...
-    # [Die übrigen Methoden bleibe ich hier gekürzt – in deinem Code sind sie vorhanden.]
-
-app = LagerSimulation()
-app.run()
Index: script.py
===================================================================
diff --git a/script.py b/script.py
deleted file mode 100644
--- a/script.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,16 +0,0 @@
-# This is a sample Python script.
-
-# Press Umschalt+F10 to execute it or replace it with your code.
-# Press Double Shift to search everywhere for classes, files, tool windows, actions, and settings.
-
-
-def print_hi(name):
-    # Use a breakpoint in the code line below to debug your script.
-    print(f'Hi, {name}')  # Press Strg+F8 to toggle the breakpoint.
-
-
-# Press the green button in the gutter to run the script.
-if __name__ == '__main__':
-    print_hi('PyCharm')
-
-# See PyCharm help at https://www.jetbrains.com/help/pycharm/
Index: FFZ/FFZ20.py
===================================================================
diff --git a/FFZ/FFZ20.py b/FFZ/FFZ20.py
deleted file mode 100644
--- a/FFZ/FFZ20.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,478 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    LineSegs,
-    Vec3,
-    NodePath
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import math
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5  # Standardgeschwindigkeit in m/s
-
-        # Kameraeinstellungen (Fahrtrichtung: entlang der Y-Achse)
-        self.cam.setPos(0, -30, 10)
-        self.cam.lookAt(0, 0, 0)
-
-        # Licht und Raster erstellen
-        self.setup_light()
-        self.create_grid(center_extent=10, cell_size=0.1)
-
-        # Fahrzeug erstellen (Chassis, Gabel, Mast, etc.)
-        self.vehicle = self.create_vehicle()
-
-        # Regler für die Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Laufzeitanzeige
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom via Mausrad
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Update-Tasks
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        # Der Task zur Bewegung des Fahrzeugs wurde entfernt – somit fährt das Fahrzeug aktuell nicht.
-        # self.taskMgr.add(self.update_vehicle, "UpdateVehicleTask")
-        # Optional: Der Task für eine mögliche Gabel-Animation (update_cable) kann hinzugefügt werden.
-        # self.taskMgr.add(self.update_cable, "UpdateCableTask")
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        # Dieser Task wird aktuell nicht aufgerufen, sodass das Fahrzeug stationär bleibt.
-        dt = ClockObject.getGlobalClock().getDt()
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0  # Beschleunigungs-/Verzögerungsrate in m/s²
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    def create_grid(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            x += cell_size
-
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        grid_np = self.render.attachNewNode(node)
-        grid_np.setColor(0.7, 0.7, 0.7, 1)
-        return grid_np
-
-    def setup_light(self):
-        ambient_light = AmbientLight("ambient_light")
-        ambient_light.setColor((0.5, 0.5, 0.5, 1))
-        ambient_np = self.render.attachNewNode(ambient_light)
-        self.render.setLight(ambient_np)
-
-        directional_light = DirectionalLight("directional_light")
-        directional_light.setColor((1, 1, 1, 1))
-        directional_np = self.render.attachNewNode(directional_light)
-        directional_np.setPos(10, -10, 10)
-        self.render.setLight(directional_np)
-
-    def create_vehicle(self):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Fahrmodul (Chassis): 1 x 0.5 x 1.2 in Rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-
-        # Schwarze Kanten zum Fahrmodul hinzufügen
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # Gabelmodul (Fork): Zwei Zähne (je 0.2 x 1.2 x 0.1)
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-        self.fork_node = fork_node
-
-        # --- Zeichne die Linie, die die äußersten Ecken des hinteren Endes der Zähne verbindet ---
-        # Lokale Koordinaten: linker Zahn: (0, 0, 0.05), rechter Zahn: (1.0, 0, 0.05)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_corner_global = fork_node.getPos() + left_corner_local
-        right_corner_global = fork_node.getPos() + right_corner_local
-
-        ls_new = LineSegs()
-        ls_new.setThickness(2.0)
-        ls_new.setColor(1, 1, 1, 1)  # Weiß
-        ls_new.moveTo(left_corner_global)
-        ls_new.drawTo(right_corner_global)
-        vehicle_node.attachNewNode(ls_new.create())
-
-        # --- Zusätzliche Linie: von der Mitte der obigen Linie genau senkrecht in Richtung Fahrzeug ---
-        # Berechne den Mittelpunkt der Verbindungslinie:
-        midpoint = (left_corner_global + right_corner_global) * 0.5
-
-        # Errechne den Richtungsvektor der Verbindungslinie:
-        white_line_vec = right_corner_global - left_corner_global
-        if white_line_vec.length() != 0:
-            white_line_dir = white_line_vec.normalized()
-        else:
-            white_line_dir = Vec3(0, 0, 0)
-
-        # Zwei senkrechte Richtungen (in der XY-Ebene):
-        candidate = Vec3(-white_line_dir.getY(), white_line_dir.getX(), 0)
-        # Fahrzeugposition (Chassis) befindet sich im Fahrzeugknoten bei (0,0,0).
-        vehicle_pos = vehicle_node.getPos()
-        # Wähle die senkrechte Richtung, die in Richtung des Fahrzeugs zeigt:
-        if candidate.dot(vehicle_pos - midpoint) < 0:
-            candidate = -candidate
-        if candidate.length() != 0:
-            perp_direction = candidate.normalized()
-        else:
-            perp_direction = Vec3(0, 0, 0)
-
-        # Länge der neuen Linie (z. B. 1 Meter)
-        line_length = 1.0
-        line_end = midpoint + perp_direction * line_length
-
-        ls_mid = LineSegs()
-        ls_mid.setThickness(2.0)
-        ls_mid.setColor(1, 1, 1, 1)  # Weiß
-        ls_mid.moveTo(midpoint)
-        ls_mid.drawTo(line_end)
-        vehicle_node.attachNewNode(ls_mid.create())
-
-        # --- Setze einen grünen Punkt 0.5 Meter vom Schnittpunkt (Midpoint) entlang der senkrechten Richtung ---
-        green_point_global = midpoint + perp_direction * 0.5
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))  # Grün
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.05 / 2, 0.05 / 2, 0.05 / 2))
-
-        # --- Restlicher Fahrzeugaufbau (Mast, Diagonalen, etc.) ---
-        mast_node = vehicle_node.attachNewNode("mast")
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-
-        self.add_diagonals_to_mast(mast_node)
-        intersection = Vec3(0.5, 0.05, 1.0)
-
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        lidar_center = Vec3(intersection.x, intersection.y, -1)
-        self.add_lidar_circle(mast_node, lidar_center, 2)
-
-        # Positioniere den Fahrzeugknoten so, dass dessen X- und Y-Koordinaten dem Schnittpunkt der Diagonalen entsprechen
-        vehicle_node.setPos(intersection.x, intersection.y, 0)
-
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)  # Orange
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)  # Grün
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        # Top center
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        # Top circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        # Bottom center
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        # Bottom circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        # Top fan
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        # Bottom fan
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        # Side faces
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        # Unterseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        # Oberseite
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        # Vorderseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        # Rückseite
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        # Linke Seite
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        # Rechte Seite
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        # Unterkante
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        # Oberkante
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        # Vertikale Kanten
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: KI/KI20.py
===================================================================
diff --git a/KI/KI20.py b/KI/KI20.py
deleted file mode 100644
--- a/KI/KI20.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,403 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode
-)
-
-# Wir nutzen globalClock für dt
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit bleibt konstant: 1.5 m/s.
-        self.base_speed = 1.5
-        # Der Multiplikator (speed_factor) steuert den Zeitskalierungsfaktor.
-        # Startwert 1.0 => normale Simulation.
-        self.speed_factor = 1.0
-
-        # Eigener Simulationszeitticker (in simulierten Sekunden)
-        self.sim_clock = 0.0
-        # Zähler der abgegebenen Pakete
-        self.delivered_packages = 0
-        # Hier wird die bisher maximal erreichte Liegedauer (Wartezeit) gespeichert.
-        self.max_overall_wait_time = 0.0
-
-        # Zeitpunkt des Simulationsstart (reale Zeit)
-        self.sim_start_real = globalClock.getFrameTime()
-
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeuge initialisieren – zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}  # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}  # Fahrzeug -> aktuell reservierte Abgabestation
-
-        # Fahrzeug 1: startet sofort
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-
-        # Fahrzeug 2: startet 8 simulierte Sekunden später
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)  # y-Offset von 2 Einheiten
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-
-        # Globaler Pool für Pickup-Pakete und Zeitstempel (in simulierten Sekunden)
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider zur Anpassung des Multiplikators (Zeitskalierung)
-        # Wertebereich: 0.1 bis 10, Startwert: 1.0
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Info-Anzeige rechts: Laufzeit (in h, m, s), Summe abgegebener Pakete,
-        # Pakete pro Minute sowie Kennzahlen der Liegedauer.
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tasks:
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_vehicle2_start, "CheckVehicle2StartTask")
-
-        # Fahrzeug 1 startet den Liefervorgang sofort
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-        # Fahrzeug 2 startet, sobald 8 simulierte Sekunden erreicht sind (über Task)
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        # Erhöhe die interne Simulationszeit um dt * speed_factor.
-        # Höherer Faktor => Simulation läuft schneller (mehr simulierte Sekunden pro realer Sekunde)
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        # Berechnung der aktuellen maximalen Liegedauer aller Pakete an den Annahmestationen
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-
-        # Aktualisieren der über die gesamte Simulationslaufzeit maximal erreichten Liegedauer
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-
-        # Formatierung der beiden Kennzahlen
-        if current_max_wait_time > 0:
-            current_wait_text = f"Liegedauer (aktuell): {current_max_wait_time:.1f}s"
-        else:
-            current_wait_text = "Kein Paket an Annahmestation"
-
-        maximal_wait_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-
-        # Gliedere die simulierte Laufzeit in Stunden, Minuten und Sekunden
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-
-        # Berechne die abgegebenen Pakete pro Minute (basierend auf der simulierten Zeit)
-        if self.sim_clock > 0:
-            delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0)
-        else:
-            delivered_per_minute = 0
-
-        self.info_label['text'] = (f"Laufzeit: {formatted_time}\n"
-                                   f"Abgegebene Pakete: {self.delivered_packages}\n"
-                                   f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-                                   f"{current_wait_text}\n"
-                                   f"{maximal_wait_text}")
-        return Task.cont
-
-    def sim_time(self, t):
-        """
-        Skalierung eines Basiszeitwerts t (in Sekunden) anhand des Multiplikators.
-        Wir verwenden hier die Formel: t / speed_factor.
-        Dadurch wird bei einem kleineren Faktor (z. B. 0.1) t größer (Simulation wird verlangsamt),
-        und bei einem höheren Faktor (z. B. 10) t kleiner (Simulation beschleunigt).
-        """
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def check_vehicle2_start(self, task):
-        """
-        Überprüft kontinuierlich, ob 8 simulierte Sekunden vergangen sind.
-        Sobald self.sim_clock >= 8, wird Fahrzeug 2 gestartet.
-        """
-        if self.sim_clock >= 8.0 and not hasattr(self, 'vehicle2_started'):
-            self.vehicle2_started = True
-            self.start_delivery_cycle(self.vehicles[1], self.vehicles[1].getPos())
-            return Task.done
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        # Basiswartezeit von 1 simulierten Sekunde:
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(
-            station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1)
-        )
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            direction = target - current_pos
-            distance = direction.length()
-            # Effektiver Schritt = (base_speed * speed_factor) * dt.
-            # Höherer Multiplikator => Fahrzeuge bewegen sich in realer Zeit schneller.
-            step = (self.base_speed * self.speed_factor) * dt
-            if distance <= step:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-            else:
-                vehicle.setPos(current_pos + direction.normalized() * step)
-                return Task.cont
-
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        pickup_pos = pickup_station.getPos()
-
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.occupied_pickups.remove(pickup_station)
-
-            def wait_for_dropoff(task):
-                if any(ds not in self.occupied_dropoffs for ds in self.abgabe_stationen):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_dropoff, f"WaitDropoff_{id(vehicle)}")
-            return
-
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_pos = dropoff_station.getPos()
-
-        self.move_vehicle_to(vehicle, pickup_pos, lambda: self.after_pickup(vehicle, pickup_station, dropoff_pos))
-
-    def after_pickup(self, vehicle, pickup_station, dropoff_pos):
-        self.pickup_package(vehicle, pickup_station)
-        self.move_vehicle_to(vehicle, dropoff_pos, lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        self.drop_cargo(vehicle)
-        start_wait = self.sim_clock
-
-        def wait_task(task):
-            if self.sim_clock - start_wait >= self.sim_time(1):
-                self.finish_cycle(vehicle)
-                return Task.done
-            return Task.cont
-
-        self.taskMgr.add(wait_task, f"WaitAfterDrop_{id(vehicle)}")
-
-    def finish_cycle(self, vehicle):
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        if dropoff_station in self.occupied_dropoffs:
-            self.occupied_dropoffs.remove(dropoff_station)
-            del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
Index: FFZ/FFZ16.py
===================================================================
diff --git a/FFZ/FFZ16.py b/FFZ/FFZ16.py
deleted file mode 100644
--- a/FFZ/FFZ16.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,506 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    LineSegs,
-    Vec3,
-    NodePath
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import random
-import math
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5  # Startgeschwindigkeit in m/s
-        self.obstacles = []       # Liste der Hindernisse
-
-        # Kameraeinstellungen (Fahrtrichtung entlang der Y-Achse)
-        self.cam.setPos(0, -30, 10)
-        self.cam.lookAt(0, 0, 0)
-
-        # Licht und Raster
-        self.setup_light()
-        self.create_grid(center_extent=10, cell_size=0.1)
-
-        # Zufällige Hindernisse erzeugen
-        self.create_obstacles()
-
-        # Fahrzeug erstellen (Chassis, Fork, Mast, etc.)
-        self.vehicle = self.create_vehicle()
-
-        # Slider für Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Slider zur Einstellung der Forkhöhe (0 bis 1 m)
-        self.fork_slider = DirectSlider(
-            range=(0.0, 1.0),
-            value=0.0,
-            pageSize=0.01,
-            command=self.update_fork_height,
-            pos=(-0.7, 0, -0.85),
-            scale=0.3
-        )
-        self.fork_label = DirectLabel(
-            text="Fork Höhe: 0.00m",
-            pos=(-0.7, 0, -0.75),
-            scale=0.07
-        )
-
-        # Laufzeitanzeige
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom via Mausrad
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Fahrzeugbewegung mit Hindernisvermeidung und dynamischer Geschwindigkeitsanpassung
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_vehicle, "UpdateVehicleTask")
-
-    def create_obstacles(self):
-        """Erzeugt 10 zufällige Hindernisse als Boxen, die auf der Ebene (Z=0) platziert werden."""
-        for i in range(10):
-            w = random.uniform(0.3, 0.7)
-            d = random.uniform(0.3, 0.7)
-            h = 0.5
-            box = self.create_box(w, d, h, (0.5, 0.5, 0.5, 1))
-            obstacle = self.render.attachNewNode(box)
-            x = random.uniform(-5, 5)
-            y = random.uniform(-5, 5)
-            obstacle.setPos(x, y, 0)
-            self.obstacles.append(obstacle)
-
-    def update_vehicle(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        # Berechne den minimalen Abstand zu Hindernissen vor dem Fahrzeug
-        min_dist = float("inf")
-        for obs in self.obstacles:
-            obs_pos = obs.getPos(self.render)
-            diff = obs_pos - pos
-            if diff.dot(forward) > 0:
-                dist = diff.length()
-                min_dist = min(min_dist, dist)
-
-        # Bestimme Zielgeschwindigkeit: Normal 1.5 m/s, falls Hindernis nahe (<3 m) verlangsamen; falls <0.5 m rückwärts
-        if min_dist < float("inf"):
-            if min_dist < 0.5:
-                target_speed = -0.5
-            elif min_dist < 3.0:
-                target_speed = 0.5
-            else:
-                target_speed = 1.5
-        else:
-            target_speed = 1.5
-
-        # Passe die aktuelle Geschwindigkeit (Beschleunigungsrate 2 m/s²)
-        acc_rate = 2.0
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        # Hindernisbasierte Lenkung
-        avoid_vector = Vec3(0, 0, 0)
-        for obs in self.obstacles:
-            obs_pos = obs.getPos(self.render)
-            diff = obs_pos - pos
-            if diff.dot(forward) > 0 and diff.length() < 3.0:
-                avoid_vector += diff.normalized() * ((3.0 - diff.length()) / 3.0)
-
-        current_heading = self.vehicle.getH()
-        if avoid_vector.length() > 0:
-            if target_speed < 0:
-                desired_dir = -(forward + avoid_vector).normalized()
-            else:
-                desired_dir = (forward + avoid_vector).normalized()
-            desired_heading = math.degrees(math.atan2(desired_dir.getX(), desired_dir.getY()))
-            new_heading = current_heading + 0.1 * (desired_heading - current_heading)
-            self.vehicle.setH(new_heading)
-            forward = self.vehicle.getQuat().getForward()
-
-        # Aktualisiere Fahrzeugposition
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_fork_height(self, height=0, *args):
-        try:
-            height = float(height)
-        except ValueError:
-            height = 0.0
-        self.fork_node.setZ(height)
-        self.fork_label['text'] = f"Fork Höhe: {height:.2f}m"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def create_grid(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            x += cell_size
-
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        grid_np = self.render.attachNewNode(node)
-        grid_np.setColor(0.7, 0.7, 0.7, 1)
-        return grid_np
-
-    def setup_light(self):
-        ambient_light = AmbientLight("ambient_light")
-        ambient_light.setColor((0.5, 0.5, 0.5, 1))
-        ambient_np = self.render.attachNewNode(ambient_light)
-        self.render.setLight(ambient_np)
-
-        directional_light = DirectionalLight("directional_light")
-        directional_light.setColor((1, 1, 1, 1))
-        directional_np = self.render.attachNewNode(directional_light)
-        directional_np.setPos(10, -10, 10)
-        self.render.setLight(directional_np)
-
-    def create_vehicle(self):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Fahrmodul (Chassis): 1 x 0.5 x 1.2 in Rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        # Schwarze Kanten für das Chassis
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # Gabelmodul (Fork): Zwei Zähne (je 0.2 x 1.2 x 0.1)
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-        self.fork_node = fork_node
-
-        # Mast: Rahmen aus vier Balken
-        mast_node = vehicle_node.attachNewNode("mast")
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-
-        # Diagonalen auf der oberen Fläche des Mastes
-        self.add_diagonals_to_mast(mast_node)
-        # Schnittpunkt der Diagonalen in lokalen Mast-Koordinaten
-        intersection = Vec3(0.5, 0.05, 1.0)
-
-        # Gelber Zylinder: Durchmesser 0.1, Höhe 0.1, Farbe Gelb (1,1,0,1)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        # Lidar-Kreis: Mittelpunkt soll 1 m in negativer Z-Richtung liegen (also Z = -1),
-        # Farbe Grün, Radius 2
-        lidar_center = Vec3(intersection.x, intersection.y, -1)
-        self.add_lidar_circle(mast_node, lidar_center, 2)
-
-        # Setze den Fahrzeugknoten so, dass seine X- und Y-Koordinaten dem Schnittpunkt der Diagonalen (auf dem Mast) entsprechen,
-        # und in Z-Richtung 0 ist (d.h. das Fahrzeug sitzt auf der Ebene).
-        # Das bedeutet: vehicle_node.setPos(intersection.x, intersection.y, 0)
-        vehicle_node.setPos(intersection.x, intersection.y, 0)
-
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)  # Orange
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)  # Grün
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        # Top center
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        # Top circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        # Bottom center
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        # Bottom circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        # Top fan
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        # Bottom fan
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        # Side faces
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        # Unterseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        # Oberseite
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        # Vorderseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        # Rückseite
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        # Linke Seite
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        # Rechte Seite
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base+1, base+2)
-            tris.closePrimitive()
-            tris.addVertices(base, base+2, base+3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        # Unterkante
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        # Oberkante
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        # Vertikale Kanten
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: KI/KI19.py
===================================================================
diff --git a/KI/KI19.py b/KI/KI19.py
deleted file mode 100644
--- a/KI/KI19.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,401 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode
-)
-
-# Wir nutzen globalClock für dt
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit bleibt konstant: 1.5 m/s.
-        self.base_speed = 1.5
-        # Der Multiplikator (speed_factor) steuert den Zeitskalierungsfaktor.
-        # Startwert 1.0 => normale Simulation.
-        self.speed_factor = 1.0
-
-        # Eigener Simulationszeitticker (in simulierten Sekunden)
-        self.sim_clock = 0.0
-        # Zähler der abgegebenen Pakete
-        self.delivered_packages = 0
-        # Hier wird die bisher maximal erreichte Wartezeit gespeichert.
-        self.max_overall_wait_time = 0.0
-
-        # Zeitpunkt des Simulationsstart (reale Zeit)
-        self.sim_start_real = globalClock.getFrameTime()
-
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeuge initialisieren – zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}  # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}  # Fahrzeug -> aktuell reservierte Abgabestation
-
-        # Fahrzeug 1: startet sofort
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-
-        # Fahrzeug 2: startet 8 simulierte Sekunden später
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)  # y-Offset von 2 Einheiten
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-
-        # Globaler Pool für Pickup-Pakete und Zeitstempel (in simulierten Sekunden)
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider zur Anpassung des Multiplikators (Zeitskalierung)
-        # Wertebereich: 0.1 bis 10, Startwert: 1.0
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Info-Anzeige rechts: Laufzeit (in h, m, s), Summe abgegebener Pakete,
-        # Pakete pro Minute sowie Kennzahlen der Wartezeiten.
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tasks:
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_vehicle2_start, "CheckVehicle2StartTask")
-
-        # Fahrzeug 1 startet den Liefervorgang sofort
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-        # Fahrzeug 2 startet, sobald 8 simulierte Sekunden erreicht sind (über Task)
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        # Erhöhe die interne Simulationszeit um dt * speed_factor.
-        # Höherer Faktor => Simulation läuft schneller (mehr simulierte Sekunden pro realer Sekunde)
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        # Berechnung der aktuellen maximalen Wartezeit aller Pakete an den Annahmestationen
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-
-        # Aktualisieren der über die gesamte Simulationslaufzeit maximal erreichten Wartezeit
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-
-        # Formatierung der beiden Wartezeit-Kennzahlen
-        if current_max_wait_time > 0:
-            current_wait_text = f"Paket mit höchster Wartezeit (aktuell): {current_max_wait_time:.1f}s"
-        else:
-            current_wait_text = "Kein Paket an Annahmestation"
-
-        maximal_wait_text = f"Paket mit höchster Wartezeit (maximal): {self.max_overall_wait_time:.1f}s"
-
-        # Gliedere die simulierte Laufzeit in Stunden, Minuten und Sekunden
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-
-        # Berechne die abgegebenen Pakete pro Minute (basierend auf der simulierten Zeit)
-        if self.sim_clock > 0:
-            delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0)
-        else:
-            delivered_per_minute = 0
-
-        self.info_label['text'] = (f"Laufzeit: {formatted_time}\n"
-                                   f"Abgegebene Pakete: {self.delivered_packages}\n"
-                                   f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-                                   f"{current_wait_text}\n"
-                                   f"{maximal_wait_text}")
-        return Task.cont
-
-    def sim_time(self, t):
-        """
-        Skalierung eines Basiszeitwerts t (in Sekunden) anhand des Multiplikators.
-        Wir verwenden hier die Formel: t / speed_factor.
-        Dadurch wird bei einem kleineren Faktor (z. B. 0.1) t größer (Simulation wird verlangsamt),
-        und bei einem höheren Faktor (z. B. 10) t kleiner (Simulation beschleunigt).
-        """
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def check_vehicle2_start(self, task):
-        """
-        Überprüft kontinuierlich, ob 8 simulierte Sekunden vergangen sind.
-        Sobald self.sim_clock >= 8, wird Fahrzeug 2 gestartet.
-        """
-        if self.sim_clock >= 8.0 and not hasattr(self, 'vehicle2_started'):
-            self.vehicle2_started = True
-            self.start_delivery_cycle(self.vehicles[1], self.vehicles[1].getPos())
-            return Task.done
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        # Basiswartezeit von 1 simulierten Sekunde:
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            direction = target - current_pos
-            distance = direction.length()
-            # Effektiver Schritt = (base_speed * speed_factor) * dt.
-            # Höherer Multiplikator => Fahrzeuge bewegen sich in realer Zeit schneller.
-            step = (self.base_speed * self.speed_factor) * dt
-            if distance <= step:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-            else:
-                vehicle.setPos(current_pos + direction.normalized() * step)
-                return Task.cont
-
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        pickup_pos = pickup_station.getPos()
-
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.occupied_pickups.remove(pickup_station)
-
-            def wait_for_dropoff(task):
-                if any(ds not in self.occupied_dropoffs for ds in self.abgabe_stationen):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_dropoff, f"WaitDropoff_{id(vehicle)}")
-            return
-
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_pos = dropoff_station.getPos()
-
-        self.move_vehicle_to(vehicle, pickup_pos, lambda: self.after_pickup(vehicle, pickup_station, dropoff_pos))
-
-    def after_pickup(self, vehicle, pickup_station, dropoff_pos):
-        self.pickup_package(vehicle, pickup_station)
-        self.move_vehicle_to(vehicle, dropoff_pos, lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        self.drop_cargo(vehicle)
-        start_wait = self.sim_clock
-
-        def wait_task(task):
-            if self.sim_clock - start_wait >= self.sim_time(1):
-                self.finish_cycle(vehicle)
-                return Task.done
-            return Task.cont
-
-        self.taskMgr.add(wait_task, f"WaitAfterDrop_{id(vehicle)}")
-
-    def finish_cycle(self, vehicle):
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        if dropoff_station in self.occupied_dropoffs:
-            self.occupied_dropoffs.remove(dropoff_station)
-            del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
Index: TestFFZ/TestFFZ4.py
===================================================================
diff --git a/TestFFZ/TestFFZ4.py b/TestFFZ/TestFFZ4.py
deleted file mode 100644
--- a/TestFFZ/TestFFZ4.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,512 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs,
-    CardMaker
-)
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-# Globaler Clock (wird für die Zeitberechnung genutzt)
-globalClock = ClockObject.getGlobalClock()
-
-
-# =============================================================================
-# Klasse: SimulationSurface
-# =============================================================================
-class SimulationSurface(ShowBase):
-    def __init__(self):
-        super().__init__()
-        # Basisparameter und Statistik
-        self.base_speed = 1.5         # Maximalgeschwindigkeit (m/s)
-        self.speed_factor = 1.0
-        self.sim_clock = 0.0
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-        self.sim_start_real = globalClock.getFrameTime()
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        # Umgebung, Stationen, UI, Tasks & Graph aufbauen
-        self.setup_environment()
-        self.setup_stations()
-        self.setup_UI()
-        self.setup_tasks()
-        self.setup_graph()
-
-        # Mausevents (Zoom)
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-    def setup_environment(self):
-        self.erzeuge_licht()
-        self.boden = self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-    def setup_stations(self):
-        # Erzeuge Pickup-Station (bei x = -9) und Drop-Station (bei x = 9)
-        self.pickup_station = self.erzeuge_gitterbox(-9, 0, 0, LColor(1, 0, 0, 1))
-        self.drop_station = self.erzeuge_gitterbox(9, 0, 0, LColor(0, 1, 0, 1))
-        # Zeichne Align-Punkte zur besseren Orientierung
-        ls1 = LineSegs()
-        ls1.setThickness(3.0)
-        ls1.setColor(LColor(1, 1, 1, 1))
-        p1 = self.pickup_station.getPos(self.render)
-        ls1.moveTo(p1)
-        ls1.drawTo(p1 + Vec3(2, 0, 0))
-        self.render.attachNewNode(ls1.create())
-        ls2 = LineSegs()
-        ls2.setThickness(3.0)
-        ls2.setColor(LColor(1, 1, 1, 1))
-        p2 = self.drop_station.getPos(self.render)
-        ls2.moveTo(p2)
-        ls2.drawTo(p2 + Vec3(-2, 0, 0))
-        self.render.attachNewNode(ls2.create())
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-    def setup_UI(self):
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-    def setup_tasks(self):
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-
-    def setup_graph(self):
-        self.graph_opened = False
-        self.accept("g", self.open_graph)
-        self.graph_data = []
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in [self.pickup_station, self.drop_station]:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            current_max = max(current_max, elapsed)
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        current_text = f"Liegedauer (aktuell): {current_max:.1f}s" if current_max > 0 else "Kein Paket"
-        maximal_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-        avg_val = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        delivered = self.delivered_packages
-        ppm = delivered / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\nAbgegebene Pakete: {delivered}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n{current_text}\n{maximal_text}\n"
-            f"Durchschn. Liegedauer: {avg_val:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.setTitle("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.setTitle("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n = 0
-        mi = -center_extent - 0.5
-        ma = center_extent + 0.5
-        y = mi
-        while y <= ma:
-            writer.addData3(mi, y, 0)
-            writer.addData3(ma, y, 0)
-            lines.addVertices(n, n + 1)
-            n += 2
-            y += cell_size
-        x = mi
-        while x <= ma:
-            writer.addData3(x, mi, 0)
-            writer.addData3(x, ma, 0)
-            lines.addVertices(n, n + 1)
-            n += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        box = self.loader.loadModel("models/box")
-        box.setScale(1, 1, 1)
-        box.setPos(x, y, z)
-        box.setColor(farbe)
-        box.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        box.reparentTo(self.render)
-        return box
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        cube = self.loader.loadModel("models/box")
-        cube.setScale(1, 1, 1)
-        cube.setPos(x, y, z + 1)
-        cube.setColor(farbe)
-        cube.reparentTo(self.render)
-        return cube
-
-    def draw_coordinate_axes(self, axis_length=5):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), LColor(1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), LColor(0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), LColor(0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        curr = lens.getFov()[0]
-        new = max(10, curr - 5)
-        lens.setFov(new)
-        print(f"Zoom In: FOV von {curr} auf {new}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        curr = lens.getFov()[0]
-        new = min(100, curr + 5)
-        lens.setFov(new)
-        print(f"Zoom Out: FOV von {curr} auf {new}")
-
-
-# =============================================================================
-# Klasse: VehicleController
-# =============================================================================
-class VehicleController:
-    def __init__(self, surface: SimulationSurface):
-        self.surface = surface
-        self.vehicles = []         # Liste aller Fahrzeuge
-        self.cargos = {}           # Ordnet Fahrzeugen aktuell mitgeführte Pakete zu
-        self.current_dropoffs = {}
-        self.create_vehicles()
-
-    def create_vehicles(self):
-        roles = ["pickup_to_dropoff", "dropoff_to_pickup"]
-        start_positions = [
-            self.surface.pickup_station.getPos(),
-            self.surface.drop_station.getPos()
-        ]
-        for i in range(2):
-            vehicle = self.surface.loader.loadModel("models/box")
-            vehicle.setScale(1, 1, 0.5)
-            if i % 2 == 0:
-                vehicle.setColor(LColor(0, 0, 1, 1))
-            else:
-                vehicle.setColor(LColor(0, 0, 0.8, 1))
-            vehicle.setPos(start_positions[i])
-            vehicle.reparentTo(self.surface.render)
-            vehicle.setPythonTag("role", roles[i])
-            vehicle.setPythonTag("phase", "pickup")  # Fährt auf die Station zu
-            vehicle.setPythonTag("speed", 0.0)         # Startet aus dem Stand
-            self.add_center_marker(vehicle)
-            self.attach_lidar_sensor(vehicle, offset=Vec3(0.5, 0.5, 0), radius=2.5)
-            self.vehicles.append(vehicle)
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        marker = self.surface.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def attach_lidar_sensor(self, vehicle, offset=Vec3(0.5, 0.5, 0), radius=2.5):
-        sensor_np = vehicle.attachNewNode("lidar_sensor")
-        sensor_np.setPos(offset)
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 1, 0, 1))
-        segments = 64
-        ls.moveTo(radius * math.cos(0), radius * math.sin(0), 0)
-        for i in range(1, segments + 1):
-            angle = (2 * math.pi * i) / segments
-            x = radius * math.cos(angle)
-            y = radius * math.sin(angle)
-            ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        sensor_np.attachNewNode(circle_geom)
-
-    def get_source_target(self, vehicle):
-        role = vehicle.getPythonTag("role")
-        if role == "pickup_to_dropoff":
-            return self.surface.pickup_station, self.surface.drop_station
-        else:
-            return self.surface.drop_station, self.surface.pickup_station
-
-    def compute_avoidance_vector(self, vehicle):
-        """
-        Berechnet einen Abstoßungsvektor basierend auf der Position aller anderen Fahrzeuge.
-        Je näher ein anderes Fahrzeug ist, desto stärker wirkt der Abstoßungseffekt.
-        """
-        avoidance = Vec3(0, 0, 0)
-        sensor_center = vehicle.getPos(self.surface.render) + Vec3(0.5, 0.5, 0)
-        detection_radius = 2.5  # Sensor-Radius
-        for other in self.vehicles:
-            if other is vehicle:
-                continue
-            other_center = other.getPos(self.surface.render)
-            diff = sensor_center - other_center
-            distance = diff.length()
-            if distance < detection_radius and distance > 0:
-                avoidance += diff.normalized() * (detection_radius - distance)
-        return avoidance
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        max_speed = 1.5
-        accel = 2.5
-        decel = 2.5
-
-        def move_task(task):
-            dt_real = globalClock.getDt()
-            dt = dt_real * self.surface.speed_factor
-
-            pos = vehicle.getPos()
-            to_target = target - pos
-            distance = to_target.length()
-
-            if distance < 0.05:
-                vehicle.setPos(target)
-                on_complete()
-                vehicle.setPythonTag("speed", 0.0)
-                return Task.done
-
-            current_speed = vehicle.getPythonTag("speed")
-
-            # Bei der "deliver"-Phase: Warte, bis der Dwell-Delay abgelaufen ist.
-            if vehicle.getPythonTag("phase") == "deliver":
-                departure_ready_time = vehicle.getPythonTag("departure_ready_time")
-                if self.surface.sim_clock < departure_ready_time:
-                    vehicle.setPythonTag("speed", 0.0)
-                    return Task.cont
-
-            # Berechne den Abstoßungsvektor aus den Positionen der anderen Fahrzeuge.
-            avoidance_vector = self.compute_avoidance_vector(vehicle)
-            avoidance_weight = 1.0  # Dieser Parameter kann feinjustiert werden.
-            if avoidance_vector.length() > 0:
-                # Hier wurde die Reihenfolge geändert: zuerst der Vektor und dann der Skalar.
-                desired_direction = (to_target.normalized() + avoidance_vector.normalized() * avoidance_weight).normalized()
-            else:
-                desired_direction = to_target.normalized()
-
-            # Beschleunigungs-/Bremslogik anhand der verbleibenden Distanz
-            distance_remaining = distance
-            if distance_remaining <= (current_speed ** 2) / (2 * decel):
-                new_speed = max(current_speed - decel * dt, 0)
-            else:
-                new_speed = min(current_speed + accel * dt, max_speed)
-
-            movement = desired_direction * new_speed * dt
-            vehicle.setPos(pos + movement)
-            vehicle.setPythonTag("speed", new_speed)
-            return Task.cont
-
-        self.surface.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        vehicle.setPythonTag("job_start", self.surface.sim_clock)
-        vehicle.setPythonTag("phase", "pickup")
-        source, target = self.get_source_target(vehicle)
-        if source not in self.surface.pickup_packages:
-            self.surface.spawn_package_at_station(source)
-        self.move_vehicle_to(vehicle, source.getPos(), lambda: self.after_pickup(vehicle, source, target))
-
-    def after_pickup(self, vehicle, source, target):
-        self.pickup_package(vehicle, source)
-        vehicle.setPythonTag("phase", "deliver")
-        vehicle.setPythonTag("departure_station", source)
-        dwell_delay = 1.0
-        vehicle.setPythonTag("departure_ready_time", self.surface.sim_clock + dwell_delay)
-        self.move_vehicle_to(vehicle, target.getPos(), lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        self.drop_cargo(vehicle)
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, source):
-        if source in self.surface.pickup_packages:
-            package, spawn_time, timer_np = self.surface.pickup_packages.pop(source)
-            timer_np.removeNode()
-            dwell = self.surface.sim_clock - spawn_time
-            self.surface.total_dwell_time += dwell
-            self.surface.picked_up_count += 1
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.surface.last_removed[source] = self.surface.sim_clock
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.surface.render)
-            _, target = self.get_source_target(vehicle)
-            targetPos = target.getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.surface.delivered_packages += 1
-
-    def remove_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-
-
-# =============================================================================
-# Hauptprogramm
-# =============================================================================
-if __name__ == "__main__":
-    surface = SimulationSurface()
-    vehicle_controller = VehicleController(surface)
-    for vehicle in vehicle_controller.vehicles:
-        vehicle_controller.start_delivery_cycle(vehicle, vehicle.getPos())
-    surface.run()
Index: KI/KI29.py
===================================================================
diff --git a/KI/KI29.py b/KI/KI29.py
deleted file mode 100644
--- a/KI/KI29.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,558 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Matplotlib zum Plotten importieren
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs
-)
-
-# Wir nutzen globalClock für dt.
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit
-        self.base_speed = 1.5
-        # Zeitskalierungsfaktor
-        self.speed_factor = 1.0
-        # Simulationszeitticker (simulierte Sekunden)
-        self.sim_clock = 0.0
-        # Zähler der abgegebenen Pakete
-        self.delivered_packages = 0
-        # Maximale Liegedauer (über die gesamte Simulation)
-        self.max_overall_wait_time = 0.0
-        # Gesamte Liegedauer und Zähler für Durchschnittsberechnung
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        self.sim_start_real = globalClock.getFrameTime()
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-        # Erstelle 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Zeichne für jede Annahmestation den Align-Punkt (2m in positive X-Richtung).
-        for station in self.annahme_stationen:
-            station_pos = station.getPos()
-            ls_pickup = LineSegs()
-            ls_pickup.setThickness(3.0)
-            ls_pickup.setColor(LColor(1, 1, 1, 1))
-            ls_pickup.moveTo(station_pos)
-            ls_pickup.drawTo(station_pos + Vec3(2, 0, 0))
-            self.render.attachNewNode(ls_pickup.create())
-
-        # Zeichne für jede Abgabestation den Align-Punkt (2m in negative X-Richtung).
-        for station in self.abgabe_stationen:
-            station_pos = station.getPos()
-            ls_dropoff = LineSegs()
-            ls_dropoff.setThickness(3.0)
-            ls_dropoff.setColor(LColor(1, 1, 1, 1))
-            ls_dropoff.moveTo(station_pos)
-            ls_dropoff.drawTo(station_pos + Vec3(-2, 0, 0))
-            self.render.attachNewNode(ls_dropoff.create())
-
-        # Fahrzeuge initialisieren.
-        self.vehicles = []
-        self.cargos = {}              # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}    # Fahrzeug -> zugewiesene Dropoff-Station
-
-        # Fahrzeug 1
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-        self.add_center_marker(vehicle1)
-        self.add_offset_circle(vehicle1, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Fahrzeug 2 (später gestartet)
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-        self.add_center_marker(vehicle2)
-        self.add_offset_circle(vehicle2, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Neue Funktionalität: Erfassung von Daten für Graphen.
-        # Es werden Daten (Simulationszeit, Pakete pro Minute, durchschnittliche Liegedauer) einmal pro Simulationssekunde erfasst.
-        self.graph_data = []
-        self.taskMgr.doMethodLater(1, self.record_graph_data, "RecordGraphDataTask")
-
-        # Initialisiere den interaktiven Graphen mit zwei Subplots (dauerhaft offen und aktualisierend)
-        self.init_graph()
-        self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-
-        # Aufgaben
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_vehicle2_start, "CheckVehicle2StartTask")
-        self.taskMgr.add(self.update_lidar_status, "UpdateLidarStatusTask")
-
-        # Liefervorgang starten (Pickup-Phase)
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-
-    # --- Initialisierung des interaktiven Graphen mit zwei Subplots ---
-    def init_graph(self):
-        plt.ion()  # Interaktiven Modus aktivieren.
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        # Oberer Plot: Pakete pro Minute
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        # Unterer Plot: Durchschnittliche Liegedauer
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschn. Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    # --- Task zum Aktualisieren beider Graphen in Echtzeit ---
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        # Update des oberen Diagramms (Pakete pro Minute)
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        # Update des unteren Diagramms (Durchschnittliche Liegedauer)
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    # --- Erfassung von Daten für Graphen ---
-    def record_graph_data(self, task):
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0
-        self.graph_data.append((self.sim_clock, delivered_per_minute, avg_dwell_time))
-        return Task.again
-
-    # --- Funktion zum Setzen des Fahrzeugmittelpunkt-Markiers ---
-    def add_center_marker(self, vehicle, scale=0.2):
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    # --- Funktion zum Zeichnen des Lidar-Kreises ---
-    def add_offset_circle(self, vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5, num_segments=32):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        for i in range(num_segments + 1):
-            angle = 2 * math.pi * i / num_segments
-            x = circle_radius * math.cos(angle)
-            y = circle_radius * math.sin(angle)
-            if i == 0:
-                ls.moveTo(x, y, 0)
-            else:
-                ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        circle_np = vehicle.attachNewNode(circle_geom)
-        circle_np.setPos(offset)
-        vehicle.setPythonTag("lidar_circle", circle_np)
-
-    # --- Funktion zum Zeichnen von Koordinatensystemen ---
-    def draw_coordinate_axes(self, axis_length=5):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(1, 0, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        ls.setColor(0, 1, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        ls.setColor(0, 0, 1, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), (1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), (0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), (0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def update_lidar_status(self, task):
-        sensor_threshold = 3.0
-        for vehicle in self.vehicles:
-            if vehicle.hasPythonTag("lidar_circle"):
-                lidar_circle = vehicle.getPythonTag("lidar_circle")
-                pos = vehicle.getPos(self.render)
-                collision = False
-                avoidance_vec = Vec3(0, 0, 0)
-                for other in self.vehicles:
-                    if other is not vehicle:
-                        pos_other = other.getPos(self.render)
-                        diff = pos - pos_other
-                        if diff.length() < sensor_threshold:
-                            collision = True
-                            if diff.length() > 0:
-                                avoidance_vec += diff.normalized() * (sensor_threshold - diff.length())
-                if collision:
-                    lidar_circle.setColor(LColor(1, 0, 0, 1))
-                    vehicle.setPythonTag("avoidance", avoidance_vec)
-                    vehicle.setPythonTag("speed_multiplier", 0.5)
-                else:
-                    lidar_circle.setColor(LColor(0, 1, 0, 1))
-                    vehicle.setPythonTag("avoidance", Vec3(0, 0, 0))
-                    vehicle.setPythonTag("speed_multiplier", 1.0)
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-        current_wait_text = (f"Liegedauer (aktuell): {current_max_wait_time:.1f}s"
-                             if current_max_wait_time > 0 else "Kein Paket an Annahmestation")
-        maximal_wait_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted_time}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-            f"{current_wait_text}\n"
-            f"{maximal_wait_text}\n"
-            f"Liegedauer (Durchschnitt): {avg_dwell_time:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def check_vehicle2_start(self, task):
-        if self.sim_clock >= 8.0 and not hasattr(self, 'vehicle2_started'):
-            self.vehicle2_started = True
-            self.start_delivery_cycle(self.vehicles[1], self.vehicles[1].getPos())
-            return Task.done
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(
-            station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1)
-        )
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            to_target = target - current_pos
-            distance = to_target.length()
-            multiplier = vehicle.getPythonTag("speed_multiplier") if vehicle.hasPythonTag("speed_multiplier") else 1.0
-            effective_speed = self.base_speed * self.speed_factor * multiplier
-            step_distance = effective_speed * dt
-            if distance <= step_distance:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-            avoidance = vehicle.getPythonTag("avoidance") if vehicle.hasPythonTag("avoidance") else Vec3(0, 0, 0)
-            if avoidance.length() > 0.001:
-                combined = to_target.normalized() + avoidance.normalized() * 0.5
-                combined.normalize()
-                new_direction = combined
-            else:
-                new_direction = to_target.normalized()
-            vehicle.setPos(current_pos + new_direction * step_distance)
-            return Task.cont
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    # --- Pickup-Phase ---
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        # Für Pickup: zuerst zum Align-Punkt (auf der Linie) und dann zur Stationsmitte.
-        pickup_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        self.move_vehicle_to(vehicle, pickup_align,
-            lambda: self.move_vehicle_to(
-                vehicle,
-                pickup_station.getPos(),
-                lambda: self.after_pickup(vehicle, pickup_station)
-            )
-        )
-
-    def after_pickup(self, vehicle, pickup_station):
-        self.pickup_package(vehicle, pickup_station)
-        # Departiere jetzt von der Pickup-Stationsmitte (analog zur Dropoff-Abfahrt)
-        self.depart_from_pickup(vehicle, pickup_station,
-            lambda: self.start_dropoff_phase(vehicle)
-        )
-
-    def depart_from_pickup(self, vehicle, pickup_station, callback):
-        # Bei Pickup-Stations gibt die Linie in positive X-Richtung vor.
-        departure_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        departure_target = pickup_station.getPos() + Vec3(4, 0, 0)
-        self.move_vehicle_to(vehicle, departure_align,
-            lambda: self.move_vehicle_to(vehicle, departure_target, callback)
-        )
-
-    # --- Dropoff-Phase (Fahrzeug mit Fracht) ---
-    def start_dropoff_phase(self, vehicle):
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.start_dropoff_phase(vehicle)
-            return
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        # Für Dropoff: zuerst zum Align-Punkt (negative X-Richtung) und dann zur Stationsmitte.
-        dropoff_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-        self.move_vehicle_to(vehicle, dropoff_align,
-            lambda: self.move_vehicle_to(vehicle, dropoff_station.getPos(),
-                lambda: self.after_dropoff(vehicle)
-            )
-        )
-
-    def after_dropoff(self, vehicle):
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        self.drop_cargo(vehicle)
-        self.remove_cargo(vehicle, remove_dropoff=True)
-        if dropoff_station is not None:
-            departure_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-            departure_target = dropoff_station.getPos() + Vec3(-4, 0, 0)
-            self.move_vehicle_to(vehicle, departure_align,
-                lambda: self.move_vehicle_to(vehicle, departure_target,
-                    lambda: self.start_delivery_cycle(vehicle, departure_target)
-                )
-            )
-        else:
-            self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle, remove_dropoff=True):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        if remove_dropoff:
-            dropoff_station = self.current_dropoffs.get(vehicle)
-            if dropoff_station in self.occupied_dropoffs:
-                self.occupied_dropoffs.remove(dropoff_station)
-            if vehicle in self.current_dropoffs:
-                del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
Index: KI/KI31.py
===================================================================
diff --git a/KI/KI31.py b/KI/KI31.py
deleted file mode 100644
--- a/KI/KI31.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,572 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Matplotlib zum Plotten importieren
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs,
-    CardMaker  # Bleibt vorhanden, auch wenn aktuell nicht verwendet
-)
-
-# Wir nutzen globalClock für dt.
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit & Zeitskalierungsfaktor
-        self.base_speed = 1.5
-        self.speed_factor = 1.0
-
-        # Simulationszeitticker & Statistik
-        self.sim_clock = 0.0
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        self.sim_start_real = globalClock.getFrameTime()
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            # Erzeuge Annahmestation (rot)
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            # Erzeuge Abgabestation (grün)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Zeichne für jede Annahmestation den Align-Punkt (2 m in positive X-Richtung)
-        for station in self.annahme_stationen:
-            station_pos = station.getPos()
-            ls_pickup = LineSegs()
-            ls_pickup.setThickness(3.0)
-            ls_pickup.setColor(LColor(1, 1, 1, 1))
-            ls_pickup.moveTo(station_pos)
-            ls_pickup.drawTo(station_pos + Vec3(2, 0, 0))
-            self.render.attachNewNode(ls_pickup.create())
-
-        # Zeichne für jede Abgabestation den Align-Punkt (2 m in negative X-Richtung)
-        for station in self.abgabe_stationen:
-            station_pos = station.getPos()
-            ls_dropoff = LineSegs()
-            ls_dropoff.setThickness(3.0)
-            ls_dropoff.setColor(LColor(1, 1, 1, 1))
-            ls_dropoff.moveTo(station_pos)
-            ls_dropoff.drawTo(station_pos + Vec3(-2, 0, 0))
-            self.render.attachNewNode(ls_dropoff.create())
-
-        # Fahrzeuge initialisieren
-        self.vehicles = []
-        self.cargos = {}              # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}    # Fahrzeug -> zugewiesene Dropoff-Station
-
-        # Fahrzeug 1
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-        self.add_center_marker(vehicle1)
-        self.add_offset_circle(vehicle1, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Fahrzeug 2 (später gestartet)
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-        self.add_center_marker(vehicle2)
-        self.add_offset_circle(vehicle2, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Neue Funktionalität: Erfassung von Daten für Graphen
-        self.graph_data = []
-        self.taskMgr.doMethodLater(1, self.record_graph_data, "RecordGraphDataTask")
-
-        # Statt den Graphen sofort zu initialisieren – öffnen mit Taste "G"
-        self.graph_opened = False
-        self.accept("g", self.open_graph)
-
-        # Zoom-Funktionalität: Mit dem Mausrad hereinz- bzw. herauszoomen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_vehicle2_start, "CheckVehicle2StartTask")
-        self.taskMgr.add(self.update_lidar_status, "UpdateLidarStatusTask")
-
-        # Liefervorgang starten (Pickup-Phase)
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-
-    def zoom_in(self):
-        # Hereinzoomen: Field-of-View (FOV) verkleinern (nicht unter 10°)
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        # Herauszoomen: FOV vergrößern (nicht über 100°)
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschn. Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def record_graph_data(self, task):
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0
-        self.graph_data.append((self.sim_clock, delivered_per_minute, avg_dwell_time))
-        return Task.again
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def add_offset_circle(self, vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5, num_segments=32):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        for i in range(num_segments + 1):
-            angle = 2 * math.pi * i / num_segments
-            x = circle_radius * math.cos(angle)
-            y = circle_radius * math.sin(angle)
-            if i == 0:
-                ls.moveTo(x, y, 0)
-            else:
-                ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        circle_np = vehicle.attachNewNode(circle_geom)
-        circle_np.setPos(offset)
-        vehicle.setPythonTag("lidar_circle", circle_np)
-
-    def draw_coordinate_axes(self, axis_length=5):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(1, 0, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        ls.setColor(0, 1, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        ls.setColor(0, 0, 1, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), (1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), (0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), (0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def update_lidar_status(self, task):
-        sensor_threshold = 3.0
-        for vehicle in self.vehicles:
-            if vehicle.hasPythonTag("lidar_circle"):
-                lidar_circle = vehicle.getPythonTag("lidar_circle")
-                pos = vehicle.getPos(self.render)
-                collision = False
-                avoidance_vec = Vec3(0, 0, 0)
-                for other in self.vehicles:
-                    if other is not vehicle:
-                        pos_other = other.getPos(self.render)
-                        diff = pos - pos_other
-                        if diff.length() < sensor_threshold:
-                            collision = True
-                            if diff.length() > 0:
-                                avoidance_vec += diff.normalized() * (sensor_threshold - diff.length())
-                if collision:
-                    lidar_circle.setColor(LColor(1, 0, 0, 1))
-                    vehicle.setPythonTag("avoidance", avoidance_vec)
-                    vehicle.setPythonTag("speed_multiplier", 0.5)
-                else:
-                    lidar_circle.setColor(LColor(0, 1, 0, 1))
-                    vehicle.setPythonTag("avoidance", Vec3(0, 0, 0))
-                    vehicle.setPythonTag("speed_multiplier", 1.0)
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-        current_wait_text = (f"Liegedauer (aktuell): {current_max_wait_time:.1f}s"
-                             if current_max_wait_time > 0 else "Kein Paket an Annahmestation")
-        maximal_wait_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted_time}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-            f"{current_wait_text}\n"
-            f"{maximal_wait_text}\n"
-            f"Liegedauer (Durchschnitt): {avg_dwell_time:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def check_vehicle2_start(self, task):
-        if self.sim_clock >= 8.0 and not hasattr(self, 'vehicle2_started'):
-            self.vehicle2_started = True
-            self.start_delivery_cycle(self.vehicles[1], self.vehicles[1].getPos())
-            return Task.done
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(
-            station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1)
-        )
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            to_target = target - current_pos
-            distance = to_target.length()
-            multiplier = vehicle.getPythonTag("speed_multiplier") if vehicle.hasPythonTag("speed_multiplier") else 1.0
-            effective_speed = self.base_speed * self.speed_factor * multiplier
-            step_distance = effective_speed * dt
-            if distance <= step_distance:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-            avoidance = vehicle.getPythonTag("avoidance") if vehicle.hasPythonTag("avoidance") else Vec3(0, 0, 0)
-            if avoidance.length() > 0.001:
-                combined = to_target.normalized() + avoidance.normalized() * 0.5
-                combined.normalize()
-                new_direction = combined
-            else:
-                new_direction = to_target.normalized()
-            vehicle.setPos(current_pos + new_direction * step_distance)
-            return Task.cont
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        pickup_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        self.move_vehicle_to(vehicle, pickup_align,
-            lambda: self.move_vehicle_to(
-                vehicle,
-                pickup_station.getPos(),
-                lambda: self.after_pickup(vehicle, pickup_station)
-            )
-        )
-
-    def after_pickup(self, vehicle, pickup_station):
-        self.pickup_package(vehicle, pickup_station)
-        self.depart_from_pickup(vehicle, pickup_station,
-            lambda: self.start_dropoff_phase(vehicle)
-        )
-
-    def depart_from_pickup(self, vehicle, pickup_station, callback):
-        departure_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        departure_target = pickup_station.getPos() + Vec3(4, 0, 0)
-        self.move_vehicle_to(vehicle, departure_align,
-            lambda: self.move_vehicle_to(vehicle, departure_target, callback)
-        )
-
-    def start_dropoff_phase(self, vehicle):
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.start_dropoff_phase(vehicle)
-            return
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-        self.move_vehicle_to(vehicle, dropoff_align,
-            lambda: self.move_vehicle_to(vehicle, dropoff_station.getPos(),
-                lambda: self.after_dropoff(vehicle)
-            )
-        )
-
-    def after_dropoff(self, vehicle):
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        self.drop_cargo(vehicle)
-        self.remove_cargo(vehicle, remove_dropoff=True)
-        if dropoff_station is not None:
-            departure_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-            departure_target = dropoff_station.getPos() + Vec3(-4, 0, 0)
-            self.move_vehicle_to(vehicle, departure_align,
-                lambda: self.move_vehicle_to(vehicle, departure_target,
-                    lambda: self.start_delivery_cycle(vehicle, departure_target)
-                )
-            )
-        else:
-            self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle, remove_dropoff=True):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        if remove_dropoff:
-            dropoff_station = self.current_dropoffs.get(vehicle)
-            if dropoff_station in self.occupied_dropoffs:
-                self.occupied_dropoffs.remove(dropoff_station)
-            if vehicle in self.current_dropoffs:
-                del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices+1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices+1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z+1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
Index: Grundmodell/graph_pyqt.py
===================================================================
diff --git a/Grundmodell/graph_pyqt.py b/Grundmodell/graph_pyqt.py
deleted file mode 100644
--- a/Grundmodell/graph_pyqt.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,84 +0,0 @@
-# graph_pyqt.py
-import sys, time
-from multiprocessing import Queue
-from PyQt5 import QtWidgets, QtCore
-import pyqtgraph as pg
-
-
-class GraphWindow(QtWidgets.QWidget):
-    def __init__(self):
-        super().__init__()
-        self.setWindowTitle("Echtzeit-Visualisierung")
-        layout = QtWidgets.QVBoxLayout(self)
-
-        # Erstelle drei Plot-Widgets für die Kennzahlen:
-        self.plot1 = pg.PlotWidget(title="Abgegebene Pakete pro Minute")
-        self.plot2 = pg.PlotWidget(title="Durchschnittliche Liegedauer (s)")
-        self.plot3 = pg.PlotWidget(title="Durchschnittliche Lieferzeit (s)")
-
-        # Setze den Hintergrund weiß:
-        self.plot1.setBackground('w')
-        self.plot2.setBackground('w')
-        self.plot3.setBackground('w')
-
-        layout.addWidget(self.plot1)
-        layout.addWidget(self.plot2)
-        layout.addWidget(self.plot3)
-
-        # Erstelle Kurven (mit Symbolen):
-        self.curve1 = self.plot1.plot(pen='y', symbol='o')
-        self.curve2 = self.plot2.plot(pen='r', symbol='o')
-        self.curve3 = self.plot3.plot(pen='g', symbol='o')
-
-        self.data = []
-        # Ein Timer, der die Daten alle 500 ms aktualisiert:
-        self.timer = QtCore.QTimer()
-        self.timer.timeout.connect(self.update_plots)
-        self.timer.start(500)
-
-    def update_plots(self):
-        if not self.data:
-            return
-        times = [d[0] for d in self.data]
-        ppm = [d[1] for d in self.data]
-        dwell = [d[2] for d in self.data]
-        delivery = [d[3] for d in self.data]
-        self.curve1.setData(times, ppm)
-        self.curve2.setData(times, dwell)
-        self.curve3.setData(times, delivery)
-
-    def add_data(self, new_data):
-        self.data.append(new_data)
-
-
-def graph_process_pyqt(graph_queue: Queue):
-    # Erstelle die QApplication – das geschieht in diesem separaten Prozess
-    app = QtWidgets.QApplication(sys.argv)
-    window = GraphWindow()
-    window.show()
-
-    def check_queue():
-        # Versuche, alle neuen Daten aus der Queue auszulesen
-        while True:
-            try:
-                new_data = graph_queue.get_nowait()
-                # Zum Debuggen:
-                print("Empfangen:", new_data)
-                window.add_data(new_data)
-            except:
-                break
-
-    timer = QtCore.QTimer()
-    timer.setInterval(100)  # alle 100 ms
-    timer.timeout.connect(check_queue)
-    timer.start()
-
-    sys.exit(app.exec_())
-
-
-if __name__ == "__main__":
-    # Minimaler Test
-    from multiprocessing import Queue
-
-    q = Queue()
-    graph_process_pyqt(q)
Index: Grundmodell/Gm1.py
===================================================================
diff --git a/Grundmodell/Gm1.py b/Grundmodell/Gm1.py
deleted file mode 100644
--- a/Grundmodell/Gm1.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,561 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Für das Paketspawning an den Annahmestationen
-        self.pickup_packages = {}  # station (NodePath) -> (Paket, Spawnzeit, Timer Node)
-        self.last_removed = {}     # station -> Zeitpunkt der letzten Entfernung
-
-        # Für Graph-Daten und Steuerung
-        self.graph_data = []       # Tupel: (Sim-Zeit, Pakete pro Minute, Durchschnittliche Liegedauer)
-        self.graph_opened = False
-
-        # Ursprung (Koordinatenachsen)
-        self.draw_origin()
-
-        # Kameraeinstellungen: Das ganze Feld soll gut sichtbar sein.
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # Licht und Bodenraster erzeugen
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-
-        # Erzeuge die Mauer (das umschließende Rechteck)
-        self.create_wall()
-
-        # Erzeuge Annahme-, Abgabe- und Garagenstationen
-        self.create_annahme_stations()
-        self.create_abgabe_stations()
-        self.create_garagen_stations()
-
-        # UI: Slider und Info-Anzeige zur Simulationssteuerung
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktion: Mit dem Mausrad hereinz- bzw. herauszoomen.
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        # Graph in extra Fenster per Taste "g" öffnen
-        self.accept("g", self.open_graph)
-
-        # Tasks: Aktualisierung der Simulationszeit, Info-Anzeige, Paketspawning, Paket-Timer und Graph-Daten
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-
-        # Bestimme aktuelle maximale Liegedauer aller wartenden Pakete
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        # X-Achse (rot)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        # Y-Achse (grün)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        # Z-Achse (blau)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        # Offene Seite: Kante zwischen v1 und v2 wird weggelassen.
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_annahme_station(pt)
-            # Dummy-Node als Referenz für das Paketspawning
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            # Dekorative Kreuze hinzufügen
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        # Öffnung in negative X: linke Seite auslassen
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_abgabe_station(pt)
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            # Dekorative Kreuze hinzufügen
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 2)
-        v5 = pos + Vec3(1, 0, 2)
-        v6 = pos + Vec3(1, 2, 2)
-        v7 = pos + Vec3(0, 2, 2)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        # Dekorative Kreuze auf geschlossenen Seiten (nicht auf dem Dach)
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 2)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            center = pt + Vec3(0.5, 1, 1)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    # Methoden für Paketspawning und Timer
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        cube = self.loader.loadModel("models/box")
-        cube.setScale(1, 1, 1)
-        cube.setPos(x, y, z + 1)
-        cube.setColor(farbe)
-        cube.reparentTo(self.render)
-        return cube
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)  # 1 Sekunde Simulationszeit
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-    def update_package_timers(self, task):
-        to_remove = []
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            elapsed = self.sim_clock - spawn_time
-            timer_np.node().setText(f"{elapsed:.1f}s")
-            # Wenn das Paket zu lange an der Station liegt (z. B. 5s), entferne es und aktualisiere Kennzahlen.
-            if elapsed >= 5.0:
-                package.removeNode()
-                self.total_dwell_time += elapsed
-                self.picked_up_count += 1
-                self.delivered_packages += 1
-                to_remove.append(station)
-        for station in to_remove:
-            if station in self.pickup_packages:
-                del self.pickup_packages[station]
-            self.last_removed[station] = self.sim_clock
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor != 0 else t
-
-    # Methoden für graphische Darstellung der Kennzahlen
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: TestFFZ/TestFFZ5.py
===================================================================
diff --git a/TestFFZ/TestFFZ5.py b/TestFFZ/TestFFZ5.py
deleted file mode 100644
--- a/TestFFZ/TestFFZ5.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,535 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs,
-    CardMaker
-)
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-# Globaler Clock (wird für die Zeitberechnung genutzt)
-globalClock = ClockObject.getGlobalClock()
-
-
-# =============================================================================
-# Klasse: SimulationSurface
-# =============================================================================
-class SimulationSurface(ShowBase):
-    def __init__(self):
-        super().__init__()
-        # Basisparameter und Statistik
-        self.base_speed = 1.5         # Maximalgeschwindigkeit (m/s)
-        self.speed_factor = 1.0
-        self.sim_clock = 0.0
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-        self.sim_start_real = globalClock.getFrameTime()
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        # Umgebung, Stationen, UI, Tasks & Graph aufbauen
-        self.setup_environment()
-        self.setup_stations()
-        self.setup_UI()
-        self.setup_tasks()
-        self.setup_graph()
-
-        # Mausevents (Zoom)
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-    def setup_environment(self):
-        self.erzeuge_licht()
-        self.boden = self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-    def setup_stations(self):
-        # Erzeuge Pickup-Station (bei x = -9) und Drop-Station (bei x = 9)
-        self.pickup_station = self.erzeuge_gitterbox(-9, 0, 0, LColor(1, 0, 0, 1))
-        self.drop_station = self.erzeuge_gitterbox(9, 0, 0, LColor(0, 1, 0, 1))
-        # Zeichne Align-Punkte zur besseren Orientierung
-        ls1 = LineSegs()
-        ls1.setThickness(3.0)
-        ls1.setColor(LColor(1, 1, 1, 1))
-        p1 = self.pickup_station.getPos(self.render)
-        ls1.moveTo(p1)
-        ls1.drawTo(p1 + Vec3(2, 0, 0))
-        self.render.attachNewNode(ls1.create())
-        ls2 = LineSegs()
-        ls2.setThickness(3.0)
-        ls2.setColor(LColor(1, 1, 1, 1))
-        p2 = self.drop_station.getPos(self.render)
-        ls2.moveTo(p2)
-        ls2.drawTo(p2 + Vec3(-2, 0, 0))
-        self.render.attachNewNode(ls2.create())
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-    def setup_UI(self):
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-    def setup_tasks(self):
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-
-    def setup_graph(self):
-        self.graph_opened = False
-        self.accept("g", self.open_graph)
-        self.graph_data = []
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in [self.pickup_station, self.drop_station]:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            current_max = max(current_max, elapsed)
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        current_text = f"Liegedauer (aktuell): {current_max:.1f}s" if current_max > 0 else "Kein Paket"
-        maximal_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-        avg_val = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        delivered = self.delivered_packages
-        ppm = delivered / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\nAbgegebene Pakete: {delivered}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n{current_text}\n{maximal_text}\n"
-            f"Durchschn. Liegedauer: {avg_val:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n = 0
-        mi = -center_extent - 0.5
-        ma = center_extent + 0.5
-        y = mi
-        while y <= ma:
-            writer.addData3(mi, y, 0)
-            writer.addData3(ma, y, 0)
-            lines.addVertices(n, n + 1)
-            n += 2
-            y += cell_size
-        x = mi
-        while x <= ma:
-            writer.addData3(x, mi, 0)
-            writer.addData3(x, ma, 0)
-            lines.addVertices(n, n + 1)
-            n += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        box = self.loader.loadModel("models/box")
-        box.setScale(1, 1, 1)
-        box.setPos(x, y, z)
-        box.setColor(farbe)
-        box.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        box.reparentTo(self.render)
-        return box
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        cube = self.loader.loadModel("models/box")
-        cube.setScale(1, 1, 1)
-        cube.setPos(x, y, z + 1)
-        cube.setColor(farbe)
-        cube.reparentTo(self.render)
-        return cube
-
-    def draw_coordinate_axes(self, axis_length=5):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), LColor(1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), LColor(0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), LColor(0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        curr = lens.getFov()[0]
-        new = max(10, curr - 5)
-        lens.setFov(new)
-        print(f"Zoom In: FOV von {curr} auf {new}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        curr = lens.getFov()[0]
-        new = min(100, curr + 5)
-        lens.setFov(new)
-        print(f"Zoom Out: FOV von {curr} auf {new}")
-
-
-# =============================================================================
-# Klasse: VehicleController
-# =============================================================================
-class VehicleController:
-    def __init__(self, surface: SimulationSurface):
-        self.surface = surface
-        self.vehicles = []         # Liste aller Fahrzeuge
-        self.cargos = {}           # Ordnet Fahrzeugen aktuell mitgeführte Pakete zu
-        self.current_dropoffs = {}
-        self.create_vehicles()
-
-    def create_vehicles(self):
-        roles = ["pickup_to_dropoff", "dropoff_to_pickup"]
-        start_positions = [
-            self.surface.pickup_station.getPos(),
-            self.surface.drop_station.getPos()
-        ]
-        for i in range(2):
-            vehicle = self.surface.loader.loadModel("models/box")
-            vehicle.setScale(1, 1, 0.5)
-            if i % 2 == 0:
-                vehicle.setColor(LColor(0, 0, 1, 1))
-            else:
-                vehicle.setColor(LColor(0, 0, 0.8, 1))
-            vehicle.setPos(start_positions[i])
-            vehicle.reparentTo(self.surface.render)
-            vehicle.setPythonTag("role", roles[i])
-            vehicle.setPythonTag("phase", "pickup")  # Fährt auf die Station zu
-            vehicle.setPythonTag("speed", 0.0)         # Startet aus dem Stand
-            self.add_center_marker(vehicle)
-            self.attach_lidar_sensor(vehicle, offset=Vec3(0.5, 0.5, 0), radius=2.5)
-            self.vehicles.append(vehicle)
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        marker = self.surface.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def attach_lidar_sensor(self, vehicle, offset=Vec3(0.5, 0.5, 0), radius=2.5):
-        sensor_np = vehicle.attachNewNode("lidar_sensor")
-        sensor_np.setPos(offset)
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 1, 0, 1))
-        segments = 64
-        ls.moveTo(radius * math.cos(0), radius * math.sin(0), 0)
-        for i in range(1, segments + 1):
-            angle = (2 * math.pi * i) / segments
-            x = radius * math.cos(angle)
-            y = radius * math.sin(angle)
-            ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        sensor_np.attachNewNode(circle_geom)
-
-    def get_source_target(self, vehicle):
-        role = vehicle.getPythonTag("role")
-        if role == "pickup_to_dropoff":
-            return self.surface.pickup_station, self.surface.drop_station
-        else:
-            return self.surface.drop_station, self.surface.pickup_station
-
-    def compute_avoidance_vector(self, vehicle):
-        """
-        Berechnet einen Abstoßungsvektor basierend auf der Position aller anderen Fahrzeuge.
-        Je näher ein anderes Fahrzeug ist, desto stärker wirkt der Abstoßungseffekt.
-        """
-        avoidance = Vec3(0, 0, 0)
-        sensor_center = vehicle.getPos(self.surface.render) + Vec3(0.5, 0.5, 0)
-        detection_radius = 2.5  # Sensor-Radius
-        for other in self.vehicles:
-            if other is vehicle:
-                continue
-            other_center = other.getPos(self.surface.render)
-            diff = sensor_center - other_center
-            distance = diff.length()
-            if distance < detection_radius and distance > 0:
-                avoidance += diff.normalized() * (detection_radius - distance)
-        return avoidance
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        max_speed = 1.5
-        accel = 2.5
-        decel = 2.5
-
-        def move_task(task):
-            dt_real = globalClock.getDt()
-            dt = dt_real * self.surface.speed_factor
-
-            pos = vehicle.getPos()
-            to_target = target - pos
-            distance = to_target.length()
-
-            if distance < 0.05:
-                vehicle.setPos(target)
-                on_complete()
-                vehicle.setPythonTag("speed", 0.0)
-                return Task.done
-
-            current_speed = vehicle.getPythonTag("speed")
-
-            # Bei der "deliver"-Phase: Bei Dwell-Delay vor dem Weiterfahren bleiben.
-            if vehicle.getPythonTag("phase") == "deliver":
-                departure_ready_time = vehicle.getPythonTag("departure_ready_time")
-                if self.surface.sim_clock < departure_ready_time:
-                    vehicle.setPythonTag("speed", 0.0)
-                    return Task.cont
-
-            # Berechne den Abstoßungsvektor basierend auf dem Lidar.
-            avoidance_vector = self.compute_avoidance_vector(vehicle)
-            avoidance_weight = 1.0  # Feinjustierbar.
-            if avoidance_vector.length() > 0:
-                desired_direction = (to_target.normalized() + avoidance_vector.normalized() * avoidance_weight).normalized()
-            else:
-                desired_direction = to_target.normalized()
-
-            # Effektive Bremskraft berechnen
-            effective_decel = decel
-            if avoidance_vector.length() > 0.1:
-                effective_decel *= 1.5
-            if distance < 1.0:
-                effective_decel *= 2
-
-            # Standard-Beschleunigungs-/Bremslogik
-            if distance <= (current_speed ** 2) / (2 * effective_decel):
-                new_speed = max(current_speed - effective_decel * dt, 0)
-            else:
-                new_speed = min(current_speed + accel * dt, max_speed)
-
-            # Prüfung, ob sich das Fahrzeug in einer Station befindet:
-            # Definiere einen Stationsradius, in dem die Geschwindigkeitsbegrenzung gilt.
-            station_region_radius = 2.0
-            is_station_phase = False
-            # Falls das Ziel eine Station ist (Pickup- oder Drop-Station) und das Fahrzeug noch nah dran ist:
-            if (target - self.surface.pickup_station.getPos()).length() < 0.1 or (target - self.surface.drop_station.getPos()).length() < 0.1:
-                if (pos - target).length() < station_region_radius:
-                    is_station_phase = True
-            # Falls das Fahrzeug gerade aus der Station herausfährt:
-            if not is_station_phase and vehicle.hasPythonTag("departure_station"):
-                departure_station = vehicle.getPythonTag("departure_station")
-                if (pos - departure_station.getPos()).length() < station_region_radius:
-                    is_station_phase = True
-
-            # Wenn wir uns in der Station befinden, erzwinge konstant 0,5 m/s.
-            if is_station_phase:
-                new_speed = 0.5
-
-            movement = desired_direction * new_speed * dt
-            vehicle.setPos(pos + movement)
-            vehicle.setPythonTag("speed", new_speed)
-            return Task.cont
-
-        self.surface.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        vehicle.setPythonTag("job_start", self.surface.sim_clock)
-        vehicle.setPythonTag("phase", "pickup")
-        source, target = self.get_source_target(vehicle)
-        if source not in self.surface.pickup_packages:
-            self.surface.spawn_package_at_station(source)
-        self.move_vehicle_to(vehicle, source.getPos(), lambda: self.after_pickup(vehicle, source, target))
-
-    def after_pickup(self, vehicle, source, target):
-        self.pickup_package(vehicle, source)
-        vehicle.setPythonTag("phase", "deliver")
-        vehicle.setPythonTag("departure_station", source)
-        dwell_delay = 1.0
-        vehicle.setPythonTag("departure_ready_time", self.surface.sim_clock + dwell_delay)
-        self.move_vehicle_to(vehicle, target.getPos(), lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        self.drop_cargo(vehicle)
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, source):
-        if source in self.surface.pickup_packages:
-            package, spawn_time, timer_np = self.surface.pickup_packages.pop(source)
-            timer_np.removeNode()
-            dwell = self.surface.sim_clock - spawn_time
-            self.surface.total_dwell_time += dwell
-            self.surface.picked_up_count += 1
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.surface.last_removed[source] = self.surface.sim_clock
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.surface.render)
-            _, target = self.get_source_target(vehicle)
-            targetPos = target.getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.surface.delivered_packages += 1
-
-    def remove_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-
-
-# =============================================================================
-# Hauptprogramm
-# =============================================================================
-if __name__ == "__main__":
-    surface = SimulationSurface()
-    vehicle_controller = VehicleController(surface)
-    for vehicle in vehicle_controller.vehicles:
-        vehicle_controller.start_delivery_cycle(vehicle, vehicle.getPos())
-    surface.run()
Index: Grundmodell/Gm11.py
===================================================================
diff --git a/Grundmodell/Gm11.py b/Grundmodell/Gm11.py
deleted file mode 100644
--- a/Grundmodell/Gm11.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,979 +0,0 @@
-import random
-import math
-import tkinter as tk  # Für das extra Fenster der Auftragsübersicht
-from tkinter import ttk  # Für die tabellarische Darstellung (Treeview)
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5  # Wird in update_vehicle genutzt
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Paketspawning an den Annahmestationen:
-        # Mapping: station (Dummy-Node) -> (Paket, Spawnzeit, Timer Node)
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-        # Graph-Daten (Sim-Zeit, Pakete pro Minute, durchschnittliche Liegedauer)
-        self.graph_data = []
-        self.graph_opened = False
-
-        # Auftragsverwaltung (alle aktiv gespawnten Aufträge)
-        self.orders = {}
-        self.next_order_id = 1
-
-        # Tkinter-Fenster für Auftragsübersicht
-        self.order_win = None
-        self.order_tree = None
-
-        # Umgebung initialisieren
-        self.draw_origin()
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.create_wall()
-        self.create_annahme_stations()
-        self.create_abgabe_stations()
-        self.create_garagen_stations()
-
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # Entferne das “herumfahrende” Fahrzeug:
-        # self.vehicle = self.create_vehicle()
-        # self.taskMgr.add(self.update_vehicle, "UpdateVehicleTask")
-
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-        self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-        # Fahrzeuge in den Garagen erstellen (genau 5 Fahrzeuge)
-        self.create_garage_vehicles()
-
-    # ---------------------------
-    # SIMULATION UND UI-METHODEN
-    # ---------------------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    # ---------------------------
-    # METHODEN FÜR RASTER, LICHT, MAUER, URSPRUNG
-    # ---------------------------
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # STATIONSOBJEKTE UND ZUORDNUNG
-    # -----------------------------------
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, 0.5))
-            green_dot.reparentTo(self.render)
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, 0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            order = {
-                "id": self.next_order_id,
-                "status": "Wartend",
-                "ziel": f"Abgabestation {random.randint(1, 10)}"
-            }
-            self.orders[station_dummy] = order
-            self.next_order_id += 1
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_abgabe_station(pt)
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, 0.5))
-            green_dot.reparentTo(self.render)
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, 0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 3)
-        v5 = pos + Vec3(1, 0, 3)
-        v6 = pos + Vec3(1, 2, 3)
-        v7 = pos + Vec3(0, 2, 3)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 3)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        self.garagen_stations = []
-        self.garagen_parking_points = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            self.garagen_stations.append(pt)
-            # ParkpunktGarage: Verschoben um 0.5 in negativer Y-Richtung:
-            center = pt + Vec3(0.5, 0.5, 1.5)
-            ParkpunktGarage = center + Vec3(0, 0, 0.7)  # entspricht pt + Vec3(0.5, 0.5, 2.2)
-            self.garagen_parking_points.append(ParkpunktGarage)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def create_garage_vehicles(self):
-        """
-        Erzeugt ein Fahrzeug für jeden der 5 Garagen-Parkpunkte.
-        Die Fahrzeuge werden um 180° gedreht und so positioniert, dass
-        der Schnittpunkt der Mastdiagonalen (intersection = Vec3(0.5, 0.05, 1.0))
-        in X- und Y-Richtung genau den ParkpunktGarage hat. Die Z-Koordinate wird auf 0 gesetzt.
-        """
-        self.garage_vehicles = []
-        for park in self.garagen_parking_points:
-            # Fahrzeug ohne Parkpunktausrichtung erstellen:
-            veh = self.create_vehicle(park_point=None)
-            # Fahrzeug um 180° drehen:
-            veh.setH(veh.getH() + 180)
-            # Berechne den neuen globalen Standort so, dass:
-            # veh.getPos() + veh.getQuat().xform(intersection) == park (nur X und Y berücksichtigen)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            newPos.setZ(0)  # Fahrzeug auf dem Boden (z = 0)
-            veh.setPos(newPos)
-            self.garage_vehicles.append(veh)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            # Zeige den Parkpunkt-Marker in X und Y von park, aber auf dem Boden:
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # FAHRZEUGERSTELLUNG (FFZ20-INTEGRATION)
-    # -----------------------------------
-    def create_vehicle(self, park_point=None):
-        """
-        Erstellt ein Fahrzeug bestehend aus:
-          - Chassis (Fahrmodul) mit schwarzen Kanten,
-          - Gabel (Fork) mit zwei Zähnen inkl.:
-              - WEISSE Verbindungslinie zwischen den äußersten Ecken der Zähne,
-              - senkrechter Linie (vom Mittelpunkt der Verbindung in Fahrtrichtung),
-              - GRÜNER Marker (0,5 m vom Mittelpunkt).
-          - Mast mit Diagonalen, gelbem Zylinder und Lidar-Kreis.
-        Wird ein 'park_point' übergeben, so wird das Fahrzeug (ohne Rotation) an
-        diesem ausgerichtet (spezifisch angepasst in create_garage_vehicles).
-        """
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Chassis: 1 x 0.5 x 1.2, Farbe Rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # Fork (Gabel): Zwei Zähne
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-        self.fork_node = fork_node
-
-        # --- Zusätzliche grafische Elemente aus FFZ20 ---
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_corner_global = fork_node.getPos() + left_corner_local
-        right_corner_global = fork_node.getPos() + right_corner_local
-
-        ls_new = LineSegs()
-        ls_new.setThickness(2.0)
-        ls_new.setColor(1, 1, 1, 1)
-        ls_new.moveTo(left_corner_global)
-        ls_new.drawTo(right_corner_global)
-        vehicle_node.attachNewNode(ls_new.create())
-
-        midpoint = (left_corner_global + right_corner_global) * 0.5
-        white_line_vec = right_corner_global - left_corner_global
-        if white_line_vec.length() != 0:
-            white_line_dir = white_line_vec.normalized()
-        else:
-            white_line_dir = Vec3(0, 0, 0)
-        candidate = Vec3(-white_line_dir.getY(), white_line_dir.getX(), 0)
-        vehicle_pos = vehicle_node.getPos()
-        if candidate.dot(vehicle_pos - midpoint) < 0:
-            candidate = -candidate
-        if candidate.length() != 0:
-            perp_direction = candidate.normalized()
-        else:
-            perp_direction = Vec3(0, 0, 0)
-        line_length = 1.0
-        line_end = midpoint + perp_direction * line_length
-        ls_mid = LineSegs()
-        ls_mid.setThickness(2.0)
-        ls_mid.setColor(1, 1, 1, 1)
-        ls_mid.moveTo(midpoint)
-        ls_mid.drawTo(line_end)
-        vehicle_node.attachNewNode(ls_mid.create())
-
-        green_point_global = midpoint + perp_direction * 0.5
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        # --- Ende FFZ20-Elemente ---
-
-        # Mast: Aufbau des Mastes
-        mast_node = vehicle_node.attachNewNode("mast")
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-
-        self.add_diagonals_to_mast(mast_node)
-        intersection = Vec3(0.5, 0.05, 1.0)
-
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        lidar_center = Vec3(intersection.x, intersection.y, -1)
-        self.add_lidar_circle(mast_node, lidar_center, 2)
-
-        if park_point is None:
-            vehicle_node.setPos(intersection.x, intersection.y, 0)
-        else:
-            vehicle_node.setPos(park_point - intersection)
-
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    # -----------------------------------
-    # FEHLENDE METHODEN: Paketspawning, Würfelerzeugung u.a.
-    # -----------------------------------
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        # Erhöhe pos.z um 1, damit das Paket 1 Einheit höher spawnt.
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z + 1, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {random.randint(1, 10)}"
-        }
-        self.orders[station] = order
-        self.next_order_id += 1
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        cube = self.create_box(1, 1, 1, color)
-        cube_np = self.render.attachNewNode(cube)
-        cube_np.setPos(x, y, z)
-        return cube_np
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            elapsed = self.sim_clock - spawn_time
-            timer_np.node().setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def update_order_status(self, task):
-        for station, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[station]
-        if self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = 10.0 / self.speed_factor
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0.0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            self.order_tree = ttk.Treeview(self.order_win, columns=("ID", "Status", "Ziel"), show="headings", height=15)
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Status", text="Status")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Status", width=100, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-    def update_order_table(self):
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-        for order in self.orders.values():
-            self.order_tree.insert("", tk.END, values=(order["id"], order["status"], order["ziel"]))
-        self.order_win.update()
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    def deliver_first_order(self):
-        for station, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: FFZ/FFZ17.py
===================================================================
diff --git a/FFZ/FFZ17.py b/FFZ/FFZ17.py
deleted file mode 100644
--- a/FFZ/FFZ17.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,452 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    LineSegs,
-    Vec3,
-    NodePath
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import math
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5  # Startgeschwindigkeit in m/s
-
-        # Kameraeinstellungen (Fahrtrichtung: entlang der Y-Achse)
-        self.cam.setPos(0, -30, 10)
-        self.cam.lookAt(0, 0, 0)
-
-        # Licht und Raster erstellen
-        self.setup_light()
-        self.create_grid(center_extent=10, cell_size=0.1)
-
-        # Fahrzeug erstellen (Chassis, Fork, Mast, etc.)
-        self.vehicle = self.create_vehicle()
-
-        # Slider für Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Slider zur manuellen Einstellung der Forkhöhe (0 bis 1 m)
-        self.fork_slider = DirectSlider(
-            range=(0.0, 1.0),
-            value=0.0,
-            pageSize=0.01,
-            command=self.update_fork_height,
-            pos=(-0.7, 0, -0.85),
-            scale=0.3
-        )
-        self.fork_label = DirectLabel(
-            text="Fork Höhe: 0.00m",
-            pos=(-0.7, 0, -0.75),
-            scale=0.07
-        )
-
-        # Laufzeitanzeige
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktionalität via Mausrad
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Update-Tasks
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_vehicle, "UpdateVehicleTask")
-        # Optional: Der Task für die Fork-Animation (update_cable) kann bei Bedarf aktiviert werden.
-        # self.taskMgr.add(self.update_cable, "UpdateCableTask")
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_fork_height(self, height=0, *args):
-        try:
-            height = float(height)
-        except ValueError:
-            height = 0.0
-        self.fork_node.setZ(height)
-        self.fork_label['text'] = f"Fork Höhe: {height:.2f}m"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        """Bewegt das Fahrzeug vorwärts, wobei es konstant die Zielgeschwindigkeit 1.5 m/s anstrebt.
-           Beschleunigung und Verzögerung erfolgen mit 2 m/s²."""
-        dt = ClockObject.getGlobalClock().getDt()
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5  # Ohne Hindernisse fährt das Fahrzeug mit 1.5 m/s
-        acc_rate = 2.0      # Beschleunigungsrate: 2 m/s²
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    def create_grid(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            x += cell_size
-
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        grid_np = self.render.attachNewNode(node)
-        grid_np.setColor(0.7, 0.7, 0.7, 1)
-        return grid_np
-
-    def setup_light(self):
-        ambient_light = AmbientLight("ambient_light")
-        ambient_light.setColor((0.5, 0.5, 0.5, 1))
-        ambient_np = self.render.attachNewNode(ambient_light)
-        self.render.setLight(ambient_np)
-
-        directional_light = DirectionalLight("directional_light")
-        directional_light.setColor((1, 1, 1, 1))
-        directional_np = self.render.attachNewNode(directional_light)
-        directional_np.setPos(10, -10, 10)
-        self.render.setLight(directional_np)
-
-    def create_vehicle(self):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Fahrmodul (Chassis): 1 x 0.5 x 1.2 in Rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        # Schwarze Kanten für das Chassis
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # Gabelmodul (Fork): Zwei Zähne (je 0.2 x 1.2 x 0.1)
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-        self.fork_node = fork_node
-
-        # Mast: Rahmen aus vier Balken
-        mast_node = vehicle_node.attachNewNode("mast")
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-
-        # Diagonalen auf der oberen Fläche des Mastes
-        self.add_diagonals_to_mast(mast_node)
-        # Schnittpunkt der Diagonalen in lokalen Mast-Koordinaten
-        intersection = Vec3(0.5, 0.05, 1.0)
-
-        # Gelber Zylinder: Durchmesser 0.1, Höhe 0.1, Farbe Gelb (1,1,0,1)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        # Lidar-Kreis: Der Mittelpunkt soll 1 m in negativer Z-Richtung liegen (also Z = -1),
-        # Farbe Grün, Radius 2
-        lidar_center = Vec3(intersection.x, intersection.y, -1)
-        self.add_lidar_circle(mast_node, lidar_center, 2)
-
-        # Setze den Fahrzeugknoten so, dass seine X- und Y-Koordinaten dem Schnittpunkt (intersection)
-        # entsprechen und in Z-Richtung 0 liegt.
-        vehicle_node.setPos(intersection.x, intersection.y, 0)
-
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)  # Orange
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)  # Grün
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        # Top center
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        # Top circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        # Bottom center
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        # Bottom circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        # Top fan
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        # Bottom fan
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        # Side faces
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        # Unterseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        # Oberseite
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        # Vorderseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        # Rückseite
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        # Linke Seite
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        # Rechte Seite
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base+1, base+2)
-            tris.closePrimitive()
-            tris.addVertices(base, base+2, base+3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        # Unterkante
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        # Oberkante
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        # Vertikale Kanten
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: Grundmodell Erweitert Split/GES1.py
===================================================================
diff --git a/Grundmodell Erweitert Split/GES1.py b/Grundmodell Erweitert Split/GES1.py
deleted file mode 100644
--- a/Grundmodell Erweitert Split/GES1.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,2007 +0,0 @@
-# Standardbibliothek
-import random
-import math
-import time
-import ctypes
-import multiprocessing
-from multiprocessing import Queue, Process
-from functools import partial
-import tkinter as tk
-from tkinter import ttk
-
-# Drittanbieter
-import matplotlib
-import matplotlib.pyplot as plt
-from PyQt5 import QtWidgets, QtCore
-import pyqtgraph as pg
-
-# Panda3D und Direct (Engine-spezifische Importe)
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.task.TaskManagerGlobal import taskMgr
-from direct.gui.DirectGui import DirectButton, DirectSlider, DirectLabel
-
-from direct.showbase.ShowBase import ShowBase
-from environment_visualization import EnvironmentVisualizer
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self, graph_queue=None):
-        # Basisinitialisierung (ShowBase, etc.)
-        super().__init__()
-
-        # ------------------------------------------------------------------------
-        # 1. Umgebung aufbauen: Verwende den extrahierten EnvironmentVisualizer
-        # ------------------------------------------------------------------------
-        self.env_viz = EnvironmentVisualizer(self.render, self.loader)
-
-        # Rufe die Methoden des Visualizers auf, um die Umgebung zu erstellen.
-        self.env_viz.draw_origin()
-        self.env_viz.erzeuge_licht()
-        self.env_viz.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.env_viz.create_wall()
-        self.env_viz.create_annahme_stations()
-        self.env_viz.create_abgabe_stations()
-        self.env_viz.create_garagen_stations()
-
-        # Um in anderen Methoden (z. B. für Paket- oder Auftrags-Handling) auf die Stationen
-        # und deren Marker zugreifen zu können, übergeben wir die entsprechenden Listen.
-        self.annahme_stations = self.env_viz.annahme_stations
-        self.station_blue_dots = self.env_viz.station_blue_dots
-        self.abgabe_stations = self.env_viz.abgabe_stations
-        self.abgabe_blue_dots = self.env_viz.abgabe_blue_dots
-        self.garagen_stations = self.env_viz.garagen_stations
-        self.garagen_parking_points = self.env_viz.garagen_parking_points
-
-        # Setze den Pickup-Offset (dieser Vektor wird bei der Steuerung genutzt)
-        self.pickup_offset = Vec3(0.5, -0.5, 0)
-
-        # Falls du weitere Referenzen (wie self.blue_dot, self.station_green_dot) brauchst, ebenfalls setzen.
-        if hasattr(self.env_viz, 'blue_dot'):
-            self.blue_dot = self.env_viz.blue_dot
-        if hasattr(self.env_viz, 'station_green_dot'):
-            self.station_green_dot = self.env_viz.station_green_dot
-
-        # ------------------------------------------------------------------------
-        # 2. Restliche Initialisierung (Simulationsvariablen, UI, Tasks, etc.)
-        # (Der restliche Code bleibt weitgehend unverändert.)
-        # ------------------------------------------------------------------------
-
-        self.paused = False
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5
-
-        # Weitere Attribute, z. B. für KPIs, Paket- und Auftragsverwaltung usw.
-        self.delivered_packages = 0
-        self.pickup_packages = {}
-        self.last_removed = {}
-        self.orders = {}
-        self.orders_queue = []
-        self.next_order_id = 1
-        # (Weitere Initialisierungen kommen hier…)
-        self.cargos = {}
-        # Falls du auch weitere Attribute benötigst, wie beispielsweise eine Liste der belegten Pickup-Stations:
-        self.occupied_pickups = set()
-
-        self.max_overall_wait_time = 0.0  # Maximale Wartezeit der Pakete
-        self.total_dwell_time = 0.0  # Summe aller Liegedauern abgeholter Pakete
-        self.picked_up_count = 0  # Anzahl abgeholter Pakete
-        self.total_delivery_time = 0.0  # Summe aller Lieferzeiten
-        self.total_delivery_count = 0  # Anzahl der Lieferungen
-        self.max_overall_delivery_time = 0.0
-
-        self.graph_queue = None
-        self.graph_data = []
-
-        # Beispiel: Initialisierung des Tkinter-Fensters
-        self.tk_root = tk.Tk()
-        self.tk_root.withdraw()
-
-        # Weiterer Code: Kamera, Lichter (falls weiterhin benötigt – ansonsten übernehmen wir vollständig den Visualizer)
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # UI-bezogene Attribute initialisieren:
-        self.order_win = None
-        self.order_tree = None
-        self.graph_queue = None
-        self.graph_data = []
-
-        # TensorFlow-Modell und RL-Agent initialisieren (wie gehabt)
-        try:
-            import tensorflow as tf
-            self.tf_model = tf.keras.models.load_model("models/mein_saved_model")
-            print("TensorFlow Modell erfolgreich geladen.")
-        except Exception as e:
-            print(f"Fehler beim Laden des TensorFlow Modells: {e}")
-            self.tf_model = None
-
-        state_bins = ((10, 10), (10, 10))
-        action_space = [0, 1, 2]
-        self.rl_agent = RLAgent(state_bins, action_space, learning_rate=0.1, discount_factor=0.9, epsilon=0.2)
-        self.training_data = []  # Trainingsdatenliste
-
-        # Fahrzeuge, Aufträge, etc. erstellen (wie gehabt):
-        # Erzeuge für jede Annahmestation ein Paket:
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # Fahrzeuge in den Garagen instanziieren:
-        self.create_garage_vehicles()
-        # --- UI-Elemente für Simulationssteuerung ---
-        # Slider für Simulationsgeschwindigkeit
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        self.paused = False
-        # Pause-Knopf neben dem Slider platzieren – z.B. rechts davon.
-        self.pause_button = DirectButton(
-            text="Pause",
-            command=self.toggle_pause,
-            pos=(-0.5, 0, -0.85),  # Leicht links vom Slider
-            scale=0.07
-        )
-
-        # --- Tastenzuordnungen ---
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-        # Taste "c" öffnet das Fahrzeug-Kontrollfenster
-        self.accept("c", self.show_vehicle_control)
-
-        # --- Tasks (TaskMgr) hinzufügen ---
-        self.taskMgr.add(self._tk_update, "tkUpdateTask")
-        self.taskMgr.add(self.update_delivery_timers, "UpdateDeliveryTimersTask")
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClock")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_graph_data, "UpdateGraphDataTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-    # ---------------1. Initialisierung & Simulationssteuerung---------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        self.sim_clock += dt
-        return Task.cont
-
-    def toggle_pause(self):
-        if not self.paused:
-            # Speichern des aktuellen speed_factor, damit wir ihn beim Resume wiederherstellen können
-            self.previous_speed_factor = self.speed_factor
-            self.speed_factor = 0  # Simulation einfrieren: alle dt-basierte Updates ergeben 0
-            self.pause_button['text'] = "Weiter"
-            self.paused = True
-            print("Gesamte Simulation angehalten")
-        else:
-            # Wiederaufnahme der Simulation: speed_factor auf den vorherigen Wert zurücksetzen
-            self.speed_factor = self.previous_speed_factor if hasattr(self, 'previous_speed_factor') else 1.0
-            self.pause_button['text'] = "Pause"
-            self.paused = False
-            print("Simulation läuft wieder")
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        # dt jetzt skaliert mit der Simulationsgeschwindigkeit
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-    # ---------------2. Graphik & UI (GUI-/Tk-/Matplotlib-Funktionen)---------------
-    def open_graph(self):
-        # Starte den Graphprozess per Taste G (nur, wenn er noch nicht läuft)
-        if self.graph_process is None or not self.graph_process.is_alive():
-            from multiprocessing import Queue, Process
-            self.graph_queue = Queue()
-
-            # Sende alle bisher gesammelten Daten in die Queue:
-            for data in self.graph_data:
-                try:
-                    self.graph_queue.put(data, block=False)
-                except Exception:
-                    pass
-
-            from graph_pyqt import graph_process_pyqt
-            self.graph_process = Process(target=graph_process_pyqt, args=(self.graph_queue,))
-            self.graph_process.start()
-            print("Graphprozess gestartet.")
-        else:
-            print("Graphprozess läuft bereits.")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2, self.ax3) = plt.subplots(3, 1, figsize=(8, 9))
-
-        # Erster Plot: Pakete pro Minute
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-
-        # Zweiter Plot: Durchschnittliche Liegedauer
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-
-        # Dritter Plot: Durchschnittliche Lieferzeit
-        self.line3, = self.ax3.plot([], [], marker="o", color="green", label="Durchschnittliche Lieferzeit (s)")
-        self.ax3.set_xlabel("Simulationszeit (s)")
-        self.ax3.set_ylabel("Lieferzeit (s)")
-        self.ax3.set_title("Durchschnittliche Lieferzeit")
-        self.ax3.legend()
-        self.ax3.grid(True)
-
-        plt.show(block=False)
-        # Starte im Tkinter-Hauptloop eine periodische Aktualisierung:
-        self.tk_root.after(500, self.tk_graph_update)  # alle 500ms
-
-    def tk_graph_update(self):
-        # GIL sichern: Gibt einen Statuswert zurück, der später wieder freigegeben wird.
-        gil_state = ctypes.pythonapi.PyGILState_Ensure()
-        try:
-            times = [data[0] for data in self.graph_data]
-            rates = [data[1] for data in self.graph_data]
-            dwell = [data[2] for data in self.graph_data]
-            delivery = [data[3] for data in self.graph_data]
-
-            self.line1.set_data(times, rates)
-            self.ax1.relim()
-            self.ax1.autoscale_view()
-
-            self.line2.set_data(times, dwell)
-            self.ax2.relim()
-            self.ax2.autoscale_view()
-
-            self.line3.set_data(times, delivery)
-            self.ax3.relim()
-            self.ax3.autoscale_view()
-
-            self.fig.canvas.draw_idle()
-            self.fig.canvas.flush_events()
-        finally:
-            ctypes.pythonapi.PyGILState_Release(gil_state)
-
-        # Nächsten Aufruf in 500ms einplanen
-        self.tk_root.after(500, self.tk_graph_update)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-
-        # Bestimme die maximale Liegedauer aktueller Pakete an den Annahmestationen
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-
-        # Lieferzeit-Kennzahlen ermitteln: für Fahrzeuge, die aktuell ein Paket tragen
-        current_delivery_time = 0.0
-        for veh in self.garage_vehicles:
-            if veh.getPythonTag("package_attached"):
-                ds = veh.getPythonTag("delivery_start_time")
-                if ds:
-                    elapsed_delivery = self.sim_clock - ds
-                    current_delivery_time = max(current_delivery_time, elapsed_delivery)
-        avg_delivery_time = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        # Aktualisiere den Info-Label-Text
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s\n"
-            f"Lieferzeit (aktuell): {current_delivery_time:.1f}s\n"
-            f"Lieferzeit (maximal): {self.max_overall_delivery_time:.1f}s\n"
-            f"Durchschn. Lieferzeit: {avg_delivery_time:.1f}s"
-        )
-        return Task.cont
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def update_graph_data(self, task):
-        if self.sim_clock > 0:
-            ppm = self.delivered_packages / (self.sim_clock / 60)
-        else:
-            ppm = 0.0
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        avg_delivery = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        new_data = (self.sim_clock, ppm, avg_dwell, avg_delivery)
-        # Speichere alle Daten ab Simulationsbeginn:
-        self.graph_data.append(new_data)
-
-        # Zusätzlich: Falls der Graphprozess aktiv ist, schicke den neuen Datensatz auch an die Queue
-        if self.graph_queue is not None:
-            try:
-                self.graph_queue.put(new_data, block=False)
-            except Exception:
-                pass
-        return Task.cont
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Hier werden nur die gewünschten Spalten "ID", "Annahmestation", "Ziel" und "Fahrzeug" definiert.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    #-------Fahrzeugsteuerung(Bedienfenster)-------
-    def show_vehicle_control(self):
-        # Falls das Fenster bereits existiert, bringe es einfach in den Vordergrund,
-        # ohne die Radiobuttons neu zu initialisieren.
-        if hasattr(self, "control_win") and self.control_win.winfo_exists():
-            self.control_win.deiconify()
-            self.control_win.lift()
-            self.control_win.focus_force()
-            return
-
-        # Erstelle das Kontrollfenster als Toplevel des persistenten tk_root.
-        self.control_win = tk.Toplevel(self.tk_root)
-        self.control_win.title("Fahrzeugsteuerung")
-        # Beim Schließen soll das Fenster nicht zerstört, sondern nur versteckt werden
-        self.control_win.protocol("WM_DELETE_WINDOW", self.control_win.withdraw)
-        # Sorge dafür, dass das Fenster initial über allem liegt
-        self.control_win.attributes("-topmost", True)
-        self.control_win.after(100, lambda: self.control_win.attributes("-topmost", False))
-
-        # Erzeuge das Dictionary für die StringVar-Zuordnungen für die Fahrzeuge.
-        self.vehicle_state_vars = {}
-        row = 0
-        for veh in self.garage_vehicles:
-            frame = tk.Frame(self.control_win)
-            frame.grid(row=row, column=0, sticky="w", padx=5, pady=2)
-            vid = veh.getPythonTag("vehicle_id")
-            label = tk.Label(frame, text=f"Fahrzeug {vid}")
-            label.pack(side=tk.LEFT)
-            # Initialisiere die Radiobutton-Variable anhand des aktuellen Fahrzeugzustandes.
-            state = veh.getPythonTag("order_state")
-            if state is None:
-                state = "idle"
-            var = tk.StringVar(value=state)
-            self.vehicle_state_vars[veh] = var
-            rb_active = tk.Radiobutton(frame, text="Aufträge bearbeiten", variable=var, value="translate")
-            rb_active.pack(side=tk.LEFT)
-            rb_standby = tk.Radiobutton(frame, text="Standby", variable=var, value="idle")
-            rb_standby.pack(side=tk.LEFT)
-            row += 1
-        update_btn = tk.Button(self.control_win, text="Übernehmen", command=self.update_vehicle_control)
-        update_btn.grid(row=row, column=0, pady=5)
-
-    def update_vehicle_control(self):
-        for veh, var in self.vehicle_state_vars.items():
-            new_state = var.get()
-            if new_state == "idle" and veh.getPythonTag("current_order") is not None:
-                veh.setPythonTag("standby_pending", True)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Standby angefordert (Auftrag wird fortgesetzt).")
-            else:
-                veh.setPythonTag("standby_pending", False)
-                veh.setPythonTag("order_state", new_state)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Zustand auf {new_state} gesetzt.")
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-    def update_cable(self, task):
-        # Verwende die simulative Zeit, die bereits in update_sim_clock hochgezählt wird
-        t = self.sim_clock
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    def create_garage_vehicles(self):
-        self.garage_vehicles = []
-        vehicle_id_counter = 1
-        for park in self.garagen_parking_points:
-            veh = self.create_vehicle(park_point=park)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            newPos.setZ(0)
-            veh.setPos(newPos)
-
-            # Fahrzeuge starten im Standby (idle)
-            veh.setPythonTag("current_order", None)
-            veh.setPythonTag("order_state", "idle")
-            veh.setPythonTag("package_attached", False)
-            veh.setPythonTag("vehicle_id", vehicle_id_counter)
-            # Speichere den Parkpunkt als Rückkehrziel
-            veh.setPythonTag("garage_target", park)
-            # Speichere auch das Anfangs-Heading, um es später beim Parken wiederherzustellen.
-            veh.setPythonTag("start_heading", veh.getH())
-            vehicle_id_counter += 1
-
-            self.garage_vehicles.append(veh)
-
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-            # Füge einen Textknoten hinzu, der die Fahrzeugnummer vorne auf dem Fahrzeug anzeigt.
-            # Wir suchen den Mast-Knoten.
-            mast = veh.find("**/mast")
-            if not mast.isEmpty():
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)  # Schwarz
-                tn.setAlign(TextNode.ACenter)
-                text_np = mast.attachNewNode(tn)
-                # Positioniere den Text relativ zum Mast: Wir nutzen den Vektor "intersection"
-                # und versetzen ihn in Z-Richtung um 0.2 Einheiten oberhalb des Zylinders.
-                text_np.setPos(intersection.x, intersection.y, intersection.z + 0.2)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-            else:
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)
-                tn.setAlign(TextNode.ACenter)
-                text_np = veh.attachNewNode(tn)
-                text_np.setPos(0, 1.2, 1.5)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-
-            self.taskMgr.add(partial(self.vehicle_order_task, veh),
-                             f"VehicleOrderTask_{veh.getPythonTag('vehicle_id')}")
-
-    # --------------- Erstellung des Fahrzeugs---------------
-    def create_vehicle(self, park_point=None):
-        # Erzeuge den übergeordneten Fahrzeug-Knoten
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # --------------------------
-        # Chassis erstellen (1 x 0.5 x 1.2, Farbe Rot)
-        # --------------------------
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # --------------------------
-        # Gabel (Fork) erstellen: Zwei Zähne
-        # --------------------------
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        vehicle_node.setPythonTag("fork_node", fork_node)
-
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-
-        # --------------------------
-        # Statt weißer Kante von der Gabel: bereits eingezeichnete grüne Mittellinie verwenden.
-        # In diesem Beispiel nehmen wir an, dass du schon eine „mittlere“ Linie gezeichnet hast.
-        # Zeichne die grüne Mittellinie, z. B. von einem Punkt an der Gabel (als Ausgangspunkt)
-        # bis zu einem Referenzpunkt – hier nutzen wir einen zuvor festgelegten Offset.
-        #
-        # Wir definieren:
-        #   - Den Ausgangspunkt als den grün markierten Punkt, der den mittleren Punkt der Gabel repräsentieren soll.
-        #   - Den Zielpunkt als den Referenzpunkt, der als Idealwert in create_vehicle bestimmt wurde.
-        # In unserem Beispiel berechnen wir den Zielpunkt einmalig aus den lokalen Offsets an der weißen Kante.
-        # (Diese Werte kannst du bei Bedarf anpassen.)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_global = fork_node.getPos(self.render) + left_corner_local
-        right_global = fork_node.getPos(self.render) + right_corner_local
-        # Berechne den idealen (statischen) Mittelpunkt als Referenz – dieser wird nur einmal gesetzt.
-        midpoint_white = (left_global + right_global) * 0.5
-        # Nun lege den grünen Marker so, dass er exakt in der Mitte der Gabel liegt.
-        # Hier entspricht der grüne Punkt der Mittellinie der Gabel.
-        green_point_global = midpoint_white  # Hier wird angenommen, dass der ideale Mittelpunkt gleich dem Referenzpunkt ist.
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        vehicle_node.setPythonTag("fork_green", green_marker_np)
-
-        # Zeichne die grüne Mittellinie.
-        # Als Beispiel: Zeichne eine Linie vom grünen Marker in Richtung +Y (relativ zum Fahrzeug),
-        # weil du den idealen Zustand so festgelegt hast, dass genau diese Linie mit der Station übereinstimmen soll.
-        ls_mid = LineSegs()
-        ls_mid.setThickness(2.0)
-        ls_mid.setColor(0, 1, 0, 1)  # grün
-        # Starte die Linie am grünen Marker.
-        ls_mid.moveTo(green_point_global)
-        # Zeichne beispielsweise eine Linie 1 Einheit lang in +Y-Richtung:
-        ls_mid.drawTo(green_point_global + Vec3(0, 1, 0))
-        fork_center_line = vehicle_node.attachNewNode(ls_mid.create())
-        # Speichere den NodePath der grünen Mittellinie
-        vehicle_node.setPythonTag("fork_center_line", fork_center_line)
-        print("[DEBUG] create_vehicle: Grüne Mittellinie (fork_center_line) gesetzt.")
-
-        # --------------------------
-        # Restliche Fahrzeugteile (Mast, Lenkachse, etc.)
-        # --------------------------
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-        self.add_diagonals_to_mast(mast_node)
-
-        intersection = Vec3(0.5, 0.05, 1.0)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        # --------------------------
-        # Lenkachse erzeugen (Pivot-Node)
-        # --------------------------
-        steering_axis = mast_node.attachNewNode("steering_axis")
-        steering_axis.setPos(0.5, 0.25, -1.2)
-        steering_axis.setH(90)
-        vehicle_node.setPythonTag("steering_axis", steering_axis)
-
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(steering_axis)
-        cylinder_node.setPos(0, 0, 0)
-        self.vehicle_cylinder = steering_axis
-        self.add_steering_arrow(steering_axis, color=(0, 1, 0, 1))
-
-        # --------------------------
-        # Positioniere das Fahrzeug am Parkpunkt
-        # --------------------------
-        if park_point is None:
-            vehicle_node.setPos(0, 0, 0)
-        else:
-            intersection = Vec3(0, 0, 1.0)
-            vehicle_node.setPos(park_point - vehicle_node.getQuat().xform(intersection))
-
-        # ********** Ursprung (Koordinatensystem) am Fahrzeug einzeichnen **********
-        ls_x = LineSegs()
-        ls_x.setThickness(2)
-        ls_x.setColor(LColor(1, 0, 0, 1))
-        ls_x.moveTo(0, 0, 0)
-        ls_x.drawTo(1, 0, 0)
-        vehicle_node.attachNewNode(ls_x.create())
-
-        ls_y = LineSegs()
-        ls_y.setThickness(2)
-        ls_y.setColor(LColor(0, 1, 0, 1))
-        ls_y.moveTo(0, 0, 0)
-        ls_y.drawTo(0, 1, 0)
-        vehicle_node.attachNewNode(ls_y.create())
-
-        ls_z = LineSegs()
-        ls_z.setThickness(2)
-        ls_z.setColor(LColor(0, 0, 1, 1))
-        ls_z.moveTo(0, 0, 0)
-        ls_z.drawTo(0, 0, 1)
-        vehicle_node.attachNewNode(ls_z.create())
-
-        from panda3d.core import TextNode
-        tn_x = TextNode("label_x")
-        tn_x.setText("X")
-        tn_x.setTextColor(1, 0, 0, 1)
-        label_x = vehicle_node.attachNewNode(tn_x)
-        label_x.setScale(0.3)
-        label_x.setPos(2.0, 0, 0)
-
-        tn_y = TextNode("label_y")
-        tn_y.setText("Y")
-        tn_y.setTextColor(0, 1, 0, 1)
-        label_y = vehicle_node.attachNewNode(tn_y)
-        label_y.setScale(0.3)
-        label_y.setPos(0, 2.0, 0)
-
-        tn_z = TextNode("label_z")
-        tn_z.setText("Z")
-        tn_z.setTextColor(0, 0, 1, 1)
-        label_z = vehicle_node.attachNewNode(tn_z)
-        label_z.setScale(0.3)
-        label_z.setPos(0, 0, 2.0)
-
-        return vehicle_node
-
-    def add_steering_arrow(self, steering_axis, color=(0, 1, 0, 1)):
-        """
-        Erzeugt einen Pfeil, der die Vorwärtsrichtung (lokale X-Achse) des Lenkpivots anzeigt.
-        Der Pfeil wird als Kind des übergebenen steering_axis-Node angehängt und passt sich
-        automatisch dessen Rotation an.
-        """
-        arrow_ls = LineSegs()
-        arrow_ls.setThickness(2.0)
-        arrow_ls.setColor(*color)
-
-        # Zeichne eine Linie von (0,0,0) bis (2,0,0) – das ist die Basis des Pfeils
-        arrow_ls.moveTo(0, 0, 0)
-        arrow_ls.drawTo(2, 0, 0)
-
-        # Zeichne den Pfeilkopf: zwei kurze schräge Linien am Ende der Pfeillinie
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, 0.3, 0)
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, -0.3, 0)
-
-        arrow_np = steering_axis.attachNewNode(arrow_ls.create())
-        arrow_np.setPos(0, 0, 0)  # Falls nötig, hier noch zusätzlichen Offset anpassen
-        return arrow_np
-
-    def rotate_around_pivot(self, vehicle, pivot, delta_angle):
-        """
-        Dreht das Fahrzeug (vehicle) um den gegebenen Pivotpunkt (pivot) um delta_angle (in Grad).
-        Dabei wird die Position des Fahrzeugs neu berechnet, sodass es um den Pivot rotiert.
-        """
-        # Aktuelle globale Fahrzeugposition
-        pos = vehicle.getPos(self.render)
-        # Globaler Pivotpunkt
-        pivot_pos = pivot.getPos(self.render)
-        # Berechne den Vektor vom Pivot zum Fahrzeug
-        rel = pos - pivot_pos
-        # Wandle den Drehwinkel in Bogenmaß um
-        rad = math.radians(delta_angle)
-        cos_val = math.cos(rad)
-        sin_val = math.sin(rad)
-        # Drehe den relativen Vektor
-        new_x = rel.getX() * cos_val - rel.getY() * sin_val
-        new_y = rel.getX() * sin_val + rel.getY() * cos_val
-        new_rel = Vec3(new_x, new_y, rel.getZ())
-        # Neue globale Fahrzeugposition
-        new_pos = pivot_pos + new_rel
-        vehicle.setPos(new_pos)
-        # Aktualisiere auch das Heading des Fahrzeugs (aufaddieren des Drehwinkels)
-        vehicle.setH(vehicle.getH() + delta_angle)
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    # ---------------6. Paket- & Auftragsverwaltung---------------
-        # Beispiel einer Methode, die weiterhin auf die extrahierten Umgebungselemente zugreift:
-        # Beispiel einer Methode, die weiterhin auf die extrahierten Umgebungselemente zugreift:
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Bestimme zufällig eine Abgabestation als Ziel
-        if hasattr(self, "abgabe_stations") and self.abgabe_stations:
-            target_index = random.randint(1, len(self.abgabe_stations))
-        else:
-            target_index = 1
-
-        # Erstelle den Auftrag zur Annahmestation
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = 5.0  # 5 Sekunden Verzögerung zwischen Spawns
-        for station in self.annahme_stations:
-            # Wenn aktuell kein Paket an der Station ist
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                # Prüfe, ob seit der letzten Entnahme mindestens 5 Sekunden vergangen sind
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-        # Beispiel für eine vorhandene Methode, die auf die Umgebungselemente zugreift:
-    def update_order_table(self):
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen die Stationsnummer (oder verwende "N/A").
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z.B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige den zugewiesenen Fahrzeugnamen an (oder "-" falls noch keiner zugeordnet wurde).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END,
-                                   values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if hasattr(self, 'order_win') and self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    # ---------------7. Cargo-Handling (Pickup, Drop & Timer)---------------
-    def pickup_package(self, vehicle, station):
-        # Falls das Fahrzeug bereits ein Paket trägt, abbrechen.
-        if vehicle.getPythonTag("package_attached"):
-            return
-
-        # Führe den Pickup nur aus, wenn an der Station ein Paket vorhanden ist.
-        if station in self.pickup_packages:
-            # Hole das Paket, den Spawn-Zeitpunkt und den zugehörigen Timer-Knoten.
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            # Entferne den Timer-Knoten, sodass der angezeigte Zähler nicht weiter aktualisiert wird.
-            timer_np.removeNode()
-            # Berechne die Liegedauer (Differenz zwischen aktueller Simulationszeit und Spawn-Zeit).
-            dwell_time = self.sim_clock - spawn_time
-            # Aktualisiere globale Kennzahlen.
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Suche in den Aufträgen nach dem Auftrag, dessen Paket mit diesem Paket übereinstimmt,
-            # und speichere den errechneten Endwert (fixe Liegedauer) sowie den Status.
-            for order_id, order in self.orders.items():
-                if order.get("package") == package:
-                    order["dwell_time"] = dwell_time
-                    order["status"] = "Abgeholt"
-                    break
-
-            # Hole Referenzen zum Gabel-Knoten und zum grünen Marker des Fahrzeugs.
-            fork_node = vehicle.getPythonTag("fork_node")
-            fork_green = vehicle.getPythonTag("fork_green")
-            green_point_pos = fork_green.getPos(fork_node)
-
-            # Übergib das Paket an den Gabel-Knoten (sodass es optisch dem Fahrzeug zugeordnet wird)
-            # und positioniere es relativ zum grünen Marker.
-            package.wrtReparentTo(fork_node)
-            package.setPos(green_point_pos.getX() + 0.5,
-                           green_point_pos.getY() - 0.5,
-                           green_point_pos.getZ() + 1)
-            self.cargos[vehicle] = package
-
-            # Starte den Lieferzeit-Timer: Speichere den Zeitpunkt, an dem das Paket abgeholt wurde,
-            # und hänge einen neuen Timer-Knoten an das Paket.
-            vehicle.setPythonTag("delivery_start_time", self.sim_clock)
-            from panda3d.core import TextNode
-            delivery_timer_text = TextNode("delivery_timer")
-            delivery_timer_text.setText("0.0s")
-            delivery_timer_np = package.attachNewNode(delivery_timer_text)
-            delivery_timer_np.setScale(0.5)
-            delivery_timer_np.setPos(0, 0, 1.2)
-            package.setPythonTag("delivery_timer", delivery_timer_np)
-
-            # Aktualisiere den Zeitpunkt, zu dem an dieser Station zuletzt ein Paket entfernt wurde.
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-
-            # Berechne Lieferzeit:
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start is not None:
-                delivery_time = self.sim_clock - delivery_start
-                self.total_delivery_time += delivery_time
-                self.total_delivery_count += 1
-                self.max_overall_delivery_time = max(self.max_overall_delivery_time, delivery_time)
-                vehicle.clearPythonTag("delivery_start_time")
-
-            # Entferne den Lieferzeit-Timer vom Paket
-            delivery_timer_np = cargo.getPythonTag("delivery_timer")
-            if delivery_timer_np:
-                delivery_timer_np.removeNode()
-
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden das Paket entfernt
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def update_delivery_timers(self, task):
-        for vehicle, package in list(self.cargos.items()):
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start:
-                elapsed_delivery = self.sim_clock - delivery_start
-                delivery_timer_np = package.getPythonTag("delivery_timer")
-                if delivery_timer_np and not delivery_timer_np.isEmpty():
-                    delivery_timer_np.node().setText(f"{elapsed_delivery:.1f}s")
-        return Task.cont
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-
-    # ---------------8. Auftrags-/Fahrzeuglogik---------------
-    def select_next_order(self, vehicle):
-        # Sammle alle Aufträge, die noch "Wartend" sind
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        # Aktualisiere die Dwell-Zeit für jeden Auftrag
-        for order in waiting_orders:
-            order["dwell_time"] = self.sim_clock - order.get("spawn_time", self.sim_clock)
-
-        # Wähle den Auftrag mit der maximalen Dwell-Zeit (evtl. mit etwas Toleranz)
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        # Finde aus den Kandidaten den Auftrag, dessen Pickup-Station (order["pickup_station"])
-        # am nächsten zur aktuellen Fahrzeugposition liegt.
-        vehicle_pos = vehicle.getPos(self.render)
-        candidates.sort(key=lambda order: (order["pickup_station"].getPos(self.render) - vehicle_pos).length())
-        return candidates[0]
-
-    def show_vehicle_control(self):
-        # Falls das Fenster bereits existiert, bringe es einfach in den Vordergrund,
-        # ohne die Radiobuttons neu zu initialisieren.
-        if hasattr(self, "control_win") and self.control_win.winfo_exists():
-            self.control_win.deiconify()
-            self.control_win.lift()
-            self.control_win.focus_force()
-            return
-
-        # Erstelle das Kontrollfenster als Toplevel des persistenten tk_root.
-        self.control_win = tk.Toplevel(self.tk_root)
-        self.control_win.title("Fahrzeugsteuerung")
-        # Beim Schließen soll das Fenster nicht zerstört, sondern nur versteckt werden
-        self.control_win.protocol("WM_DELETE_WINDOW", self.control_win.withdraw)
-        # Sorge dafür, dass das Fenster initial über allem liegt
-        self.control_win.attributes("-topmost", True)
-        self.control_win.after(100, lambda: self.control_win.attributes("-topmost", False))
-
-        # Erzeuge das Dictionary für die StringVar-Zuordnungen für die Fahrzeuge.
-        self.vehicle_state_vars = {}
-        row = 0
-        for veh in self.garage_vehicles:
-            frame = tk.Frame(self.control_win)
-            frame.grid(row=row, column=0, sticky="w", padx=5, pady=2)
-            vid = veh.getPythonTag("vehicle_id")
-            label = tk.Label(frame, text=f"Fahrzeug {vid}")
-            label.pack(side=tk.LEFT)
-            # Initialisiere die Radiobutton-Variable anhand des aktuellen Fahrzeugzustandes.
-            state = veh.getPythonTag("order_state")
-            if state is None:
-                state = "idle"
-            var = tk.StringVar(value=state)
-            self.vehicle_state_vars[veh] = var
-            rb_active = tk.Radiobutton(frame, text="Aufträge bearbeiten", variable=var, value="translate")
-            rb_active.pack(side=tk.LEFT)
-            rb_standby = tk.Radiobutton(frame, text="Standby", variable=var, value="idle")
-            rb_standby.pack(side=tk.LEFT)
-            row += 1
-        update_btn = tk.Button(self.control_win, text="Übernehmen", command=self.update_vehicle_control)
-        update_btn.grid(row=row, column=0, pady=5)
-
-    def vehicle_order_task(self, vehicle, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-
-        # Frame-Zähler einbauen, um die Frequenz der Modellinferenz zu reduzieren
-        frame_count = vehicle.getPythonTag("frame_count")
-        if frame_count is None:
-            frame_count = 0
-        frame_count += 1
-        vehicle.setPythonTag("frame_count", frame_count)
-
-        # Sensordatenerfassung
-        sensor_data = self.collect_sensor_data(vehicle)
-        import numpy as np
-        # Führe die Modellinferenz nur alle 10 Frames durch, um den Hauptthread zu entlasten
-        if self.tf_model is not None and (frame_count % 10 == 0):
-            input_data = sensor_data.reshape(1, sensor_data.shape[0], sensor_data.shape[1], 1)
-            prediction = self.tf_model.predict(input_data)
-            model_delta_angle = prediction[0][0]
-            print(f"[TF] Modell-Korrektur: {model_delta_angle:.2f}°")
-        else:
-            model_delta_angle = 0.0
-            if self.tf_model is not None:
-                print(f"[TF] Modell-Korrektur übersprungen (Frame Count: {frame_count})")
-            else:
-                print("[TF] Kein Modell vorhanden, Modell-Korrektur wird übersprungen.")
-
-        # Berechne den idealen Korrekturwert (unverändert)
-        ideal_correction = self.compute_ideal_steering_correction(vehicle)
-        print(f"[IDEAL] Ideal berechneter Korrekturwinkel: {ideal_correction:.2f}°")
-
-        # Logge Trainingsdaten nur in der 'translate'-Phase
-        state = vehicle.getPythonTag("order_state")
-        if state == "translate":
-            self.log_training_sample(sensor_data, ideal_correction)
-
-        # Führe die zustandsabhängige Logik aus
-        if state == "translate":
-            self.handle_translate_phase(vehicle, dt)
-        elif state == "rotate":
-            self.handle_rotate_phase(vehicle, dt)
-        elif state == "approach":
-            self.handle_approach_phase(vehicle, dt)
-        elif state == "pickup":
-            self.handle_pickup_phase(vehicle, dt)
-        elif state == "drive_out":
-            self.handle_drive_out_phase(vehicle, dt)
-        elif state == "to_delivery":
-            self.handle_to_delivery_phase(vehicle, dt)
-        elif state == "align_delivery":
-            self.handle_align_delivery_phase(vehicle, dt)
-        elif state == "delivery_center":
-            self.handle_delivery_center_phase(vehicle, dt)
-        elif state == "drop":
-            self.handle_drop_phase(vehicle, dt)
-        elif state == "phase11":
-            self.handle_phase11(vehicle, dt)
-        elif state == "return_to_garage":
-            self.handle_return_to_garage_phase(vehicle, dt)
-        else:
-            print(f"Unbekannter Zustand: {state}")
-
-        return Task.cont
-
-    # -------------------- Handler für einzelne Phasen --------------------
-
-    def handle_translate_phase(self, vehicle, dt):
-        # --- Zusätzlicher Safety-Zweig in der Translate-Phase ---
-        # (1) Zuerst: Falls ein Fahrzeug auf das Ziel (Pickup-Station) wartet, soll gewartet werden.
-        current_order = vehicle.getPythonTag("current_order")
-        station_occupied = False
-        if current_order is not None and "pickup_station" in current_order:
-            pickup_station = current_order["pickup_station"]
-            if self.is_station_occupied(pickup_station, exclude_vehicle=vehicle):
-                station_occupied = True
-                print(
-                    f"[WARTEN] Station {pickup_station.getName()} belegt. Fahrzeug {vehicle.getPythonTag('vehicle_id')} wartet.")
-
-        # (2) Festlegen der Basisgeschwindigkeit:
-        base_speed = 1.5 if not station_occupied else 0.0
-
-        # (3) Kollisionsvermeidung: Passe die Geschwindigkeit an, wenn andere Fahrzeuge in der Nähe sind.
-        adjusted_speed = self.collision_avoidance_adjustment(vehicle, base_speed)
-
-        # --- Rest der originalen Translate-Logik ---
-        # Falls kein Auftrag zugeordnet, versuche einen neuen Auftrag zu wählen.
-        if current_order is None:
-            next_order = self.select_next_order(vehicle)
-            if next_order is not None:
-                next_order["status"] = "In Bearbeitung"
-                next_order["vehicle"] = f"Fahrzeug {vehicle.getPythonTag('vehicle_id')}"
-                vehicle.setPythonTag("current_order", next_order)
-                print(f"Auftrag {next_order['id']} wird zugewiesen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}.")
-            current_order = vehicle.getPythonTag("current_order")
-
-        # Bestimme das Ziel: Zum Beispiel den blauen Marker der Pickup-Station.
-        if current_order is not None:
-            pickup_station = current_order.get("pickup_station")
-            if pickup_station in self.station_blue_dots:
-                target = self.station_blue_dots[pickup_station].getPos(self.render)
-            else:
-                target = self.blue_dot.getPos(self.render)
-        else:
-            target = self.blue_dot.getPos(self.render)
-
-        current_pos = vehicle.getPos(self.render)
-        pivot = vehicle.getPythonTag("steering_axis")
-
-        # Berechne den Offset-Punkt, von dem aus das Fahrzeug navigiert.
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        import math
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-        heading_error = desired_heading_rad - current_heading_rad
-        while heading_error > math.pi:
-            heading_error -= 2 * math.pi
-        while heading_error < -math.pi:
-            heading_error += 2 * math.pi
-
-        # Berechne den Drehwinkel (gilt für die Korrektur) – normale Drehung.
-        gain = 1.0
-        max_delta = gain * dt
-        delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-        self.rotate_around_pivot(vehicle, pivot, math.degrees(delta_heading_rad))
-
-        # Jetzt Vorwärtsbewegung: Verwende dafür die angepasste Geschwindigkeit.
-        global_hpr = pivot.getNetTransform().getHpr()
-        new_heading_rad = math.radians(global_hpr.getX())
-        new_x = current_pos.getX() + adjusted_speed * math.cos(new_heading_rad) * dt
-        new_y = current_pos.getY() + adjusted_speed * math.sin(new_heading_rad) * dt
-        new_pos = Vec3(new_x, new_y, 0)
-        vehicle.setPos(new_pos)
-
-        # Wenn das Fahrzeug nahe genug am Ziel ist, wechsle den Zustand in die Rotationsphase.
-        new_offset_pos = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        if (target - new_offset_pos).length() < 0.1:
-            vehicle.setPythonTag("order_state", "rotate")
-
-        return Task.cont
-
-    def handle_rotate_phase(self, vehicle, dt):
-        import math
-        from panda3d.core import Vec3
-
-        # 1. Hole den grünen Referenzpunkt (fork_green) der Gabel.
-        fork_green = vehicle.getPythonTag("fork_green")
-        if not fork_green or fork_green.isEmpty():
-            print("[DEBUG] handle_rotate_phase: Kein fork_green gefunden!")
-            return
-
-        # 2. Hole den aktuellen Auftrag und die zugehörige Pickup-Station.
-        current_order = vehicle.getPythonTag("current_order")
-        if not current_order or "pickup_station" not in current_order:
-            print("[DEBUG] handle_rotate_phase: Kein aktueller Auftrag oder Station gefunden!")
-            return
-        station = current_order["pickup_station"]
-
-        # Hole den Referenzpunkt der Station (white_center) und den Richtungsvektor (white_direction)
-        white_center = station.getPythonTag("white_center")
-        if white_center is None:
-            print("[DEBUG] handle_rotate_phase: Kein white_center in der Station gefunden!")
-            return
-        target = white_center  # Ziel: Mittelpunkt der weißen Linie
-
-        # 3. Berechne den Drehpunkt des Fahrzeugs.
-        pivot = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-
-        # 4. Falls sich der pivot nahe am Ziel befindet, final: Setze die exakte Ausrichtung.
-        distance = (target - pivot).length()
-        stop_threshold = 0.5  # Schwellenwert, evtl. an Modelldimensionen anpassen
-        if distance < stop_threshold:
-            desired_vector = target - pivot
-            desired_angle = math.degrees(math.atan2(desired_vector.getY(), desired_vector.getX())) + 90
-            desired_angle %= 360
-            vehicle.setH(self.render, desired_angle)
-            print(f"[DEBUG] final step: Fahrzeugheading auf {desired_angle:.2f}° gesetzt.")
-
-            # Final: Richte den grünen Richtungspfeil ("fork_center_line") exakt aus.
-            white_direction = station.getPythonTag("white_direction")
-            if white_direction is not None:
-                desired_arrow_angle = math.degrees(math.atan2(white_direction.getY(), white_direction.getX()))
-                arrow_relative = (desired_arrow_angle - desired_angle + 180) % 360 - 180
-                fork_center_line = vehicle.getPythonTag("fork_center_line")
-                if fork_center_line:
-                    fork_center_line.setH(arrow_relative)
-                    print(f"[DEBUG] final step: Grüner Pfeil auf relativen Winkel {arrow_relative:.2f}° gesetzt.")
-            # Hier ändern wir den Zustand in 'approach' statt "next_phase"
-            vehicle.setPythonTag("order_state", "approach")
-            return
-
-        # 5. Andernfalls: Berechne den gewünschten globalen Winkel (inklusive +90°-Offset)
-        desired_vector = target - pivot
-        desired_angle = math.degrees(math.atan2(desired_vector.getY(), desired_vector.getX())) + 90
-        desired_angle %= 360
-
-        # 6. Ermittle den aktuellen Fahrzeugheading in Weltkoordinaten und berechne die Winkelabweichung.
-        current_heading = vehicle.getH(self.render)
-        angle_diff = (desired_angle - current_heading + 180) % 360 - 180
-
-        if abs(angle_diff) < 2.0:
-            vehicle.setH(self.render, desired_angle)
-            white_direction = station.getPythonTag("white_direction")
-            if white_direction is not None:
-                desired_arrow_angle = math.degrees(math.atan2(white_direction.getY(), white_direction.getX()))
-                arrow_relative = (desired_arrow_angle - desired_angle + 180) % 360 - 180
-                fork_center_line = vehicle.getPythonTag("fork_center_line")
-                if fork_center_line:
-                    fork_center_line.setH(arrow_relative)
-                    print(f"[DEBUG] fine alignment: Grüner Pfeil auf {arrow_relative:.2f}° gesetzt.")
-            # Ändere auch hier sofort den Zustand in "approach"
-            vehicle.setPythonTag("order_state", "approach")
-            return
-
-        # 7. Begrenze die Drehung pro Frame (z.B. 20,9° pro Sekunde)
-        max_rotation_speed = 20.9  # Grad pro Sekunde
-        max_delta = max_rotation_speed * dt
-        delta_angle = max(-max_delta, min(max_delta, angle_diff))
-
-        # 8. Drehe das Fahrzeug schrittweise um delta_angle
-        temp_pivot = self.render.attachNewNode("temp_pivot")
-        temp_pivot.setPos(pivot)
-        self.rotate_around_pivot(vehicle, temp_pivot, delta_angle)
-        temp_pivot.removeNode()
-
-        print(f"[DEBUG] rotating: Gedreht um {delta_angle:.2f}°; Restliche Differenz: {angle_diff - delta_angle:.2f}°")
-
-    def handle_approach_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None:
-            pickup_station = current_order.get("pickup_station")
-            target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-        else:
-            target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-        current = vehicle.getPos(self.render)
-        error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-        if error_vec.length() > 0.05:
-            direction = error_vec.normalized()
-            move_distance = 1.5 * dt
-            new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                           current.getY() + direction.getY() * move_distance, target.getZ())
-            vehicle.setPos(new_pos)
-        else:
-            vehicle.setPos(target)
-            vehicle.setPythonTag("order_state", "pickup")
-
-    def handle_pickup_phase(self, vehicle, dt):
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        target_z = 1.0
-        raise_speed = 0.5
-        if current_z < target_z:
-            fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-        else:
-            if vehicle.getPythonTag("current_order") is None:
-                if self.orders_queue:
-                    vehicle.setPythonTag("current_order", self.orders_queue.pop(0))
-                else:
-                    print(
-                        f"Keine verfügbaren Aufträge für Fahrzeug {vehicle.getPythonTag('vehicle_id')}. Überspringe Pickup-Phase.")
-                    vehicle.setPythonTag("order_state", "drive_out")
-                    return
-            if not vehicle.getPythonTag("package_attached"):
-                pickup_station = vehicle.getPythonTag("current_order")["pickup_station"]
-                self.pickup_package(vehicle, pickup_station)
-                vehicle.setPythonTag("package_attached", True)
-            if vehicle.getPythonTag("drive_out_target") is None:
-                vehicle.setPythonTag("drive_out_target",
-                                     vehicle.getPos(self.render) + vehicle.getQuat(self.render).getForward() * 5.0)
-            vehicle.setPythonTag("order_state", "drive_out")
-
-    def handle_drive_out_phase(self, vehicle, dt):
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        if current_z > 0:
-            lower_speed = 0.5
-            fork_node.setZ(max(0, current_z - lower_speed * dt))
-        current_pos = vehicle.getPos(self.render)
-        drive_out_target = vehicle.getPythonTag("drive_out_target")
-        if drive_out_target is None:
-            drive_out_target = current_pos + vehicle.getQuat(self.render).getForward() * 5.0
-            vehicle.setPythonTag("drive_out_target", drive_out_target)
-        diff = drive_out_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            vehicle.setPythonTag("order_state", "to_delivery")
-            vehicle.setPythonTag("drive_out_target", None)
-
-    def handle_to_delivery_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is None:
-            return Task.cont
-
-        # Bestimme den Zielpunkt der Abgabestation:
-        delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-        try:
-            target_index = int(delivery_target_str.split()[-1])
-        except ValueError:
-            target_index = 1
-        if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-            target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-        else:
-            target = self.abgabe_blue_dots[0].getPos(self.render)
-
-        # Prüfe, ob die Abgabestation bereits durch ein Fahrzeug,
-        # das aktuell ein Paket abgibt oder in der Drop-Phase ist, besetzt ist.
-        if self.is_delivery_station_occupied(target, exclude_vehicle=vehicle, occupancy_threshold=1.0):
-            print(f"[WARTEN] Abgabestation belegt. Fahrzeug {vehicle.getPythonTag('vehicle_id')} wartet.")
-            return Task.cont  # Das Fahrzeug setzt keine Bewegung fort
-
-        # Falls die Abgabestation frei ist, folgt der übliche Bewegungs- und Drehvorgang:
-        current_pos = vehicle.getPos(self.render)
-        pivot = vehicle.getPythonTag("steering_axis")
-        import math
-        desired_heading_rad = math.atan2(target.getY() - current_pos.getY(),
-                                         target.getX() - current_pos.getX())
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-        heading_error = desired_heading_rad - current_heading_rad
-        while heading_error > math.pi:
-            heading_error -= 2 * math.pi
-        while heading_error < -math.pi:
-            heading_error += 2 * math.pi
-        gain = 1.0
-        max_delta = gain * dt
-        delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-        self.rotate_around_pivot(vehicle, pivot, math.degrees(delta_heading_rad))
-
-        # Vorwärtsbewegung:
-        new_heading_rad = math.radians(pivot.getNetTransform().getHpr().getX())
-        speed = 1.5  # Basisgeschwindigkeit
-        new_x = current_pos.getX() + speed * math.cos(new_heading_rad) * dt
-        new_y = current_pos.getY() + speed * math.sin(new_heading_rad) * dt
-        new_pos = Vec3(new_x, new_y, 0)
-        vehicle.setPos(new_pos)
-
-        # Falls das Fahrzeug nahe genug am Ziel ist, wechsele den Zustand:
-        if (target - new_pos).length() < 0.5:
-            print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat die Abgabestation erreicht.")
-            vehicle.setPythonTag("order_state", "align_delivery")
-
-        return Task.cont
-
-    def handle_align_delivery_phase(self, vehicle, dt):
-        desired_heading = 90.0
-        current_heading = vehicle.getH() % 360
-        angle_diff = ((desired_heading - current_heading + 180) % 360) - 180
-        print(
-            f"Phase 8: Align Delivery | Fahrzeug {vehicle.getPythonTag('vehicle_id')}: Current {current_heading:.2f}°, Desired {desired_heading:.2f}°, Diff {angle_diff:.2f}°")
-        fixed_turn_speed = 90.0
-        turn_amount = fixed_turn_speed * dt
-        if abs(angle_diff) < 1.0:
-            vehicle.setH(desired_heading)
-            print(
-                f"Phase 8 abgeschlossen: Fahrzeug {vehicle.getPythonTag('vehicle_id')} ausgerichtet (Heading = {desired_heading:.2f}°).")
-            vehicle.setPythonTag("order_state", "delivery_center")
-        else:
-            new_heading = current_heading + (turn_amount if angle_diff > 0 else -turn_amount)
-            new_heading %= 360
-            vehicle.setH(new_heading)
-            print(f"Phase 8: Rotating - Fahrzeug {vehicle.getPythonTag('vehicle_id')} New Heading: {new_heading:.2f}°")
-
-    def handle_delivery_center_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is None:
-            return
-        delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-        try:
-            target_index = int(delivery_target_str.split()[-1])
-        except ValueError:
-            target_index = 1
-        if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-            blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-        else:
-            blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-        current = vehicle.getPos(self.render)
-        target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-        print(f"Phase 9: Zielpunkt der Abgabestation für Fahrzeug {vehicle.getPythonTag('vehicle_id')}: {target_point}")
-        error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-        tolerance = 0.05
-        move_distance = 1.5 * dt
-        if error_vec.length() > tolerance:
-            direction = error_vec.normalized()
-            new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                           current.getY() + direction.getY() * move_distance, current.getZ())
-            vehicle.setPos(new_pos)
-            print(f"Phase 9: Fahrzeug {vehicle.getPythonTag('vehicle_id')} bewegt sich von {current} nach {new_pos}")
-        else:
-            vehicle.setPos(target_point)
-            print(f"Phase 9: Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den Zielpunkt erreicht.")
-            vehicle.setPythonTag("order_state", "drop")
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_fork_z = fork_node.getZ()
-        if current_fork_z < 1.0:
-            new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-            fork_node.setZ(new_fork_z)
-            print(
-                f"Phase 9: Gabel wird angehoben für Fahrzeug {vehicle.getPythonTag('vehicle_id')} (Z = {new_fork_z}).")
-
-    def handle_drop_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if vehicle.getPythonTag("package_attached"):
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            # (Bei Bedarf kann man hier noch Zielpositionen abfragen.)
-            self.drop_cargo(vehicle)
-            print(f"Phase 10: Paket abgesetzt für Fahrzeug {vehicle.getPythonTag('vehicle_id')}")
-            vehicle.setPythonTag("package_attached", False)
-        else:
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            if current_z > 0:
-                lower_speed = 0.5
-                new_z = max(0, current_z - lower_speed * dt)
-                fork_node.setZ(new_z)
-                print(
-                    f"Phase 10: Gabel wird abgesenkt für Fahrzeug {vehicle.getPythonTag('vehicle_id')}, aktueller Z-Wert: {new_z}")
-            else:
-                print(f"Phase 10: Dropoff abgeschlossen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}")
-                if vehicle.getPythonTag("standby_pending"):
-                    vehicle.setPythonTag("order_state", "return_to_garage")
-                    print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} kehrt zur Garage zurück (Standby).")
-                else:
-                    vehicle.setPythonTag("order_state", "translate")
-                current_order["status"] = "Abgegeben"
-                current_order["delivered_at"] = self.sim_clock
-                vehicle.clearPythonTag("current_order")
-
-    def handle_phase11(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if vehicle.getPythonTag("last_delivery_marker") is not None:
-            target_point = vehicle.getPythonTag("last_delivery_marker")
-        else:
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                target_point = self.abgabe_blue_dots[0].getPos(self.render)
-        print(f"Phase 11: Zielpunkt (blauer Marker) für Fahrzeug {vehicle.getPythonTag('vehicle_id')}: {target_point}")
-        current_pos = vehicle.getPos(self.render)
-        diff = target_point - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            vehicle.setPos(new_pos)
-            print(
-                f"Phase 11: Fahrzeug {vehicle.getPythonTag('vehicle_id')} fährt aus der Station, neue Position: {new_pos}")
-        else:
-            vehicle.setPos(target_point)
-            print(
-                f"Phase 11: Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den blauen Marker erreicht. Nächster Auftrag wird gestartet.")
-            vehicle.setPythonTag("order_state", "next_order")
-
-    def handle_return_to_garage_phase(self, vehicle, dt):
-        garage_target = vehicle.getPythonTag("garage_target")
-        if garage_target is None:
-            garage_target = self.garagen_parking_points[0]
-        current_pos = vehicle.getPos(self.render)
-        diff = garage_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 1.0 * dt
-            new_pos = current_pos + diff.normalized() * move_distance
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            if vehicle.hasPythonTag("start_heading"):
-                vehicle.setH(vehicle.getPythonTag("start_heading"))
-            vehicle.setPythonTag("order_state", "idle")
-            vehicle.setPythonTag("standby_pending", False)
-            print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} ist in der Garage (Standby).")
-
-    def collect_sensor_data(self, vehicle, sensor_range=5, grid_resolution=0.5):
-        """
-        Erzeugt ein einfaches 2D-Occupancy-Grid, das den Bereich um das Fahrzeug simuliert.
-
-        Parameter:
-          sensor_range: Radius (in Welt-Einheiten) um das Fahrzeug.
-          grid_resolution: Größe der einzelnen Zellen im Grid.
-
-        Rückgabe:
-          Ein NumPy-Array (2D) mit 0 (frei) als Platzhalter.
-        """
-        import numpy as np
-        grid_size = int((sensor_range * 2) / grid_resolution)
-        sensor_grid = np.zeros((grid_size, grid_size))
-        # --- Hier kannst du später echte Kollisionsabfragen oder Ray-Casting integrieren ---
-        return sensor_grid
-
-    def compute_ideal_steering_correction(self, vehicle):
-        """
-        Berechnet einen idealen Korrekturwinkel (in Grad) für die Navigation in der 'translate'-Phase.
-        Es wird ein vereinfachtes Modell genutzt, das den Unterschied zwischen dem gewünschten und dem aktuellen
-        Heading (über die Fahrzeug-Steuerachse) ermittelt.
-        """
-        import math
-
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None and "pickup_station" in current_order:
-            pickup_station = current_order["pickup_station"]
-            if pickup_station in self.station_blue_dots:
-                target = self.station_blue_dots[pickup_station].getPos(self.render)
-            else:
-                target = self.blue_dot.getPos(self.render)
-        else:
-            target = self.blue_dot.getPos(self.render)
-
-        current_pos = vehicle.getPos(self.render)
-        # Bestimme einen Offset-Punkt, basierend auf der bereits existierenden pickup_offset
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        # Berechne den gewünschten Heading-Winkel (in Radiant): Richtung von offset_pos zu target
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-
-        # Hole den aktuellen Heading-Wert vom Steuerachsen-Node (pivot)
-        pivot = vehicle.getPythonTag("steering_axis")
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-
-        ideal_correction_rad = desired_heading_rad - current_heading_rad
-        # Winkelbereich anpassen [-pi, pi]
-        while ideal_correction_rad > math.pi:
-            ideal_correction_rad -= 2 * math.pi
-        while ideal_correction_rad < -math.pi:
-            ideal_correction_rad += 2 * math.pi
-
-        return math.degrees(ideal_correction_rad)
-
-    def log_training_sample(self, sensor_data, ideal_angle):
-        """
-        Speichert ein Trainingssample bestehend aus den gesammelten Sensorwerten und dem idealen Korrekturwinkel.
-        """
-        self.training_data.append((sensor_data.copy(), ideal_angle))
-        # Optional: Gib eine Debug-Ausgabe aus, um das Logging zu überwachen.
-        print(
-            f"[LOG] Trainingssample gespeichert: Ideal Correction = {ideal_angle:.2f}°, Sensor Shape = {sensor_data.shape}")
-
-    def apply_safety_rules(self, vehicle, sensor_data, model_delta_angle, ideal_correction):
-        """
-        Kombiniert den vom Modell (model_delta_angle) und den ideal berechneten Korrekturwert (ideal_correction)
-        nur dann mit einem festen Sicherheitswert, wenn die Sensordaten einen kritischen Occupancy-Level anzeigen.
-
-        Falls der Occupancy-Level niedrig ist, wird ausschließlich der ideal vorhandene Korrekturwert verwendet.
-        """
-        import numpy as np
-        # Beispiel: Untersuche die mittlere Zeile des sensor_data-Grids als Indikator für frontale Hindernisse
-        middle_row = sensor_data[sensor_data.shape[0] // 2]
-        occupancy_level = np.sum(middle_row)
-
-        # Definiere einen kritischen Schwellenwert (diesen Wert ggf. anpassen)
-        threshold = 1.0
-
-        if occupancy_level > threshold:
-            print(
-                f"[RULE] Kritischer Occupancy-Level = {occupancy_level:.2f} erkannt. Sicherheitskorrektur wird angewendet.")
-            # Hier legen wir fest, dass in kritischen Situationen der Sicherheitswert stärker gewichtet wird.
-            safety_correction = 15.0  # z. B. 15° als feste Korrektur (Wert anpassen)
-            # Gewichteter Ansatz: Sicherheitskorrektur dominiert, während ein kleiner Anteil des idealen Wertes einfließt.
-            final_angle = 0.7 * safety_correction + 0.3 * ideal_correction
-        else:
-            # Wenn kein kritischer Wert vorliegt, einfach den ideal berechneten Korrekturwert verwenden.
-            final_angle = ideal_correction
-
-        return final_angle
-
-    def collision_avoidance_adjustment(self, current_vehicle, base_speed, safe_distance=3.0):
-        current_pos = current_vehicle.getPos(self.render)
-        adjusted_speed = base_speed
-        # Berechne einen Basisfaktor (z.B. basierend auf Abstand zu anderen Fahrzeugen):
-        for veh in self.garage_vehicles:
-            if veh == current_vehicle:
-                continue
-            other_pos = veh.getPos(self.render)
-            distance = (current_pos - other_pos).length()
-            if distance < safe_distance:
-                factor = (distance / safe_distance) ** 2
-                candidate_speed = base_speed * factor
-                if candidate_speed < adjusted_speed:
-                    adjusted_speed = candidate_speed
-
-        # Hier integrieren wir den RL-Ausdruck:
-        # Nehme als Zustandsvektor bspw. [min_distance_to_others, current_speed]
-        min_distance = min(
-            [(current_pos - v.getPos(self.render)).length() for v in self.garage_vehicles if v != current_vehicle])
-        current_speed = self.current_speed  # oder eine entsprechende Eigenschaft des Fahrzeugs
-        state = [min_distance, current_speed]
-
-        # Angenommen, du hast für jedes Fahrzeug einen eigenen RL-Agenten (oder einen globalen)
-        action = self.rl_agent.select_action(state)
-        # Definiere, wie Aktion in einen zusätzlichen Bremsfaktor übersetzt wird:
-        # Beispiel: Aktion 0: kein zusätzlicher Bremsfaktor, 1: 20% Reduktion, 2: 50% Reduktion
-        action_to_factor = {0: 1.0, 1: 0.8, 2: 0.5}
-        braking_factor = action_to_factor.get(action, 1.0)
-        adjusted_speed *= braking_factor
-
-        return adjusted_speed
-
-    def is_station_occupied(self, station, exclude_vehicle=None, occupancy_threshold=1.0):
-        """
-        Prüft, ob sich bereits ein Fahrzeug an der gegebenen Station (z. B. Pickup‑Station)
-        befindet. Dabei wird als Zielpunkt zumeist der blaue Marker genutzt, der der Station
-        zugeordnet ist. Das Fahrzeug exclude_vehicle (z. B. das aktuell agierende Fahrzeug)
-        wird dabei nicht berücksichtigt.
-        """
-        # Falls ein blauer Marker vorhanden ist, nutze dessen Position als Zielort:
-        if hasattr(self, 'station_blue_dots') and station in self.station_blue_dots:
-            station_pos = self.station_blue_dots[station].getPos(self.render)
-        else:
-            station_pos = station.getPos(self.render)
-        for veh in self.garage_vehicles:
-            if veh == exclude_vehicle:
-                continue
-            if (veh.getPos(self.render) - station_pos).length() < occupancy_threshold:
-                return True
-        return False
-
-    def is_delivery_station_occupied(self, target_pos, exclude_vehicle=None, occupancy_threshold=1.0):
-        """
-        Prüft, ob sich ein Fahrzeug in der Nähe der Abgabestation (target_pos) befindet,
-        welches in einer Lieferphase (z. B. drop, delivery_center oder align_delivery) ist oder noch ein Paket
-        transportiert (package_attached = True). Das Fahrzeug exclude_vehicle (z. B. das aktuell anfahrende Fahrzeug)
-        wird dabei nicht berücksichtigt.
-        """
-        for veh in self.garage_vehicles:
-            if veh == exclude_vehicle:
-                continue
-            # Hole den aktuellen Zustand und ob ein Paket noch angebracht ist.
-            state = veh.getPythonTag("order_state")
-            package_attached = veh.getPythonTag("package_attached")
-            if state in ["drop", "delivery_center", "align_delivery"] or package_attached:
-                if (veh.getPos(self.render) - target_pos).length() < occupancy_threshold:
-                    return True
-        return False
-
-    def check_collisions(self):
-        collision_threshold = 1.0  # z. B. wenn Fahrzeuge näher als 1 Einheit sind
-        collisions = []
-        for i in range(len(self.garage_vehicles)):
-            veh1 = self.garage_vehicles[i]
-            pos1 = veh1.getPos(self.render)
-            for j in range(i + 1, len(self.garage_vehicles)):
-                veh2 = self.garage_vehicles[j]
-                pos2 = veh2.getPos(self.render)
-                if (pos1 - pos2).length() < collision_threshold:
-                    collisions.append((veh1, veh2))
-        return collisions
-
-    def update_rl_on_collisions(self):
-        collisions = self.check_collisions()
-        for veh1, veh2 in collisions:
-            # Für jedes beteiligte Fahrzeug:
-            for veh in (veh1, veh2):
-                # Erstelle einen Zustandsvektor – analog zum, der in collision_avoidance_adjustment verwendet wird.
-                current_pos = veh.getPos(self.render)
-                min_distance = min([(current_pos - v.getPos(self.render)).length()
-                                    for v in self.garage_vehicles if v != veh])
-                current_speed = self.current_speed  # oder fahrzeugspezifisch
-                state = [min_distance, current_speed]
-                # Nehme an, die letzte von deinem Agenten gewählte Aktion ist gespeichert (das könntest du in einem PythonTag ablegen)
-                last_action = veh.getPythonTag("last_braking_action")
-
-                # Definiere den negativen Reward
-                reward = -10
-                # Erfasse den nächsten Zustand (nach Entfernen des Kollisionsereignisses oder nach einer kurzen Verzögerung)
-                next_state = state  # In einem echten Setup wäre hier der nächste gemessene Zustand
-                self.rl_agent.update(state, last_action, reward, next_state)
-                print(f"RL-Update für Fahrzeug {veh.getPythonTag('vehicle_id')}: Kollisionsreward {reward} vergeben.")
-
-import random
-import numpy as np
-
-class RLAgent:
-    def __init__(self, state_bins, action_space, learning_rate=0.1, discount_factor=0.9, epsilon=0.2):
-        """
-        state_bins: Tuple oder Liste, um kontinuierliche Zustände zu diskretisieren (z.B. (max_distance, num_bins))
-        action_space: Liste diskreter Aktionen (z.B. [0, 1, 2] --> 0: keine Bremsung, 1: leicht, 2: stark)
-        """
-        self.state_bins = state_bins
-        self.action_space = action_space
-        self.lr = learning_rate
-        self.gamma = discount_factor
-        self.epsilon = epsilon
-        # Initialisiere Q-Tabelle als Dictionary: key: (discretisierter_state), value: Liste von Q-Werten pro Aktion
-        self.q_table = {}
-
-    def discretize_state(self, state):
-        """
-        Nimmt einen Zustandsvektor (z.B. [distance, speed]) und gibt einen diskreten Zustand zurück.
-        Hier ein Beispiel: Falls state[0] = Abstand und state[1] = Geschwindigkeit.
-        """
-        # Beispiel: Wir nehmen an, dass state_bins = ((max_distance, num_bins), (max_speed, num_bins))
-        discrete_state = []
-        for i, (max_val, bins) in enumerate(self.state_bins):
-            # Begrenze state[i] um max_val:
-            val = min(state[i], max_val)
-            bin_size = max_val / bins
-            discrete_state.append(int(val // bin_size))
-        return tuple(discrete_state)
-
-    def select_action(self, state):
-        discrete_state = self.discretize_state(state)
-        if discrete_state not in self.q_table:
-            self.q_table[discrete_state] = [0.0 for _ in self.action_space]
-        # Epsilon-greedy Auswahl:
-        if random.random() < self.epsilon:
-            return random.choice(self.action_space)
-        else:
-            q_values = self.q_table[discrete_state]
-            return self.action_space[np.argmax(q_values)]
-
-    def update(self, state, action, reward, next_state):
-        s = self.discretize_state(state)
-        s_next = self.discretize_state(next_state)
-        if s not in self.q_table:
-            self.q_table[s] = [0.0 for _ in self.action_space]
-        if s_next not in self.q_table:
-            self.q_table[s_next] = [0.0 for _ in self.action_space]
-        a_index = self.action_space.index(action)
-        # Q-Learning Update-Regel:
-        best_next = max(self.q_table[s_next])
-        self.q_table[s][a_index] += self.lr * (reward + self.gamma * best_next - self.q_table[s][a_index])
-
-
-if __name__ == "__main__":
-    # Wichtig: setze auf Windows die Startmethode auf "spawn"
-    multiprocessing.set_start_method('spawn')
-
-    # Erzeuge eine Queue, auch wenn sie später eventuell neu erstellt wird, wenn "G" gedrückt wird.
-    graph_q = Queue()
-    app = LagerSimulation(graph_q)
-    app.run()
-
-    # Beim Schließen der Simulation den Graphprozess ggf. beenden
-    if app.graph_process is not None:
-        app.graph_process.terminate()
-        app.graph_process.join()
\ No newline at end of file
Index: KI/KI17.py
===================================================================
diff --git a/KI/KI17.py b/KI/KI17.py
deleted file mode 100644
--- a/KI/KI17.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,388 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode
-)
-
-# Wir nutzen globalClock für dt
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit bleibt konstant: 1.5 m/s.
-        self.base_speed = 1.5
-        # Der Multiplikator (speed_factor) steuert den Zeitskalierungsfaktor.
-        # Startwert 1.0 => normale Simulation.
-        self.speed_factor = 1.0
-
-        # Eigener Simulationszeitticker (in simulierten Sekunden)
-        self.sim_clock = 0.0
-        # Zähler der abgegebenen Pakete
-        self.delivered_packages = 0
-
-        # Zeitpunkt des Simulationsstart (reale Zeit)
-        self.sim_start_real = globalClock.getFrameTime()
-
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeuge initialisieren – zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}  # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}  # Fahrzeug -> aktuell reservierte Abgabestation
-
-        # Fahrzeug 1: startet sofort
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-
-        # Fahrzeug 2: startet 8 simulierte Sekunden später
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)  # y-Offset von 2 Einheiten
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-
-        # Globaler Pool für Pickup-Pakete und Zeitstempel (in simulierten Sekunden)
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider zur Anpassung des Multiplikators (Zeitskalierung)
-        # Wertebereich: 0.1 bis 10, Startwert: 1.0
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Info-Anzeige rechts: Laufzeit der Simulation, Summe abgegebener Pakete,
-        # Pakete pro Minute und Kennzahl des am längsten wartenden Pakets
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tasks:
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_vehicle2_start, "CheckVehicle2StartTask")
-
-        # Fahrzeug 1 startet den Liefervorgang sofort
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-        # Fahrzeug 2 startet, sobald 8 simulierte Sekunden erreicht sind (über Task)
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        # Erhöhe die interne Simulationszeit um dt * speed_factor.
-        # Höherer Faktor => Simulation läuft schneller (mehr simulierte Sekunden pro realer Sekunde)
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        max_wait_time = 0
-        max_wait_package = None
-
-        # Berechne die maximale Wartezeit aller Pakete an den Annahmestationen
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > max_wait_time:
-                max_wait_time = elapsed
-                max_wait_package = package
-
-        if max_wait_package:
-            max_wait_text = f"Paket mit höchster Wartezeit: {max_wait_time:.1f}s"
-        else:
-            max_wait_text = "Kein Paket an Annahmestation"
-
-        # Berechne die abgegebenen Pakete pro Minute (basierend auf der simulierten Zeit)
-        if self.sim_clock > 0:
-            delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0)
-        else:
-            delivered_per_minute = 0
-
-        self.info_label['text'] = (f"Laufzeit: {self.sim_clock:.1f} s\n"
-                                   f"Abgegebene Pakete: {self.delivered_packages}\n"
-                                   f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-                                   f"{max_wait_text}")
-        return Task.cont
-
-    def sim_time(self, t):
-        """
-        Skalierung eines Basiszeitwerts t (in Sekunden) anhand des Multiplikators.
-        Wir verwenden hier die Formel: t / speed_factor.
-        Dadurch wird bei einem kleineren Faktor (z. B. 0.1) t größer (Simulation wird verlangsamt),
-        und bei einem höheren Faktor (z. B. 10) t kleiner (Simulation beschleunigt).
-        """
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def check_vehicle2_start(self, task):
-        """
-        Überprüft kontinuierlich, ob 8 simulierte Sekunden vergangen sind.
-        Sobald self.sim_clock >= 8, wird Fahrzeug 2 gestartet.
-        """
-        if self.sim_clock >= 8.0 and not hasattr(self, 'vehicle2_started'):
-            self.vehicle2_started = True
-            self.start_delivery_cycle(self.vehicles[1], self.vehicles[1].getPos())
-            return Task.done
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        # Basiswartezeit von 1 simulierten Sekunde:
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            direction = target - current_pos
-            distance = direction.length()
-            # Effektiver Schritt = (base_speed * speed_factor) * dt.
-            # Höherer Multiplikator => Fahrzeuge bewegen sich in realer Zeit schneller.
-            step = (self.base_speed * self.speed_factor) * dt
-            if distance <= step:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-            else:
-                vehicle.setPos(current_pos + direction.normalized() * step)
-                return Task.cont
-
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        pickup_pos = pickup_station.getPos()
-
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.occupied_pickups.remove(pickup_station)
-
-            def wait_for_dropoff(task):
-                if any(ds not in self.occupied_dropoffs for ds in self.abgabe_stationen):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_dropoff, f"WaitDropoff_{id(vehicle)}")
-            return
-
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_pos = dropoff_station.getPos()
-
-        self.move_vehicle_to(vehicle, pickup_pos, lambda: self.after_pickup(vehicle, pickup_station, dropoff_pos))
-
-    def after_pickup(self, vehicle, pickup_station, dropoff_pos):
-        self.pickup_package(vehicle, pickup_station)
-        self.move_vehicle_to(vehicle, dropoff_pos, lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        self.drop_cargo(vehicle)
-        start_wait = self.sim_clock
-
-        def wait_task(task):
-            if self.sim_clock - start_wait >= self.sim_time(1):
-                self.finish_cycle(vehicle)
-                return Task.done
-            return Task.cont
-
-        self.taskMgr.add(wait_task, f"WaitAfterDrop_{id(vehicle)}")
-
-    def finish_cycle(self, vehicle):
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        if dropoff_station in self.occupied_dropoffs:
-            self.occupied_dropoffs.remove(dropoff_station)
-            del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
Index: KI/KI18.py
===================================================================
diff --git a/KI/KI18.py b/KI/KI18.py
deleted file mode 100644
--- a/KI/KI18.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,395 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode
-)
-
-# Wir nutzen globalClock für dt
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit bleibt konstant: 1.5 m/s.
-        self.base_speed = 1.5
-        # Der Multiplikator (speed_factor) steuert den Zeitskalierungsfaktor.
-        # Startwert 1.0 => normale Simulation.
-        self.speed_factor = 1.0
-
-        # Eigener Simulationszeitticker (in simulierten Sekunden)
-        self.sim_clock = 0.0
-        # Zähler der abgegebenen Pakete
-        self.delivered_packages = 0
-
-        # Zeitpunkt des Simulationsstart (reale Zeit)
-        self.sim_start_real = globalClock.getFrameTime()
-
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeuge initialisieren – zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}  # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}  # Fahrzeug -> aktuell reservierte Abgabestation
-
-        # Fahrzeug 1: startet sofort
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-
-        # Fahrzeug 2: startet 8 simulierte Sekunden später
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)  # y-Offset von 2 Einheiten
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-
-        # Globaler Pool für Pickup-Pakete und Zeitstempel (in simulierten Sekunden)
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider zur Anpassung des Multiplikators (Zeitskalierung)
-        # Wertebereich: 0.1 bis 10, Startwert: 1.0
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Info-Anzeige rechts: Laufzeit (in h, m, s), Summe abgegebener Pakete,
-        # Pakete pro Minute und Kennzahl des am längsten wartenden Pakets
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tasks:
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_vehicle2_start, "CheckVehicle2StartTask")
-
-        # Fahrzeug 1 startet den Liefervorgang sofort
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-        # Fahrzeug 2 startet, sobald 8 simulierte Sekunden erreicht sind (über Task)
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        # Erhöhe die interne Simulationszeit um dt * speed_factor.
-        # Höherer Faktor => Simulation läuft schneller (mehr simulierte Sekunden pro realer Sekunde)
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        max_wait_time = 0
-        max_wait_package = None
-
-        # Berechne die maximale Wartezeit aller Pakete an den Annahmestationen
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > max_wait_time:
-                max_wait_time = elapsed
-                max_wait_package = package
-
-        if max_wait_package:
-            max_wait_text = f"Paket mit höchster Wartezeit: {max_wait_time:.1f}s"
-        else:
-            max_wait_text = "Kein Paket an Annahmestation"
-
-        # Gliedere die simulierte Laufzeit in Stunden, Minuten und Sekunden
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-
-        # Berechne die abgegebenen Pakete pro Minute (basierend auf der simulierten Zeit)
-        if self.sim_clock > 0:
-            delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0)
-        else:
-            delivered_per_minute = 0
-
-        self.info_label['text'] = (f"Laufzeit: {formatted_time}\n"
-                                   f"Abgegebene Pakete: {self.delivered_packages}\n"
-                                   f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-                                   f"{max_wait_text}")
-        return Task.cont
-
-    def sim_time(self, t):
-        """
-        Skalierung eines Basiszeitwerts t (in Sekunden) anhand des Multiplikators.
-        Wir verwenden hier die Formel: t / speed_factor.
-        Dadurch wird bei einem kleineren Faktor (z. B. 0.1) t größer (Simulation wird verlangsamt),
-        und bei einem höheren Faktor (z. B. 10) t kleiner (Simulation beschleunigt).
-        """
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def check_vehicle2_start(self, task):
-        """
-        Überprüft kontinuierlich, ob 8 simulierte Sekunden vergangen sind.
-        Sobald self.sim_clock >= 8, wird Fahrzeug 2 gestartet.
-        """
-        if self.sim_clock >= 8.0 and not hasattr(self, 'vehicle2_started'):
-            self.vehicle2_started = True
-            self.start_delivery_cycle(self.vehicles[1], self.vehicles[1].getPos())
-            return Task.done
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        # Basiswartezeit von 1 simulierten Sekunde:
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            direction = target - current_pos
-            distance = direction.length()
-            # Effektiver Schritt = (base_speed * speed_factor) * dt.
-            # Höherer Multiplikator => Fahrzeuge bewegen sich in realer Zeit schneller.
-            step = (self.base_speed * self.speed_factor) * dt
-            if distance <= step:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-            else:
-                vehicle.setPos(current_pos + direction.normalized() * step)
-                return Task.cont
-
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        pickup_pos = pickup_station.getPos()
-
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.occupied_pickups.remove(pickup_station)
-
-            def wait_for_dropoff(task):
-                if any(ds not in self.occupied_dropoffs for ds in self.abgabe_stationen):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_dropoff, f"WaitDropoff_{id(vehicle)}")
-            return
-
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_pos = dropoff_station.getPos()
-
-        self.move_vehicle_to(vehicle, pickup_pos, lambda: self.after_pickup(vehicle, pickup_station, dropoff_pos))
-
-    def after_pickup(self, vehicle, pickup_station, dropoff_pos):
-        self.pickup_package(vehicle, pickup_station)
-        self.move_vehicle_to(vehicle, dropoff_pos, lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        self.drop_cargo(vehicle)
-        start_wait = self.sim_clock
-
-        def wait_task(task):
-            if self.sim_clock - start_wait >= self.sim_time(1):
-                self.finish_cycle(vehicle)
-                return Task.done
-            return Task.cont
-
-        self.taskMgr.add(wait_task, f"WaitAfterDrop_{id(vehicle)}")
-
-    def finish_cycle(self, vehicle):
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        if dropoff_station in self.occupied_dropoffs:
-            self.occupied_dropoffs.remove(dropoff_station)
-            del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
Index: Test/ki41test.py
===================================================================
diff --git a/Test/ki41test.py b/Test/ki41test.py
deleted file mode 100644
--- a/Test/ki41test.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,451 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Matplotlib zum Plotten importieren
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs,
-    CardMaker, AmbientLight, DirectionalLight
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-from panda3d.ai import AIBehaviors   # Importiere AI-Funktionalitäten
-
-from panda3d.core import loadPrcFileData
-# Erzwingt ein Fenster mit einer definierten Größe und Titel
-loadPrcFileData("", "window-type onscreen")
-loadPrcFileData("", "win-size 800 600")
-loadPrcFileData("", "window-title Lager Simulation")
-
-
-# globalClock ist nützlich zur Berechnung von dt
-globalClock = ClockObject.getGlobalClock()
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basis-Parameter
-        self.base_speed = 1.5  # m/s
-        self.speed_factor = 1.0
-        self.max_steering_rate = 90  # Grad pro Sekunde
-        self.acceleration = 2.5  # m/s²
-        self.braking_deceleration = -2.5  # m/s² (negativ)
-
-        # Simulationsvariablen und Statistiken
-        self.sim_clock = 0.0
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        self.sim_start_real = globalClock.getFrameTime()
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        # Szene aufbauen
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün)
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Zeichne Ausrichtungs-Punkte an den Stationen
-        for station in self.annahme_stationen:
-            station_pos = station.getPos()
-            ls_pickup = LineSegs()
-            ls_pickup.setThickness(3.0)
-            ls_pickup.setColor(LColor(1, 1, 1, 1))
-            ls_pickup.moveTo(station_pos)
-            ls_pickup.drawTo(station_pos + Vec3(2, 0, 0))
-            self.render.attachNewNode(ls_pickup.create())
-        for station in self.annahme_stationen:
-            station_pos = station.getPos()
-            ls_pickup_offset = LineSegs()
-            ls_pickup_offset.setThickness(3.0)
-            ls_pickup_offset.setColor(LColor(1, 1, 1, 1))
-            ls_pickup_offset.moveTo(station_pos + Vec3(0, 1, 0))
-            ls_pickup_offset.drawTo(station_pos + Vec3(2, 1, 0))
-            self.render.attachNewNode(ls_pickup_offset.create())
-        for station in self.annahme_stationen:
-            station_pos = station.getPos()
-            ls_align = LineSegs()
-            ls_align.setThickness(3.0)
-            ls_align.setColor(LColor(1, 1, 0, 1))
-            ls_align.moveTo(station_pos)
-            ls_align.drawTo(station_pos + Vec3(0, 1, 0.1))
-            self.render.attachNewNode(ls_align.create())
-
-        for station in self.abgabe_stationen:
-            station_pos = station.getPos()
-            ls_dropoff = LineSegs()
-            ls_dropoff.setThickness(3.0)
-            ls_dropoff.setColor(LColor(1, 1, 1, 1))
-            ls_dropoff.moveTo(station_pos)
-            ls_dropoff.drawTo(station_pos + Vec3(-2, 0, 0))
-            self.render.attachNewNode(ls_dropoff.create())
-        for station in self.abgabe_stationen:
-            station_pos = station.getPos()
-            ls_dropoff_offset = LineSegs()
-            ls_dropoff_offset.setThickness(3.0)
-            ls_dropoff_offset.setColor(LColor(1, 1, 1, 1))
-            ls_dropoff_offset.moveTo(station_pos + Vec3(0, 1, 0))
-            ls_dropoff_offset.drawTo(station_pos + Vec3(-2, 1, 0))
-            self.render.attachNewNode(ls_dropoff_offset.create())
-        for station in self.abgabe_stationen:
-            station_pos = station.getPos()
-            ls_align_dropoff = LineSegs()
-            ls_align_dropoff.setThickness(3.0)
-            ls_align_dropoff.setColor(LColor(1, 1, 0, 1))
-            ls_align_dropoff.moveTo(station_pos)
-            ls_align_dropoff.drawTo(station_pos + Vec3(0, 1, 0.1))
-            self.render.attachNewNode(ls_align_dropoff.create())
-
-        # Anfahrstationen für Fahrzeuge
-        self.anfahrstationen = []
-        num_departure = 2
-        spacing_departure = 4.0
-        start_x = -spacing_departure * (num_departure - 1) / 2
-        for i in range(num_departure):
-            pos = Vec3(start_x + i * spacing_departure, 15, 0)
-            station = self.erzeuge_gitterbox(pos.getX(), pos.getY(), pos.getZ(), LColor(0.8, 0.8, 0, 1))
-            self.anfahrstationen.append(station)
-
-        # Fahrzeuge erstellen und mit AI ausstatten
-        self.vehicles = []
-        self.cargos = {}
-        self.current_dropoffs = {}
-        for i, start_station in enumerate(self.anfahrstationen):
-            vehicle = self.loader.loadModel("models/box")
-            vehicle.setScale(2, 1, 0.5)
-            if i % 2 == 0:
-                vehicle.setColor(LColor(0, 0, 1, 1))
-            else:
-                vehicle.setColor(LColor(0, 0, 0.8, 1))
-            vehicle.setPos(start_station.getPos())
-            vehicle.reparentTo(self.render)
-            vehicle.setPythonTag("current_speed", 0.0)
-            vehicle.setH(0)
-            vehicle.setPythonTag("phase", "pickup")
-            self.add_center_marker(vehicle)
-            self.add_front_marker(vehicle)
-            self.add_y_marker(vehicle)
-            self.add_alignment_marker(vehicle)
-            self.add_offset_circle(vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-            self.setup_ai_for_vehicle(vehicle)  # AI-Behaviors initialisieren
-            self.vehicles.append(vehicle)
-
-        # Restliche Logik (Pickup/Dropoff etc.)
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider, Info-Anzeige und Graphen
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        self.graph_data = []
-        self.taskMgr.doMethodLater(1, self.record_graph_data, "RecordGraphDataTask")
-        self.graph_opened = False
-        self.accept("g", self.open_graph)
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_lidar_status, "UpdateLidarStatusTask")
-
-        # Starte den Liefervorgang (Pickup-Phase) gestaffelt
-        for i, vehicle in enumerate(self.vehicles):
-            self.taskMgr.doMethodLater(i * 0.5,
-                                       lambda task, v=vehicle: self.start_delivery_cycle(v, v.getPos()),
-                                       f"StartDeliveryCycleTask_{i}")
-
-    def setup_ai_for_vehicle(self, vehicle):
-        """
-        Initialisiert AIBehaviors für ein Fahrzeug.
-        Die Parameter (maxForce, maxSpeed, maxAvoidForce) können je nach Bedarf angepasst werden.
-        """
-        ai_behaviors = AIBehaviors(vehicle, 10.0, self.base_speed, 1.0)
-        vehicle.setPythonTag("ai_behaviors", ai_behaviors)
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange",
-                                      label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def record_graph_data(self, task):
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0
-        self.graph_data.append((self.sim_clock, delivered_per_minute, avg_dwell_time))
-        return Task.again
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(0, 1, 0, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def add_front_marker(self, vehicle, scale=0.15):
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 0, 0, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(1.0, 0, 0.01)
-
-    def add_y_marker(self, vehicle, scale=0.15):
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(0, 1, 0, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 1.0, 0.01)
-
-    def add_alignment_marker(self, vehicle, scale=0.15):
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 0, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 1, 0.1)
-
-    def add_offset_circle(self, vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5, num_segments=32):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        for i in range(num_segments + 1):
-            angle = 2 * math.pi * i / num_segments
-            x = circle_radius * math.cos(angle)
-            y = circle_radius * math.sin(angle)
-            if i == 0:
-                ls.moveTo(x, y, 0)
-            else:
-                ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        circle_np = vehicle.attachNewNode(circle_geom)
-        circle_np.setPos(offset)
-        vehicle.setPythonTag("lidar_circle", circle_np)
-
-    def draw_coordinate_axes(self, axis_length=5):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(1, 0, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        ls.setColor(0, 1, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        ls.setColor(0, 0, 1, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), (1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), (0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), (0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def update_lidar_status(self, task):
-        sensor_threshold = 3.0
-        for vehicle in self.vehicles:
-            pos = vehicle.getPos(self.render)
-            total_avoidance = Vec3(0, 0, 0)
-            multiplier = 1.0
-            phase = vehicle.getPythonTag("phase") if vehicle.hasPythonTag("phase") else "pickup"
-            for other in self.vehicles:
-                if other is vehicle:
-                    continue
-                pos_other = other.getPos(self.render)
-                diff = pos - pos_other
-                d = diff.length()
-                if d < sensor_threshold:
-                    other_phase = other.getPythonTag("phase") if other.hasPythonTag("phase") else "pickup"
-                    if phase == "pickup" and other_phase == "dropoff":
-                        candidate = 0.1
-                        avoidance_weight = 2.0
-                    elif phase == "dropoff" and other_phase == "dropoff":
-                        my_dropoff = self.current_dropoffs.get(vehicle)
-                        other_dropoff = self.current_dropoffs.get(other)
-                        if my_dropoff and other_dropoff:
-                            my_distance = (pos - my_dropoff.getPos()).length()
-                            other_distance = (pos_other - other_dropoff.getPos()).length()
-                            if my_distance > other_distance:
-                                candidate = 0.1
-                                avoidance_weight = 2.0
-                            else:
-                                candidate = 1.0
-                                avoidance_weight = 1.0
-                        else:
-                            candidate = 1.0
-                            avoidance_weight = 1.0
-                    else:
-                        candidate = 1.0
-                        avoidance_weight = 1.0
-                    multiplier = min(multiplier, candidate)
-                    if d > 0:
-                        total_avoidance += diff.normalized() * (sensor_threshold - d) * avoidance_weight
-            static_obstacles = self.annahme_stationen + self.abgabe_stationen + self.anfahrstationen
-            for obst in static_obstacles:
-                pos_obst = obst.getPos(self.render)
-                diff = pos - pos_obst
-                d = diff.length()
-                if d < sensor_threshold:
-                    candidate = 0.1
-                    avoidance_weight = 2.0
-                    multiplier = min(multiplier, candidate)
-                    if d > 0:
-                        total_avoidance += diff.normalized() * (sensor_threshold - d) * avoidance_weight
-            vehicle.setPythonTag("speed_multiplier", multiplier)
-            vehicle.setPythonTag("avoidance", total_avoidance)
-            lidar_circle = vehicle.getPythonTag("lidar_circle")
-            if lidar_circle:
-                if multiplier < 1.0 or total_avoidance.length() > 0.001:
-                    lidar_circle.setColor(LColor(1, 0, 0, 1))
-                else:
-                    lidar_circle.setColor(LColor(0, 1, 0, 1))
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-        current_wait_text = (
-            f"Liegedauer (aktuell): {current_max_wait_time:.1f}s"
-            if current_max_wait_time > 0 else "Kein Paket an Annahmestation"
-        )
-        maximal_wait_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted_time}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-            f"{current_wait_text}\n"
-            f"{maximal_wait_text}\n"
-            f"Liegedauer (Durchschnitt): {avg_dwell_time:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label
\ No newline at end of file
Index: FFZ/FFZ18.py
===================================================================
diff --git a/FFZ/FFZ18.py b/FFZ/FFZ18.py
deleted file mode 100644
--- a/FFZ/FFZ18.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,430 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    LineSegs,
-    Vec3,
-    NodePath
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import math
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5  # Standardgeschwindigkeit in m/s
-
-        # Kameraeinstellungen (Fahrtrichtung: entlang der Y-Achse)
-        self.cam.setPos(0, -30, 10)
-        self.cam.lookAt(0, 0, 0)
-
-        # Licht und Raster erstellen
-        self.setup_light()
-        self.create_grid(center_extent=10, cell_size=0.1)
-
-        # Fahrzeug erstellen (Chassis, Fork, Mast, etc.)
-        self.vehicle = self.create_vehicle()
-
-        # Regler für die Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Hinweis: Der Regler für die Gabelhöhe wurde bereits entfernt
-
-        # Laufzeitanzeige
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom via Mausrad
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Update-Tasks
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_vehicle, "UpdateVehicleTask")
-        # Optional: Der Task für die Fork-Animation (update_cable) kann hinzugefügt werden, falls gewünscht.
-        # self.taskMgr.add(self.update_cable, "UpdateCableTask")
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        # Ohne Hindernisse beträgt die Zielgeschwindigkeit konstant 1.5 m/s
-        target_speed = 1.5
-        acc_rate = 2.0  # Beschleunigungs-/Verzögerungsrate in m/s²
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    def create_grid(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            x += cell_size
-
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        grid_np = self.render.attachNewNode(node)
-        grid_np.setColor(0.7, 0.7, 0.7, 1)
-        return grid_np
-
-    def setup_light(self):
-        ambient_light = AmbientLight("ambient_light")
-        ambient_light.setColor((0.5, 0.5, 0.5, 1))
-        ambient_np = self.render.attachNewNode(ambient_light)
-        self.render.setLight(ambient_np)
-
-        directional_light = DirectionalLight("directional_light")
-        directional_light.setColor((1, 1, 1, 1))
-        directional_np = self.render.attachNewNode(directional_light)
-        directional_np.setPos(10, -10, 10)
-        self.render.setLight(directional_np)
-
-    def create_vehicle(self):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Fahrmodul (Chassis): 1 x 0.5 x 1.2 in Rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        # Schwarze Kanten für das Chassis
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # Gabelmodul (Fork): Zwei Zähne (je 0.2 x 1.2 x 0.1)
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-        self.fork_node = fork_node
-
-        # Mast: Rahmen aus vier Balken
-        mast_node = vehicle_node.attachNewNode("mast")
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-
-        # Diagonalen auf der oberen Fläche des Mastes
-        self.add_diagonals_to_mast(mast_node)
-        # Schnittpunkt der Diagonalen in lokalen Mast-Koordinaten
-        intersection = Vec3(0.5, 0.05, 1.0)
-
-        # Gelber Zylinder: Durchmesser 0.1, Höhe 0.1, Farbe Gelb (1,1,0,1)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        # Lidar-Kreis: Mittelpunkt soll 1 m in negativer Z-Richtung liegen (also Z = -1),
-        # Farbe Grün, Radius 2
-        lidar_center = Vec3(intersection.x, intersection.y, -1)
-        self.add_lidar_circle(mast_node, lidar_center, 2)
-
-        # Setze den Fahrzeugknoten so, dass seine X- und Y-Koordinaten dem Schnittpunkt der Diagonalen (intersection) entsprechen
-        # und in Z-Richtung 0 liegt (Fahrzeug sitzt auf der Ebene)
-        vehicle_node.setPos(intersection.x, intersection.y, 0)
-
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)  # Orange
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)  # Grün
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        # Top center
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        # Top circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        # Bottom center
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        # Bottom circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        # Top fan
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        # Bottom fan
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        # Side faces
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        # Unterseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        # Oberseite
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        # Vorderseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        # Rückseite
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        # Linke Seite
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        # Rechte Seite
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base+1, base+2)
-            tris.closePrimitive()
-            tris.addVertices(base, base+2, base+3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        # Unterkante
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        # Oberkante
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        # Vertikale Kanten
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: Grundmodell Erweitert Split Angepasst/GESA1.py
===================================================================
diff --git a/Grundmodell Erweitert Split Angepasst/GESA1.py b/Grundmodell Erweitert Split Angepasst/GESA1.py
deleted file mode 100644
--- a/Grundmodell Erweitert Split Angepasst/GESA1.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,1725 +0,0 @@
-# Standardbibliothek
-import random
-import math
-import time
-import ctypes
-import multiprocessing
-from multiprocessing import Queue, Process
-from functools import partial
-import tkinter as tk
-from tkinter import ttk
-
-# Drittanbieter
-import matplotlib
-import matplotlib.pyplot as plt
-from PyQt5 import QtWidgets, QtCore
-import pyqtgraph as pg
-
-# Panda3D und Direct (Engine-spezifische Importe)
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.task.TaskManagerGlobal import taskMgr
-from direct.gui.DirectGui import DirectButton, DirectSlider, DirectLabel
-
-from environment_visualization import EnvironmentVisualizer
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self, graph_queue=None):
-        # Basisinitialisierung und Simulationsvariablen
-        super().__init__()
-        self.paused = False
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5
-        self.state_timer = 0.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-        self.total_delivery_time = 0.0
-        self.total_delivery_count = 0
-        self.max_overall_delivery_time = 0.0
-
-        # Paket- und Auftragsverwaltung
-        self.pickup_packages = {}  # {Station: (Paket, Spawn-Zeit, Timer-Node)}
-        self.last_removed = {}  # Letzte Entfernungszeit pro Station
-        self.cargos = {}  # Fahrzeug -> transportiertes Paket
-        self.occupied_pickups = set()  # Bereits belegte Annahmestationen
-        self.graph_data = []  # (Sim-Zeit, Pakete/Minute, durchschnittliche Liegedauer, Lieferzeit)
-        self.graph_opened = False# Zum Beispiel: 0.5 Einheiten in X‑Richtung (vorne) und 0 in Y, 0 in Z.
-        self.pickup_offset = Vec3(0.5, -0.5, 0)
-
-
-        self.orders = {}
-        self.orders_queue = []
-        self.next_order_id = 1
-
-        # Fenster und UI für Auftragsübersicht
-        self.order_win = None
-        self.order_tree = None
-
-        # Graph-Prozess (für interaktive Graphen via PyQt)
-        self.graph_process = None
-        self.graph_queue = None
-
-        # Tkinter-Grundfenster: Es wird im Hintergrund ausgeführt.
-        self.tk_root = tk.Tk()
-        self.tk_root.withdraw()
-
-        self.env_viz = EnvironmentVisualizer(self.render, self.loader)
-
-        # Rufe die Methoden des Visualizers auf, um die Umgebung zu erstellen.
-        self.env_viz.draw_origin()
-        self.env_viz.erzeuge_licht()
-        self.env_viz.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.env_viz.create_wall()
-        self.env_viz.create_annahme_stations()
-        self.env_viz.create_abgabe_stations()
-        self.env_viz.create_garagen_stations()
-
-        # Um in anderen Methoden (z. B. für Paket- oder Auftrags-Handling) auf die Stationen
-        # und deren Marker zugreifen zu können, übergeben wir die entsprechenden Listen.
-        self.annahme_stations = self.env_viz.annahme_stations
-        self.station_blue_dots = self.env_viz.station_blue_dots
-        self.abgabe_stations = self.env_viz.abgabe_stations
-        self.abgabe_blue_dots = self.env_viz.abgabe_blue_dots
-        self.garagen_stations = self.env_viz.garagen_stations
-        self.garagen_parking_points = self.env_viz.garagen_parking_points
-
-        # Verbindungslinien
-        self.env_viz.connect_annahme_abgabe_blue_dots(color=LColor(1, 1, 1, 1), thickness=2.0)
-
-        self.env_viz.connect_garagen_blue_dots(line_color=LColor(1, 1, 1, 1), thickness=2.0,
-                                               text_color=LColor(0, 0, 1, 1))
-        self.env_viz.connect_annahme_stations(color=LColor(1, 1, 1, 1), thickness=2.0)
-        self.env_viz.connect_abgabe_stations(color=LColor(1, 1, 1, 1), thickness=2.0)
-
-        # Erzeuge den fixierten blauen Punkt (wird nur einmal erzeugt)
-        self.fixed_blue_dot = self.env_viz.create_fixed_blue_dot()
-        # Erstelle die Verbindungslinie, die den blauen Marker der 10. Abgabestation mit dem fixierten Punkt verbindet
-        self.fixed_connection_line = self.env_viz.create_fixed_connection_line()
-        # Erzeuge die Verbindungslinie von dem fixierten Punkt zur 5. Garage.
-        self.garage5_connection_line = self.env_viz.create_garage5_connection_line()
-
-        self.first_garage_to_10_annahme_connection = self.env_viz.create_connection_line_first_garage_to_10_annahme()
-
-        self.yellow_station_points = self.env_viz.create_yellow_station_points(offset=3.0, scale=0.1)
-        self.yellow_abgabe_points = self.env_viz.create_yellow_abgabe_points(offset=3.0, scale=0.1)
-        self.yellow_garage_points = self.env_viz.create_yellow_garage_points(offset=3.0, scale=0.1)
-
-        # --- Aufbau der Umgebung ---
-        # Ursprung und Kamera
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-
-        # Für jede Annahmestation ein Paket spawnen
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # Fahrzeuge in den Garagen erstellen (insgesamt 5 Fahrzeuge)
-        self.create_garage_vehicles()  # Fahrzeuge werden hier erzeugt – sorge dafür, dass self.garage_vehicles gesetzt wird.
-
-        # Zusätzliche Testvariablen
-        self.first_vehicle_order_state = "idle"
-        self.attached_package = None
-        self.current_order = None
-
-        # --- UI-Elemente für Simulationssteuerung ---
-        # Slider für Simulationsgeschwindigkeit
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        self.paused = False
-        # Pause-Knopf neben dem Slider platzieren – z.B. rechts davon.
-        self.pause_button = DirectButton(
-            text="Pause",
-            command=self.toggle_pause,
-            pos=(-0.5, 0, -0.85),  # Leicht links vom Slider
-            scale=0.07
-        )
-
-        # --- Tastenzuordnungen ---
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-        # Taste "c" öffnet das Fahrzeug-Kontrollfenster
-        self.accept("c", self.show_vehicle_control)
-
-
-        # --- Tasks (TaskMgr) hinzufügen ---
-        self.taskMgr.add(self._tk_update, "tkUpdateTask")
-        self.taskMgr.add(self.update_delivery_timers, "UpdateDeliveryTimersTask")
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClock")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_graph_data, "UpdateGraphDataTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-
-    # ---------------1. Initialisierung & Simulationssteuerung---------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        self.sim_clock += dt
-        return Task.cont
-
-    def toggle_pause(self):
-        if not self.paused:
-            # Speichern des aktuellen speed_factor, damit wir ihn beim Resume wiederherstellen können
-            self.previous_speed_factor = self.speed_factor
-            self.speed_factor = 0  # Simulation einfrieren: alle dt-basierte Updates ergeben 0
-            self.pause_button['text'] = "Weiter"
-            self.paused = True
-            print("Gesamte Simulation angehalten")
-        else:
-            # Wiederaufnahme der Simulation: speed_factor auf den vorherigen Wert zurücksetzen
-            self.speed_factor = self.previous_speed_factor if hasattr(self, 'previous_speed_factor') else 1.0
-            self.pause_button['text'] = "Pause"
-            self.paused = False
-            print("Simulation läuft wieder")
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        # dt jetzt skaliert mit der Simulationsgeschwindigkeit
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-    # ---------------2. Graphik & UI (GUI-/Tk-/Matplotlib-Funktionen)---------------
-    def open_graph(self):
-        # Starte den Graphprozess per Taste G (nur, wenn er noch nicht läuft)
-        if self.graph_process is None or not self.graph_process.is_alive():
-            from multiprocessing import Queue, Process
-            self.graph_queue = Queue()
-
-            # Sende alle bisher gesammelten Daten in die Queue:
-            for data in self.graph_data:
-                try:
-                    self.graph_queue.put(data, block=False)
-                except Exception:
-                    pass
-
-            from graph_pyqt import graph_process_pyqt
-            self.graph_process = Process(target=graph_process_pyqt, args=(self.graph_queue,))
-            self.graph_process.start()
-            print("Graphprozess gestartet.")
-        else:
-            print("Graphprozess läuft bereits.")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2, self.ax3) = plt.subplots(3, 1, figsize=(8, 9))
-
-        # Erster Plot: Pakete pro Minute
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-
-        # Zweiter Plot: Durchschnittliche Liegedauer
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-
-        # Dritter Plot: Durchschnittliche Lieferzeit
-        self.line3, = self.ax3.plot([], [], marker="o", color="green", label="Durchschnittliche Lieferzeit (s)")
-        self.ax3.set_xlabel("Simulationszeit (s)")
-        self.ax3.set_ylabel("Lieferzeit (s)")
-        self.ax3.set_title("Durchschnittliche Lieferzeit")
-        self.ax3.legend()
-        self.ax3.grid(True)
-
-        plt.show(block=False)
-        # Starte im Tkinter-Hauptloop eine periodische Aktualisierung:
-        self.tk_root.after(500, self.tk_graph_update)  # alle 500ms
-
-    def tk_graph_update(self):
-        # GIL sichern: Gibt einen Statuswert zurück, der später wieder freigegeben wird.
-        gil_state = ctypes.pythonapi.PyGILState_Ensure()
-        try:
-            times = [data[0] for data in self.graph_data]
-            rates = [data[1] for data in self.graph_data]
-            dwell = [data[2] for data in self.graph_data]
-            delivery = [data[3] for data in self.graph_data]
-
-            self.line1.set_data(times, rates)
-            self.ax1.relim()
-            self.ax1.autoscale_view()
-
-            self.line2.set_data(times, dwell)
-            self.ax2.relim()
-            self.ax2.autoscale_view()
-
-            self.line3.set_data(times, delivery)
-            self.ax3.relim()
-            self.ax3.autoscale_view()
-
-            self.fig.canvas.draw_idle()
-            self.fig.canvas.flush_events()
-        finally:
-            ctypes.pythonapi.PyGILState_Release(gil_state)
-
-        # Nächsten Aufruf in 500ms einplanen
-        self.tk_root.after(500, self.tk_graph_update)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-
-        # Bestimme die maximale Liegedauer aktueller Pakete an den Annahmestationen
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-
-        # Berechne aktuelle Lieferzeiten für Fahrzeuge, die ein Paket tragen
-        current_delivery_time = 0.0
-        for veh in self.garage_vehicles:
-            if veh.getPythonTag("package_attached"):
-                ds = veh.getPythonTag("delivery_start_time")
-                if ds:
-                    elapsed_delivery = self.sim_clock - ds
-                    current_delivery_time = max(current_delivery_time, elapsed_delivery)
-        avg_delivery_time = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s\n"
-            f"Lieferzeit (aktuell): {current_delivery_time:.1f}s\n"
-            f"Lieferzeit (maximal): {self.max_overall_delivery_time:.1f}s\n"
-            f"Durchschn. Lieferzeit: {avg_delivery_time:.1f}s"
-        )
-        return task.cont
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def update_graph_data(self, task):
-        if self.sim_clock > 0:
-            ppm = self.delivered_packages / (self.sim_clock / 60)
-        else:
-            ppm = 0.0
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        avg_delivery = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        new_data = (self.sim_clock, ppm, avg_dwell, avg_delivery)
-        # Speichere alle Daten ab Simulationsbeginn:
-        self.graph_data.append(new_data)
-
-        # Zusätzlich: Falls der Graphprozess aktiv ist, schicke den neuen Datensatz auch an die Queue
-        if self.graph_queue is not None:
-            try:
-                self.graph_queue.put(new_data, block=False)
-            except Exception:
-                pass
-        return Task.cont
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Hier werden nur die gewünschten Spalten "ID", "Annahmestation", "Ziel" und "Fahrzeug" definiert.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-    def update_order_table(self):
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen die Stationsnummer (oder verwende "N/A").
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z.B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige den zugewiesenen Fahrzeugnamen an (oder "-" falls noch keiner zugeordnet wurde).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END,
-                                   values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    #-------Fahrzeugsteuerung(Bedienfenster)-------
-    def show_vehicle_control(self):
-        # Falls das Fenster bereits existiert, bringe es einfach in den Vordergrund,
-        # ohne die Radiobuttons neu zu initialisieren.
-        if hasattr(self, "control_win") and self.control_win.winfo_exists():
-            self.control_win.deiconify()
-            self.control_win.lift()
-            self.control_win.focus_force()
-            return
-
-        # Erstelle das Kontrollfenster als Toplevel des persistenten tk_root.
-        self.control_win = tk.Toplevel(self.tk_root)
-        self.control_win.title("Fahrzeugsteuerung")
-        # Beim Schließen soll das Fenster nicht zerstört, sondern nur versteckt werden
-        self.control_win.protocol("WM_DELETE_WINDOW", self.control_win.withdraw)
-        # Sorge dafür, dass das Fenster initial über allem liegt
-        self.control_win.attributes("-topmost", True)
-        self.control_win.after(100, lambda: self.control_win.attributes("-topmost", False))
-
-        # Erzeuge das Dictionary für die StringVar-Zuordnungen für die Fahrzeuge.
-        self.vehicle_state_vars = {}
-        row = 0
-        for veh in self.garage_vehicles:
-            frame = tk.Frame(self.control_win)
-            frame.grid(row=row, column=0, sticky="w", padx=5, pady=2)
-            vid = veh.getPythonTag("vehicle_id")
-            label = tk.Label(frame, text=f"Fahrzeug {vid}")
-            label.pack(side=tk.LEFT)
-            # Initialisiere die Radiobutton-Variable anhand des aktuellen Fahrzeugzustandes.
-            state = veh.getPythonTag("order_state")
-            if state is None:
-                state = "idle"
-            var = tk.StringVar(value=state)
-            self.vehicle_state_vars[veh] = var
-            rb_active = tk.Radiobutton(frame, text="Aufträge bearbeiten", variable=var, value="translate")
-            rb_active.pack(side=tk.LEFT)
-            rb_standby = tk.Radiobutton(frame, text="Standby", variable=var, value="idle")
-            rb_standby.pack(side=tk.LEFT)
-            row += 1
-        update_btn = tk.Button(self.control_win, text="Übernehmen", command=self.update_vehicle_control)
-        update_btn.grid(row=row, column=0, pady=5)
-
-    def update_vehicle_control(self):
-        for veh, var in self.vehicle_state_vars.items():
-            new_state = var.get()
-            if new_state == "idle" and veh.getPythonTag("current_order") is not None:
-                veh.setPythonTag("standby_pending", True)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Standby angefordert (Auftrag wird fortgesetzt).")
-            else:
-                veh.setPythonTag("standby_pending", False)
-                veh.setPythonTag("order_state", new_state)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Zustand auf {new_state} gesetzt.")
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-    # ---------------3. Umgebungsaufbau & Visualisierungsaufbau---------------
-    def update_cable(self, task):
-        # Verwende die simulative Zeit, die bereits in update_sim_clock hochgezählt wird
-        t = self.sim_clock
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    def create_garage_vehicles(self):
-        # Stelle sicher, dass self.garagen_parking_points bereits gesetzt wurde
-        self.garage_vehicles = []
-        vehicle_id_counter = 1
-        for park in self.garagen_parking_points:
-            # Erzeuge Fahrzeug – hierbei wird davon ausgegangen, dass die Methode create_vehicle existiert.
-            veh = self.create_vehicle(park_point=park)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            newPos.setZ(0)
-            veh.setPos(newPos)
-            # Setze Fahrzeug-Tags
-            veh.setPythonTag("current_order", None)
-            veh.setPythonTag("order_state", "idle")
-            veh.setPythonTag("package_attached", False)
-            veh.setPythonTag("vehicle_id", vehicle_id_counter)
-            veh.setPythonTag("garage_target", park)
-            veh.setPythonTag("start_heading", veh.getH())
-            vehicle_id_counter += 1
-            self.garage_vehicles.append(veh)
-
-            # Markierung für das Fahrzeug (z.B. als Standort in der Garage)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-            # Fahrzeugnummer als Text – Suche nach Mast oder hänge direkt an das Fahrzeug
-            mast = veh.find("**/mast")
-            if not mast.isEmpty():
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(LColor(0, 0, 0, 1))
-                tn.setAlign(TextNode.ACenter)
-                text_np = mast.attachNewNode(tn)
-                text_np.setPos(intersection.x, intersection.y, intersection.z + 0.2)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-            else:
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(LColor(0, 0, 0, 1))
-                tn.setAlign(TextNode.ACenter)
-                text_np = veh.attachNewNode(tn)
-                text_np.setPos(0, 1.2, 1.5)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-            # Starte den Fahrzeugtask (sofern diese Logik besteht)
-            self.taskMgr.add(partial(self.vehicle_order_task, veh),
-                             f"VehicleOrderTask_{veh.getPythonTag('vehicle_id')}")
-
-    # --------------- Erstellung des Fahrzeugs---------------
-    def create_vehicle(self, park_point=None):
-        # Erzeuge den übergeordneten Fahrzeug-Knoten
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # --------------------------
-        # Chassis erstellen (1 x 0.5 x 1.2, Farbe Rot)
-        # --------------------------
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # --------------------------
-        # Gabel (Fork) erstellen: Zwei Zähne
-        # --------------------------
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        vehicle_node.setPythonTag("fork_node", fork_node)
-
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-
-        # --------------------------
-        # Statt weißer Kante von der Gabel: bereits eingezeichnete grüne Mittellinie verwenden.
-        # In diesem Beispiel nehmen wir an, dass du schon eine „mittlere“ Linie gezeichnet hast.
-        # Zeichne die grüne Mittellinie, z. B. von einem Punkt an der Gabel (als Ausgangspunkt)
-        # bis zu einem Referenzpunkt – hier nutzen wir einen zuvor festgelegten Offset.
-        #
-        # Wir definieren:
-        #   - Den Ausgangspunkt als den grün markierten Punkt, der den mittleren Punkt der Gabel repräsentieren soll.
-        #   - Den Zielpunkt als den Referenzpunkt, der als Idealwert in create_vehicle bestimmt wurde.
-        # In unserem Beispiel berechnen wir den Zielpunkt einmalig aus den lokalen Offsets an der weißen Kante.
-        # (Diese Werte kannst du bei Bedarf anpassen.)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_global = fork_node.getPos(self.render) + left_corner_local
-        right_global = fork_node.getPos(self.render) + right_corner_local
-        # Berechne den idealen (statischen) Mittelpunkt als Referenz – dieser wird nur einmal gesetzt.
-        midpoint_white = (left_global + right_global) * 0.5
-        # Nun lege den grünen Marker so, dass er exakt in der Mitte der Gabel liegt.
-        # Hier entspricht der grüne Punkt der Mittellinie der Gabel.
-        green_point_global = midpoint_white  # Hier wird angenommen, dass der ideale Mittelpunkt gleich dem Referenzpunkt ist.
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        vehicle_node.setPythonTag("fork_green", green_marker_np)
-
-        # Zeichne die grüne Mittellinie.
-        # Als Beispiel: Zeichne eine Linie vom grünen Marker in Richtung +Y (relativ zum Fahrzeug),
-        # weil du den idealen Zustand so festgelegt hast, dass genau diese Linie mit der Station übereinstimmen soll.
-        ls_mid = LineSegs()
-        ls_mid.setThickness(2.0)
-        ls_mid.setColor(0, 1, 0, 1)  # grün
-        # Starte die Linie am grünen Marker.
-        ls_mid.moveTo(green_point_global)
-        # Zeichne beispielsweise eine Linie 1 Einheit lang in +Y-Richtung:
-        ls_mid.drawTo(green_point_global + Vec3(0, 1, 0))
-        fork_center_line = vehicle_node.attachNewNode(ls_mid.create())
-        # Speichere den NodePath der grünen Mittellinie
-        vehicle_node.setPythonTag("fork_center_line", fork_center_line)
-        print("[DEBUG] create_vehicle: Grüne Mittellinie (fork_center_line) gesetzt.")
-
-        # --------------------------
-        # Restliche Fahrzeugteile (Mast, Lenkachse, etc.)
-        # --------------------------
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-        self.add_diagonals_to_mast(mast_node)
-
-        intersection = Vec3(0.5, 0.05, 1.0)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        # --------------------------
-        # Lenkachse erzeugen (Pivot-Node)
-        # --------------------------
-        steering_axis = mast_node.attachNewNode("steering_axis")
-        steering_axis.setPos(0.5, 0.25, -1.2)
-        steering_axis.setH(90)
-        vehicle_node.setPythonTag("steering_axis", steering_axis)
-
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(steering_axis)
-        cylinder_node.setPos(0, 0, 0)
-        self.vehicle_cylinder = steering_axis
-        self.add_steering_arrow(steering_axis, color=(0, 1, 0, 1))
-
-        # --------------------------
-        # Positioniere das Fahrzeug am Parkpunkt
-        # --------------------------
-        if park_point is None:
-            vehicle_node.setPos(0, 0, 0)
-        else:
-            intersection = Vec3(0, 0, 1.0)
-            vehicle_node.setPos(park_point - vehicle_node.getQuat().xform(intersection))
-
-        # ********** Ursprung (Koordinatensystem) am Fahrzeug einzeichnen **********
-        ls_x = LineSegs()
-        ls_x.setThickness(2)
-        ls_x.setColor(LColor(1, 0, 0, 1))
-        ls_x.moveTo(0, 0, 0)
-        ls_x.drawTo(1, 0, 0)
-        vehicle_node.attachNewNode(ls_x.create())
-
-        ls_y = LineSegs()
-        ls_y.setThickness(2)
-        ls_y.setColor(LColor(0, 1, 0, 1))
-        ls_y.moveTo(0, 0, 0)
-        ls_y.drawTo(0, 1, 0)
-        vehicle_node.attachNewNode(ls_y.create())
-
-        ls_z = LineSegs()
-        ls_z.setThickness(2)
-        ls_z.setColor(LColor(0, 0, 1, 1))
-        ls_z.moveTo(0, 0, 0)
-        ls_z.drawTo(0, 0, 1)
-        vehicle_node.attachNewNode(ls_z.create())
-
-        from panda3d.core import TextNode
-        tn_x = TextNode("label_x")
-        tn_x.setText("X")
-        tn_x.setTextColor(1, 0, 0, 1)
-        label_x = vehicle_node.attachNewNode(tn_x)
-        label_x.setScale(0.3)
-        label_x.setPos(2.0, 0, 0)
-
-        tn_y = TextNode("label_y")
-        tn_y.setText("Y")
-        tn_y.setTextColor(0, 1, 0, 1)
-        label_y = vehicle_node.attachNewNode(tn_y)
-        label_y.setScale(0.3)
-        label_y.setPos(0, 2.0, 0)
-
-        tn_z = TextNode("label_z")
-        tn_z.setText("Z")
-        tn_z.setTextColor(0, 0, 1, 1)
-        label_z = vehicle_node.attachNewNode(tn_z)
-        label_z.setScale(0.3)
-        label_z.setPos(0, 0, 2.0)
-
-        return vehicle_node
-
-    def add_steering_arrow(self, steering_axis, color=(0, 1, 0, 1)):
-        """
-        Erzeugt einen Pfeil, der die Vorwärtsrichtung (lokale X-Achse) des Lenkpivots anzeigt.
-        Der Pfeil wird als Kind des übergebenen steering_axis-Node angehängt und passt sich
-        automatisch dessen Rotation an.
-        """
-        arrow_ls = LineSegs()
-        arrow_ls.setThickness(2.0)
-        arrow_ls.setColor(*color)
-
-        # Zeichne eine Linie von (0,0,0) bis (2,0,0) – das ist die Basis des Pfeils
-        arrow_ls.moveTo(0, 0, 0)
-        arrow_ls.drawTo(2, 0, 0)
-
-        # Zeichne den Pfeilkopf: zwei kurze schräge Linien am Ende der Pfeillinie
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, 0.3, 0)
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, -0.3, 0)
-
-        arrow_np = steering_axis.attachNewNode(arrow_ls.create())
-        arrow_np.setPos(0, 0, 0)  # Falls nötig, hier noch zusätzlichen Offset anpassen
-        return arrow_np
-
-    def rotate_around_pivot(self, vehicle, pivot, delta_angle):
-        """
-        Dreht das Fahrzeug (vehicle) um den gegebenen Pivotpunkt (pivot) um delta_angle (in Grad).
-        Dabei wird die Position des Fahrzeugs neu berechnet, sodass es um den Pivot rotiert.
-        """
-        # Aktuelle globale Fahrzeugposition
-        pos = vehicle.getPos(self.render)
-        # Globaler Pivotpunkt
-        pivot_pos = pivot.getPos(self.render)
-        # Berechne den Vektor vom Pivot zum Fahrzeug
-        rel = pos - pivot_pos
-        # Wandle den Drehwinkel in Bogenmaß um
-        rad = math.radians(delta_angle)
-        cos_val = math.cos(rad)
-        sin_val = math.sin(rad)
-        # Drehe den relativen Vektor
-        new_x = rel.getX() * cos_val - rel.getY() * sin_val
-        new_y = rel.getX() * sin_val + rel.getY() * cos_val
-        new_rel = Vec3(new_x, new_y, rel.getZ())
-        # Neue globale Fahrzeugposition
-        new_pos = pivot_pos + new_rel
-        vehicle.setPos(new_pos)
-        # Aktualisiere auch das Heading des Fahrzeugs (aufaddieren des Drehwinkels)
-        vehicle.setH(vehicle.getH() + delta_angle)
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    # ---------------6. Paket- & Auftragsverwaltung---------------
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Bestimme zufällig eine Abgabestation als Ziel
-        if hasattr(self, "abgabe_stations") and self.abgabe_stations:
-            target_index = random.randint(1, len(self.abgabe_stations))
-        else:
-            target_index = 1
-
-        # Erstelle den Auftrag zur Annahmestation
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = 5.0  # 5 Sekunden Verzögerung zwischen Spawns
-        for station in self.annahme_stations:
-            # Wenn aktuell kein Paket an der Station ist
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                # Prüfe, ob seit der letzten Entnahme mindestens 5 Sekunden vergangen sind
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def update_order_table(self):
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen die Stationsnummer (oder verwende "N/A").
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z.B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige den zugewiesenen Fahrzeugnamen an (oder "-" falls noch keiner zugeordnet wurde).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END,
-                                   values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    # ---------------7. Cargo-Handling (Pickup, Drop & Timer)---------------
-    def pickup_package(self, vehicle, station):
-        # Falls das Fahrzeug bereits ein Paket trägt, abbrechen.
-        if vehicle.getPythonTag("package_attached"):
-            return
-
-        # Führe den Pickup nur aus, wenn an der Station ein Paket vorhanden ist.
-        if station in self.pickup_packages:
-            # Hole das Paket, den Spawn-Zeitpunkt und den zugehörigen Timer-Knoten.
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            # Entferne den Timer-Knoten, sodass der angezeigte Zähler nicht weiter aktualisiert wird.
-            timer_np.removeNode()
-            # Berechne die Liegedauer (Differenz zwischen aktueller Simulationszeit und Spawn-Zeit).
-            dwell_time = self.sim_clock - spawn_time
-            # Aktualisiere globale Kennzahlen.
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Suche in den Aufträgen nach dem Auftrag, dessen Paket mit diesem Paket übereinstimmt,
-            # und speichere den errechneten Endwert (fixe Liegedauer) sowie den Status.
-            for order_id, order in self.orders.items():
-                if order.get("package") == package:
-                    order["dwell_time"] = dwell_time
-                    order["status"] = "Abgeholt"
-                    break
-
-            # Hole Referenzen zum Gabel-Knoten und zum grünen Marker des Fahrzeugs.
-            fork_node = vehicle.getPythonTag("fork_node")
-            fork_green = vehicle.getPythonTag("fork_green")
-            green_point_pos = fork_green.getPos(fork_node)
-
-            # Übergib das Paket an den Gabel-Knoten (sodass es optisch dem Fahrzeug zugeordnet wird)
-            # und positioniere es relativ zum grünen Marker.
-            package.wrtReparentTo(fork_node)
-            package.setPos(green_point_pos.getX() + 0.5,
-                           green_point_pos.getY() - 0.5,
-                           green_point_pos.getZ() + 1)
-            self.cargos[vehicle] = package
-
-            # Starte den Lieferzeit-Timer: Speichere den Zeitpunkt, an dem das Paket abgeholt wurde,
-            # und hänge einen neuen Timer-Knoten an das Paket.
-            vehicle.setPythonTag("delivery_start_time", self.sim_clock)
-            from panda3d.core import TextNode
-            delivery_timer_text = TextNode("delivery_timer")
-            delivery_timer_text.setText("0.0s")
-            delivery_timer_np = package.attachNewNode(delivery_timer_text)
-            delivery_timer_np.setScale(0.5)
-            delivery_timer_np.setPos(0, 0, 1.2)
-            package.setPythonTag("delivery_timer", delivery_timer_np)
-
-            # Aktualisiere den Zeitpunkt, zu dem an dieser Station zuletzt ein Paket entfernt wurde.
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-
-            # Berechne Lieferzeit:
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start is not None:
-                delivery_time = self.sim_clock - delivery_start
-                self.total_delivery_time += delivery_time
-                self.total_delivery_count += 1
-                self.max_overall_delivery_time = max(self.max_overall_delivery_time, delivery_time)
-                vehicle.clearPythonTag("delivery_start_time")
-
-            # Entferne den Lieferzeit-Timer vom Paket
-            delivery_timer_np = cargo.getPythonTag("delivery_timer")
-            if delivery_timer_np:
-                delivery_timer_np.removeNode()
-
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden das Paket entfernt
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def update_delivery_timers(self, task):
-        for vehicle, package in list(self.cargos.items()):
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start:
-                elapsed_delivery = self.sim_clock - delivery_start
-                delivery_timer_np = package.getPythonTag("delivery_timer")
-                if delivery_timer_np and not delivery_timer_np.isEmpty():
-                    delivery_timer_np.node().setText(f"{elapsed_delivery:.1f}s")
-        return Task.cont
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-
-    # ---------------8. Auftrags-/Fahrzeuglogik---------------
-    def select_next_order(self, vehicle):
-        # Sammle alle Aufträge, die noch "Wartend" sind
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        # Aktualisiere die Dwell-Zeit für jeden Auftrag
-        for order in waiting_orders:
-            order["dwell_time"] = self.sim_clock - order.get("spawn_time", self.sim_clock)
-
-        # Wähle den Auftrag mit der maximalen Dwell-Zeit (evtl. mit etwas Toleranz)
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        # Finde aus den Kandidaten den Auftrag, dessen Pickup-Station (order["pickup_station"])
-        # am nächsten zur aktuellen Fahrzeugposition liegt.
-        vehicle_pos = vehicle.getPos(self.render)
-        candidates.sort(key=lambda order: (order["pickup_station"].getPos(self.render) - vehicle_pos).length())
-        return candidates[0]
-
-    def show_vehicle_control(self):
-        # Falls das Fenster bereits existiert, bringe es einfach in den Vordergrund,
-        # ohne die Radiobuttons neu zu initialisieren.
-        if hasattr(self, "control_win") and self.control_win.winfo_exists():
-            self.control_win.deiconify()
-            self.control_win.lift()
-            self.control_win.focus_force()
-            return
-
-        # Erstelle das Kontrollfenster als Toplevel des persistenten tk_root.
-        self.control_win = tk.Toplevel(self.tk_root)
-        self.control_win.title("Fahrzeugsteuerung")
-        # Beim Schließen soll das Fenster nicht zerstört, sondern nur versteckt werden
-        self.control_win.protocol("WM_DELETE_WINDOW", self.control_win.withdraw)
-        # Sorge dafür, dass das Fenster initial über allem liegt
-        self.control_win.attributes("-topmost", True)
-        self.control_win.after(100, lambda: self.control_win.attributes("-topmost", False))
-
-        # Erzeuge das Dictionary für die StringVar-Zuordnungen für die Fahrzeuge.
-        self.vehicle_state_vars = {}
-        row = 0
-        for veh in self.garage_vehicles:
-            frame = tk.Frame(self.control_win)
-            frame.grid(row=row, column=0, sticky="w", padx=5, pady=2)
-            vid = veh.getPythonTag("vehicle_id")
-            label = tk.Label(frame, text=f"Fahrzeug {vid}")
-            label.pack(side=tk.LEFT)
-            # Initialisiere die Radiobutton-Variable anhand des aktuellen Fahrzeugzustandes.
-            state = veh.getPythonTag("order_state")
-            if state is None:
-                state = "idle"
-            var = tk.StringVar(value=state)
-            self.vehicle_state_vars[veh] = var
-            rb_active = tk.Radiobutton(frame, text="Aufträge bearbeiten", variable=var, value="translate")
-            rb_active.pack(side=tk.LEFT)
-            rb_standby = tk.Radiobutton(frame, text="Standby", variable=var, value="idle")
-            rb_standby.pack(side=tk.LEFT)
-            row += 1
-        update_btn = tk.Button(self.control_win, text="Übernehmen", command=self.update_vehicle_control)
-        update_btn.grid(row=row, column=0, pady=5)
-
-    def vehicle_order_task(self, vehicle, task):
-        # Berechne das Zeitintervall (dt)
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        state = vehicle.getPythonTag("order_state")
-
-        # Zustandsbasierte Weiterleitung an die jeweiligen Handler
-        if state == "translate":
-            self.handle_translate_phase(vehicle, dt)
-        elif state == "rotate":
-            self.handle_rotate_phase(vehicle, dt)
-        elif state == "approach":
-            self.handle_approach_phase(vehicle, dt)
-        elif state == "pickup":
-            self.handle_pickup_phase(vehicle, dt)
-        elif state == "drive_out":
-            self.handle_drive_out_phase(vehicle, dt)
-        elif state == "to_delivery":
-            self.handle_to_delivery_phase(vehicle, dt)
-        elif state == "align_delivery":
-            self.handle_align_delivery_phase(vehicle, dt)
-        elif state == "delivery_center":
-            self.handle_delivery_center_phase(vehicle, dt)
-        elif state == "drop":
-            self.handle_drop_phase(vehicle, dt)
-        elif state == "phase11":
-            self.handle_phase11(vehicle, dt)
-        elif state == "return_to_garage":
-            self.handle_return_to_garage_phase(vehicle, dt)
-        else:
-            print(f"Unbekannter Zustand: {state}")
-        return Task.cont
-
-    # -------------------- Handler für einzelne Phasen --------------------
-
-    def handle_translate_phase(self, vehicle, dt):
-        # Wenn noch kein Auftrag zugeordnet wurde, wähle einen Auftrag aus.
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is None:
-            next_order = self.select_next_order(vehicle)
-            if next_order is not None:
-                next_order["status"] = "In Bearbeitung"
-                next_order["vehicle"] = f"Fahrzeug {vehicle.getPythonTag('vehicle_id')}"
-                vehicle.setPythonTag("current_order", next_order)
-                print(f"Auftrag {next_order['id']} wird zugewiesen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}.")
-            else:
-                print("Kein Auftrag verfügbar – Fallback zum globalen Ziel.")
-            current_order = vehicle.getPythonTag("current_order")
-
-        # Bestimme das Ziel (Pickup-Station über den blauen Marker)
-        if current_order is not None:
-            pickup_station = current_order.get("pickup_station")
-            if pickup_station in self.station_blue_dots:
-                target = self.station_blue_dots[pickup_station].getPos(self.render)
-            else:
-                target = self.blue_dot.getPos(self.render)
-        else:
-            target = self.blue_dot.getPos(self.render)
-
-        current_pos = vehicle.getPos(self.render)
-        pivot = vehicle.getPythonTag("steering_axis")
-
-        # Berechne den tatsächlichen Steuerpunkt (also den Offset-Punkt)
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-
-        # Berechne den gewünschten Heading-Winkel: Richtung von Offset-Punkt zum Ziel
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-
-        # Ermittle aktuellen Heading-Winkel über den `steering_axis`
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-
-        # Berechnung des Fehlerwinkels
-        heading_error = desired_heading_rad - current_heading_rad
-        while heading_error > math.pi:
-            heading_error -= 2 * math.pi
-        while heading_error < -math.pi:
-            heading_error += 2 * math.pi
-
-        # Drehung zur Korrektur, nur basierend auf Fehlerwinkel
-        gain = 1.0
-        max_delta = gain * dt
-        delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-        self.rotate_around_pivot(vehicle, pivot, math.degrees(delta_heading_rad))
-
-        # Bewege das Fahrzeug entlang der neuen Richtung
-        global_hpr = pivot.getNetTransform().getHpr()
-        new_heading_rad = math.radians(global_hpr.getX())
-        speed = 1.5
-        new_x = current_pos.getX() + speed * math.cos(new_heading_rad) * dt
-        new_y = current_pos.getY() + speed * math.sin(new_heading_rad) * dt
-        new_pos = Vec3(new_x, new_y, 0)
-        vehicle.setPos(new_pos)
-
-        # Aktualisiere den Offset-Punkt (Steuerachse) nach der Bewegung
-        new_offset_pos = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-
-        # Prüfe, ob sich der Offset-Punkt exakt auf dem Ziel befindet
-        if (target - new_offset_pos).length() < 0.1:
-            vehicle.setPythonTag("order_state", "rotate")  # Wechsel zur nächsten Phase
-
-    def handle_rotate_phase(self, vehicle, dt):
-        import math
-        from panda3d.core import Vec3
-
-        # 1. Hole den grünen Referenzpunkt (fork_green) der Gabel.
-        fork_green = vehicle.getPythonTag("fork_green")
-        if not fork_green or fork_green.isEmpty():
-            print("[DEBUG] handle_rotate_phase: Kein fork_green gefunden!")
-            return
-
-        # 2. Hole den aktuellen Auftrag und die zugehörige Pickup-Station.
-        current_order = vehicle.getPythonTag("current_order")
-        if not current_order or "pickup_station" not in current_order:
-            print("[DEBUG] handle_rotate_phase: Kein aktueller Auftrag oder Station gefunden!")
-            return
-        station = current_order["pickup_station"]
-
-        # Hole den Referenzpunkt der Station (white_center) und den Richtungsvektor (white_direction)
-        white_center = station.getPythonTag("white_center")
-        if white_center is None:
-            print("[DEBUG] handle_rotate_phase: Kein white_center in der Station gefunden!")
-            return
-        target = white_center  # Ziel: Mittelpunkt der weißen Linie
-
-        # 3. Berechne den Drehpunkt des Fahrzeugs.
-        pivot = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-
-        # 4. Falls sich der pivot nahe am Ziel befindet, final: Setze die exakte Ausrichtung.
-        distance = (target - pivot).length()
-        stop_threshold = 0.5  # Schwellenwert, evtl. an Modelldimensionen anpassen
-        if distance < stop_threshold:
-            desired_vector = target - pivot
-            desired_angle = math.degrees(math.atan2(desired_vector.getY(), desired_vector.getX())) + 90
-            desired_angle %= 360
-            vehicle.setH(self.render, desired_angle)
-            print(f"[DEBUG] final step: Fahrzeugheading auf {desired_angle:.2f}° gesetzt.")
-
-            # Final: Richte den grünen Richtungspfeil ("fork_center_line") exakt aus.
-            white_direction = station.getPythonTag("white_direction")
-            if white_direction is not None:
-                desired_arrow_angle = math.degrees(math.atan2(white_direction.getY(), white_direction.getX()))
-                arrow_relative = (desired_arrow_angle - desired_angle + 180) % 360 - 180
-                fork_center_line = vehicle.getPythonTag("fork_center_line")
-                if fork_center_line:
-                    fork_center_line.setH(arrow_relative)
-                    print(f"[DEBUG] final step: Grüner Pfeil auf relativen Winkel {arrow_relative:.2f}° gesetzt.")
-            # Hier ändern wir den Zustand in 'approach' statt "next_phase"
-            vehicle.setPythonTag("order_state", "approach")
-            return
-
-        # 5. Andernfalls: Berechne den gewünschten globalen Winkel (inklusive +90°-Offset)
-        desired_vector = target - pivot
-        desired_angle = math.degrees(math.atan2(desired_vector.getY(), desired_vector.getX())) + 90
-        desired_angle %= 360
-
-        # 6. Ermittle den aktuellen Fahrzeugheading in Weltkoordinaten und berechne die Winkelabweichung.
-        current_heading = vehicle.getH(self.render)
-        angle_diff = (desired_angle - current_heading + 180) % 360 - 180
-
-        if abs(angle_diff) < 2.0:
-            vehicle.setH(self.render, desired_angle)
-            white_direction = station.getPythonTag("white_direction")
-            if white_direction is not None:
-                desired_arrow_angle = math.degrees(math.atan2(white_direction.getY(), white_direction.getX()))
-                arrow_relative = (desired_arrow_angle - desired_angle + 180) % 360 - 180
-                fork_center_line = vehicle.getPythonTag("fork_center_line")
-                if fork_center_line:
-                    fork_center_line.setH(arrow_relative)
-                    print(f"[DEBUG] fine alignment: Grüner Pfeil auf {arrow_relative:.2f}° gesetzt.")
-            # Ändere auch hier sofort den Zustand in "approach"
-            vehicle.setPythonTag("order_state", "approach")
-            return
-
-        # 7. Begrenze die Drehung pro Frame (z.B. 20,9° pro Sekunde)
-        max_rotation_speed = 20.9  # Grad pro Sekunde
-        max_delta = max_rotation_speed * dt
-        delta_angle = max(-max_delta, min(max_delta, angle_diff))
-
-        # 8. Drehe das Fahrzeug schrittweise um delta_angle
-        temp_pivot = self.render.attachNewNode("temp_pivot")
-        temp_pivot.setPos(pivot)
-        self.rotate_around_pivot(vehicle, temp_pivot, delta_angle)
-        temp_pivot.removeNode()
-
-        print(f"[DEBUG] rotating: Gedreht um {delta_angle:.2f}°; Restliche Differenz: {angle_diff - delta_angle:.2f}°")
-
-    def handle_approach_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None:
-            pickup_station = current_order.get("pickup_station")
-            target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-        else:
-            target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-        current = vehicle.getPos(self.render)
-        error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-        if error_vec.length() > 0.05:
-            direction = error_vec.normalized()
-            move_distance = 1.5 * dt
-            new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                           current.getY() + direction.getY() * move_distance, target.getZ())
-            vehicle.setPos(new_pos)
-        else:
-            vehicle.setPos(target)
-            vehicle.setPythonTag("order_state", "pickup")
-
-    def handle_pickup_phase(self, vehicle, dt):
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        target_z = 1.0
-        raise_speed = 0.5
-        if current_z < target_z:
-            fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-        else:
-            if vehicle.getPythonTag("current_order") is None:
-                if self.orders_queue:
-                    vehicle.setPythonTag("current_order", self.orders_queue.pop(0))
-                else:
-                    print(
-                        f"Keine verfügbaren Aufträge für Fahrzeug {vehicle.getPythonTag('vehicle_id')}. Überspringe Pickup-Phase.")
-                    vehicle.setPythonTag("order_state", "drive_out")
-                    return
-            if not vehicle.getPythonTag("package_attached"):
-                pickup_station = vehicle.getPythonTag("current_order")["pickup_station"]
-                self.pickup_package(vehicle, pickup_station)
-                vehicle.setPythonTag("package_attached", True)
-            if vehicle.getPythonTag("drive_out_target") is None:
-                vehicle.setPythonTag("drive_out_target",
-                                     vehicle.getPos(self.render) + vehicle.getQuat(self.render).getForward() * 5.0)
-            vehicle.setPythonTag("order_state", "drive_out")
-
-    def handle_drive_out_phase(self, vehicle, dt):
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        if current_z > 0:
-            lower_speed = 0.5
-            fork_node.setZ(max(0, current_z - lower_speed * dt))
-        current_pos = vehicle.getPos(self.render)
-        drive_out_target = vehicle.getPythonTag("drive_out_target")
-        if drive_out_target is None:
-            drive_out_target = current_pos + vehicle.getQuat(self.render).getForward() * 5.0
-            vehicle.setPythonTag("drive_out_target", drive_out_target)
-        diff = drive_out_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            vehicle.setPythonTag("order_state", "to_delivery")
-            vehicle.setPythonTag("drive_out_target", None)
-
-    def handle_to_delivery_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is None:
-            return
-        # Ziel der Abgabestation als Vektor verwenden:
-        delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-        try:
-            target_index = int(delivery_target_str.split()[-1])
-        except ValueError:
-            target_index = 1
-        if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-            target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-        else:
-            target = self.abgabe_blue_dots[0].getPos(self.render)
-        current_pos = vehicle.getPos(self.render)
-        pivot = vehicle.getPythonTag("steering_axis")
-        global_hpr = pivot.getNetTransform().getHpr()
-        global_heading = global_hpr.getX()
-        current_heading_rad = math.radians(global_heading)
-        desired_heading_rad = math.atan2(target.getY() - current_pos.getY(),
-                                         target.getX() - current_pos.getX())
-        heading_error = desired_heading_rad - current_heading_rad
-        while heading_error > math.pi:
-            heading_error -= 2 * math.pi
-        while heading_error < -math.pi:
-            heading_error += 2 * math.pi
-        gain = 1.0
-        max_delta = gain * dt
-        delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-        self.rotate_around_pivot(vehicle, pivot, math.degrees(delta_heading_rad))
-        global_hpr = pivot.getNetTransform().getHpr()
-        new_heading_rad = math.radians(global_hpr.getX())
-        speed = 1.5
-        new_x = current_pos.getX() + speed * math.cos(new_heading_rad) * dt
-        new_y = current_pos.getY() + speed * math.sin(new_heading_rad) * dt
-        new_pos = Vec3(new_x, new_y, 0)
-        vehicle.setPos(new_pos)
-        if math.sqrt((target.getX() - new_pos.getX()) ** 2 + (target.getY() - new_pos.getY()) ** 2) < 0.5:
-            print(
-                f"Phase 7 abgeschlossen: Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den blauen Punkt erreicht.")
-            vehicle.setPythonTag("order_state", "align_delivery")
-
-    def handle_align_delivery_phase(self, vehicle, dt):
-        desired_heading = 90.0
-        current_heading = vehicle.getH() % 360
-        angle_diff = ((desired_heading - current_heading + 180) % 360) - 180
-        print(
-            f"Phase 8: Align Delivery | Fahrzeug {vehicle.getPythonTag('vehicle_id')}: Current {current_heading:.2f}°, Desired {desired_heading:.2f}°, Diff {angle_diff:.2f}°")
-        fixed_turn_speed = 90.0
-        turn_amount = fixed_turn_speed * dt
-        if abs(angle_diff) < 1.0:
-            vehicle.setH(desired_heading)
-            print(
-                f"Phase 8 abgeschlossen: Fahrzeug {vehicle.getPythonTag('vehicle_id')} ausgerichtet (Heading = {desired_heading:.2f}°).")
-            vehicle.setPythonTag("order_state", "delivery_center")
-        else:
-            new_heading = current_heading + (turn_amount if angle_diff > 0 else -turn_amount)
-            new_heading %= 360
-            vehicle.setH(new_heading)
-            print(f"Phase 8: Rotating - Fahrzeug {vehicle.getPythonTag('vehicle_id')} New Heading: {new_heading:.2f}°")
-
-    def handle_delivery_center_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is None:
-            return
-        delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-        try:
-            target_index = int(delivery_target_str.split()[-1])
-        except ValueError:
-            target_index = 1
-        if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-            blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-        else:
-            blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-        current = vehicle.getPos(self.render)
-        target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-        print(f"Phase 9: Zielpunkt der Abgabestation für Fahrzeug {vehicle.getPythonTag('vehicle_id')}: {target_point}")
-        error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-        tolerance = 0.05
-        move_distance = 1.5 * dt
-        if error_vec.length() > tolerance:
-            direction = error_vec.normalized()
-            new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                           current.getY() + direction.getY() * move_distance, current.getZ())
-            vehicle.setPos(new_pos)
-            print(f"Phase 9: Fahrzeug {vehicle.getPythonTag('vehicle_id')} bewegt sich von {current} nach {new_pos}")
-        else:
-            vehicle.setPos(target_point)
-            print(f"Phase 9: Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den Zielpunkt erreicht.")
-            vehicle.setPythonTag("order_state", "drop")
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_fork_z = fork_node.getZ()
-        if current_fork_z < 1.0:
-            new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-            fork_node.setZ(new_fork_z)
-            print(
-                f"Phase 9: Gabel wird angehoben für Fahrzeug {vehicle.getPythonTag('vehicle_id')} (Z = {new_fork_z}).")
-
-    def handle_drop_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if vehicle.getPythonTag("package_attached"):
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            # (Bei Bedarf kann man hier noch Zielpositionen abfragen.)
-            self.drop_cargo(vehicle)
-            print(f"Phase 10: Paket abgesetzt für Fahrzeug {vehicle.getPythonTag('vehicle_id')}")
-            vehicle.setPythonTag("package_attached", False)
-        else:
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            if current_z > 0:
-                lower_speed = 0.5
-                new_z = max(0, current_z - lower_speed * dt)
-                fork_node.setZ(new_z)
-                print(
-                    f"Phase 10: Gabel wird abgesenkt für Fahrzeug {vehicle.getPythonTag('vehicle_id')}, aktueller Z-Wert: {new_z}")
-            else:
-                print(f"Phase 10: Dropoff abgeschlossen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}")
-                if vehicle.getPythonTag("standby_pending"):
-                    vehicle.setPythonTag("order_state", "return_to_garage")
-                    print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} kehrt zur Garage zurück (Standby).")
-                else:
-                    vehicle.setPythonTag("order_state", "translate")
-                current_order["status"] = "Abgegeben"
-                current_order["delivered_at"] = self.sim_clock
-                vehicle.clearPythonTag("current_order")
-
-    def handle_phase11(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if vehicle.getPythonTag("last_delivery_marker") is not None:
-            target_point = vehicle.getPythonTag("last_delivery_marker")
-        else:
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                target_point = self.abgabe_blue_dots[0].getPos(self.render)
-        print(f"Phase 11: Zielpunkt (blauer Marker) für Fahrzeug {vehicle.getPythonTag('vehicle_id')}: {target_point}")
-        current_pos = vehicle.getPos(self.render)
-        diff = target_point - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            vehicle.setPos(new_pos)
-            print(
-                f"Phase 11: Fahrzeug {vehicle.getPythonTag('vehicle_id')} fährt aus der Station, neue Position: {new_pos}")
-        else:
-            vehicle.setPos(target_point)
-            print(
-                f"Phase 11: Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den blauen Marker erreicht. Nächster Auftrag wird gestartet.")
-            vehicle.setPythonTag("order_state", "next_order")
-
-    def handle_return_to_garage_phase(self, vehicle, dt):
-        garage_target = vehicle.getPythonTag("garage_target")
-        if garage_target is None:
-            garage_target = self.garagen_parking_points[0]
-        current_pos = vehicle.getPos(self.render)
-        diff = garage_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 1.0 * dt
-            new_pos = current_pos + diff.normalized() * move_distance
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            if vehicle.hasPythonTag("start_heading"):
-                vehicle.setH(vehicle.getPythonTag("start_heading"))
-            vehicle.setPythonTag("order_state", "idle")
-            vehicle.setPythonTag("standby_pending", False)
-            print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} ist in der Garage (Standby).")
-
-
-
-if __name__ == "__main__":
-    # Wichtig: setze auf Windows die Startmethode auf "spawn"
-    multiprocessing.set_start_method('spawn')
-
-    # Erzeuge eine Queue, auch wenn sie später eventuell neu erstellt wird, wenn "G" gedrückt wird.
-    graph_q = Queue()
-    app = LagerSimulation(graph_q)
-    app.run()
-
-    # Beim Schließen der Simulation den Graphprozess ggf. beenden
-    if app.graph_process is not None:
-        app.graph_process.terminate()
-        app.graph_process.join()
\ No newline at end of file
Index: Grundmodell/Gm22.py
===================================================================
diff --git a/Grundmodell/Gm22.py b/Grundmodell/Gm22.py
deleted file mode 100644
--- a/Grundmodell/Gm22.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,1578 +0,0 @@
-import random
-import math
-import tkinter as tk  # Für das extra Fenster der Auftragsübersicht
-from tkinter import ttk  # Für die tabellarische Darstellung (Treeview)
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-from direct.task.TaskManagerGlobal import taskMgr
-
-
-from functools import partial
-
-
-
-
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-            super().__init__()
-
-            # Basis-Simulationsvariablen
-            self.sim_clock = 0.0
-            self.speed_factor = 1.0
-            self.current_speed = 1.5  # Wird in update_vehicle genutzt
-            self.state_timer = 0.0
-
-            # Kennzahlen (KPIs)
-            self.delivered_packages = 0
-            self.max_overall_wait_time = 0.0
-            self.total_dwell_time = 0.0
-            self.picked_up_count = 0
-
-            # Paketspawning an den Annahmestationen:
-            # Mapping: station (Dummy-Node) -> (Paket, Spawnzeit, Timer Node)
-            self.pickup_packages = {}
-            self.last_removed = {}
-
-            # Fahrzeug-spezifische Zuordnung: Fahrzeug -> transportiertes Paket
-            self.cargos = {}
-
-            # NEU: Initialisiere die belegten Annahmestationen
-            self.occupied_pickups = set()  # Oder: [] für eine Liste
-
-            # Graph-Daten (Sim-Zeit, Pakete pro Minute, durchschnittliche Liegedauer)
-            self.graph_data = []
-            self.graph_opened = False
-
-            # Auftragsverwaltung: Speichere alle Aufträge (für die Anzeige) sowie in
-            # einer Queue (Liste) zur sequentiellen Abarbeitung.
-            self.orders = {}
-            self.orders_queue = []
-            self.next_order_id = 1
-
-            # Tkinter-Fenster für Auftragsübersicht
-            self.order_win = None
-            self.order_tree = None
-
-            # Umgebung initialisieren
-            self.draw_origin()
-            self.cam.setPos(11, -80, 40)
-            self.cam.lookAt(11, 30, 0)
-            self.erzeuge_licht()
-            self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-            self.create_wall()
-            self.create_annahme_stations()
-            self.create_abgabe_stations()  # Hier wird auch self.abgabe_stations angelegt.
-            self.create_garagen_stations()
-
-            for station in self.annahme_stations:
-                self.spawn_package_at_station(station)
-
-            # Fahrzeuge in den Garagen erstellen (genau 5 Fahrzeuge)
-            self.create_garage_vehicles()
-
-            # NEU: Testvariablen (werden nicht mehr aktiv über diesen globalen Mechanismus gesteuert)
-            self.first_vehicle_order_state = "idle"
-            self.attached_package = None
-            self.current_order = None  # Der aktuell abgearbeitete Auftrag (wird durch Fahrzeuge individuell genutzt)
-
-            # UI – Slider und Info-Anzeige
-            self.speed_slider = DirectSlider(
-                range=(0.1, 10.0),
-                value=self.speed_factor,
-                pageSize=0.1,
-                command=self.update_simulation_speed,
-                pos=(0, 0, -0.85),
-                scale=0.3
-            )
-            self.speed_label = DirectLabel(
-                text=f"Sim Time Factor: {self.speed_factor:.1f}",
-                pos=(0, 0, -0.75),
-                scale=0.07
-            )
-            self.info_label = DirectLabel(
-                text="Laufzeit: 0.0s",
-                pos=(1.2, 0, 0.8),
-                scale=0.07,
-                frameColor=(0, 0, 0, 0)
-            )
-
-            # Tastenzuordnungen
-            self.accept("wheel_up", self.zoom_in)
-            self.accept("wheel_down", self.zoom_out)
-            self.accept("g", self.open_graph)
-            self.accept("a", self.show_order_list)
-            self.accept("d", self.deliver_first_order)
-            # Taste C öffnet das Fahrzeug-Kontrollfenster
-            self.accept("c", self.show_vehicle_control)
-
-            # Task-Manager
-            self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-            self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-            self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-            self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-            self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-            self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    # ---------------------------
-    # SIMULATION UND UI-METHODEN
-    # ---------------------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        # dt jetzt skaliert mit der Simulationsgeschwindigkeit
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    # ---------------------------
-    # METHODEN FÜR RASTER, LICHT, MAUER, URSPRUNG
-    # ---------------------------
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # STATIONSOBJEKTE UND ZUORDNUNG
-    # -----------------------------------
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        """
-        Erzeugt die Annahmestationen und erstellt für jede Station:
-          - Einen weißen Marker zur Orientierung
-          - Einen grünen Punkt (optional)
-          - Eine weiße Linie, an deren Endpunkt ein blauer Marker als Ziel in der "Translate‑Phase" dient
-
-        Zusätzlich wird ein Dictionary self.station_blue_dots aufgebaut, in dem jedem Annahmestations‑Node
-        der zugehörige blaue Marker zugeordnet wird. Außerdem wird für die erste Station die globale Variable
-        self.station_white_direction festgelegt.
-        """
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        self.station_blue_dots = {}
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basisstation (zum Beispiel als Rahmen)
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Erzeuge den weißen Marker als Orientierung
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Erzeuge den grünen Punkt (optional)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zeichne die weiße Linie: Sie beginnt bei center + Vec3(0, 0, -0.5) und verläuft 3 Meter in X‑Richtung.
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Erzeuge den blauen Marker, der als Ziel in der Translate‑Phase dient
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            # Speichere den blauen Marker im Dictionary, sodass er später erzeugt werden kann
-            self.station_blue_dots[station_dummy] = blue_dot
-
-            # Optionale Textanzeige der Stationsnummer
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) – falls benötigt:
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-            # Für die erste Station (oder den ersten relevanten Pickup) setzen wir globale Referenzen,
-            # die in vehicle_order_task benötigt werden.
-            if i == 1:
-                self.blue_dot = blue_dot
-                self.station_green_dot = green_dot
-                # Berechne den Mittelpunkt der weißen Linie als Referenz (optional)
-                self.white_line_center = (start_line + end_line) * 0.5
-                line_vec = end_line - start_line
-                if line_vec.length() != 0:
-                    self.station_white_direction = Vec2(line_vec.getX(), line_vec.getY()).normalized()
-                else:
-                    self.station_white_direction = Vec2(1, 0)  # Fallback-Wert
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        self.abgabe_stations = []  # Liste der Abgabestationen
-        self.abgabe_blue_dots = []  # Liste zum Speichern der blauen Marker für die Abgabe
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basiskonstruktion der Abgabestation
-            node = self.create_abgabe_station(pt)
-            self.abgabe_stations.append(node)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Marker am Zentrum (weiß)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Grüner Punkt: center + Vec3(0, 0, -0.5)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Weiße Linie: Startet bei center + Vec3(0, 0, -0.5)
-            # und verläuft 3 Meter in negativer X-Richtung
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt: wird an der Endposition der Linie erzeugt
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            # Speichere den blauen Marker für spätere Navigation der Abgabestation
-            self.abgabe_blue_dots.append(blue_dot)
-
-            # Anzeige der Stationsnummer (textuell)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) auf der Station
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 3)
-        v5 = pos + Vec3(1, 0, 3)
-        v6 = pos + Vec3(1, 2, 3)
-        v7 = pos + Vec3(0, 2, 3)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 3)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        self.garagen_stations = []
-        self.garagen_parking_points = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            self.garagen_stations.append(pt)
-            # ParkpunktGarage: Verschoben um 0.5 in negativer Y-Richtung:
-            center = pt + Vec3(0.5, 0.5, 1.5)
-            ParkpunktGarage = center + Vec3(0, 0, 0.7)
-            self.garagen_parking_points.append(ParkpunktGarage)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def create_garage_vehicles(self):
-        self.garage_vehicles = []
-        vehicle_id_counter = 1
-        for park in self.garagen_parking_points:
-            veh = self.create_vehicle(park_point=park)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            newPos.setZ(0)
-            veh.setPos(newPos)
-
-            # Fahrzeuge starten zunächst im Standby (idle)
-            veh.setPythonTag("current_order", None)
-            veh.setPythonTag("order_state", "idle")
-            veh.setPythonTag("package_attached", False)
-            veh.setPythonTag("vehicle_id", vehicle_id_counter)
-            # Speichere den Parkpunkt (Garage) als Rückkehrziel
-            veh.setPythonTag("garage_target", park)
-            vehicle_id_counter += 1
-
-            self.garage_vehicles.append(veh)
-
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-            # Füge einen Textknoten am Mast hinzu – die Nummer soll vorne auf dem Fahrzeug angezeigt werden.
-            # Wir suchen nach dem Knoten "mast", der in create_vehicle angehängt wird.
-            mast = veh.find("**/mast")
-            if not mast.isEmpty():
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)  # Schwarz
-                tn.setAlign(TextNode.ACenter)
-                text_np = mast.attachNewNode(tn)
-                # Positioniere den Text vorne auf dem Fahrzeug – relativ zu 'intersection':
-                text_np.setPos(intersection.x, intersection.y, intersection.z + 0.2)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-            else:
-                # Fallback: Hänge den Text direkt am Fahrzeug
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)
-                tn.setAlign(TextNode.ACenter)
-                text_np = veh.attachNewNode(tn)
-                text_np.setPos(0, 1.2, 1.5)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-
-            # Registriere den Task für das Fahrzeug:
-            self.taskMgr.add(partial(self.vehicle_order_task, veh),
-                             f"VehicleOrderTask_{veh.getPythonTag('vehicle_id')}")
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # FAHRZEUGERSTELLUNG (FFZ20-INTEGRATION)
-    # -----------------------------------
-    def create_vehicle(self, park_point=None):
-        # Erzeuge den übergeordneten Fahrzeug-Knoten
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # --------------------------
-        # Chassis erstellen (1 x 0.5 x 1.2, Farbe Rot)
-        # --------------------------
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # --------------------------
-        # Gabel (Fork) erstellen: Zwei Zähne
-        # --------------------------
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-
-        # Speichere den Gabel-Knoten als Python-Tag am Fahrzeug
-        vehicle_node.setPythonTag("fork_node", fork_node)
-
-        # --------------------------
-        # Erzeuge den grünen Referenzmarker (Gabel – grüner Punkt)
-        # --------------------------
-        ls_new = LineSegs()
-        ls_new.setThickness(2.0)
-        ls_new.setColor(1, 1, 1, 1)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_corner_global = fork_node.getPos() + left_corner_local
-        right_corner_global = fork_node.getPos() + right_corner_local
-        ls_new.moveTo(left_corner_global)
-        ls_new.drawTo(right_corner_global)
-        vehicle_node.attachNewNode(ls_new.create())
-        midpoint = (left_corner_global + right_corner_global) * 0.5
-        white_line_vec = right_corner_global - left_corner_global
-        white_line_dir = white_line_vec.normalized() if white_line_vec.length() != 0 else Vec3(0, 0, 0)
-        candidate = Vec3(-white_line_dir.getY(), white_line_dir.getX(), 0)
-        perp_direction = candidate.normalized() if candidate.length() != 0 else Vec3(0, 0, 0)
-        green_point_global = midpoint + perp_direction * 0.5
-
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        # Speichere den grünen Marker ebenfalls als Python-Tag
-        vehicle_node.setPythonTag("fork_green", green_marker_np)
-
-        # --------------------------
-        # Mast und weitere Fahrzeugteile
-        # --------------------------
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-        self.add_diagonals_to_mast(mast_node)
-        intersection = Vec3(0.5, 0.05, 1.0)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-        self.vehicle_cylinder = cylinder_node
-
-        # --------------------------
-        # Fahrzeugpositionierung am Parkpunkt
-        # --------------------------
-        if park_point is None:
-            vehicle_node.setPos(intersection.x, intersection.y, 0)
-        else:
-            vehicle_node.setPos(park_point - vehicle_node.getQuat().xform(intersection))
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        # Verwende die simulative Zeit, die bereits in update_sim_clock hochgezählt wird
-        t = self.sim_clock
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    # -----------------------------------
-    # FEHLENDE METHODEN: Paketspawning, Würfelerzeugung u.a.
-    # -----------------------------------
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Bestimme zufällig eine Abgabestation als Ziel
-        if hasattr(self, "abgabe_stations") and self.abgabe_stations:
-            target_index = random.randint(1, len(self.abgabe_stations))
-        else:
-            target_index = 1
-
-        # Erstelle den Auftrag zur Annahmestation
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def update_order_table(self):
-        """
-        Aktualisiert die Auftragsübersicht in der Tkinter-Tabelle und zeigt in der
-        letzten Spalte den zugewiesenen Fahrzeugnamen (oder "-" falls noch keiner zugeordnet wurde).
-        """
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen (z. B. "annahme_station_3") die Stationsnummer.
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z. B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige in der letzten Spalte den zugewiesenen Fahrzeugnamen an (oder "-" falls noch kein Fahrzeug zugewiesen ist).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END, values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = 5.0  # 5 Sekunden Verzögerung zwischen Spawns
-        for station in self.annahme_stations:
-            # Wenn aktuell kein Paket an der Station ist
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                # Prüfe, ob seit der letzten Entnahme mindestens 5 Sekunden vergangen sind
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0.0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Wir legen hier die Spalten in der gewünschten Reihenfolge an: Auftrags ID, Annahmestation, Ziel, Fahrzeug.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Hole die fahrzeugspezifischen Knoten mittels getPythonTag
-            fork_node = vehicle.getPythonTag("fork_node")
-            fork_green = vehicle.getPythonTag("fork_green")
-
-            # Hole die Position des grünen Markers relativ zum Gabelknoten
-            green_point_pos = fork_green.getPos(fork_node)
-
-            # Reparent das Paket zur Gabel des Fahrzeugs und positioniere es entsprechend
-            package.wrtReparentTo(fork_node)
-            package.setPos(
-                green_point_pos.getX() + 0.5,  # Offset in X-Richtung
-                green_point_pos.getY() - 0.5,  # Offset in Y-Richtung
-                green_point_pos.getZ() + 1  # Z-Offset, sodass das Paket oberhalb liegt
-            )
-
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    from direct.task.TaskManagerGlobal import taskMgr  # Sicherstellen, dass taskMgr verfügbar ist
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden removeCargoTask aufruft,
-            # und übergib dabei das cargo als extra Argument:
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return Task.done
-
-    def select_next_order(self, vehicle):
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        for order in waiting_orders:
-            dwell_time = self.sim_clock - order.get("spawn_time", self.sim_clock)
-            order["dwell_time"] = dwell_time
-
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        vehicle_pos = vehicle.getPos(self.render)
-
-        def distance_to_station(order):
-            station = order.get("pickup_station")
-            if station:
-                station_pos = station.getPos(self.render)
-                return (station_pos - vehicle_pos).length()
-            return float('inf')
-
-        candidates.sort(key=distance_to_station)
-        chosen_order = candidates[0]
-        chosen_order["vehicle"] = f"Fahrzeug {vehicle.getPythonTag('vehicle_id')}"
-        return chosen_order
-
-    def vehicle_order_task(self, vehicle, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-
-        # Wenn das Fahrzeug im "idle"-Zustand steht, soll es nichts tun.
-        if vehicle.getPythonTag("order_state") == "idle":
-            return task.cont
-
-        state = vehicle.getPythonTag("order_state")
-        current_order = vehicle.getPythonTag("current_order")
-
-        # ------------------ Phase 1: Translate ------------------
-        if state == "translate":
-            if current_order is None:
-                next_order = self.select_next_order(vehicle)
-                if next_order is not None:
-                    vehicle.setPythonTag("current_order", next_order)
-                    next_order["status"] = "In Bearbeitung"
-                    print(
-                        f"Auftrag {next_order['id']} wird zugewiesen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}.")
-                else:
-                    print("Kein Auftrag verfügbar – Fallback zum globalen Ziel.")
-            current_order = vehicle.getPythonTag("current_order")
-            if current_order is not None:
-                pickup_station = current_order.get("pickup_station")
-                if pickup_station in self.station_blue_dots:
-                    blue_target = self.station_blue_dots[pickup_station].getPos(self.render)
-                else:
-                    blue_target = self.blue_dot.getPos(self.render)
-            else:
-                blue_target = self.blue_dot.getPos(self.render)
-            local_mast = Vec3(0.5, 0.05, 1.0)
-            mast_global = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(local_mast)
-            target_xy = Vec2(blue_target.getX(), blue_target.getY())
-            mast_xy = Vec2(mast_global.getX(), mast_global.getY())
-            error_vector = target_xy - mast_xy
-            threshold = 0.05
-            if error_vector.length() > threshold:
-                direction = error_vector.normalized()
-                move_distance = 1.5 * dt
-                current_pos = vehicle.getPos(self.render)
-                new_pos = Vec3(current_pos.getX() + direction.getX() * move_distance,
-                               current_pos.getY() + direction.getY() * move_distance, 0)
-                vehicle.setPos(new_pos)
-            else:
-                local_offset = vehicle.getQuat(self.render).xform(local_mast)
-                exact_pos = Vec3(blue_target.getX() - local_offset.getX(),
-                                 blue_target.getY() - local_offset.getY(), 0)
-                vehicle.setPos(exact_pos)
-                vehicle.setPythonTag("order_state", "rotate")
-
-        # ------------------ Phase 2: Rotate ------------------
-        elif state == "rotate":
-            desired_angle = math.degrees(math.atan2(self.station_white_direction.getY(),
-                                                    self.station_white_direction.getX()))
-            desired_angle = (desired_angle + 180) % 360
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_angle - current_heading + 180) % 360) - 180
-            kp_heading = 0.5
-            new_heading = current_heading + kp_heading * angle_diff
-            vehicle.setH(new_heading)
-            if abs(angle_diff) < 1.0:
-                vehicle.setPythonTag("order_state", "turn_right")
-
-        # ------------------ Phase 3: Turn Right ------------------
-        elif state == "turn_right":
-            if vehicle.getPythonTag("turn_right_init") is None:
-                vehicle.setPythonTag("turn_right_init", vehicle.getH() % 360)
-                vehicle.setPythonTag("turn_right_target", (vehicle.getPythonTag("turn_right_init") + 90) % 360)
-                print("Phase 3: Initialisiert für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "Start Heading =", vehicle.getPythonTag("turn_right_init"),
-                      "Target Heading =", vehicle.getPythonTag("turn_right_target"))
-            current_heading = vehicle.getH() % 360
-            turn_right_target = vehicle.getPythonTag("turn_right_target")
-            angle_diff = ((turn_right_target - current_heading + 180) % 360) - 180
-            kp_turn = 0.5
-            turn_rate = kp_turn * angle_diff
-            new_heading = current_heading + turn_rate * dt
-            vehicle.setH(new_heading)
-            print("Phase 3: Fahrzeug", vehicle.getPythonTag("vehicle_id"), "- Aktuelles Heading =", current_heading,
-                  "Winkelabweichung =", angle_diff, "Neues Heading =", new_heading)
-            if abs(angle_diff) < 1.0:
-                print("Phase 3: Drehung abgeschlossen für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      ". Übergang in 'approach'.")
-                vehicle.setPythonTag("order_state", "approach")
-                vehicle.clearPythonTag("turn_right_init")
-                vehicle.clearPythonTag("turn_right_target")
-
-        # ------------------ Phase 4: Approach ------------------
-        elif state == "approach":
-            if current_order is not None:
-                pickup_station = current_order.get("pickup_station")
-                target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-            else:
-                target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-            current = vehicle.getPos(self.render)
-            error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-            if error_vec.length() > 0.05:
-                direction = error_vec.normalized()
-                move_distance = 1.5 * dt
-                new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                               current.getY() + direction.getY() * move_distance, target.getZ())
-                vehicle.setPos(new_pos)
-            else:
-                vehicle.setPos(target)
-                vehicle.setPythonTag("order_state", "pickup")
-
-        # ------------------ Phase 5: Pickup ------------------
-        elif state == "pickup":
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            target_z = 1.0
-            raise_speed = 0.5
-            if current_z < target_z:
-                fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-            else:
-                if current_order is None:
-                    if self.orders_queue:
-                        vehicle.setPythonTag("current_order", self.orders_queue.pop(0))
-                    else:
-                        print("Keine verfügbaren Aufträge für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                              ". Überspringe Pickup-Phase.")
-                        vehicle.setPythonTag("order_state", "drive_out")
-                        return task.cont
-                pickup_station = vehicle.getPythonTag("current_order")["pickup_station"]
-                self.pickup_package(vehicle, pickup_station)
-                vehicle.setPythonTag("package_attached", True)
-                vehicle.setPythonTag("drive_out_start", vehicle.getPos(self.render))
-                vehicle.setPythonTag("drive_out_target",
-                                     vehicle.getPos(self.render) + vehicle.getQuat(self.render).getForward() * 5.0)
-                vehicle.setPythonTag("order_state", "drive_out")
-
-        # ------------------ Phase 6: Drive Out ------------------
-        elif state == "drive_out":
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            if current_z > 0.0:
-                lower_speed = 0.5
-                fork_node.setZ(max(0.0, current_z - lower_speed * dt))
-            current_pos = vehicle.getPos(self.render)
-            drive_out_target = vehicle.getPythonTag("drive_out_target")
-            diff = drive_out_target - current_pos
-            if diff.length() > 0.1:
-                move_distance = 0.5 * dt
-                step = diff.normalized() * move_distance
-                vehicle.setPos(current_pos + step)
-            else:
-                vehicle.setPythonTag("order_state", "to_delivery")
-
-        # ------------------ Phase 7: To Delivery ------------------
-        elif state == "to_delivery":
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current_pos = vehicle.getPos(self.render)
-            diff = blue_target - current_pos
-            threshold = 0.5
-            move_distance = 1.5 * dt
-            if move_distance > diff.length():
-                vehicle.setPos(blue_target)
-            else:
-                vehicle.setPos(current_pos + diff.normalized() * move_distance)
-            if (blue_target - vehicle.getPos(self.render)).length() <= threshold:
-                print("Phase 7 abgeschlossen: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "hat den blauen Punkt der Abgabestation erreicht.")
-                vehicle.setPythonTag("order_state", "align_delivery")
-
-        # ------------------ Phase 8: Align Delivery ------------------
-        elif state == "align_delivery":
-            desired_heading = 90.0
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_heading - current_heading + 180) % 360) - 180
-            print("Phase 8: Align Delivery | Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                  "Current Heading: {:.2f}°, Desired: {:.2f}°, Diff: {:.2f}°".format(current_heading, desired_heading,
-                                                                                     angle_diff))
-            fixed_turn_speed = 90.0
-            turn_amount = fixed_turn_speed * dt
-            if abs(angle_diff) < 1.0:
-                vehicle.setH(desired_heading)
-                print("Phase 8 abgeschlossen: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "ausgerichtet (Heading = {:.2f}°).".format(desired_heading))
-                vehicle.setPythonTag("order_state", "delivery_center")
-            else:
-                if angle_diff > 0:
-                    new_heading = current_heading + turn_amount
-                else:
-                    new_heading = current_heading - turn_amount
-                new_heading %= 360
-                vehicle.setH(new_heading)
-                print("Phase 8: Rotating - Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "New Heading set to {:.2f}°".format(new_heading))
-
-        # ------------------ Phase 9: Delivery Approach ------------------
-        elif state == "delivery_center":
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current = vehicle.getPos(self.render)
-            target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-            print("Phase 9: Zielpunkt der Abgabestation für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                  "=", target_point)
-            error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-            tolerance = 0.05
-            move_distance = 1.5 * dt
-            if error_vec.length() > tolerance:
-                direction = error_vec.normalized()
-                new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                               current.getY() + direction.getY() * move_distance,
-                               current.getZ())
-                vehicle.setPos(new_pos)
-                print("Phase 9: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "bewegt sich von", current, "nach", new_pos)
-            else:
-                vehicle.setPos(target_point)
-                print("Phase 9: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "hat den Zielpunkt erreicht.")
-                vehicle.setPythonTag("order_state", "drop")
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_fork_z = fork_node.getZ()
-            if current_fork_z < 1.0:
-                new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-                fork_node.setZ(new_fork_z)
-                print("Phase 9: Gabel wird angehoben für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "(Z =", new_fork_z, ").")
-
-        # ------------------ Phase 10: Dropoff ------------------
-        elif state == "drop":
-            if vehicle.getPythonTag("package_attached"):
-                delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-                self.drop_cargo(vehicle)
-                print("Phase 10: Paket abgesetzt für Fahrzeug", vehicle.getPythonTag("vehicle_id"))
-                vehicle.setPythonTag("package_attached", False)
-            else:
-                fork_node = vehicle.getPythonTag("fork_node")
-                current_z = fork_node.getZ()
-                if current_z > 0.0:
-                    lower_speed = 0.5
-                    new_z = max(0.0, current_z - lower_speed * dt)
-                    fork_node.setZ(new_z)
-                    print("Phase 10: Gabel wird abgesenkt für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          ", aktueller Z-Wert =", new_z)
-                else:
-                    print("Phase 10: Dropoff vollständig abgeschlossen für Fahrzeug",
-                          vehicle.getPythonTag("vehicle_id"))
-                    # Hier prüfen wir das Standby-Flag
-                    if vehicle.getPythonTag("standby_pending"):
-                        vehicle.setPythonTag("order_state", "return_to_garage")
-                        print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} kehrt zur Garage zurück (Standby).")
-                    else:
-                        vehicle.setPythonTag("order_state", "translate")
-                    current_order["status"] = "Abgegeben"
-                    current_order["delivered_at"] = self.sim_clock
-                    vehicle.setPythonTag("current_order", None)
-
-        # ------------------ Neue Phase: Return to Garage (Standby) ------------------
-        elif state == "return_to_garage":
-            garage_target = vehicle.getPythonTag("garage_target")
-            if garage_target is None:
-                garage_target = self.garagen_parking_points[0]
-            current_pos = vehicle.getPos(self.render)
-            diff = garage_target - current_pos
-            if diff.length() > 0.1:
-                move_distance = 1.0 * dt  # Geschwindigkeit zur Garage
-                new_pos = current_pos + diff.normalized() * move_distance
-                vehicle.setPos(new_pos)
-            else:
-                vehicle.setPythonTag("order_state", "idle")
-                vehicle.setPythonTag("standby_pending", False)
-                print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} ist in der Garage (Standby).")
-
-        # ------------------ Phase 11: Exit Station and Start Next Order ------------------
-        elif state == "phase11":
-            if vehicle.getPythonTag("last_delivery_marker") is not None:
-                target_point = vehicle.getPythonTag("last_delivery_marker")
-            else:
-                delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    target_point = self.abgabe_blue_dots[0].getPos(self.render)
-                print("Phase 11: Zielpunkt (blauer Marker) für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "=", target_point)
-                current_pos = vehicle.getPos(self.render)
-                diff = target_point - current_pos
-                if diff.length() > 0.1:
-                    move_distance = 0.5 * dt
-                    step = diff.normalized() * move_distance
-                    vehicle.setPos(current_pos + step)
-                    print("Phase 11: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          "fährt aus der Station, neue Position =", current_pos + step)
-                else:
-                    vehicle.setPos(target_point)
-                    print("Phase 11: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          "hat den blauen Marker erreicht. Nächster Auftrag wird gestartet.")
-                    vehicle.setPythonTag("order_state", "next_order")
-
-        return task.cont
-
-    # Neue Methode: Kontrollfenster zur Fahrzeugsteuerung
-    def show_vehicle_control(self):
-        if hasattr(self, "control_win") and self.control_win.winfo_exists():
-            self.control_win.deiconify()
-            self.control_win.lift()
-            return
-        self.control_win = tk.Toplevel()
-        self.control_win.title("Fahrzeugsteuerung")
-        self.vehicle_state_vars = {}
-        row = 0
-        for veh in self.garage_vehicles:
-            frame = tk.Frame(self.control_win)
-            frame.grid(row=row, column=0, sticky="w", padx=5, pady=2)
-            vid = veh.getPythonTag("vehicle_id")
-            label = tk.Label(frame, text=f"Fahrzeug {vid}")
-            label.pack(side=tk.LEFT)
-            state = veh.getPythonTag("order_state")
-            if state is None:
-                state = "idle"
-            var = tk.StringVar(value=state)
-            self.vehicle_state_vars[veh] = var
-            rb_active = tk.Radiobutton(frame, text="Aufträge bearbeiten", variable=var, value="translate")
-            rb_active.pack(side=tk.LEFT)
-            rb_standby = tk.Radiobutton(frame, text="Standby", variable=var, value="idle")
-            rb_standby.pack(side=tk.LEFT)
-            row += 1
-        update_btn = tk.Button(self.control_win, text="Übernehmen", command=self.update_vehicle_control)
-        update_btn.grid(row=row, column=0, pady=5)
-
-    def update_vehicle_control(self):
-        for veh, var in self.vehicle_state_vars.items():
-            new_state = var.get()
-            if new_state == "idle" and veh.getPythonTag("current_order") is not None:
-                veh.setPythonTag("standby_pending", True)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Standby angefordert (Auftrag wird fortgesetzt).")
-            else:
-                veh.setPythonTag("standby_pending", False)
-                veh.setPythonTag("order_state", new_state)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Zustand auf {new_state} gesetzt.")
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: KI/KI30.py
===================================================================
diff --git a/KI/KI30.py b/KI/KI30.py
deleted file mode 100644
--- a/KI/KI30.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,568 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Matplotlib zum Plotten importieren
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs
-)
-
-# Wir nutzen globalClock für dt.
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit
-        self.base_speed = 1.5
-        # Zeitskalierungsfaktor
-        self.speed_factor = 1.0
-        # Simulationszeitticker (simulierte Sekunden)
-        self.sim_clock = 0.0
-        # Zähler der abgegebenen Pakete
-        self.delivered_packages = 0
-        # Maximale Liegedauer (über die gesamte Simulation)
-        self.max_overall_wait_time = 0.0
-        # Gesamte Liegedauer und Zähler für Durchschnittsberechnung
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        self.sim_start_real = globalClock.getFrameTime()
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-        # Erstelle 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Zeichne für jede Annahmestation den Align-Punkt (2m in positive X-Richtung).
-        for station in self.annahme_stationen:
-            station_pos = station.getPos()
-            ls_pickup = LineSegs()
-            ls_pickup.setThickness(3.0)
-            ls_pickup.setColor(LColor(1, 1, 1, 1))
-            ls_pickup.moveTo(station_pos)
-            ls_pickup.drawTo(station_pos + Vec3(2, 0, 0))
-            self.render.attachNewNode(ls_pickup.create())
-
-        # Zeichne für jede Abgabestation den Align-Punkt (2m in negative X-Richtung).
-        for station in self.abgabe_stationen:
-            station_pos = station.getPos()
-            ls_dropoff = LineSegs()
-            ls_dropoff.setThickness(3.0)
-            ls_dropoff.setColor(LColor(1, 1, 1, 1))
-            ls_dropoff.moveTo(station_pos)
-            ls_dropoff.drawTo(station_pos + Vec3(-2, 0, 0))
-            self.render.attachNewNode(ls_dropoff.create())
-
-        # Fahrzeuge initialisieren.
-        self.vehicles = []
-        self.cargos = {}              # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}    # Fahrzeug -> zugewiesene Dropoff-Station
-
-        # Fahrzeug 1
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-        self.add_center_marker(vehicle1)
-        self.add_offset_circle(vehicle1, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Fahrzeug 2 (später gestartet)
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-        self.add_center_marker(vehicle2)
-        self.add_offset_circle(vehicle2, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Neue Funktionalität: Erfassung von Daten für Graphen.
-        # Es werden Daten (Simulationszeit, Pakete pro Minute, durchschnittliche Liegedauer) einmal pro Simulationssekunde erfasst.
-        self.graph_data = []
-        self.taskMgr.doMethodLater(1, self.record_graph_data, "RecordGraphDataTask")
-
-        # Statt den Graphen sofort zu initialisieren und zu aktualisieren,
-        # öffnen wir diesen erst beim Drücken der Taste G.
-        # Mit dem "close_event" wird außerdem sichergestellt, dass nach Schließen
-        # das Fenster wieder neu geöffnet werden kann.
-        self.graph_opened = False
-        self.accept("g", self.open_graph)
-
-        # Aufgaben
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_vehicle2_start, "CheckVehicle2StartTask")
-        self.taskMgr.add(self.update_lidar_status, "UpdateLidarStatusTask")
-
-        # Liefervorgang starten (Pickup-Phase)
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()  # Initialisiert das Matplotlib-Fenster
-            # Bei Schließen des Graphenfensters wird der Callback ausgelöst,
-            # der das Flag zurücksetzt und den Update-Task entfernt.
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def on_graph_close(self, event):
-        # Diese Methode wird aufgerufen, wenn das Graphenfenster geschlossen wird.
-        self.graph_opened = False
-        # Entferne den Update-Task, damit keine Updates mehr an das geschlossene Fenster gesendet werden.
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def init_graph(self):
-        plt.ion()  # Interaktiven Modus aktivieren.
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        # Oberer Plot: Pakete pro Minute
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        # Unterer Plot: Durchschnittliche Liegedauer
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschn. Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        # Update des oberen Diagramms (Pakete pro Minute)
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        # Update des unteren Diagramms (Durchschnittliche Liegedauer)
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def record_graph_data(self, task):
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0
-        self.graph_data.append((self.sim_clock, delivered_per_minute, avg_dwell_time))
-        return Task.again
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def add_offset_circle(self, vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5, num_segments=32):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        for i in range(num_segments + 1):
-            angle = 2 * math.pi * i / num_segments
-            x = circle_radius * math.cos(angle)
-            y = circle_radius * math.sin(angle)
-            if i == 0:
-                ls.moveTo(x, y, 0)
-            else:
-                ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        circle_np = vehicle.attachNewNode(circle_geom)
-        circle_np.setPos(offset)
-        vehicle.setPythonTag("lidar_circle", circle_np)
-
-    def draw_coordinate_axes(self, axis_length=5):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(1, 0, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        ls.setColor(0, 1, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        ls.setColor(0, 0, 1, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), (1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), (0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), (0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def update_lidar_status(self, task):
-        sensor_threshold = 3.0
-        for vehicle in self.vehicles:
-            if vehicle.hasPythonTag("lidar_circle"):
-                lidar_circle = vehicle.getPythonTag("lidar_circle")
-                pos = vehicle.getPos(self.render)
-                collision = False
-                avoidance_vec = Vec3(0, 0, 0)
-                for other in self.vehicles:
-                    if other is not vehicle:
-                        pos_other = other.getPos(self.render)
-                        diff = pos - pos_other
-                        if diff.length() < sensor_threshold:
-                            collision = True
-                            if diff.length() > 0:
-                                avoidance_vec += diff.normalized() * (sensor_threshold - diff.length())
-                if collision:
-                    lidar_circle.setColor(LColor(1, 0, 0, 1))
-                    vehicle.setPythonTag("avoidance", avoidance_vec)
-                    vehicle.setPythonTag("speed_multiplier", 0.5)
-                else:
-                    lidar_circle.setColor(LColor(0, 1, 0, 1))
-                    vehicle.setPythonTag("avoidance", Vec3(0, 0, 0))
-                    vehicle.setPythonTag("speed_multiplier", 1.0)
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-        current_wait_text = (f"Liegedauer (aktuell): {current_max_wait_time:.1f}s"
-                             if current_max_wait_time > 0 else "Kein Paket an Annahmestation")
-        maximal_wait_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted_time}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-            f"{current_wait_text}\n"
-            f"{maximal_wait_text}\n"
-            f"Liegedauer (Durchschnitt): {avg_dwell_time:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def check_vehicle2_start(self, task):
-        if self.sim_clock >= 8.0 and not hasattr(self, 'vehicle2_started'):
-            self.vehicle2_started = True
-            self.start_delivery_cycle(self.vehicles[1], self.vehicles[1].getPos())
-            return Task.done
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(
-            station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1)
-        )
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            to_target = target - current_pos
-            distance = to_target.length()
-            multiplier = vehicle.getPythonTag("speed_multiplier") if vehicle.hasPythonTag("speed_multiplier") else 1.0
-            effective_speed = self.base_speed * self.speed_factor * multiplier
-            step_distance = effective_speed * dt
-            if distance <= step_distance:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-            avoidance = vehicle.getPythonTag("avoidance") if vehicle.hasPythonTag("avoidance") else Vec3(0, 0, 0)
-            if avoidance.length() > 0.001:
-                combined = to_target.normalized() + avoidance.normalized() * 0.5
-                combined.normalize()
-                new_direction = combined
-            else:
-                new_direction = to_target.normalized()
-            vehicle.setPos(current_pos + new_direction * step_distance)
-            return Task.cont
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        # Für Pickup: zuerst zum Align-Punkt (auf der Linie) und dann zur Stationsmitte.
-        pickup_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        self.move_vehicle_to(vehicle, pickup_align,
-            lambda: self.move_vehicle_to(
-                vehicle,
-                pickup_station.getPos(),
-                lambda: self.after_pickup(vehicle, pickup_station)
-            )
-        )
-
-    def after_pickup(self, vehicle, pickup_station):
-        self.pickup_package(vehicle, pickup_station)
-        # Departiere jetzt von der Pickup-Stationsmitte (analog zur Dropoff-Abfahrt)
-        self.depart_from_pickup(vehicle, pickup_station,
-            lambda: self.start_dropoff_phase(vehicle)
-        )
-
-    def depart_from_pickup(self, vehicle, pickup_station, callback):
-        # Bei Pickup-Stations gibt die Linie in positive X-Richtung vor.
-        departure_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        departure_target = pickup_station.getPos() + Vec3(4, 0, 0)
-        self.move_vehicle_to(vehicle, departure_align,
-            lambda: self.move_vehicle_to(vehicle, departure_target, callback)
-        )
-
-    def start_dropoff_phase(self, vehicle):
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.start_dropoff_phase(vehicle)
-            return
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        # Für Dropoff: zuerst zum Align-Punkt (negative X-Richtung) und dann zur Stationsmitte.
-        dropoff_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-        self.move_vehicle_to(vehicle, dropoff_align,
-            lambda: self.move_vehicle_to(vehicle, dropoff_station.getPos(),
-                lambda: self.after_dropoff(vehicle)
-            )
-        )
-
-    def after_dropoff(self, vehicle):
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        self.drop_cargo(vehicle)
-        self.remove_cargo(vehicle, remove_dropoff=True)
-        if dropoff_station is not None:
-            departure_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-            departure_target = dropoff_station.getPos() + Vec3(-4, 0, 0)
-            self.move_vehicle_to(vehicle, departure_align,
-                lambda: self.move_vehicle_to(vehicle, departure_target,
-                    lambda: self.start_delivery_cycle(vehicle, departure_target)
-                )
-            )
-        else:
-            self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle, remove_dropoff=True):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        if remove_dropoff:
-            dropoff_station = self.current_dropoffs.get(vehicle)
-            if dropoff_station in self.occupied_dropoffs:
-                self.occupied_dropoffs.remove(dropoff_station)
-            if vehicle in self.current_dropoffs:
-                del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
Index: FFZ/FFZ9.py
===================================================================
diff --git a/FFZ/FFZ9.py b/FFZ/FFZ9.py
deleted file mode 100644
--- a/FFZ/FFZ9.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,313 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    CardMaker,
-    LineSegs,
-    Vec3
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import math
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte für Simulationszeit und -geschwindigkeit
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kameraeinstellungen (Annahme: Fahrtrichtung entlang der Y-Achse)
-        self.cam.setPos(0, -30, 10)
-        self.cam.lookAt(0, 0, 0)
-
-        # Licht und Raster
-        self.setup_light()
-        self.create_grid(center_extent=10, cell_size=0.1)
-
-        # Fahrzeug erstellen und Referenz speichern
-        self.vehicle = self.create_vehicle()
-
-        # Slider zur Anpassung der Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Slider zur Steuerung der Forkhöhe (0 bis 1 Meter)
-        self.fork_slider = DirectSlider(
-            range=(0.0, 1.0),
-            value=0.0,
-            pageSize=0.01,
-            command=self.update_fork_height,
-            pos=(-0.7, 0, -0.85),
-            scale=0.3
-        )
-        self.fork_label = DirectLabel(
-            text="Fork Höhe: 0.00m",
-            pos=(-0.7, 0, -0.75),
-            scale=0.07
-        )
-
-        # Anzeige der Laufzeit
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktionalität
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben hinzufügen
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_cable, "UpdateCableTask")
-        # Das Fahrzeug fährt stationär.
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_fork_height(self, height=0, *args):
-        try:
-            height = float(height)
-        except ValueError:
-            height = 0.0
-        self.fork_node.setZ(height)
-        self.fork_label['text'] = f"Fork Höhe: {height:.2f}m"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def create_grid(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            x += cell_size
-
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        grid_np = self.render.attachNewNode(node)
-        grid_np.setColor(0.7, 0.7, 0.7, 1)
-        return grid_np
-
-    def setup_light(self):
-        ambient_light = AmbientLight("ambient_light")
-        ambient_light.setColor((0.5, 0.5, 0.5, 1))
-        ambient_np = self.render.attachNewNode(ambient_light)
-        self.render.setLight(ambient_np)
-
-        directional_light = DirectionalLight("directional_light")
-        directional_light.setColor((1, 1, 1, 1))
-        directional_np = self.render.attachNewNode(directional_light)
-        directional_np.setPos(10, -10, 10)
-        self.render.setLight(directional_np)
-
-    def create_vehicle(self):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Fahrmodul (Chassis)
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-
-        # Gabelmodul (Fork) – hier wird ein Elternknoten angelegt,
-        # unter dem die zwei Zähne (linker und rechter Zahn) angeordnet werden.
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-        self.fork_node = fork_node
-
-        # Mast – Erstelle einen Rahmen, der nur die Kanten in X- und Z-Richtung besitzt.
-        mast_node = vehicle_node.attachNewNode("mast")
-        # Top-Bar
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        # Bottom-Bar
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        # Left-Bar
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        # Right-Bar
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-
-        # Hier fügen wir die Diagonalen ein:
-        self.add_diagonals_to_mast(mast_node)
-
-        vehicle_node.setPos(-0.5, 0, 0)
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        """
-        Zeichnet zwei Diagonalen auf der oberen Fläche des Mastes.
-        Die obere Fläche (des Top-Bars) erstreckt sich in den Mast-Koordinaten
-        von (0, 0, 1.0) bis (1, 0.1, 1.0).
-        Die Diagonalen verbinden:
-          - (0, 0, 1.0) mit (1, 0.1, 1.0)
-          - (1, 0, 1.0) mit (0, 0.1, 1.0)
-        """
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)  # Orange
-        # Diagonale 1
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        # Diagonale 2
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        # Unterseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        # Oberseite
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        # Vorderseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        # Rückseite
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        # Linke Seite
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        # Rechte Seite
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def update_cable(self, task):
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)  # Werte zwischen 0 und 1
-        self.fork_node.setZ(new_height)
-        self.fork_label['text'] = f"Fork Höhe: {new_height:.2f}m"
-        return Task.cont
-
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: Feld/Feld2.py
===================================================================
diff --git a/Feld/Feld2.py b/Feld/Feld2.py
deleted file mode 100644
--- a/Feld/Feld2.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,220 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec3
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import math
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte für Simulationszeit und -geschwindigkeit
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kameraeinstellungen: So, dass das gesamte Feld gut sichtbar ist
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # Erzeuge Licht und Bodenraster
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-
-        # Erzeuge die Mauer (die vier Segmente schließen exakt ein Rechteck ab).
-        # Die vier Eckpunkte lauten:
-        # (0, 0, 0), (0, 60, 0), (22, 60, 0) und (22, 0, 0).
-        self.create_wall()
-
-        # Slider zur Anpassung der Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Anzeige der Kennzahlen (z. B. Laufzeit)
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktionalität: Mit Mausrad hereinz- bzw. herauszoomen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben: Simulationszeit aktualisieren und Kennzahlen anzeigen
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        # Horizontale Linien
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        # Vertikale Linien
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        """
-        Fügt ein Wandsegment hinzu – so, dass die innere Kante exakt den
-        Linien zwischen 'start' und 'end' entspricht.
-        Die Berechnungen gehen davon aus, dass die vier Eckpunkte in Clockwise-Reihenfolge angegeben sind.
-        """
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-
-        # Normierter Richtungsvektor entlang des Segments
-        d = seg_vector.normalized()
-        # Da die Punkte in Clockwise vorliegen und das Innere rechts liegt,
-        # berechnen wir den Vektor, der von der inneren Kante wegzeigt:
-        outward = Vec3(-d.getY(), d.getX(), 0)
-
-        # Der ideale Mittelpunkt des Wandstücks:
-        # Er soll (start+end)/2 plus einen Versatz in Richtung outward (thickness/2) haben.
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-
-        # Berechnung des Rotationswinkels in Grad
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-
-        # Wir erstellen einen Container, um das Box-Modell neu zu zentrieren.
-        wall_np = self.render.attachNewNode("wall_np")
-
-        wall = self.loader.loadModel("models/box")
-        # Pivot-Korrektur: Zentriere das Modell anhand seiner Tight Bounds.
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-
-        # Wende die Skalierung, Position und Drehung auf den Container an.
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def create_wall(self):
-        """
-        Erzeugt vier Wandsegmente, die ein Rechteck abschließen.
-        Die vier Eckpunkte lauten exakt:
-            p1 = (0, 0, 0)
-            p2 = (0, 60, 0)
-            p3 = (22, 60, 0)
-            p4 = (22, 0, 0)
-        Das Ergebnis ist eine Mauer, deren innere Kante exakt entlang dieser Punkte verläuft.
-        """
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: KI/KI26.py
===================================================================
diff --git a/KI/KI26.py b/KI/KI26.py
deleted file mode 100644
--- a/KI/KI26.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,549 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs
-)
-
-# Wir nutzen globalClock für dt.
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit
-        self.base_speed = 1.5
-        # Zeitskalierungsfaktor
-        self.speed_factor = 1.0
-        # Simulationszeitticker in simulierten Sekunden
-        self.sim_clock = 0.0
-        # Zähler der abgegebenen Pakete
-        self.delivered_packages = 0
-        # Speichert über die gesamte Simulation die maximal erreichte Liegedauer eines Pakets
-        self.max_overall_wait_time = 0.0
-        # Neue Attribute zur Erfassung der durchschnittlichen Liegedauer (in Sekunden)
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Zeitpunkt des Simulationsstarts (reale Zeit)
-        self.sim_start_real = globalClock.getFrameTime()
-
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-        # Erstelle 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Zeichne für jede Annahmestation eine Linie, die 2 Meter in positive x-Richtung verläuft.
-        for station in self.annahme_stationen:
-            station_pos = station.getPos()
-            ls_pickup = LineSegs()
-            ls_pickup.setThickness(3.0)
-            ls_pickup.setColor(LColor(1, 1, 1, 1))  # Weiß
-            ls_pickup.moveTo(station_pos)
-            ls_pickup.drawTo(station_pos + Vec3(2, 0, 0))
-            self.render.attachNewNode(ls_pickup.create())
-
-        # Zeichne für jede Abgabestation eine Linie, die 2 Meter in negative x-Richtung verläuft.
-        for station in self.abgabe_stationen:
-            station_pos = station.getPos()
-            ls_dropoff = LineSegs()
-            ls_dropoff.setThickness(3.0)
-            ls_dropoff.setColor(LColor(1, 1, 1, 1))
-            ls_dropoff.moveTo(station_pos)
-            ls_dropoff.drawTo(station_pos + Vec3(-2, 0, 0))
-            self.render.attachNewNode(ls_dropoff.create())
-
-        # Fahrzeuge initialisieren – zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}  # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}  # Fahrzeug -> aktuell reservierte Abgabestation
-
-        # Fahrzeug 1: startet sofort.
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-        # Fahrzeugmittelpunkt markieren und Lidar-Kreis hinzufügen.
-        self.add_center_marker(vehicle1)
-        self.add_offset_circle(vehicle1, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Fahrzeug 2: startet 8 simulierte Sekunden später.
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)  # y-Offset von 2 Einheiten.
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-        self.add_center_marker(vehicle2)
-        self.add_offset_circle(vehicle2, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Globaler Pool für Pickup-Pakete und Zeitstempel (in simulierten Sekunden).
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider zur Anpassung des Zeitskalierungsfaktors.
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Info-Anzeige.
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tasks.
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_vehicle2_start, "CheckVehicle2StartTask")
-        # Task zur Aktualisierung der Lidar-Farbe und Kollisionsausweichlogik.
-        self.taskMgr.add(self.update_lidar_status, "UpdateLidarStatusTask")
-
-        # Starte Liefervorgänge.
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-        # Fahrzeug 2 startet, sobald 8 simulierte Sekunden erreicht sind (via Task).
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        """
-        Fügt dem Fahrzeug einen weißen Punkt als Markierung des Fahrzeugmittelpunkts hinzu.
-        """
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def add_offset_circle(self, vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5, num_segments=32):
-        """
-        Zeichnet einen Kreis als Visualisierung der Lidar-Grenze des Fahrzeugs.
-        Der Kreis wird relativ zum Fahrzeug angehängt und über den Offset positioniert.
-        """
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))  # Standard: grün.
-        for i in range(num_segments + 1):
-            angle = 2 * math.pi * i / num_segments
-            x = circle_radius * math.cos(angle)
-            y = circle_radius * math.sin(angle)
-            if i == 0:
-                ls.moveTo(x, y, 0)
-            else:
-                ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        circle_np = vehicle.attachNewNode(circle_geom)
-        circle_np.setPos(offset)
-        vehicle.setPythonTag("lidar_circle", circle_np)
-
-    def draw_coordinate_axes(self, axis_length=5):
-        """
-        Zeichnet ein einfaches Koordinatensystem (Achsen) im Ursprung.
-         - X-Achse in Rot,
-         - Y-Achse in Grün,
-         - Z-Achse in Blau.
-        Zusätzlich werden an den Endpunkten Labels positioniert.
-        """
-        ls = LineSegs()
-        ls.setThickness(2)
-        # X-Achse (Rot)
-        ls.setColor(1, 0, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        # Y-Achse (Grün)
-        ls.setColor(0, 1, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        # Z-Achse (Blau)
-        ls.setColor(0, 0, 1, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-
-        # Achsenbeschriftungen
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), (1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), (0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), (0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def update_lidar_status(self, task):
-        """
-        Aktualisiert die Lidar-Anzeige und berechnet eine zusätzliche Ausweichlogik.
-        Liegt ein anderes Fahrzeug im Abstand < 3 m, wird:
-          - Der Kreis rot gefärbt,
-          - Ein repulsiver Ausweichvektor berechnet,
-          - und der Geschwindigkeitsfaktor auf 0.5 gesetzt.
-        """
-        sensor_threshold = 3.0  # Summe der Lidar-Radien
-        for vehicle in self.vehicles:
-            if vehicle.hasPythonTag("lidar_circle"):
-                lidar_circle = vehicle.getPythonTag("lidar_circle")
-                pos = vehicle.getPos(self.render)
-                collision = False
-                avoidance_vec = Vec3(0, 0, 0)
-                for other in self.vehicles:
-                    if other is not vehicle:
-                        pos_other = other.getPos(self.render)
-                        diff = pos - pos_other
-                        distance = diff.length()
-                        if distance < sensor_threshold:
-                            collision = True
-                            if distance > 0:
-                                avoidance_vec += diff.normalized() * (sensor_threshold - distance)
-                if collision:
-                    lidar_circle.setColor(LColor(1, 0, 0, 1))  # rot
-                    vehicle.setPythonTag("avoidance", avoidance_vec)
-                    vehicle.setPythonTag("speed_multiplier", 0.5)
-                else:
-                    lidar_circle.setColor(LColor(0, 1, 0, 1))  # grün
-                    vehicle.setPythonTag("avoidance", Vec3(0, 0, 0))
-                    vehicle.setPythonTag("speed_multiplier", 1.0)
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-
-        if current_max_wait_time > 0:
-            current_wait_text = f"Liegedauer (aktuell): {current_max_wait_time:.1f}s"
-        else:
-            current_wait_text = "Kein Paket an Annahmestation"
-
-        maximal_wait_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-
-        # Berechne den Durchschnitt der Liegedauer (in Sekunden)
-        if self.picked_up_count > 0:
-            avg_dwell_time = self.total_dwell_time / self.picked_up_count
-        else:
-            avg_dwell_time = 0.0
-
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-
-        if self.sim_clock > 0:
-            delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0)
-        else:
-            delivered_per_minute = 0
-
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted_time}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-            f"{current_wait_text}\n"
-            f"{maximal_wait_text}\n"
-            f"Liegedauer (Durchschnitt): {avg_dwell_time:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def check_vehicle2_start(self, task):
-        if self.sim_clock >= 8.0 and not hasattr(self, 'vehicle2_started'):
-            self.vehicle2_started = True
-            self.start_delivery_cycle(self.vehicles[1], self.vehicles[1].getPos())
-            return Task.done
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(
-            station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1)
-        )
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        """
-        Bewegt ein Fahrzeug schrittweise in Richtung des Zielpunkts.
-        Hier fließt neben der direkten Zielrichtung auch der berechnete Ausweichvektor ein.
-        """
-
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            to_target = target - current_pos
-            distance = to_target.length()
-            # Bestimme den individuellen Geschwindigkeitsfaktor (Standard 1.0)
-            multiplier = 1.0
-            if vehicle.hasPythonTag("speed_multiplier"):
-                multiplier = vehicle.getPythonTag("speed_multiplier")
-            effective_speed = self.base_speed * self.speed_factor * multiplier
-            step_distance = effective_speed * dt
-
-            if distance <= step_distance:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-
-            # Hole den Ausweichvektor (falls vorhanden)
-            avoidance = Vec3(0, 0, 0)
-            if vehicle.hasPythonTag("avoidance"):
-                avoidance = vehicle.getPythonTag("avoidance")
-            if avoidance.length() > 0.001:
-                combined = to_target.normalized() + avoidance.normalized() * 0.5
-                combined.normalize()
-                new_direction = combined
-            else:
-                new_direction = to_target.normalized()
-            vehicle.setPos(current_pos + new_direction * step_distance)
-            return Task.cont
-
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        pickup_pos = pickup_station.getPos()
-
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.occupied_pickups.remove(pickup_station)
-
-            def wait_for_dropoff(task):
-                if any(ds not in self.occupied_dropoffs for ds in self.abgabe_stationen):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_dropoff, f"WaitDropoff_{id(vehicle)}")
-            return
-
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_pos = dropoff_station.getPos()
-
-        self.move_vehicle_to(vehicle, pickup_pos, lambda: self.after_pickup(vehicle, pickup_station, dropoff_pos))
-
-    def after_pickup(self, vehicle, pickup_station, dropoff_pos):
-        self.pickup_package(vehicle, pickup_station)
-        self.move_vehicle_to(vehicle, dropoff_pos, lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        self.drop_cargo(vehicle)
-        start_wait = self.sim_clock
-
-        def wait_task(task):
-            if self.sim_clock - start_wait >= self.sim_time(1):
-                self.finish_cycle(vehicle)
-                return Task.done
-            return Task.cont
-
-        self.taskMgr.add(wait_task, f"WaitAfterDrop_{id(vehicle)}")
-
-    def finish_cycle(self, vehicle):
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            # Erfasse die Liegedauer (Wartezeit) des Pakets und aktualisiere Gesamt- und Zählerwerte.
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        if dropoff_station in self.occupied_dropoffs:
-            self.occupied_dropoffs.remove(dropoff_station)
-            del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
Index: FFZ/FFZ14.py
===================================================================
diff --git a/FFZ/FFZ14.py b/FFZ/FFZ14.py
deleted file mode 100644
--- a/FFZ/FFZ14.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,484 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    LineSegs,
-    Vec3,
-    NodePath
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import random
-import math
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.steering_angle = 0.0  # aktueller Heading-Wert in Grad
-        self.obstacles = []        # Liste der Hindernisse
-
-        # Kameraeinstellungen (Fahrtrichtung: entlang der Y-Achse)
-        self.cam.setPos(0, -30, 10)
-        self.cam.lookAt(0, 0, 0)
-
-        # Licht und Raster
-        self.setup_light()
-        self.create_grid(center_extent=10, cell_size=0.1)
-
-        # Hindernisse zufällig platzieren
-        self.create_obstacles()
-
-        # Fahrzeug erzeugen (bestehend aus Chassis, Fork, Mast, etc.)
-        self.vehicle = self.create_vehicle()
-
-        # Slider für Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3)
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07)
-
-        # Slider zur Einstellung der Forkhöhe (0 bis 1 m)
-        self.fork_slider = DirectSlider(
-            range=(0.0, 1.0),
-            value=0.0,
-            pageSize=0.01,
-            command=self.update_fork_height,
-            pos=(-0.7, 0, -0.85),
-            scale=0.3)
-        self.fork_label = DirectLabel(
-            text="Fork Höhe: 0.00m",
-            pos=(-0.7, 0, -0.75),
-            scale=0.07)
-
-        # Laufzeitanzeige
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0))
-
-        # Zoom über Mausrad
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben hinzufügen:
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_vehicle, "UpdateVehicleTask")  # Fahrzeugbewegung + Hindernisvermeidung
-
-    def create_obstacles(self):
-        """Erstellt zufällige Hindernisse (Boxen) und speichert sie in self.obstacles."""
-        for i in range(10):  # Beispiel: 10 Hindernisse
-            w = random.uniform(0.3, 0.7)
-            d = random.uniform(0.3, 0.7)
-            h = 0.5
-            box = self.create_box(w, d, h, (0.5, 0.5, 0.5, 1))
-            obstacle = self.render.attachNewNode(box)
-            # Positioniere die Hindernisse zentral in einem Bereich von -5 bis 5 in X und Y,
-            # sodass sie auf dem Boden (Z=0) liegen.
-            x = random.uniform(-5, 5)
-            y = random.uniform(-5, 5)
-            obstacle.setPos(x, y, 0)
-            self.obstacles.append(obstacle)
-
-    def update_vehicle(self, task):
-        """Bewegt das Fahrzeug vorwärts und passt die Lenkung an, um Hindernissen auszuweichen."""
-        dt = ClockObject.getGlobalClock().getDt()
-        speed = 2.0  # Geschwindigkeit in Einheiten pro Sekunde
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        # Fahrzeug lenken: Hindernisvermeidung
-        avoid_vector = Vec3(0, 0, 0)
-        for obstacle in self.obstacles:
-            obs_pos = obstacle.getPos(self.render)
-            diff = pos - obs_pos
-            dist = diff.length()
-            # Definiere einen Vermeidungsradius (z.B. 3 Einheiten)
-            if dist < 3.0:
-                # Nur berücksichtigen, wenn das Hindernis vor dem Fahrzeug liegt:
-                if diff.dot(forward) > 0:
-                    strength = (3.0 - dist) / 3.0
-                    avoid_vector += diff.normalized() * strength
-
-        if avoid_vector.length() > 0:
-            # Neuen Zielvektor aus Fahrtrichtung und Vermeidungsvektor
-            desired_dir = (forward + avoid_vector).normalized()
-            # Berechne den gewünschten Heading in Grad (nur in XY-Ebene):
-            desired_heading = math.degrees(math.atan2(desired_dir.getX(), desired_dir.getY()))
-            current_heading = self.vehicle.getH()
-            # Interpolieren (glätten) des Heading-Wechsels:
-            new_heading = current_heading + 0.1 * (desired_heading - current_heading)
-            self.vehicle.setH(new_heading)
-            forward = self.vehicle.getQuat().getForward()
-
-        new_pos = pos + forward * speed * dt
-        self.vehicle.setPos(new_pos)
-
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_fork_height(self, height=0, *args):
-        try:
-            height = float(height)
-        except ValueError:
-            height = 0.0
-        self.fork_node.setZ(height)
-        self.fork_label['text'] = f"Fork Höhe: {height:.2f}m"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def create_grid(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            x += cell_size
-
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        grid_np = self.render.attachNewNode(node)
-        grid_np.setColor(0.7, 0.7, 0.7, 1)
-        return grid_np
-
-    def setup_light(self):
-        ambient_light = AmbientLight("ambient_light")
-        ambient_light.setColor((0.5, 0.5, 0.5, 1))
-        ambient_np = self.render.attachNewNode(ambient_light)
-        self.render.setLight(ambient_np)
-
-        directional_light = DirectionalLight("directional_light")
-        directional_light.setColor((1, 1, 1, 1))
-        directional_np = self.render.attachNewNode(directional_light)
-        directional_np.setPos(10, -10, 10)
-        self.render.setLight(directional_np)
-
-    def create_vehicle(self):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Fahrmodul (Chassis): 1 x 0.5 x 1.2 in Rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        # Schwarze Kanten für das Chassis
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # Gabelmodul (Fork): Zwei Zähne (je 0.2 x 1.2 x 0.1)
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-        self.fork_node = fork_node
-
-        # Mast: Rahmen aus vier Balken
-        mast_node = vehicle_node.attachNewNode("mast")
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-
-        # Diagonalen auf der oberen Fläche des Mastes
-        self.add_diagonals_to_mast(mast_node)
-        # Schnittpunkt der Diagonalen in Mast-Koordinaten:
-        intersection = Vec3(0.5, 0.05, 1.0)
-
-        # Gelber Zylinder: Durchmesser 0.1, Höhe 0.1, Farbe Gelb
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        # Lidar-Kreis: Der Mittelpunkt soll 1 m in negativer Z-Richtung liegen (also Z = -1)
-        lidar_center = Vec3(intersection.x, intersection.y, -1)
-        self.add_lidar_circle(mast_node, lidar_center, 2)
-
-        # Setze den Fahrzeugknoten so, dass er auf der Ebene sitzt (Z=0).
-        # Da alle Bauteile (Chassis, Fork, Mast) als Kind des Fahrzeugknotens aufgebaut sind,
-        # wird beim Setzen von vehicle_node.setPos(0, 0, 0) das gesamte Fahrzeug auf der Ebene liegen.
-        vehicle_node.setPos(0, 0, 0)
-
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)  # Orange
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)  # Grün
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        # Top center
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        # Top circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        # Bottom center
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        # Bottom circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        # Top fan
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        # Bottom fan
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        # Side faces
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        # Unterseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        # Oberseite
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        # Vorderseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        # Rückseite
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        # Linke Seite
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        # Rechte Seite
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        # Unterkante
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        # Oberkante
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        # Vertikale Kanten
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        # Falls du weiterhin eine oszillierende Bewegung der Fork wünschen solltest,
-        # kannst du diese Methode behalten. Andernfalls kann dieser Task entfernt werden.
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: FFZ/FFZ4.py
===================================================================
diff --git a/FFZ/FFZ4.py b/FFZ/FFZ4.py
deleted file mode 100644
--- a/FFZ/FFZ4.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,312 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    CardMaker,
-    LineSegs
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte für Simulationszeit und -geschwindigkeit
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kameraeinstellungen: (Fahrtrichtung wird entlang der Y-Achse angenommen)
-        self.cam.setPos(0, -30, 10)
-        self.cam.lookAt(0, 0, 0)
-
-        # Licht und Raster (Raster-Zellen: 0.1 x 0.1)
-        self.setup_light()
-        self.create_grid(center_extent=10, cell_size=0.1)
-
-        # Fahrzeug erstellen
-        self.create_vehicle()
-
-        # Slider zur Anpassung der Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Anzeige der Laufzeit
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktionalität: Mausrad heran-/herauszoomen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben zur Aktualisierung der Simulationszeit und Anzeige
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def create_grid(self, center_extent=40, cell_size=1):
-        """
-        Erstellt ein Raster in der XY-Ebene (Z=0 entspricht dem Boden)
-        mit der angegebenen Zellengröße.
-        """
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        # Horizontale Linien
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            y += cell_size
-
-        # Vertikale Linien
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            x += cell_size
-
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        grid_np = self.render.attachNewNode(node)
-        grid_np.setColor(0.7, 0.7, 0.7, 1)
-        return grid_np
-
-    def setup_light(self):
-        ambient_light = AmbientLight("ambient_light")
-        ambient_light.setColor((0.5, 0.5, 0.5, 1))
-        ambient_np = self.render.attachNewNode(ambient_light)
-        self.render.setLight(ambient_np)
-
-        directional_light = DirectionalLight("directional_light")
-        directional_light.setColor((1, 1, 1, 1))
-        directional_np = self.render.attachNewNode(directional_light)
-        directional_np.setPos(10, -10, 10)
-        self.render.setLight(directional_np)
-
-    def create_vehicle(self):
-        """
-        Erzeugt ein fahrerloses Transportfahrzeug als 3D-Modell,
-        bestehend aus drei lückenlos verbundenen Modulen:
-
-          • Fahrmodul (Chassis): Größe 1 x 0.5 x 1.2,
-            platziert von (0,0,0) bis (1,0.5,1.2).
-
-          • Gabelmodul (Fork): Größe 1 x 1.2 x 0.2,
-            wird hinten am Fahrmodul angesetzt.
-            (Das Modul wird so verschoben, dass die an das Fahrmodul anstoßende Seite
-             (global y = 0) nicht vom Rahmen überdeckt wird, sondern die freie Seite
-             (global y = -1.2) genutzt wird.)
-
-          • Mast: Größe 1 x 0.1 x 1,
-            sitzt oben auf dem Fahrmodul (beginnt bei z = 1.2) und wird in Y zentriert.
-        """
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Fahrmodul (Chassis) – Farbe: Rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-
-        # Gabelmodul (Fork) – Farbe: Grau, Höhe 0.2
-        box_fork = self.create_box(1, 1.2, 0.2, (0.3, 0.3, 0.3, 1))
-        node_fork = vehicle_node.attachNewNode(box_fork)
-        node_fork.setTwoSided(True)
-        node_fork.setPos(0, -1.2, 0)
-
-        # Füge einen Rahmen mit Diagonalen plus einen Punkt hinzu.
-        self.add_rectangle_to_fork(node_fork)
-
-        # Mast – Farbe: Dunkles Grau (0.2, 0.2, 0.2, 1)
-        box_mast = self.create_box(1, 0.1, 1, (0.2, 0.2, 0.2, 1))
-        node_mast = vehicle_node.attachNewNode(box_mast)
-        node_mast.setTwoSided(True)
-        node_mast.setPos(0, 0.2, 1.2)
-
-        # Zentriere den gesamten Fahrzeugknoten in X
-        vehicle_node.setPos(-0.5, 0, 0)
-
-    def add_rectangle_to_fork(self, fork_node):
-        """
-        Fügt dem übergebenen Gabelmodul-Knoten einen Rahmen hinzu.
-        Es wird ein 1x1-Rahmen (ohne Füllung) mittels LineSegs gezeichnet,
-        der in lokalen XY-Koordinaten von (0,0) bis (1,1) liegt und auf der
-        oberen Fläche (z = 0.201) des Gabelmoduls positioniert wird.
-        Außerdem werden zwei Diagonale eingezeichnet, deren Schnittpunkt
-        (0.5, 0.5, 0.201) ermittelt wird. Von diesem Schnittpunkt wird in Z-Richtung
-        ein Punkt platziert, 0.5 höher, also bei (0.5, 0.5, 0.701).
-        """
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)  # Orange
-
-        # Rahmen zeichnen
-        ls.moveTo(0, 0, 0.201)
-        ls.drawTo(1, 0, 0.201)
-        ls.drawTo(1, 1, 0.201)
-        ls.drawTo(0, 1, 0.201)
-        ls.drawTo(0, 0, 0.201)
-
-        # Diagonale 1: von (0,0) bis (1,1)
-        ls.moveTo(0, 0, 0.201)
-        ls.drawTo(1, 1, 0.201)
-
-        # Diagonale 2: von (1,0) bis (0,1)
-        ls.moveTo(1, 0, 0.201)
-        ls.drawTo(0, 1, 0.201)
-
-        fork_node.attachNewNode(ls.create())
-
-        # Erzeuge den Punkt am Schnitt der Diagonalen.
-        # Der Schnittpunkt der Diagonalen ist bei (0.5, 0.5, 0.201).
-        # Wir setzen den Punkt 0.5 in Z-Richtung höher (also bei z = 0.701).
-        point = loader.loadModel("models/smiley")  # Verwende bspw. das Smiley-Modell als Markierung
-        point.setScale(0.05)
-        point.setPos(0.5, 0.5, 0.701)
-        point.setColor(1, 1, 1, 1)  # z. B. Weiß
-        point.reparentTo(fork_node)
-
-    def create_box(self, width, depth, height, color):
-        """
-        Erzeugt einen vollflächigen Quader (Box) mit den Dimensionen:
-          - Breite (X): width
-          - Tiefe (Y): depth
-          - Höhe (Z): height
-
-        Für jede Seite werden eigene Eckpunkte mit korrekten Normalen erzeugt,
-        sodass das Objekt wirklich solide wirkt.
-        """
-        format = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData('box', format, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, 'vertex')
-        normal = GeomVertexWriter(vdata, 'normal')
-        col = GeomVertexWriter(vdata, 'color')
-
-        # Unterseite (z = 0)
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-
-        # Oberseite (z = height)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-
-        # Vorderseite (y = 0)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-
-        # Rückseite (y = depth)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-
-        # Linke Seite (x = 0)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-
-        # Rechte Seite (x = width)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            triangles.addVertices(base, base + 1, base + 2)
-            triangles.closePrimitive()
-            triangles.addVertices(base, base + 2, base + 3)
-            triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(triangles)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: TestFFZ/TestFFZ2.py
===================================================================
diff --git a/TestFFZ/TestFFZ2.py b/TestFFZ/TestFFZ2.py
deleted file mode 100644
--- a/TestFFZ/TestFFZ2.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,500 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs,
-    CardMaker
-)
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-# Globaler Clock (wird für die Zeitberechnung genutzt)
-globalClock = ClockObject.getGlobalClock()
-
-
-# =============================================================================
-# Klasse für die statische Oberfläche (Boden, Licht, Stationen, GUI usw.)
-# =============================================================================
-class SimulationSurface(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisparameter und Statistik
-        self.base_speed = 1.5  # Maximalgeschwindigkeit (m/s)
-        self.speed_factor = 1.0
-        self.sim_clock = 0.0
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-        self.sim_start_real = globalClock.getFrameTime()
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        # Umgebung und statische Elemente aufbauen
-        self.setup_environment()
-        self.setup_stations()
-        self.setup_UI()
-        self.setup_tasks()
-        self.setup_graph()
-
-        # Mausevents für Zoom
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-    def setup_environment(self):
-        self.erzeuge_licht()
-        self.boden = self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-    def setup_stations(self):
-        # Erzeuge Pickup-Station bei x=-9 und Drop-Station bei x=9
-        self.pickup_station = self.erzeuge_gitterbox(-9, 0, 0, LColor(1, 0, 0, 1))
-        self.drop_station = self.erzeuge_gitterbox(9, 0, 0, LColor(0, 1, 0, 1))
-        # Zeichne Align-Punkte zur Orientierung
-        ls1 = LineSegs()
-        ls1.setThickness(3.0)
-        ls1.setColor(LColor(1, 1, 1, 1))
-        p1 = self.pickup_station.getPos()
-        ls1.moveTo(p1)
-        ls1.drawTo(p1 + Vec3(2, 0, 0))
-        self.render.attachNewNode(ls1.create())
-
-        ls2 = LineSegs()
-        ls2.setThickness(3.0)
-        ls2.setColor(LColor(1, 1, 1, 1))
-        p2 = self.drop_station.getPos()
-        ls2.moveTo(p2)
-        ls2.drawTo(p2 + Vec3(-2, 0, 0))
-        self.render.attachNewNode(ls2.create())
-
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-    def setup_UI(self):
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-    def setup_tasks(self):
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-
-    def setup_graph(self):
-        self.graph_opened = False
-        self.accept("g", self.open_graph)
-        self.graph_data = []  # Für spätere Graph-Aktualisierungen
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in [self.pickup_station, self.drop_station]:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            current_max = max(current_max, elapsed)
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        current_text = f"Liegedauer (aktuell): {current_max:.1f}s" if current_max > 0 else "Kein Paket"
-        maximal_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-        avg_val = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        delivered = self.delivered_packages
-        ppm = delivered / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\nAbgegebene Pakete: {delivered}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n{current_text}\n{maximal_text}\n"
-            f"Durchschn. Liegedauer: {avg_val:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n = 0
-        mi = -center_extent - 0.5
-        ma = center_extent + 0.5
-        y = mi
-        while y <= ma:
-            writer.addData3(mi, y, 0)
-            writer.addData3(ma, y, 0)
-            lines.addVertices(n, n + 1)
-            n += 2
-            y += cell_size
-        x = mi
-        while x <= ma:
-            writer.addData3(x, mi, 0)
-            writer.addData3(x, ma, 0)
-            lines.addVertices(n, n + 1)
-            n += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        box = self.loader.loadModel("models/box")
-        box.setScale(1, 1, 1)
-        box.setPos(x, y, z)
-        box.setColor(farbe)
-        box.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        box.reparentTo(self.render)
-        return box
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        cube = self.loader.loadModel("models/box")
-        cube.setScale(1, 1, 1)
-        cube.setPos(x, y, z + 1)
-        cube.setColor(farbe)
-        cube.reparentTo(self.render)
-        return cube
-
-    def draw_coordinate_axes(self, axis_length=5):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), LColor(1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), LColor(0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), LColor(0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        curr = lens.getFov()[0]
-        new = max(10, curr - 5)
-        lens.setFov(new)
-        print(f"Zoom In: FOV von {curr} auf {new}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        curr = lens.getFov()[0]
-        new = min(100, curr + 5)
-        lens.setFov(new)
-        print(f"Zoom Out: FOV von {curr} auf {new}")
-
-
-# =============================================================================
-# Fahrzeuglogik mit integriertem Lidarsensor, physikalisch korrekter Brems-/Beschleunigungslogik
-# und kontrolliertem Anfahren/Losfahren der Station.
-# =============================================================================
-class VehicleController:
-    def __init__(self, surface: SimulationSurface):
-        self.surface = surface
-        self.vehicles = []         # Liste der Fahrzeuge
-        self.cargos = {}           # Fahrzeug -> aktuelles Paket
-        self.current_dropoffs = {}
-        self.create_vehicles()
-
-    def create_vehicles(self):
-        roles = ["pickup_to_dropoff", "dropoff_to_pickup"]
-        start_positions = [self.surface.pickup_station.getPos(), self.surface.drop_station.getPos()]
-        for i in range(2):
-            vehicle = self.surface.loader.loadModel("models/box")
-            vehicle.setScale(1, 1, 0.5)
-            if i % 2 == 0:
-                vehicle.setColor(LColor(0, 0, 1, 1))
-            else:
-                vehicle.setColor(LColor(0, 0, 0.8, 1))
-            vehicle.setPos(start_positions[i])
-            vehicle.reparentTo(self.surface.render)
-            vehicle.setPythonTag("role", roles[i])
-            # Phase "pickup" – das Fahrzeug fährt auf die Station zu
-            vehicle.setPythonTag("phase", "pickup")
-            # Startet mit 0 m/s
-            vehicle.setPythonTag("speed", 0.0)
-            self.add_center_marker(vehicle)
-            self.attach_lidar_sensor(vehicle, offset=Vec3(0.5, 0.5, 0), radius=2.5)
-            self.vehicles.append(vehicle)
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        marker = self.surface.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def attach_lidar_sensor(self, vehicle, offset=Vec3(0.5, 0.5, 0), radius=2.5):
-        sensor_np = vehicle.attachNewNode("lidar_sensor")
-        sensor_np.setPos(offset)
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 1, 0, 1))
-        segments = 64
-        ls.moveTo(radius * math.cos(0), radius * math.sin(0), 0)
-        for i in range(1, segments + 1):
-            angle = (2 * math.pi * i) / segments
-            x = radius * math.cos(angle)
-            y = radius * math.sin(angle)
-            ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        sensor_np.attachNewNode(circle_geom)
-
-    def get_source_target(self, vehicle):
-        role = vehicle.getPythonTag("role")
-        if role == "pickup_to_dropoff":
-            return self.surface.pickup_station, self.surface.drop_station
-        else:
-            return self.surface.drop_station, self.surface.pickup_station
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        # Parameter in m/s und m/s²
-        max_speed = 1.5
-        accel = 2.5
-        decel = 2.5
-
-        def move_task(task):
-            # Effektiver Zeitschritt, skaliert durch den Simulationsfaktor
-            dt_real = globalClock.getDt()
-            dt = dt_real * self.surface.speed_factor
-
-            pos = vehicle.getPos()
-            to_target = target - pos
-            distance = to_target.length()
-
-            # Stoppe, wenn das Fahrzeug nahezu am Ziel ist
-            if distance < 0.05:
-                vehicle.setPos(target)
-                on_complete()
-                vehicle.setPythonTag("speed", 0.0)
-                return Task.done
-
-            current_speed = vehicle.getPythonTag("speed")
-
-            # Beim Losfahren (Phase "deliver"): Solange die Dwell-Time nicht abgelaufen ist, bleibt das Fahrzeug stehen.
-            if vehicle.getPythonTag("phase") == "deliver":
-                departure_ready_time = vehicle.getPythonTag("departure_ready_time")
-                if self.surface.sim_clock < departure_ready_time:
-                    vehicle.setPythonTag("speed", 0.0)
-                    return Task.cont
-
-            # Hier berechnen wir den verbleibenden Abstand entlang der x-Achse zum Ziel.
-            # Wir gehen davon aus, dass Fahrt und Station entlang der x-Achse erfolgen.
-            distance_remaining = abs(pos.getX() - target.getX())
-
-            # Wenn der verbleibende Abstand kleiner oder gleich dem Bremsweg ist, bremsen wir.
-            if distance_remaining <= (current_speed ** 2) / (2 * decel):
-                new_speed = max(current_speed - decel * dt, 0)
-            else:
-                new_speed = min(current_speed + accel * dt, max_speed)
-
-            movement = to_target.normalized() * new_speed * dt
-            vehicle.setPos(pos + movement)
-            vehicle.setPythonTag("speed", new_speed)
-            return Task.cont
-
-        self.surface.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        # Beim Anfahren der Station (Phase "pickup")
-        vehicle.setPythonTag("job_start", self.surface.sim_clock)
-        vehicle.setPythonTag("phase", "pickup")
-        source, target = self.get_source_target(vehicle)
-        if source not in self.surface.pickup_packages:
-            self.surface.spawn_package_at_station(source)
-        self.move_vehicle_to(vehicle, source.getPos(),
-                             lambda: self.after_pickup(vehicle, source, target))
-
-    def after_pickup(self, vehicle, source, target):
-        self.pickup_package(vehicle, source)
-        # Wechsel in die Phase "deliver" für das Losfahren
-        vehicle.setPythonTag("phase", "deliver")
-        # Speichere die Station als Ausgangspunkt
-        vehicle.setPythonTag("departure_station", source)
-        # Definiere eine Dwell-Time (z. B. 1,0 s), bevor das Fahrzeug den Beschleunigungsvorgang startet
-        dwell_delay = 1.0
-        vehicle.setPythonTag("departure_ready_time", self.surface.sim_clock + dwell_delay)
-        self.move_vehicle_to(vehicle, target.getPos(),
-                             lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        self.drop_cargo(vehicle)
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, source):
-        if source in self.surface.pickup_packages:
-            package, spawn_time, timer_np = self.surface.pickup_packages.pop(source)
-            timer_np.removeNode()
-            dwell = self.surface.sim_clock - spawn_time
-            self.surface.total_dwell_time += dwell
-            self.surface.picked_up_count += 1
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.surface.last_removed[source] = self.surface.sim_clock
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.surface.render)
-            _, target = self.get_source_target(vehicle)
-            targetPos = target.getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.surface.delivered_packages += 1
-
-    def remove_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-
-
-# =============================================================================
-# Hauptprogramm: Erzeuge Oberfläche und starte die Fahrzeuglogik
-# =============================================================================
-if __name__ == "__main__":
-    surface = SimulationSurface()
-    vehicle_controller = VehicleController(surface)
-    for vehicle in vehicle_controller.vehicles:
-        vehicle_controller.start_delivery_cycle(vehicle, vehicle.getPos())
-    surface.run()
Index: Grundmodell Erweitert Split/GES7.py
===================================================================
diff --git a/Grundmodell Erweitert Split/GES7.py b/Grundmodell Erweitert Split/GES7.py
deleted file mode 100644
--- a/Grundmodell Erweitert Split/GES7.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,2301 +0,0 @@
-# Standardbibliothek
-import random
-import math
-import time
-import ctypes
-import multiprocessing
-from multiprocessing import Queue, Process
-from functools import partial
-import tkinter as tk
-from tkinter import ttk
-
-# Drittanbieter
-import matplotlib
-import matplotlib.pyplot as plt
-from PyQt5 import QtWidgets, QtCore
-import pyqtgraph as pg
-
-# Panda3D und Direct (Engine-spezifische Importe)
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.task.TaskManagerGlobal import taskMgr
-from direct.gui.DirectGui import DirectButton, DirectSlider, DirectLabel
-
-from direct.showbase.ShowBase import ShowBase
-from environment_visualization import EnvironmentVisualizer
-
-class LagerSimulation(ShowBase):
-    def __init__(self, graph_queue=None):
-        # Basisinitialisierung (ShowBase, etc.)
-        super().__init__()
-
-        # ------------------------------------------------------------------------
-        # 1. Umgebung aufbauen: Verwende den extrahierten EnvironmentVisualizer
-        # ------------------------------------------------------------------------
-        self.env_viz = EnvironmentVisualizer(self.render, self.loader)
-
-        # Rufe die Methoden des Visualizers auf, um die Umgebung zu erstellen.
-        self.env_viz.draw_origin()
-        self.env_viz.erzeuge_licht()
-        self.env_viz.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.env_viz.create_wall()
-        self.env_viz.create_annahme_stations()
-        self.env_viz.create_abgabe_stations()
-        self.env_viz.create_garagen_stations()
-
-        # Um in anderen Methoden (z. B. für Paket- oder Auftrags-Handling) auf die Stationen
-        # und deren Marker zugreifen zu können, übergeben wir die entsprechenden Listen.
-        self.annahme_stations = self.env_viz.annahme_stations
-        self.station_blue_dots = self.env_viz.station_blue_dots
-        self.abgabe_stations = self.env_viz.abgabe_stations
-        self.abgabe_blue_dots = self.env_viz.abgabe_blue_dots
-        self.garagen_stations = self.env_viz.garagen_stations
-        self.garagen_parking_points = self.env_viz.garagen_parking_points
-
-        # Setze den Pickup-Offset (dieser Vektor wird bei der Steuerung genutzt)
-        self.pickup_offset = Vec3(0.5, -0.5, 0)
-
-        # Falls du weitere Referenzen (wie self.blue_dot, self.station_green_dot) brauchst, ebenfalls setzen.
-        if hasattr(self.env_viz, 'blue_dot'):
-            self.blue_dot = self.env_viz.blue_dot
-        if hasattr(self.env_viz, 'station_green_dot'):
-            self.station_green_dot = self.env_viz.station_green_dot
-
-        # ------------------------------------------------------------------------
-        # 2. Restliche Initialisierung (Simulationsvariablen, UI, Tasks, etc.)
-        # (Der restliche Code bleibt weitgehend unverändert.)
-        # ------------------------------------------------------------------------
-
-        self.paused = False
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5
-
-        # Weitere Attribute, z. B. für KPIs, Paket- und Auftragsverwaltung usw.
-        self.delivered_packages = 0
-        self.pickup_packages = {}
-        self.last_removed = {}
-        self.orders = {}
-        self.orders_queue = []
-        self.next_order_id = 1
-        # (Weitere Initialisierungen kommen hier…)
-        self.cargos = {}
-        # Falls du auch weitere Attribute benötigst, wie beispielsweise eine Liste der belegten Pickup-Stations:
-        self.occupied_pickups = set()
-
-        self.max_overall_wait_time = 0.0  # Maximale Wartezeit der Pakete
-        self.total_dwell_time = 0.0  # Summe aller Liegedauern abgeholter Pakete
-        self.picked_up_count = 0  # Anzahl abgeholter Pakete
-        self.total_delivery_time = 0.0  # Summe aller Lieferzeiten
-        self.total_delivery_count = 0  # Anzahl der Lieferungen
-        self.max_overall_delivery_time = 0.0
-
-        self.graph_queue = None
-        self.graph_data = []
-        self.graph_process = None
-
-        # Beispiel: Initialisierung des Tkinter-Fensters
-        self.tk_root = tk.Tk()
-        self.tk_root.withdraw()
-
-        # Weiterer Code: Kamera, Lichter (falls weiterhin benötigt – ansonsten übernehmen wir vollständig den Visualizer)
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # UI-bezogene Attribute initialisieren:
-        self.order_win = None
-        self.order_tree = None
-        self.graph_queue = None
-        self.graph_data = []
-
-        # TensorFlow-Modell und RL-Agent initialisieren (wie gehabt)
-        try:
-            import tensorflow as tf
-            self.tf_model = tf.keras.models.load_model("mein_model.keras")
-            print("TensorFlow Modell erfolgreich geladen.")
-        except Exception as e:
-            print(f"Fehler beim Laden des TensorFlow Modells: {e}")
-            self.tf_model = None
-
-        state_bins = ((10, 10), (10, 10))
-        action_space = [0, 1, 2]
-        self.rl_agent = RLAgent(state_bins, action_space, learning_rate=0.1, discount_factor=0.9, epsilon=0.2)
-        self.training_data = []  # Trainingsdatenliste
-
-        # Spawn-Einstellungen (Standardwerte)
-        self.package_spawn_delay = 5.0
-        self.package_spawn_distribution = "uniform"
-        # Hier speichern wir die Variablen für die Stationen als Dictionary (Index -> BooleanVar)
-        self.spawn_station_vars = {}
-        # Falls du beispielsweise 10 Annahmestationen hast:
-        for i in range(10):
-            self.spawn_station_vars[i] = tk.BooleanVar(value=False)
-
-        # Fahrzeuge in den Garagen instanziieren:
-        self.create_garage_vehicles()
-        # --- UI-Elemente für Simulationssteuerung ---
-        # Slider für Simulationsgeschwindigkeit
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        self.paused = False
-        # Pause-Knopf neben dem Slider platzieren – z.B. rechts davon.
-        self.pause_button = DirectButton(
-            text="Pause",
-            command=self.toggle_pause,
-            pos=(-0.5, 0, -0.85),  # Leicht links vom Slider
-            scale=0.07
-        )
-
-        # --- Tastenzuordnungen ---
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-        # Taste "c" öffnet das Fahrzeug-Kontrollfenster
-        self.accept("c", self.show_vehicle_control)
-
-        # --- Tasks (TaskMgr) hinzufügen ---
-        self.taskMgr.add(self._tk_update, "tkUpdateTask")
-        self.taskMgr.add(self.update_delivery_timers, "UpdateDeliveryTimersTask")
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClock")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_graph_data, "UpdateGraphDataTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-    # ---------------1. Initialisierung & Simulationssteuerung---------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        self.sim_clock += dt
-        return Task.cont
-
-    def toggle_pause(self):
-        if not self.paused:
-            # Speichern des aktuellen speed_factor, damit wir ihn beim Resume wiederherstellen können
-            self.previous_speed_factor = self.speed_factor
-            self.speed_factor = 0  # Simulation einfrieren: alle dt-basierte Updates ergeben 0
-            self.pause_button['text'] = "Weiter"
-            self.paused = True
-            print("Gesamte Simulation angehalten")
-        else:
-            # Wiederaufnahme der Simulation: speed_factor auf den vorherigen Wert zurücksetzen
-            self.speed_factor = self.previous_speed_factor if hasattr(self, 'previous_speed_factor') else 1.0
-            self.pause_button['text'] = "Pause"
-            self.paused = False
-            print("Simulation läuft wieder")
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        # dt jetzt skaliert mit der Simulationsgeschwindigkeit
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-    # ---------------2. Graphik & UI (GUI-/Tk-/Matplotlib-Funktionen)---------------
-    def open_graph(self):
-        # Starte den Graphprozess per Taste G (nur, wenn er noch nicht läuft)
-        if self.graph_process is None or not self.graph_process.is_alive():
-            from multiprocessing import Queue, Process
-            self.graph_queue = Queue()
-
-            # Sende alle bisher gesammelten Daten in die Queue:
-            for data in self.graph_data:
-                try:
-                    self.graph_queue.put(data, block=False)
-                except Exception:
-                    pass
-
-            from graph_pyqt import graph_process_pyqt
-            self.graph_process = Process(target=graph_process_pyqt, args=(self.graph_queue,))
-            self.graph_process.start()
-            print("Graphprozess gestartet.")
-        else:
-            print("Graphprozess läuft bereits.")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2, self.ax3) = plt.subplots(3, 1, figsize=(8, 9))
-
-        # Erster Plot: Pakete pro Minute
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-
-        # Zweiter Plot: Durchschnittliche Liegedauer
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-
-        # Dritter Plot: Durchschnittliche Lieferzeit
-        self.line3, = self.ax3.plot([], [], marker="o", color="green", label="Durchschnittliche Lieferzeit (s)")
-        self.ax3.set_xlabel("Simulationszeit (s)")
-        self.ax3.set_ylabel("Lieferzeit (s)")
-        self.ax3.set_title("Durchschnittliche Lieferzeit")
-        self.ax3.legend()
-        self.ax3.grid(True)
-
-        plt.show(block=False)
-        # Starte im Tkinter-Hauptloop eine periodische Aktualisierung:
-        self.tk_root.after(500, self.tk_graph_update)  # alle 500ms
-
-    def tk_graph_update(self):
-        # GIL sichern: Gibt einen Statuswert zurück, der später wieder freigegeben wird.
-        gil_state = ctypes.pythonapi.PyGILState_Ensure()
-        try:
-            times = [data[0] for data in self.graph_data]
-            rates = [data[1] for data in self.graph_data]
-            dwell = [data[2] for data in self.graph_data]
-            delivery = [data[3] for data in self.graph_data]
-
-            self.line1.set_data(times, rates)
-            self.ax1.relim()
-            self.ax1.autoscale_view()
-
-            self.line2.set_data(times, dwell)
-            self.ax2.relim()
-            self.ax2.autoscale_view()
-
-            self.line3.set_data(times, delivery)
-            self.ax3.relim()
-            self.ax3.autoscale_view()
-
-            self.fig.canvas.draw_idle()
-            self.fig.canvas.flush_events()
-        finally:
-            ctypes.pythonapi.PyGILState_Release(gil_state)
-
-        # Nächsten Aufruf in 500ms einplanen
-        self.tk_root.after(500, self.tk_graph_update)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-
-        # Bestimme die maximale Liegedauer aktueller Pakete an den Annahmestationen
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-
-        # Lieferzeit-Kennzahlen ermitteln: für Fahrzeuge, die aktuell ein Paket tragen
-        current_delivery_time = 0.0
-        for veh in self.garage_vehicles:
-            if veh.getPythonTag("package_attached"):
-                ds = veh.getPythonTag("delivery_start_time")
-                if ds:
-                    elapsed_delivery = self.sim_clock - ds
-                    current_delivery_time = max(current_delivery_time, elapsed_delivery)
-        avg_delivery_time = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        # Aktualisiere den Info-Label-Text
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s\n"
-            f"Lieferzeit (aktuell): {current_delivery_time:.1f}s\n"
-            f"Lieferzeit (maximal): {self.max_overall_delivery_time:.1f}s\n"
-            f"Durchschn. Lieferzeit: {avg_delivery_time:.1f}s"
-        )
-        return Task.cont
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def update_graph_data(self, task):
-        if self.sim_clock > 0:
-            ppm = self.delivered_packages / (self.sim_clock / 60)
-        else:
-            ppm = 0.0
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        avg_delivery = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        standard_data = (self.sim_clock, ppm, avg_dwell, avg_delivery)
-        self.graph_data.append(standard_data)
-
-        # Sende die Standarddaten an die Queue
-        if self.graph_queue is not None:
-            try:
-                self.graph_queue.put(standard_data, block=False)
-            except Exception:
-                pass
-
-        # Erzeuge zusätzlich Fahrzeug-Rating-Daten.
-        # Hier als Beispiel: Zufällige Bewertungen für 5 Fahrzeuge;
-        # in deinem System müsstest du diese Werte natürlich aus deinen Messungen oder Berechnungen ableiten.
-        vehicle_ratings = [random.uniform(0, 100) for _ in range(5)]
-        rating_data = (self.sim_clock, *vehicle_ratings)
-
-        # Sende die Rating-Daten
-        if self.graph_queue is not None:
-            try:
-                self.graph_queue.put(rating_data, block=False)
-            except Exception:
-                pass
-
-        return Task.cont
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Hier werden nur die gewünschten Spalten "ID", "Annahmestation", "Ziel" und "Fahrzeug" definiert.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    #-------Fahrzeugsteuerung(Bedienfenster)-------
-    def update_vehicle_control(self):
-        for veh, var in self.vehicle_state_vars.items():
-            new_state = var.get()
-            if new_state == "idle" and veh.getPythonTag("current_order") is not None:
-                veh.setPythonTag("standby_pending", True)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Standby angefordert (Auftrag wird fortgesetzt).")
-            else:
-                veh.setPythonTag("standby_pending", False)
-                veh.setPythonTag("order_state", new_state)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Zustand auf {new_state} gesetzt.")
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-    def update_cable(self, task):
-        # Verwende die simulative Zeit, die bereits in update_sim_clock hochgezählt wird
-        t = self.sim_clock
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    def create_garage_vehicles(self):
-        self.garage_vehicles = []
-        vehicle_id_counter = 1
-        for park in self.garagen_parking_points:
-            veh = self.create_vehicle(park_point=park)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            newPos.setZ(0)
-            veh.setPos(newPos)
-
-            # Fahrzeuge starten im Standby (idle)
-            veh.setPythonTag("current_order", None)
-            veh.setPythonTag("order_state", "idle")
-            veh.setPythonTag("package_attached", False)
-            veh.setPythonTag("vehicle_id", vehicle_id_counter)
-            # Speichere den Parkpunkt als Rückkehrziel
-            veh.setPythonTag("garage_target", park)
-            # Speichere auch das Anfangs-Heading, um es später beim Parken wiederherzustellen.
-            veh.setPythonTag("start_heading", veh.getH())
-            vehicle_id_counter += 1
-
-            self.garage_vehicles.append(veh)
-
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-            # Füge einen Textknoten hinzu, der die Fahrzeugnummer vorne auf dem Fahrzeug anzeigt.
-            # Wir suchen den Mast-Knoten.
-            mast = veh.find("**/mast")
-            if not mast.isEmpty():
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)  # Schwarz
-                tn.setAlign(TextNode.ACenter)
-                text_np = mast.attachNewNode(tn)
-                # Positioniere den Text relativ zum Mast: Wir nutzen den Vektor "intersection"
-                # und versetzen ihn in Z-Richtung um 0.2 Einheiten oberhalb des Zylinders.
-                text_np.setPos(intersection.x, intersection.y, intersection.z + 0.2)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-            else:
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)
-                tn.setAlign(TextNode.ACenter)
-                text_np = veh.attachNewNode(tn)
-                text_np.setPos(0, 1.2, 1.5)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-
-            self.taskMgr.add(partial(self.vehicle_order_task, veh),
-                             f"VehicleOrderTask_{veh.getPythonTag('vehicle_id')}")
-
-    # --------------- Erstellung des Fahrzeugs---------------
-    def create_vehicle(self, park_point=None):
-        # Erzeuge den übergeordneten Fahrzeug-Knoten
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # --------------------------
-        # Chassis erstellen (1 x 0.5 x 1.2, Farbe Rot)
-        # --------------------------
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # --------------------------
-        # Gabel (Fork) erstellen: Zwei Zähne
-        # --------------------------
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        vehicle_node.setPythonTag("fork_node", fork_node)
-
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-
-        # --------------------------
-        # Statt weißer Kante von der Gabel: bereits eingezeichnete grüne Mittellinie verwenden.
-        # In diesem Beispiel nehmen wir an, dass du schon eine „mittlere“ Linie gezeichnet hast.
-        # Zeichne die grüne Mittellinie, z. B. von einem Punkt an der Gabel (als Ausgangspunkt)
-        # bis zu einem Referenzpunkt – hier nutzen wir einen zuvor festgelegten Offset.
-        #
-        # Wir definieren:
-        #   - Den Ausgangspunkt als den grün markierten Punkt, der den mittleren Punkt der Gabel repräsentieren soll.
-        #   - Den Zielpunkt als den Referenzpunkt, der als Idealwert in create_vehicle bestimmt wurde.
-        # In unserem Beispiel berechnen wir den Zielpunkt einmalig aus den lokalen Offsets an der weißen Kante.
-        # (Diese Werte kannst du bei Bedarf anpassen.)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_global = fork_node.getPos(self.render) + left_corner_local
-        right_global = fork_node.getPos(self.render) + right_corner_local
-        # Berechne den idealen (statischen) Mittelpunkt als Referenz – dieser wird nur einmal gesetzt.
-        midpoint_white = (left_global + right_global) * 0.5
-        # Nun lege den grünen Marker so, dass er exakt in der Mitte der Gabel liegt.
-        # Hier entspricht der grüne Punkt der Mittellinie der Gabel.
-        green_point_global = midpoint_white  # Hier wird angenommen, dass der ideale Mittelpunkt gleich dem Referenzpunkt ist.
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        vehicle_node.setPythonTag("fork_green", green_marker_np)
-
-        # Zeichne die grüne Mittellinie.
-        # Als Beispiel: Zeichne eine Linie vom grünen Marker in Richtung +Y (relativ zum Fahrzeug),
-        # weil du den idealen Zustand so festgelegt hast, dass genau diese Linie mit der Station übereinstimmen soll.
-        ls_mid = LineSegs()
-        ls_mid.setThickness(2.0)
-        ls_mid.setColor(0, 1, 0, 1)  # grün
-        # Starte die Linie am grünen Marker.
-        ls_mid.moveTo(green_point_global)
-        # Zeichne beispielsweise eine Linie 1 Einheit lang in +Y-Richtung:
-        ls_mid.drawTo(green_point_global + Vec3(0, 1, 0))
-        fork_center_line = vehicle_node.attachNewNode(ls_mid.create())
-        # Speichere den NodePath der grünen Mittellinie
-        vehicle_node.setPythonTag("fork_center_line", fork_center_line)
-        print("[DEBUG] create_vehicle: Grüne Mittellinie (fork_center_line) gesetzt.")
-
-        # --------------------------
-        # Restliche Fahrzeugteile (Mast, Lenkachse, etc.)
-        # --------------------------
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-        self.add_diagonals_to_mast(mast_node)
-
-        intersection = Vec3(0.5, 0.05, 1.0)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        # --------------------------
-        # Lenkachse erzeugen (Pivot-Node)
-        # --------------------------
-        steering_axis = mast_node.attachNewNode("steering_axis")
-        steering_axis.setPos(0.5, 0.25, -1.2)
-        steering_axis.setH(90)
-        vehicle_node.setPythonTag("steering_axis", steering_axis)
-
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(steering_axis)
-        cylinder_node.setPos(0, 0, 0)
-        self.vehicle_cylinder = steering_axis
-        self.add_steering_arrow(steering_axis, color=(0, 1, 0, 1))
-
-        # --------------------------
-        # Positioniere das Fahrzeug am Parkpunkt
-        # --------------------------
-        if park_point is None:
-            vehicle_node.setPos(0, 0, 0)
-        else:
-            intersection = Vec3(0, 0, 1.0)
-            vehicle_node.setPos(park_point - vehicle_node.getQuat().xform(intersection))
-
-        # ********** Ursprung (Koordinatensystem) am Fahrzeug einzeichnen **********
-        ls_x = LineSegs()
-        ls_x.setThickness(2)
-        ls_x.setColor(LColor(1, 0, 0, 1))
-        ls_x.moveTo(0, 0, 0)
-        ls_x.drawTo(1, 0, 0)
-        vehicle_node.attachNewNode(ls_x.create())
-
-        ls_y = LineSegs()
-        ls_y.setThickness(2)
-        ls_y.setColor(LColor(0, 1, 0, 1))
-        ls_y.moveTo(0, 0, 0)
-        ls_y.drawTo(0, 1, 0)
-        vehicle_node.attachNewNode(ls_y.create())
-
-        ls_z = LineSegs()
-        ls_z.setThickness(2)
-        ls_z.setColor(LColor(0, 0, 1, 1))
-        ls_z.moveTo(0, 0, 0)
-        ls_z.drawTo(0, 0, 1)
-        vehicle_node.attachNewNode(ls_z.create())
-
-        from panda3d.core import TextNode
-        tn_x = TextNode("label_x")
-        tn_x.setText("X")
-        tn_x.setTextColor(1, 0, 0, 1)
-        label_x = vehicle_node.attachNewNode(tn_x)
-        label_x.setScale(0.3)
-        label_x.setPos(2.0, 0, 0)
-
-        tn_y = TextNode("label_y")
-        tn_y.setText("Y")
-        tn_y.setTextColor(0, 1, 0, 1)
-        label_y = vehicle_node.attachNewNode(tn_y)
-        label_y.setScale(0.3)
-        label_y.setPos(0, 2.0, 0)
-
-        tn_z = TextNode("label_z")
-        tn_z.setText("Z")
-        tn_z.setTextColor(0, 0, 1, 1)
-        label_z = vehicle_node.attachNewNode(tn_z)
-        label_z.setScale(0.3)
-        label_z.setPos(0, 0, 2.0)
-
-        return vehicle_node
-
-    def add_steering_arrow(self, steering_axis, color=(0, 1, 0, 1)):
-        """
-        Erzeugt einen Pfeil, der die Vorwärtsrichtung (lokale X-Achse) des Lenkpivots anzeigt.
-        Der Pfeil wird als Kind des übergebenen steering_axis-Node angehängt und passt sich
-        automatisch dessen Rotation an.
-        """
-        arrow_ls = LineSegs()
-        arrow_ls.setThickness(2.0)
-        arrow_ls.setColor(*color)
-
-        # Zeichne eine Linie von (0,0,0) bis (2,0,0) – das ist die Basis des Pfeils
-        arrow_ls.moveTo(0, 0, 0)
-        arrow_ls.drawTo(2, 0, 0)
-
-        # Zeichne den Pfeilkopf: zwei kurze schräge Linien am Ende der Pfeillinie
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, 0.3, 0)
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, -0.3, 0)
-
-        arrow_np = steering_axis.attachNewNode(arrow_ls.create())
-        arrow_np.setPos(0, 0, 0)  # Falls nötig, hier noch zusätzlichen Offset anpassen
-        return arrow_np
-
-    def rotate_around_pivot(self, vehicle, pivot, delta_angle):
-        """
-        Dreht das Fahrzeug (vehicle) um den gegebenen Pivotpunkt (pivot) um delta_angle (in Grad).
-        Dabei wird die Position des Fahrzeugs neu berechnet, sodass es um den Pivot rotiert.
-        """
-        # Aktuelle globale Fahrzeugposition
-        pos = vehicle.getPos(self.render)
-        # Globaler Pivotpunkt
-        pivot_pos = pivot.getPos(self.render)
-        # Berechne den Vektor vom Pivot zum Fahrzeug
-        rel = pos - pivot_pos
-        # Wandle den Drehwinkel in Bogenmaß um
-        rad = math.radians(delta_angle)
-        cos_val = math.cos(rad)
-        sin_val = math.sin(rad)
-        # Drehe den relativen Vektor
-        new_x = rel.getX() * cos_val - rel.getY() * sin_val
-        new_y = rel.getX() * sin_val + rel.getY() * cos_val
-        new_rel = Vec3(new_x, new_y, rel.getZ())
-        # Neue globale Fahrzeugposition
-        new_pos = pivot_pos + new_rel
-        vehicle.setPos(new_pos)
-        # Aktualisiere auch das Heading des Fahrzeugs (aufaddieren des Drehwinkels)
-        vehicle.setH(vehicle.getH() + delta_angle)
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    # ---------------6. Paket- & Auftragsverwaltung---------------
-        # Beispiel einer Methode, die weiterhin auf die extrahierten Umgebungselemente zugreift:
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Je nach gewählter Verteilung kannst du hier Anpassungen vornehmen.
-        # Für den Moment wählen wir einfach zufällig aus allen Abgabestationen,
-        # falls keine spezielle Logik für die Verteilung implementiert ist.
-        target_index = random.randint(1, len(self.abgabe_stations))
-
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def check_and_spawn_packages(self, task):
-        # Verwende den neuen Delay-Wert aus den Einstellungen
-        spawn_delay = self.package_spawn_delay
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-        # Beispiel für eine vorhandene Methode, die auf die Umgebungselemente zugreift:
-    def update_order_table(self):
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen die Stationsnummer (oder verwende "N/A").
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z.B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige den zugewiesenen Fahrzeugnamen an (oder "-" falls noch keiner zugeordnet wurde).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END,
-                                   values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if hasattr(self, 'order_win') and self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    # ---------------7. Cargo-Handling (Pickup, Drop & Timer)---------------
-    def pickup_package(self, vehicle, station):
-        # Falls das Fahrzeug bereits ein Paket trägt, abbrechen.
-        if vehicle.getPythonTag("package_attached"):
-            return
-
-        # Führe den Pickup nur aus, wenn an der Station ein Paket vorhanden ist.
-        if station in self.pickup_packages:
-            # Hole das Paket, den Spawn-Zeitpunkt und den zugehörigen Timer-Knoten.
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            # Entferne den Timer-Knoten, sodass der angezeigte Zähler nicht weiter aktualisiert wird.
-            timer_np.removeNode()
-            # Berechne die Liegedauer (Differenz zwischen aktueller Simulationszeit und Spawn-Zeit).
-            dwell_time = self.sim_clock - spawn_time
-            # Aktualisiere globale Kennzahlen.
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Suche in den Aufträgen nach dem Auftrag, dessen Paket mit diesem Paket übereinstimmt,
-            # und speichere den errechneten Endwert (fixe Liegedauer) sowie den Status.
-            for order_id, order in self.orders.items():
-                if order.get("package") == package:
-                    order["dwell_time"] = dwell_time
-                    order["status"] = "Abgeholt"
-                    break
-
-            # Hole Referenzen zum Gabel-Knoten und zum grünen Marker des Fahrzeugs.
-            fork_node = vehicle.getPythonTag("fork_node")
-            fork_green = vehicle.getPythonTag("fork_green")
-            green_point_pos = fork_green.getPos(fork_node)
-
-            # Übergib das Paket an den Gabel-Knoten (sodass es optisch dem Fahrzeug zugeordnet wird)
-            # und positioniere es relativ zum grünen Marker.
-            package.wrtReparentTo(fork_node)
-            package.setPos(green_point_pos.getX() + 0.5,
-                           green_point_pos.getY() - 0.5,
-                           green_point_pos.getZ() + 1)
-            self.cargos[vehicle] = package
-
-            # Starte den Lieferzeit-Timer: Speichere den Zeitpunkt, an dem das Paket abgeholt wurde,
-            # und hänge einen neuen Timer-Knoten an das Paket.
-            vehicle.setPythonTag("delivery_start_time", self.sim_clock)
-            from panda3d.core import TextNode
-            delivery_timer_text = TextNode("delivery_timer")
-            delivery_timer_text.setText("0.0s")
-            delivery_timer_np = package.attachNewNode(delivery_timer_text)
-            delivery_timer_np.setScale(0.5)
-            delivery_timer_np.setPos(0, 0, 1.2)
-            package.setPythonTag("delivery_timer", delivery_timer_np)
-
-            # Aktualisiere den Zeitpunkt, zu dem an dieser Station zuletzt ein Paket entfernt wurde.
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-
-            # Berechne Lieferzeit:
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start is not None:
-                delivery_time = self.sim_clock - delivery_start
-                self.total_delivery_time += delivery_time
-                self.total_delivery_count += 1
-                self.max_overall_delivery_time = max(self.max_overall_delivery_time, delivery_time)
-                vehicle.clearPythonTag("delivery_start_time")
-
-            # Entferne den Lieferzeit-Timer vom Paket
-            delivery_timer_np = cargo.getPythonTag("delivery_timer")
-            if delivery_timer_np:
-                delivery_timer_np.removeNode()
-
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden das Paket entfernt
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def update_delivery_timers(self, task):
-        for vehicle, package in list(self.cargos.items()):
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start:
-                elapsed_delivery = self.sim_clock - delivery_start
-                delivery_timer_np = package.getPythonTag("delivery_timer")
-                if delivery_timer_np and not delivery_timer_np.isEmpty():
-                    delivery_timer_np.node().setText(f"{elapsed_delivery:.1f}s")
-        return Task.cont
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-
-    # ---------------8. Auftrags-/Fahrzeuglogik---------------
-    def select_next_order(self, vehicle):
-        # Sammle alle Aufträge, die noch "Wartend" sind
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        # Aktualisiere die Dwell-Zeit für jeden Auftrag
-        for order in waiting_orders:
-            order["dwell_time"] = self.sim_clock - order.get("spawn_time", self.sim_clock)
-
-        # Wähle den Auftrag mit der maximalen Dwell-Zeit (evtl. mit etwas Toleranz)
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        # Finde aus den Kandidaten den Auftrag, dessen Pickup-Station (order["pickup_station"])
-        # am nächsten zur aktuellen Fahrzeugposition liegt.
-        vehicle_pos = vehicle.getPos(self.render)
-        candidates.sort(key=lambda order: (order["pickup_station"].getPos(self.render) - vehicle_pos).length())
-        return candidates[0]
-
-    def show_vehicle_control(self):
-        # Falls das Fenster bereits existiert, wiederverwenden
-        if hasattr(self, "control_win") and self.control_win.winfo_exists():
-            self.control_win.deiconify()
-            self.control_win.lift()
-            self.control_win.focus_force()
-            return
-
-        self.control_win = tk.Toplevel(self.tk_root)
-        self.control_win.title("Kontrollfenster")
-        self.control_win.protocol("WM_DELETE_WINDOW", self.control_win.withdraw)
-        self.control_win.attributes("-topmost", True)
-        self.control_win.after(100, lambda: self.control_win.attributes("-topmost", False))
-
-        # ---------------- Fahrzeugsteuerung ----------------
-        # Zunächst einen Button einfügen, der ALLE Fahrzeuge auf "Aufträge bearbeiten" setzt.
-        all_vehicles_btn = tk.Button(
-            self.control_win,
-            text="Alle Fahrzeuge auf 'Aufträge bearbeiten' setzen",
-            command=lambda: [self.vehicle_state_vars[veh].set("translate") for veh in self.garage_vehicles]
-        )
-        all_vehicles_btn.grid(row=0, column=0, sticky="w", padx=5, pady=5)
-
-        # Nun die einzelnen Fahrzeugzeilen – starte ab Zeile 1
-        self.vehicle_state_vars = {}
-        row = 1
-        for veh in self.garage_vehicles:
-            frame = tk.Frame(self.control_win)
-            frame.grid(row=row, column=0, sticky="w", padx=5, pady=2)
-            vid = veh.getPythonTag("vehicle_id")
-            label = tk.Label(frame, text=f"Fahrzeug {vid}")
-            label.pack(side=tk.LEFT)
-            state = veh.getPythonTag("order_state") or "idle"
-            var = tk.StringVar(value=state)
-            self.vehicle_state_vars[veh] = var
-            rb_active = tk.Radiobutton(frame, text="Aufträge bearbeiten", variable=var, value="translate")
-            rb_active.pack(side=tk.LEFT)
-            rb_standby = tk.Radiobutton(frame, text="Standby", variable=var, value="idle")
-            rb_standby.pack(side=tk.LEFT)
-            row += 1
-
-        update_btn = tk.Button(self.control_win, text="Übernehmen", command=self.update_vehicle_control)
-        update_btn.grid(row=row, column=0, pady=5)
-        row += 1
-
-        # ---------------- Spawn-Einstellungen ----------------
-        spawn_frame = tk.LabelFrame(self.control_win, text="Spawn Einstellungen", padx=5, pady=5)
-        spawn_frame.grid(row=row, column=0, sticky="w", padx=5, pady=5)
-
-        # Eingabe der Spawnverzögerung
-        tk.Label(spawn_frame, text="Spawnverzögerung (Sekunden):").grid(row=0, column=0, sticky="w")
-        self.spawn_delay_var = tk.DoubleVar(value=self.package_spawn_delay)
-        delay_entry = tk.Entry(spawn_frame, textvariable=self.spawn_delay_var, width=6)
-        delay_entry.grid(row=0, column=1, sticky="w")
-
-        # Direkt in diesem Spawn-Feld: Button, der alle Annahmestationen auswählt
-        btn_select_all_stations = tk.Button(
-            spawn_frame,
-            text="Alle Annahmestationen auswählen",
-            command=lambda: [self.spawn_station_vars[i].set(True) for i in self.spawn_station_vars]
-        )
-        btn_select_all_stations.grid(row=0, column=2, padx=5)
-
-        # Auswahl der Annahmestationen (Checkbuttons)
-        tk.Label(spawn_frame, text="Annahmestationen:").grid(row=1, column=0, sticky="w", pady=(5, 0))
-        stations_frame = tk.Frame(spawn_frame)
-        stations_frame.grid(row=2, column=0, columnspan=3, sticky="w")
-        for i in range(min(10, len(self.annahme_stations))):
-            cb = tk.Checkbutton(stations_frame, text=f"Annahmestation {i + 1}",
-                                variable=self.spawn_station_vars[i])
-            cb.pack(anchor="w")
-
-        def apply_spawn_from_control():
-            self.package_spawn_delay = self.spawn_delay_var.get()
-            selected = []
-            for i, var in self.spawn_station_vars.items():
-                if var.get():
-                    selected.append(self.annahme_stations[i])
-            self.package_spawn_stations = selected
-            print(
-                f"Spawn Einstellungen übernommen: Delay={self.package_spawn_delay}s, "
-                f"Stations: {[i + 1 for i, var in self.spawn_station_vars.items() if var.get()]}"
-            )
-            # Spawne nur an Stationen, an denen noch kein Paket existiert:
-            for station in self.package_spawn_stations:
-                if station not in self.pickup_packages:
-                    self.spawn_package_at_station(station)
-            # Option: spawn_win schließen oder offen lassen
-            # self.control_win.withdraw()
-
-        apply_btn = tk.Button(
-            spawn_frame,
-            text="Einstellungen übernehmen und spawnen",
-            command=apply_spawn_from_control
-        )
-        apply_btn.grid(row=3, column=0, columnspan=3, pady=5)
-
-    def show_spawn_control(self):
-        spawn_win = tk.Toplevel(self.tk_root)
-        spawn_win.title("Paketspawn Einstellungen")
-
-        # Eingabefeld für Spawnverzögerung
-        tk.Label(spawn_win, text="Spawnverzögerung (Sekunden):").pack(pady=2)
-        delay_entry = tk.Entry(spawn_win)
-        delay_entry.insert(0, str(self.package_spawn_delay))
-        delay_entry.pack(pady=2)
-
-        # (Dropdown für Spawn-Verteilung wurde entfernt)
-
-        # Checkbuttons für die Auswahl der Annahmestationen
-        tk.Label(spawn_win, text="Annahmestationen auswählen (1-10):").pack(pady=2)
-        stations_frame = tk.Frame(spawn_win)
-        stations_frame.pack(pady=2)
-
-        station_vars = {}
-        for idx, station in enumerate(self.annahme_stations):
-            var = tk.BooleanVar(value=False)
-            station_label = f"Annahmestation {idx + 1}"
-            cb = tk.Checkbutton(stations_frame, text=station_label, variable=var)
-            cb.pack(anchor="w")
-            station_vars[idx] = var
-
-        def apply_spawn_settings():
-            try:
-                new_delay = float(delay_entry.get())
-            except ValueError:
-                new_delay = self.package_spawn_delay
-            new_stations = []
-            for idx, var in station_vars.items():
-                if var.get():
-                    new_stations.append(self.annahme_stations[idx])
-
-            self.package_spawn_delay = new_delay
-            self.package_spawn_stations = new_stations
-
-            print(f"Spawn-Einstellungen aktualisiert: Delay={new_delay}s, "
-                  f"Stationen: {[f'Annahmestation {idx + 1}' for idx, var in station_vars.items() if var.get()]}")
-            # Spawne nur dort Pakete, wo noch kein Paket vorhanden ist:
-            for station in self.package_spawn_stations:
-                if station not in self.pickup_packages:
-                    self.spawn_package_at_station(station)
-
-            spawn_win.destroy()
-
-        tk.Button(spawn_win, text="Einstellungen speichern", command=apply_spawn_settings).pack(pady=5)
-
-    def vehicle_in_collision(self, vehicle):
-        """
-        Prüft, ob das angegebene Fahrzeug in einer Kollision mit einem anderen Fahrzeug liegt.
-        Verwendet dafür die bereits vorhandene Methode check_collisions.
-        """
-        collisions = self.check_collisions()
-        for pair in collisions:
-            if vehicle in pair:
-                return True
-        return False
-    def vehicle_order_task(self, vehicle, task):
-        # Berechne dt (unter Berücksichtigung der Simulationsgeschwindigkeit)
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-
-        state = vehicle.getPythonTag("order_state")
-        if state is None or state == "idle":
-            return Task.cont
-
-        # --- Modellinferenz & Trainingsdatenerfassung (wie gehabt) ---
-        frame_count = vehicle.getPythonTag("frame_count") or 0
-        frame_count += 1
-        vehicle.setPythonTag("frame_count", frame_count)
-
-        sensor_data = self.collect_sensor_data(vehicle)
-        import numpy as np
-        if self.tf_model is not None and (frame_count % 10 == 0):
-            if sensor_data.ndim == 2:
-                sensor_data = np.expand_dims(sensor_data, axis=-1)
-            if sensor_data.ndim == 3:  # (20,20,1)
-                flat_vector = sensor_data.flatten()[:10]
-                input_data = flat_vector.reshape(1, -1)
-            elif sensor_data.ndim == 4:
-                input_data = np.array([img.flatten()[:10] for img in sensor_data])
-            else:
-                raise ValueError("Unerwartete Eingabeform, es werden (20,20,1) Daten erwartet.")
-            prediction = self.tf_model.predict(input_data)
-            model_delta_angle = prediction[0][0]
-            print(f"[TF] Modell-Korrektur: {model_delta_angle:.2f}°")
-        else:
-            model_delta_angle = 0.0
-            if self.tf_model is not None:
-                print(f"[TF] Modell-Korrektur übersprungen (Frame Count: {frame_count})")
-            else:
-                print("[TF] Kein Modell vorhanden, Modell-Korrektur wird übersprungen.")
-
-        ideal_correction = self.compute_ideal_steering_correction(vehicle)
-        print(f"[IDEAL] Ideal berechneter Korrekturwinkel: {ideal_correction:.2f}°")
-
-        if state == "translate":
-            self.log_training_sample(sensor_data, ideal_correction)
-
-        # Hier werden die Standard-Phasen aufgerufen:
-        if state == "translate":
-            self.handle_translate_phase(vehicle, dt)
-        elif state == "rotate":
-            self.handle_rotate_phase(vehicle, dt)
-        elif state == "approach":
-            self.handle_approach_phase(vehicle, dt)
-        elif state == "pickup":
-            self.handle_pickup_phase(vehicle, dt)
-        elif state == "drive_out":
-            self.handle_drive_out_phase(vehicle, dt)
-        elif state == "to_delivery":
-            self.handle_to_delivery_phase(vehicle, dt)
-        elif state == "align_delivery":
-            self.handle_align_delivery_phase(vehicle, dt)
-        elif state == "delivery_center":
-            self.handle_delivery_center_phase(vehicle, dt)
-        elif state == "drop":
-            self.handle_drop_phase(vehicle, dt)
-        elif state == "delivery_exit":
-            self.handle_drive_out_phase_delivery(vehicle, dt)
-        elif state == "return_to_garage":
-            self.handle_return_to_garage_phase(vehicle, dt)
-        else:
-            print(f"Unbekannter Zustand '{state}' für Fahrzeug {vehicle.getPythonTag('vehicle_id')}. Setze auf 'translate'.")
-            vehicle.setPythonTag("order_state", "translate")
-
-        # Zusätzliche Bewertung (RL-Rating) in ausgewählten Phasen und nur bei Kollision:
-        rating_phases = ["translate", "to_delivery", "phase11", "return_to_garage"]
-        if state in rating_phases and self.vehicle_in_collision(vehicle):
-            # Hier verwenden wir als Rating beispielhaft den idealen Korrekturwert
-            rating_value = ideal_correction
-            vehicle_id = vehicle.getPythonTag("vehicle_id")
-            # Wir senden eine Nachricht als Tupel mit Identifier "rating".
-            if self.graph_queue is not None:
-                try:
-                    self.graph_queue.put(("rating", vehicle_id, self.sim_clock, rating_value), block=False)
-                except Exception as e:
-                    print("Fehler beim Senden der Bewertungsdaten:", e)
-
-        return Task.cont
-
-    # -------------------- Handler für einzelne Phasen --------------------
-
-    def handle_translate_phase(self, vehicle, dt):
-        import math
-        from panda3d.core import Vec3
-        current_order = vehicle.getPythonTag("current_order")
-        station_occupied = False
-        if current_order is not None and "pickup_station" in current_order:
-            pickup_station = current_order["pickup_station"]
-            occupant = pickup_station.getPythonTag("occupied_by")
-            if occupant is None:
-                pickup_station.setPythonTag("occupied_by", vehicle)
-                print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} loggt sich an Pickup-Station {pickup_station.getName()}.")
-            elif occupant != vehicle:
-                station_occupied = True
-                print(f"[WARTEN] Pickup-Station {pickup_station.getName()} bereits besetzt durch Fahrzeug {occupant.getPythonTag('vehicle_id')}.")
-        base_speed = 1.5 if not station_occupied else 0.0
-        adjusted_speed = self.collision_avoidance_adjustment(vehicle, base_speed)
-        if current_order is None:
-            next_order = self.select_next_order(vehicle)
-            if next_order is not None:
-                next_order["status"] = "In Bearbeitung"
-                next_order["vehicle"] = f"Fahrzeug {vehicle.getPythonTag('vehicle_id')}"
-                vehicle.setPythonTag("current_order", next_order)
-                print(f"Auftrag {next_order['id']} wird zugewiesen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}.")
-            current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None:
-            pickup_station = current_order.get("pickup_station")
-            if pickup_station in self.station_blue_dots:
-                target = self.station_blue_dots[pickup_station].getPos(self.render)
-            else:
-                target = self.blue_dot.getPos(self.render)
-        else:
-            target = self.blue_dot.getPos(self.render)
-        current_pos = vehicle.getPos(self.render)
-        pivot = vehicle.getPythonTag("steering_axis")
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-        heading_error = desired_heading_rad - current_heading_rad
-        while heading_error > math.pi:
-            heading_error -= 2 * math.pi
-        while heading_error < -math.pi:
-            heading_error += 2 * math.pi
-        gain = 1.0
-        max_delta = gain * dt
-        delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-        self.rotate_around_pivot(vehicle, pivot, math.degrees(delta_heading_rad))
-        global_hpr = pivot.getNetTransform().getHpr()
-        new_heading_rad = math.radians(global_hpr.getX())
-        new_x = current_pos.getX() + adjusted_speed * math.cos(new_heading_rad) * dt
-        new_y = current_pos.getY() + adjusted_speed * math.sin(new_heading_rad) * dt
-        new_pos = Vec3(new_x, new_y, 0)
-        vehicle.setPos(new_pos)
-        new_offset_pos = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        if (target - new_offset_pos).length() < 0.1:
-            vehicle.setPythonTag("order_state", "rotate")
-        return Task.cont
-
-    def handle_rotate_phase(self, vehicle, dt):
-        import math
-        from panda3d.core import Vec3  # Nur Vec3 importieren, Task nicht
-
-        # 1. Hole den grünen Referenzpunkt (fork_green) der Gabel.
-        fork_green = vehicle.getPythonTag("fork_green")
-        if not fork_green or fork_green.isEmpty():
-            print("[DEBUG] handle_rotate_phase: Kein fork_green gefunden!")
-            return Task.cont
-
-        # 2. Hole den aktuellen Auftrag und die zugehörige Pickup-Station.
-        current_order = vehicle.getPythonTag("current_order")
-        if not current_order or "pickup_station" not in current_order:
-            print("[DEBUG] handle_rotate_phase: Kein aktueller Auftrag oder Station gefunden!")
-            return Task.cont
-        station = current_order["pickup_station"]
-
-        # Hole den Referenzpunkt der Station (white_center) und prüfe auf den Richtungsvektor (optional)
-        white_center = station.getPythonTag("white_center")
-        if white_center is None:
-            print("[DEBUG] handle_rotate_phase: Kein white_center in der Station gefunden!")
-            return Task.cont
-        target = white_center  # Das Ziel ist der Mittelpunkt der weißen Linie
-
-        # 3. Berechne den Drehpunkt des Fahrzeugs.
-        pivot = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-
-        # 4. Wenn der Abstand vom Pivot zum Ziel sehr gering ist, setze die exakte Ausrichtung.
-        distance = (target - pivot).length()
-        stop_threshold = 0.5  # Schwellenwert – je nach Modelldimension anpassen
-        if distance < stop_threshold:
-            desired_vector = target - pivot
-            desired_angle = (math.degrees(math.atan2(desired_vector.getY(), desired_vector.getX())) + 90) % 360
-            vehicle.setH(self.render, desired_angle)
-            print(f"[DEBUG] final step: Fahrzeugheading auf {desired_angle:.2f}° gesetzt.")
-            # Richte den grünen Richtungspfeil (fork_center_line) aus, falls vorhanden.
-            white_direction = station.getPythonTag("white_direction")
-            if white_direction is not None:
-                desired_arrow_angle = math.degrees(math.atan2(white_direction.getY(), white_direction.getX()))
-                arrow_relative = (desired_arrow_angle - desired_angle + 180) % 360 - 180
-                fork_center_line = vehicle.getPythonTag("fork_center_line")
-                if fork_center_line:
-                    fork_center_line.setH(arrow_relative)
-                    print(f"[DEBUG] final step: Grüner Pfeil auf relativen Winkel {arrow_relative:.2f}° gesetzt.")
-            vehicle.setPythonTag("order_state", "approach")
-            return Task.cont
-
-        # 5. Berechne den gewünschten globalen Winkel vom Pivot zum Ziel (inklusive +90°-Offset).
-        desired_vector = target - pivot
-        desired_angle = (math.degrees(math.atan2(desired_vector.getY(), desired_vector.getX())) + 90) % 360
-
-        # 6. Ermittle den aktuellen Fahrzeugheading in Weltkoordinaten und berechne die Differenz.
-        current_heading = vehicle.getH(self.render)
-        angle_diff = (desired_angle - current_heading + 180) % 360 - 180
-
-        if abs(angle_diff) < 2.0:
-            vehicle.setH(self.render, desired_angle)
-            white_direction = station.getPythonTag("white_direction")
-            if white_direction is not None:
-                desired_arrow_angle = math.degrees(math.atan2(white_direction.getY(), white_direction.getX()))
-                arrow_relative = (desired_arrow_angle - desired_angle + 180) % 360 - 180
-                fork_center_line = vehicle.getPythonTag("fork_center_line")
-                if fork_center_line:
-                    fork_center_line.setH(arrow_relative)
-                    print(f"[DEBUG] fine alignment: Grüner Pfeil auf {arrow_relative:.2f}° gesetzt.")
-            vehicle.setPythonTag("order_state", "approach")
-            return Task.cont
-
-        # 7. Begrenze den Drehwinkel pro Frame.
-        max_rotation_speed = 20.9  # Grad pro Sekunde
-        max_delta = max_rotation_speed * dt
-        delta_angle = max(-max_delta, min(max_delta, angle_diff))
-
-        # 8. Drehe das Fahrzeug schrittweise um delta_angle über einen temporären Pivot.
-        temp_pivot = self.render.attachNewNode("temp_pivot")
-        temp_pivot.setPos(pivot)
-        self.rotate_around_pivot(vehicle, temp_pivot, delta_angle)
-        temp_pivot.removeNode()
-
-        print(f"[DEBUG] rotating: Gedreht um {delta_angle:.2f}°; Restliche Differenz: {angle_diff - delta_angle:.2f}°")
-        return Task.cont
-
-    def handle_approach_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None:
-            pickup_station = current_order.get("pickup_station")
-            target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-        else:
-            target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-        current = vehicle.getPos(self.render)
-        error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-        if error_vec.length() > 0.05:
-            direction = error_vec.normalized()
-            move_distance = 1.5 * dt
-            new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                           current.getY() + direction.getY() * move_distance, target.getZ())
-            vehicle.setPos(new_pos)
-        else:
-            vehicle.setPos(target)
-            vehicle.setPythonTag("order_state", "pickup")
-
-    def handle_pickup_phase(self, vehicle, dt):
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        target_z = 1.0
-        raise_speed = 0.5
-        if current_z < target_z:
-            fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-        else:
-            if vehicle.getPythonTag("current_order") is None:
-                if self.orders_queue:
-                    vehicle.setPythonTag("current_order", self.orders_queue.pop(0))
-                else:
-                    print(
-                        f"Keine verfügbaren Aufträge für Fahrzeug {vehicle.getPythonTag('vehicle_id')}. Überspringe Pickup-Phase.")
-                    vehicle.setPythonTag("order_state", "drive_out")
-                    return
-            if not vehicle.getPythonTag("package_attached"):
-                pickup_station = vehicle.getPythonTag("current_order")["pickup_station"]
-                self.pickup_package(vehicle, pickup_station)
-                vehicle.setPythonTag("package_attached", True)
-            if vehicle.getPythonTag("drive_out_target") is None:
-                vehicle.setPythonTag("drive_out_target",
-                                     vehicle.getPos(self.render) + vehicle.getQuat(self.render).getForward() * 5.0)
-            vehicle.setPythonTag("order_state", "drive_out")
-
-    def handle_drive_out_phase(self, vehicle, dt):
-        from panda3d.core import Vec3
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        if current_z > 0:
-            lower_speed = 0.5
-            fork_node.setZ(max(0, current_z - lower_speed * dt))
-        current_pos = vehicle.getPos(self.render)
-        drive_out_target = vehicle.getPythonTag("drive_out_target")
-        if drive_out_target is None:
-            drive_out_target = current_pos + vehicle.getQuat(self.render).getForward() * 5.0
-            vehicle.setPythonTag("drive_out_target", drive_out_target)
-        diff = drive_out_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            # Sobald das Fahrzeug seinen Drive-Out erreicht hat, geben wir den Lock an der Pickup-Station frei
-            current_order = vehicle.getPythonTag("current_order")
-            if current_order is not None and "pickup_station" in current_order:
-                pickup_station = current_order["pickup_station"]
-                # Ersetze clearPythonTag durch setPythonTag(..., None) für die Freigabe
-                pickup_station.setPythonTag("occupied_by", None)
-                print(
-                    f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} verlässt Pickup-Station {pickup_station.getName()} und entsperrt diese.")
-            vehicle.setPythonTag("order_state", "to_delivery")
-            vehicle.setPythonTag("drive_out_target", None)
-        return Task.cont
-
-    def handle_to_delivery_phase(self, vehicle, dt):
-        import math
-        from panda3d.core import Vec3
-
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is None:
-            return Task.cont
-
-        # Bestimme den Zielindex aus dem String (z.B. "Abgabestation 3")
-        try:
-            target_index = int(current_order.get("ziel", "Abgabestation 1").split()[-1])
-        except Exception:
-            target_index = 1
-
-        # Statt direkt die Position abzufragen, verweisen wir auf den gesamten NodePath
-        if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-            delivery_station = self.abgabe_blue_dots[target_index - 1]
-        else:
-            delivery_station = self.abgabe_blue_dots[0]
-
-        # Jetzt holen wir die Position vom NodePath
-        target = delivery_station.getPos(self.render)
-        current_pos = vehicle.getPos(self.render)
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-
-        # Prüfe, ob an der Abgabestation bereits ein Fahrzeug blockiert:
-        if self.is_delivery_station_occupied(delivery_station, exclude_vehicle=vehicle):
-            print(f"[WARTEN] Abgabestation blockiert. Fahrzeug {vehicle.getPythonTag('vehicle_id')} wartet.")
-            return Task.cont
-
-        # Berechne den gewünschten Basiswinkel vom Offset-Punkt zum Ziel.
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-        pivot = vehicle.getPythonTag("steering_axis")
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-        heading_error = desired_heading_rad - current_heading_rad
-        while heading_error > math.pi:
-            heading_error -= 2 * math.pi
-        while heading_error < -math.pi:
-            heading_error += 2 * math.pi
-
-        gain = 1.0
-        max_delta = gain * dt
-        delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-        self.rotate_around_pivot(vehicle, pivot, math.degrees(delta_heading_rad))
-
-        global_hpr = pivot.getNetTransform().getHpr()
-        new_heading_rad = math.radians(global_hpr.getX())
-        adjusted_speed = self.collision_avoidance_adjustment(vehicle, base_speed=1.5)
-        new_x = current_pos.getX() + adjusted_speed * math.cos(new_heading_rad) * dt
-        new_y = current_pos.getY() + adjusted_speed * math.sin(new_heading_rad) * dt
-        new_pos = Vec3(new_x, new_y, current_pos.getZ())
-        vehicle.setPos(new_pos)
-
-        new_offset_pos = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        if (target - new_offset_pos).length() < 0.1:
-            vehicle.setPythonTag("order_state", "align_delivery")
-        return Task.cont
-
-    def handle_align_delivery_phase(self, vehicle, dt):
-        import math
-        from panda3d.core import Vec3
-
-        # 1. Ermittle den Basiszielwinkel aus der weißen Linie der Abgabestation.
-        try:
-            base_target_heading = self.abgabe_white_line.getH(self.render) % 360
-        except Exception as e:
-            base_target_heading = 90.0
-            print(
-                f"[Align Delivery] Warning: self.abgabe_white_line nicht gefunden, verwende Default {base_target_heading}°.")
-
-        # 2. Berechne den gewünschten Endwinkel.
-        # Ursprünglich wurde desired_heading so gesetzt:
-        #    (base_target_heading + 90 + 180) % 360
-        # Um 90° mehr gegen den Uhrzeigersinn zu drehen, addieren wir zusätzlich 90°:
-        desired_heading = (base_target_heading + 90 + 180 + 90) % 360
-        # Das entspricht (base_target_heading + 360) % 360, also einfach:
-        desired_heading = base_target_heading % 360
-
-        # 3. Berechne den Pivot-Punkt so wie in handle_rotate_phase,
-        # damit das Fahrzeug auf der Stelle rotiert.
-        pivot = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-
-        # 4. Ermittle den aktuellen globalen Heading des Fahrzeugs.
-        current_heading = vehicle.getH(self.render) % 360
-
-        # 5. Berechne den minimalen Winkelunterschied (normiert auf [-180, 180]).
-        error = (desired_heading - current_heading + 180) % 360 - 180
-
-        print(
-            f"[Align Delivery] Fahrzeug {vehicle.getPythonTag('vehicle_id')}: Aktueller Heading: {current_heading:.2f}°, "
-            f"Ziel: {desired_heading:.2f}° (Basis: {base_target_heading:.2f}°), Error: {error:.2f}°")
-
-        # 6. Wenn der Fehler sehr klein ist (< 1°), setze den Endwinkel und wechsle in den nächsten Zustand.
-        if abs(error) < 1.0:
-            vehicle.setH(self.render, desired_heading)
-            vehicle.setPythonTag("order_state", "delivery_center")
-            print(f"[Align Delivery] Alignment complete for vehicle {vehicle.getPythonTag('vehicle_id')}.")
-            return Task.cont
-
-        # 7. Begrenze den Drehschritt basierend auf einer maximalen Drehgeschwindigkeit.
-        turn_speed = 90.0  # Grad pro Sekunde
-        max_turn = turn_speed * dt
-        turn_angle = max(-max_turn, min(max_turn, error))
-
-        # 8. Rotiere das Fahrzeug schrittweise um turn_angle mit Hilfe eines temporären Pivots.
-        temp_pivot = self.render.attachNewNode("temp_pivot")
-        temp_pivot.setPos(pivot)
-        self.rotate_around_pivot(vehicle, temp_pivot, turn_angle)
-        temp_pivot.removeNode()
-
-        return Task.cont
-
-    def handle_delivery_center_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is None:
-            return
-        delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-        try:
-            target_index = int(delivery_target_str.split()[-1])
-        except ValueError:
-            target_index = 1
-        if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-            blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-        else:
-            blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-        current = vehicle.getPos(self.render)
-        target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-        print(f"Phase 9: Zielpunkt der Abgabestation für Fahrzeug {vehicle.getPythonTag('vehicle_id')}: {target_point}")
-        error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-        tolerance = 0.05
-        move_distance = 1.5 * dt
-        if error_vec.length() > tolerance:
-            direction = error_vec.normalized()
-            new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                           current.getY() + direction.getY() * move_distance, current.getZ())
-            vehicle.setPos(new_pos)
-            print(f"Phase 9: Fahrzeug {vehicle.getPythonTag('vehicle_id')} bewegt sich von {current} nach {new_pos}")
-        else:
-            vehicle.setPos(target_point)
-            print(f"Phase 9: Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den Zielpunkt erreicht.")
-            vehicle.setPythonTag("order_state", "drop")
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_fork_z = fork_node.getZ()
-        if current_fork_z < 1.0:
-            new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-            fork_node.setZ(new_fork_z)
-            print(
-                f"Phase 9: Gabel wird angehoben für Fahrzeug {vehicle.getPythonTag('vehicle_id')} (Z = {new_fork_z}).")
-
-    def handle_drop_phase(self, vehicle, dt):
-        # Falls das Fahrzeug ein Paket trägt, wird dieses abgesetzt.
-        if vehicle.getPythonTag("package_attached"):
-            self.drop_cargo(vehicle)
-            print(f"Phase 10: Paket abgesetzt für Fahrzeug {vehicle.getPythonTag('vehicle_id')}")
-            vehicle.setPythonTag("package_attached", False)
-        else:
-            # Falls die Gabel noch abgesenkt werden muss:
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            if current_z > 0:
-                lower_speed = 0.5
-                fork_node.setZ(max(0, current_z - lower_speed * dt))
-            print(f"Phase 10: Dropoff abgeschlossen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}")
-
-        # Setze den Zustand nun auf "delivery_exit", damit das Fahrzeug aus dem Lieferbereich herausfährt.
-        vehicle.setPythonTag("order_state", "delivery_exit")
-        # Optional: den Auftrag als "Abgegeben" markieren und löschen.
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None:
-            current_order["status"] = "Abgegeben"
-            current_order["delivered_at"] = self.sim_clock
-        vehicle.clearPythonTag("current_order")
-
-        return Task.cont
-
-    def handle_drive_out_phase_delivery(self, vehicle, dt):
-        from panda3d.core import Vec3
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        if current_z > 0:
-            lower_speed = 0.5
-            fork_node.setZ(max(0, current_z - lower_speed * dt))
-        current_pos = vehicle.getPos(self.render)
-        drive_out_target = vehicle.getPythonTag("drive_out_target")
-        if drive_out_target is None:
-            drive_out_target = current_pos + vehicle.getQuat(self.render).getForward() * 5.0
-            vehicle.setPythonTag("drive_out_target", drive_out_target)
-        diff = drive_out_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            # Sobald das Fahrzeug seinen Drive-Out im Lieferbereich erreicht hat, geben wir den Lock frei
-            current_order = vehicle.getPythonTag("current_order")
-            if current_order is not None:
-                try:
-                    target_index = int(current_order.get("ziel", "Abgabestation 1").split()[-1])
-                except Exception:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_stations):
-                    delivery_station = self.abgabe_stations[target_index - 1]
-                else:
-                    delivery_station = self.abgabe_stations[0]
-                # Freigabe des Locks an der Delivery-Station
-                delivery_station.setPythonTag("occupied_by", None)
-                print(
-                    f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} verlässt Delivery-Station {delivery_station.getName()} und entsperrt diese.")
-            vehicle.setPythonTag("order_state", "translate")
-            vehicle.setPythonTag("drive_out_target", None)
-            print(
-                f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den Lieferbereich verlassen und wechselt in 'translate'.")
-        return Task.cont
-
-    def handle_phase11(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if vehicle.getPythonTag("last_delivery_marker") is not None:
-            target_point = vehicle.getPythonTag("last_delivery_marker")
-        else:
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                target_point = self.abgabe_blue_dots[0].getPos(self.render)
-        print(f"Phase 11: Zielpunkt (blauer Marker) für Fahrzeug {vehicle.getPythonTag('vehicle_id')}: {target_point}")
-        current_pos = vehicle.getPos(self.render)
-        diff = target_point - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            vehicle.setPos(new_pos)
-            print(
-                f"Phase 11: Fahrzeug {vehicle.getPythonTag('vehicle_id')} fährt aus der Station, neue Position: {new_pos}")
-        else:
-            vehicle.setPos(target_point)
-            print(
-                f"Phase 11: Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den blauen Marker erreicht. Nächster Auftrag wird gestartet.")
-            vehicle.setPythonTag("order_state", "next_order")
-
-    def handle_return_to_garage_phase(self, vehicle, dt):
-        garage_target = vehicle.getPythonTag("garage_target")
-        if garage_target is None:
-            garage_target = self.garagen_parking_points[0]
-        current_pos = vehicle.getPos(self.render)
-        diff = garage_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 1.0 * dt
-            new_pos = current_pos + diff.normalized() * move_distance
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            if vehicle.hasPythonTag("start_heading"):
-                vehicle.setH(vehicle.getPythonTag("start_heading"))
-            vehicle.setPythonTag("order_state", "idle")
-            vehicle.setPythonTag("standby_pending", False)
-            print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} ist in der Garage (Standby).")
-
-    def collect_sensor_data(self, vehicle, sensor_range=5, grid_resolution=0.5):
-        """
-        Erzeugt ein einfaches 2D-Occupancy-Grid, das den Bereich um das Fahrzeug simuliert.
-
-        Parameter:
-          sensor_range: Radius (in Welt-Einheiten) um das Fahrzeug.
-          grid_resolution: Größe der einzelnen Zellen im Grid.
-
-        Rückgabe:
-          Ein NumPy-Array (2D) mit 0 (frei) als Platzhalter.
-        """
-        import numpy as np
-        grid_size = int((sensor_range * 2) / grid_resolution)
-        sensor_grid = np.zeros((grid_size, grid_size))
-        # --- Hier kannst du später echte Kollisionsabfragen oder Ray-Casting integrieren ---
-        return sensor_grid
-
-    def compute_ideal_steering_correction(self, vehicle):
-        """
-        Berechnet einen idealen Korrekturwinkel (in Grad) für die Navigation in der 'translate'-Phase.
-        Es wird ein vereinfachtes Modell genutzt, das den Unterschied zwischen dem gewünschten und dem aktuellen
-        Heading (über die Fahrzeug-Steuerachse) ermittelt.
-        """
-        import math
-
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None and "pickup_station" in current_order:
-            pickup_station = current_order["pickup_station"]
-            if pickup_station in self.station_blue_dots:
-                target = self.station_blue_dots[pickup_station].getPos(self.render)
-            else:
-                target = self.blue_dot.getPos(self.render)
-        else:
-            target = self.blue_dot.getPos(self.render)
-
-        current_pos = vehicle.getPos(self.render)
-        # Bestimme einen Offset-Punkt, basierend auf der bereits existierenden pickup_offset
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        # Berechne den gewünschten Heading-Winkel (in Radiant): Richtung von offset_pos zu target
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-
-        # Hole den aktuellen Heading-Wert vom Steuerachsen-Node (pivot)
-        pivot = vehicle.getPythonTag("steering_axis")
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-
-        ideal_correction_rad = desired_heading_rad - current_heading_rad
-        # Winkelbereich anpassen [-pi, pi]
-        while ideal_correction_rad > math.pi:
-            ideal_correction_rad -= 2 * math.pi
-        while ideal_correction_rad < -math.pi:
-            ideal_correction_rad += 2 * math.pi
-
-        return math.degrees(ideal_correction_rad)
-
-    def compute_avoidance_angle(self, current_vehicle, safe_distance=3.0):
-        """
-        Berechnet einen zusätzlichen Ausweichwinkel (in Grad) basierend auf den
-        Positionen anderer Fahrzeuge. Fahrzeuge, die sehr nah sind, sollen einen
-        höheren Einfluss haben. Der Rückgabewert wird mit einem Gewichtungsfaktor
-        multipliziert, sodass der Ausweichimpuls moderat bleibt.
-        """
-        import math
-        from panda3d.core import Vec2
-
-        current_pos = current_vehicle.getPos(self.render)
-        avoidance_vector = Vec2(0, 0)
-
-        # Schleife über alle Fahrzeuge (außer dem eigenen)
-        for other in self.garage_vehicles:
-            if other == current_vehicle:
-                continue
-            other_pos = other.getPos(self.render)
-            diff = Vec2(current_pos.getX() - other_pos.getX(),
-                        current_pos.getY() - other_pos.getY())
-            dist = diff.length()
-            if dist > 0 and dist < safe_distance:
-                # Je näher das Fahrzeug, desto größer der Einfluss (gewichtete Summe)
-                weight = (safe_distance - dist) / safe_distance
-                avoidance_vector += diff.normalized() * weight
-
-        # Falls kein Fahrzeug in der Nähe ist, wird kein Ausweichwinkel angewendet.
-        if avoidance_vector.length() == 0:
-            return 0.0
-
-        # Berechne den Winkel, den der resultierende Ausweichvektor vorgibt.
-        avoidance_angle = math.degrees(math.atan2(avoidance_vector.getY(), avoidance_vector.getX()))
-        # Mit einem Faktor abschwächen, um den Einfluss zu mildern.
-        weight_factor = 0.5  # Passe diesen Faktor bei Bedarf an (0 = kein Ausweichen, 1 = voll)
-        return avoidance_angle * weight_factor
-
-    def log_training_sample(self, sensor_data, ideal_angle):
-        """
-        Speichert ein Trainingssample bestehend aus den gesammelten Sensorwerten und dem idealen Korrekturwinkel.
-        """
-        self.training_data.append((sensor_data.copy(), ideal_angle))
-        # Optional: Gib eine Debug-Ausgabe aus, um das Logging zu überwachen.
-        print(
-            f"[LOG] Trainingssample gespeichert: Ideal Correction = {ideal_angle:.2f}°, Sensor Shape = {sensor_data.shape}")
-
-    def apply_safety_rules(self, vehicle, sensor_data, model_delta_angle, ideal_correction):
-        """
-        Kombiniert den vom Modell (model_delta_angle) und den ideal berechneten Korrekturwert (ideal_correction)
-        nur dann mit einem festen Sicherheitswert, wenn die Sensordaten einen kritischen Occupancy-Level anzeigen.
-
-        Falls der Occupancy-Level niedrig ist, wird ausschließlich der ideal vorhandene Korrekturwert verwendet.
-        """
-        import numpy as np
-        # Beispiel: Untersuche die mittlere Zeile des sensor_data-Grids als Indikator für frontale Hindernisse
-        middle_row = sensor_data[sensor_data.shape[0] // 2]
-        occupancy_level = np.sum(middle_row)
-
-        # Definiere einen kritischen Schwellenwert (diesen Wert ggf. anpassen)
-        threshold = 1.0
-
-        if occupancy_level > threshold:
-            print(
-                f"[RULE] Kritischer Occupancy-Level = {occupancy_level:.2f} erkannt. Sicherheitskorrektur wird angewendet.")
-            # Hier legen wir fest, dass in kritischen Situationen der Sicherheitswert stärker gewichtet wird.
-            safety_correction = 15.0  # z. B. 15° als feste Korrektur (Wert anpassen)
-            # Gewichteter Ansatz: Sicherheitskorrektur dominiert, während ein kleiner Anteil des idealen Wertes einfließt.
-            final_angle = 0.7 * safety_correction + 0.3 * ideal_correction
-        else:
-            # Wenn kein kritischer Wert vorliegt, einfach den ideal berechneten Korrekturwert verwenden.
-            final_angle = ideal_correction
-
-        return final_angle
-
-    def collision_avoidance_adjustment(self, current_vehicle, base_speed, safe_distance=3.0):
-        """
-        Berechnet eine angepasste Geschwindigkeit für ein Fahrzeug (current_vehicle), sodass
-        dessen Basisgeschwindigkeit (base_speed) entsprechend reduziert wird, wenn andere Fahrzeuge
-        in der Nähe sind. Wenn der Abstand zu einem anderen Fahrzeug unter 1 Einheit liegt, wird
-        die Geschwindigkeit auf 0 gesetzt.
-
-        Parameter:
-          current_vehicle: Das Fahrzeug, dessen Geschwindigkeit angepasst werden soll.
-          base_speed: Die Basisgeschwindigkeit (ohne Kollisionseffekt).
-          safe_distance: Der Abstand, unterhalb dessen Fahrzeuge ihre Geschwindigkeit reduzieren.
-
-        Rückgabe:
-          Die angepasste Geschwindigkeit.
-        """
-        current_pos = current_vehicle.getPos(self.render)
-        adjusted_speed = base_speed
-        for veh in self.garage_vehicles:
-            if veh == current_vehicle:
-                continue
-            other_pos = veh.getPos(self.render)
-            distance = (current_pos - other_pos).length()
-            if distance < safe_distance:
-                # Wenn Fahrzeuge extrem nahe kommen, wird die Geschwindigkeit auf 0 gesetzt.
-                if distance < 1.0:
-                    candidate_speed = 0.0
-                else:
-                    # Lineare Reduktion: Je näher das Fahrzeug, desto geringer die erlaubte Geschwindigkeit.
-                    candidate_speed = base_speed * (distance / safe_distance)
-                # Wähle den minimalen Wert
-                if candidate_speed < adjusted_speed:
-                    adjusted_speed = candidate_speed
-                print(f"[Collision Avoidance] Fahrzeug {current_vehicle.getPythonTag('vehicle_id')} "
-                      f"reduziert Geschwindigkeit auf {adjusted_speed:.2f} (Abstand zu Fahrzeug {veh.getPythonTag('vehicle_id')}: {distance:.2f})")
-        return adjusted_speed
-
-    def check_collisions(self):
-        """
-        Ermittelt alle Fahrzeugpaare, die näher als collision_threshold (z.B. 1 Einheit)
-        beieinander liegen – also als kollidierend gelten.
-        """
-        collision_threshold = 1.0  # Fahrzeuge gelten als kollidierend, wenn ihr Abstand unter 1 Einheit liegt
-        collisions = []
-        for i in range(len(self.garage_vehicles)):
-            veh1 = self.garage_vehicles[i]
-            pos1 = veh1.getPos(self.render)
-            for j in range(i + 1, len(self.garage_vehicles)):
-                veh2 = self.garage_vehicles[j]
-                pos2 = veh2.getPos(self.render)
-                if (pos1 - pos2).length() < collision_threshold:
-                    collisions.append((veh1, veh2))
-        return collisions
-
-    def update_rl_on_collisions(self):
-        """
-        Prüft regelmäßig, ob Fahrzeuge kollidieren. Für jedes kollidierende Fahrzeugpaar
-        wird die Kollisionsdauer ermittelt. Liegt diese Dauer über 5 Sekunden,
-        wird der Zustand der Fahrzeuge auf "drive_out" gesetzt – also sollen sie dann
-        einfach weiterfahren.
-        """
-        collisions = self.check_collisions()
-        current_time = self.sim_clock
-
-        # Erstelle oder verwende ein Dictionary, um die Startzeiten der Kollisionspaare zu speichern.
-        if not hasattr(self, "collision_start_times"):
-            self.collision_start_times = {}
-
-        # Erstelle eine Menge der aktuell kollidierenden Fahrzeugpaare (als frozenset, um die Reihenfolge zu ignorieren)
-        current_collision_keys = set()
-        for veh1, veh2 in collisions:
-            key = frozenset({veh1, veh2})
-            current_collision_keys.add(key)
-            if key not in self.collision_start_times:
-                self.collision_start_times[key] = current_time
-            else:
-                duration = current_time - self.collision_start_times[key]
-                if duration > 5.0:
-                    # Wenn die Fahrzeuge länger als 5 Sekunden kollidieren, werden sie "unblocked"
-                    if veh1.getPythonTag("order_state") != "drive_out":
-                        print(
-                            f"[COLLISION] Fahrzeug {veh1.getPythonTag('vehicle_id')} kollidiert seit {duration:.1f}s – Losfahren!")
-                        veh1.setPythonTag("order_state", "drive_out")
-                    if veh2.getPythonTag("order_state") != "drive_out":
-                        print(
-                            f"[COLLISION] Fahrzeug {veh2.getPythonTag('vehicle_id')} kollidiert seit {duration:.1f}s – Losfahren!")
-                        veh2.setPythonTag("order_state", "drive_out")
-                    # Nach dem Unblocken löschen wir den Eintrag für diese kollidierende Fahrzeugpaar.
-                    if key in self.collision_start_times:
-                        del self.collision_start_times[key]
-
-        # Bereinige Einträge, die nicht mehr aktuell sind.
-        keys_to_remove = [key for key in self.collision_start_times if key not in current_collision_keys]
-        for key in keys_to_remove:
-            del self.collision_start_times[key]
-
-        # Falls du hier noch RL-Updates vornehmen möchtest, kannst du an dieser Stelle zusätzliche Logik einfügen.
-
-    def is_station_occupied(self, station, exclude_vehicle=None, occupancy_threshold=1.0):
-        # Bestimme den Zielpunkt der Station – falls über station_blue_dots verfügbar.
-        if hasattr(self, 'station_blue_dots') and station in self.station_blue_dots:
-            station_pos = self.station_blue_dots[station].getPos(self.render)
-        else:
-            station_pos = station.getPos(self.render)
-        for veh in self.garage_vehicles:
-            if veh == exclude_vehicle:
-                continue
-            current_order = veh.getPythonTag("current_order")
-            if current_order is not None and current_order.get("pickup_station") == station:
-                # Blockiere die Station, solange das Fahrzeug nicht den Zustand erreicht hat,
-                # der anzeigt, dass es die Station verlassen hat.
-                if veh.getPythonTag("order_state") not in ["to_delivery", "idle", "next_order"]:
-                    return True
-            # Zusätzlich: Blockiere, wenn ganz nahe am Station-Zielpunkt
-            if (veh.getPos(self.render) - station_pos).length() < occupancy_threshold:
-                return True
-        return False
-
-    def is_delivery_station_occupied(self, station, exclude_vehicle=None, occupancy_threshold=1.0):
-        occupant = station.getPythonTag("occupied_by")
-        if occupant is not None and occupant != exclude_vehicle:
-            return True
-        # Optional: Falls du noch eine physikalische Näheprüfung implementieren möchtest, kannst du dies ergänzen.
-        return False
-
-
-class RLAgent:
-    def __init__(self, state_bins, action_space, learning_rate=0.1, discount_factor=0.9, epsilon=0.2):
-        """
-        state_bins: Tuple oder Liste, um kontinuierliche Zustände zu diskretisieren (z.B. (max_distance, num_bins))
-        action_space: Liste diskreter Aktionen (z.B. [0, 1, 2] --> 0: keine Bremsung, 1: leicht, 2: stark)
-        """
-        self.state_bins = state_bins
-        self.action_space = action_space
-        self.lr = learning_rate
-        self.gamma = discount_factor
-        self.epsilon = epsilon
-        # Initialisiere Q-Tabelle als Dictionary: key: (discretisierter_state), value: Liste von Q-Werten pro Aktion
-        self.q_table = {}
-
-    def discretize_state(self, state):
-        """
-        Nimmt einen Zustandsvektor (z.B. [distance, speed]) und gibt einen diskreten Zustand zurück.
-        Hier ein Beispiel: Falls state[0] = Abstand und state[1] = Geschwindigkeit.
-        """
-        # Beispiel: Wir nehmen an, dass state_bins = ((max_distance, num_bins), (max_speed, num_bins))
-        discrete_state = []
-        for i, (max_val, bins) in enumerate(self.state_bins):
-            # Begrenze state[i] um max_val:
-            val = min(state[i], max_val)
-            bin_size = max_val / bins
-            discrete_state.append(int(val // bin_size))
-        return tuple(discrete_state)
-
-    def select_action(self, state):
-        discrete_state = self.discretize_state(state)
-        if discrete_state not in self.q_table:
-            self.q_table[discrete_state] = [0.0 for _ in self.action_space]
-        # Epsilon-greedy Auswahl:
-        if random.random() < self.epsilon:
-            return random.choice(self.action_space)
-        else:
-            q_values = self.q_table[discrete_state]
-            return self.action_space[np.argmax(q_values)]
-
-    def update(self, state, action, reward, next_state):
-        s = self.discretize_state(state)
-        s_next = self.discretize_state(next_state)
-        if s not in self.q_table:
-            self.q_table[s] = [0.0 for _ in self.action_space]
-        if s_next not in self.q_table:
-            self.q_table[s_next] = [0.0 for _ in self.action_space]
-        a_index = self.action_space.index(action)
-        # Q-Learning Update-Regel:
-        best_next = max(self.q_table[s_next])
-        self.q_table[s][a_index] += self.lr * (reward + self.gamma * best_next - self.q_table[s][a_index])
-
-    def preprocess_input_data(input_data):
-        """
-        Transformiert die Eingabedaten von der Form (batch_size, 20, 20, 1)
-        in einen Tensor der Form (batch_size, 10).
-
-        Vorgehen:
-          1. Jedes Beispiel (20x20x1) wird zunächst zu einem Vektor der Länge 400
-             abgeflacht.
-          2. Dieser Vektor wird in 10 gleich lange Blöcke (je 40 Werte) unterteilt.
-          3. Aus jedem Block wird der Mittelwert berechnet – das Ergebnis ist ein 10-dimensionaler Vektor.
-
-        Parameter:
-          • input_data: NumPy-Array mit Shape (batch_size, 20, 20, 1)
-
-        Rückgabe:
-          • NumPy-Array der Shape (batch_size, 10)
-        """
-        batch_size = input_data.shape[0]
-        # Abflachen jedes Bildes (20*20=400)
-        flattened = input_data.reshape(batch_size, -1)  # Shape: (batch_size, 400)
-        # Neuformen in Blöcke der Größe 40: Shape (batch_size, 10, 40)
-        reshaped = flattened.reshape(batch_size, 10, -1)
-        # Mittelwert je Block berechnen -> Ergebnis: (batch_size, 10)
-        features = np.mean(reshaped, axis=2)
-        return features
-
-    import numpy as np
-
-    def predict_vehicle_rating(self, input_data):
-        """
-        Diese Methode nimmt den Eingabetensor in der Form
-          (batch_size, 20, 20, 1)
-        und transformiert ihn in einen Tensor der Form
-          (batch_size, 10)
-        – indem jedes Beispiel ersteinmal abgeflacht und in 10 gleiche Blöcke (je 40 Werte)
-        unterteilt wird; der Mittelwert jedes Blocks wird als repräsentatives Feature
-        verwendet.
-
-        Anschließend wird der vorverarbeitete Tensor an das Keras‑Modell übergeben,
-        sodass der ValueError aufgrund inkompatibler Eingabeformen nicht mehr auftritt.
-
-        Vorgehen:
-          1. Abflachen jedes Beispiels von (20, 20, 1) zu einem Vektor der Länge 400.
-          2. Neuformen des 400-dimensionalen Vektors in (10, 40).
-          3. Berechnung des Mittelwerts in jeder der 10 Gruppen (Block), wodurch ein
-             10-dimensionaler Vektor entsteht.
-
-        Parameter:
-          • input_data: NumPy‑Array, erwartet die Form (batch_size, 20, 20, 1)
-
-        Rückgabe:
-          • prediction: Das Ergebnis von self.tf_model.predict() auf den vorverarbeiteten
-            Daten (Form (batch_size, 10))
-        """
-        # Schritt 1: Bestimme die Batch-Größe und flache die Bilder ab.
-        batch_size = input_data.shape[0]
-        flattened = input_data.reshape(batch_size, -1)  # Resultat: (batch_size, 400)
-
-        # Schritt 2: Unterteile den 400-dimensionalen Vektor in 10 Blöcke (je 40 Werte).
-        reshaped = flattened.reshape(batch_size, 10, 40)  # (batch_size, 10, 40)
-
-        # Schritt 3: Berechne den Mittelwert jedes Blocks (entsteht ein Vektor der Länge 10).
-        processed_data = np.mean(reshaped, axis=2)  # (batch_size, 10)
-
-        # Übergabe der vorverarbeiteten Daten an das Modell.
-        prediction = self.tf_model.predict(processed_data)
-        return prediction
-
-
-if __name__ == "__main__":
-    # Wichtig: setze auf Windows die Startmethode auf "spawn"
-    multiprocessing.set_start_method('spawn')
-
-    # Erzeuge eine Queue, auch wenn sie später eventuell neu erstellt wird, wenn "G" gedrückt wird.
-    graph_q = Queue()
-    app = LagerSimulation(graph_q)
-    app.run()
-
-    # Beim Schließen der Simulation den Graphprozess ggf. beenden
-    if app.graph_process is not None:
-        app.graph_process.terminate()
-        app.graph_process.join()
\ No newline at end of file
Index: KI/KI39.py
===================================================================
diff --git a/KI/KI39.py b/KI/KI39.py
deleted file mode 100644
--- a/KI/KI39.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,810 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Matplotlib zum Plotten importieren
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs,
-    CardMaker
-)
-
-# Wir nutzen globalClock für dt.
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit & Zeitskalierungsfaktor
-        self.base_speed = 1.5  # Maximale Geschwindigkeit in m/s
-        self.speed_factor = 1.0
-        self.max_steering_rate = 90  # Maximale Lenk-Änderung in Grad pro Sekunde
-
-        # Neue Parameter: Beschleunigung und Bremsverzögerung (Simulationseinheiten)
-        self.acceleration = 2.5  # m/s²
-        self.braking_deceleration = -2.5  # m/s² (negativ)
-
-        # Simulationszeitticker & Statistik
-        self.sim_clock = 0.0
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        self.sim_start_real = globalClock.getFrameTime()
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Zeichne für jede Annahmestation den Align-Punkt (2 m in positive X-Richtung)
-        for station in self.annahme_stationen:
-            station_pos = station.getPos()
-            ls_pickup = LineSegs()
-            ls_pickup.setThickness(3.0)
-            ls_pickup.setColor(LColor(1, 1, 1, 1))
-            ls_pickup.moveTo(station_pos)
-            ls_pickup.drawTo(station_pos + Vec3(2, 0, 0))
-            self.render.attachNewNode(ls_pickup.create())
-
-        # Neue parallele Linie zu jeder Annahmestation, 1.0 Einheit Versatz in Y-Richtung
-        for station in self.annahme_stationen:
-            station_pos = station.getPos()
-            ls_pickup_offset = LineSegs()
-            ls_pickup_offset.setThickness(3.0)
-            ls_pickup_offset.setColor(LColor(1, 1, 1, 1))
-            ls_pickup_offset.moveTo(station_pos + Vec3(0, 1, 0))
-            ls_pickup_offset.drawTo(station_pos + Vec3(2, 1, 0))
-            self.render.attachNewNode(ls_pickup_offset.create())
-
-        # Zusätzliche Linie für den Alignment-Punkt an jeder Annahmestation (Position: (0,1,0.1))
-        for station in self.annahme_stationen:
-            station_pos = station.getPos()
-            ls_align = LineSegs()
-            ls_align.setThickness(3.0)
-            ls_align.setColor(LColor(1, 1, 0, 1))  # Gelb
-            ls_align.moveTo(station_pos)
-            ls_align.drawTo(station_pos + Vec3(0, 1, 0.1))
-            self.render.attachNewNode(ls_align.create())
-
-        # Zeichne für jede Abgabestation den Align-Punkt (2 m in negative X-Richtung)
-        for station in self.abgabe_stationen:
-            station_pos = station.getPos()
-            ls_dropoff = LineSegs()
-            ls_dropoff.setThickness(3.0)
-            ls_dropoff.setColor(LColor(1, 1, 1, 1))
-            ls_dropoff.moveTo(station_pos)
-            ls_dropoff.drawTo(station_pos + Vec3(-2, 0, 0))
-            self.render.attachNewNode(ls_dropoff.create())
-
-        # Neue parallele Linie zu jeder Abgabestation, 1.0 Einheit Versatz in Y-Richtung
-        for station in self.abgabe_stationen:
-            station_pos = station.getPos()
-            ls_dropoff_offset = LineSegs()
-            ls_dropoff_offset.setThickness(3.0)
-            ls_dropoff_offset.setColor(LColor(1, 1, 1, 1))
-            ls_dropoff_offset.moveTo(station_pos + Vec3(0, 1, 0))
-            ls_dropoff_offset.drawTo(station_pos + Vec3(-2, 1, 0))
-            self.render.attachNewNode(ls_dropoff_offset.create())
-
-        # Zusätzliche Linie für den Alignment-Punkt an jeder Abgabestation (Position: (0,1,0.1))
-        for station in self.abgabe_stationen:
-            station_pos = station.getPos()
-            ls_align_dropoff = LineSegs()
-            ls_align_dropoff.setThickness(3.0)
-            ls_align_dropoff.setColor(LColor(1, 1, 0, 1))  # Gelb
-            ls_align_dropoff.moveTo(station_pos)
-            ls_align_dropoff.drawTo(station_pos + Vec3(0, 1, 0.1))
-            self.render.attachNewNode(ls_align_dropoff.create())
-
-        # --- Anfahrstationen (Startstationen) für die Fahrzeuge ---
-        # Diese Stationen sollen bei Y = 15 nebeneinander mit 4 Meter Abstand in X-Richtung liegen.
-        self.anfahrstationen = []
-        num_departure = 2  # Zu Beginn nur 2 Fahrzeuge
-        spacing_departure = 4.0
-        start_x = -spacing_departure * (num_departure - 1) / 2
-        for i in range(num_departure):
-            pos = Vec3(start_x + i * spacing_departure, 15, 0)
-            station = self.erzeuge_gitterbox(pos.getX(), pos.getY(), pos.getZ(), LColor(0.8, 0.8, 0, 1))
-            self.anfahrstationen.append(station)
-
-        # Fahrzeuge erstellen, jeweils eines pro Anfahrstation (insgesamt 2 Fahrzeuge)
-        self.vehicles = []
-        self.cargos = {}  # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}  # Fahrzeug -> zugewiesene Dropoff-Station
-        for i, start_station in enumerate(self.anfahrstationen):
-            vehicle = self.loader.loadModel("models/box")
-            # Fahrzeuge doppelt so lang (x-Achse verdoppelt)
-            vehicle.setScale(2, 1, 0.5)
-            if i % 2 == 0:
-                vehicle.setColor(LColor(0, 0, 1, 1))
-            else:
-                vehicle.setColor(LColor(0, 0, 0.8, 1))
-            vehicle.setPos(start_station.getPos())
-            vehicle.reparentTo(self.render)
-            # Initialisiere die aktuelle Geschwindigkeit und setze einen initialen Heading (0° = in positive X-Richtung)
-            vehicle.setPythonTag("current_speed", 0.0)
-            vehicle.setH(0)
-            # Beim Start wird die Phase "pickup" gesetzt
-            vehicle.setPythonTag("phase", "pickup")
-            self.add_center_marker(vehicle)
-            self.add_front_marker(vehicle)  # Marker in X-Richtung
-            self.add_y_marker(vehicle)  # Marker in Y-Richtung (grün)
-            self.add_alignment_marker(vehicle)  # Alignment-Marker (gelb)
-            self.add_offset_circle(vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-            self.vehicles.append(vehicle)
-
-        # Reste der Pick-up-/Drop-off-Logik
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Erfassung von Daten für Graphen (einmal pro Simulationssekunde)
-        self.graph_data = []
-        self.taskMgr.doMethodLater(1, self.record_graph_data, "RecordGraphDataTask")
-
-        # Graphen öffnen per Taste "G" (nach Schließen wieder möglich)
-        self.graph_opened = False
-        self.accept("g", self.open_graph)
-
-        # Zoom-Funktionalität: Mit Mausrad hereinz- bzw. herauszoomen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_lidar_status, "UpdateLidarStatusTask")
-
-        # Liefervorgang starten (Pickup-Phase) für jedes Fahrzeug mit gestaggertem Start
-        for i, vehicle in enumerate(self.vehicles):
-            self.taskMgr.doMethodLater(i * 0.5,
-                                       lambda task, v=vehicle: self.start_delivery_cycle(v, v.getPos()),
-                                       f"StartDeliveryCycleTask_{i}"
-                                       )
-
-    def zoom_in(self):
-        # Hereinzoomen: Field-of-View (FOV) verkleinern (nicht unter 10°)
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        # Herauszoomen: FOV vergrößern (nicht über 100°)
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def record_graph_data(self, task):
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0
-        self.graph_data.append((self.sim_clock, delivered_per_minute, avg_dwell_time))
-        return Task.again
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        # Mittelpunkt des Fahrzeugs als grüner Punkt zeichnen.
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(0, 1, 0, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def add_front_marker(self, vehicle, scale=0.15):
-        """Fügt einen zusätzlichen Marker (Punkt) am Fahrzeug hinzu, 1.0 in X-Richtung vom Mittelpunkt entfernt."""
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 0, 0, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(1.0, 0, 0.01)
-
-    def add_y_marker(self, vehicle, scale=0.15):
-        """Fügt einen zusätzlichen Marker (Punkt) am Fahrzeug hinzu, 1.0 in Y-Richtung vom Mittelpunkt entfernt.
-           Dieser Marker wird nun grün dargestellt."""
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(0, 1, 0, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 1.0, 0.01)
-
-    def add_alignment_marker(self, vehicle, scale=0.15):
-        """Fügt einen neuen Alignment-Marker hinzu, an dem sich das Fahrzeug einpendeln soll.
-           Positioniert relativ zum Fahrzeug bei (0,1,0.1) und in Gelb."""
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 0, 1))  # Gelb
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 1, 0.1)
-
-    def add_offset_circle(self, vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5, num_segments=32):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        for i in range(num_segments + 1):
-            angle = 2 * math.pi * i / num_segments
-            x = circle_radius * math.cos(angle)
-            y = circle_radius * math.sin(angle)
-            if i == 0:
-                ls.moveTo(x, y, 0)
-            else:
-                ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        circle_np = vehicle.attachNewNode(circle_geom)
-        circle_np.setPos(offset)
-        vehicle.setPythonTag("lidar_circle", circle_np)
-
-    def draw_coordinate_axes(self, axis_length=5):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(1, 0, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        ls.setColor(0, 1, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        ls.setColor(0, 0, 1, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), (1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), (0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), (0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def update_lidar_status(self, task):
-        sensor_threshold = 3.0
-        for vehicle in self.vehicles:
-            pos = vehicle.getPos(self.render)
-            total_avoidance = Vec3(0, 0, 0)
-            # Standardmäßig volle Geschwindigkeit
-            multiplier = 1.0
-            phase = vehicle.getPythonTag("phase") if vehicle.hasPythonTag("phase") else "pickup"
-            # Dynamische Hindernisse: Andere Fahrzeuge
-            for other in self.vehicles:
-                if other is vehicle:
-                    continue
-                pos_other = other.getPos(self.render)
-                diff = pos - pos_other
-                d = diff.length()
-                if d < sensor_threshold:
-                    other_phase = other.getPythonTag("phase") if other.hasPythonTag("phase") else "pickup"
-                    # Priorität: Falls ein Fahrzeug in Pickup einem in Dropoff gegenübersteht
-                    if phase == "pickup" and other_phase == "dropoff":
-                        candidate = 0.1
-                        avoidance_weight = 2.0
-                    # Falls beide Fahrzeuge in Dropoff sind, entscheidet der Abstand zur Dropoff-Station
-                    elif phase == "dropoff" and other_phase == "dropoff":
-                        my_dropoff = self.current_dropoffs.get(vehicle)
-                        other_dropoff = self.current_dropoffs.get(other)
-                        if my_dropoff and other_dropoff:
-                            my_distance = (pos - my_dropoff.getPos()).length()
-                            other_distance = (pos_other - other_dropoff.getPos()).length()
-                            if my_distance > other_distance:
-                                candidate = 0.1
-                                avoidance_weight = 2.0
-                            else:
-                                candidate = 1.0
-                                avoidance_weight = 1.0
-                        else:
-                            candidate = 1.0
-                            avoidance_weight = 1.0
-                    else:
-                        candidate = 1.0
-                        avoidance_weight = 1.0
-                    multiplier = min(multiplier, candidate)
-                    if d > 0:
-                        total_avoidance += diff.normalized() * (sensor_threshold - d) * avoidance_weight
-
-            # Statische Hindernisse (Annahme-, Abgabe- und Anfahrstationen)
-            static_obstacles = self.annahme_stationen + self.abgabe_stationen + self.anfahrstationen
-            for obst in static_obstacles:
-                pos_obst = obst.getPos(self.render)
-                diff = pos - pos_obst
-                d = diff.length()
-                if d < sensor_threshold:
-                    candidate = 0.1
-                    avoidance_weight = 2.0
-                    multiplier = min(multiplier, candidate)
-                    if d > 0:
-                        total_avoidance += diff.normalized() * (sensor_threshold - d) * avoidance_weight
-
-            vehicle.setPythonTag("speed_multiplier", multiplier)
-            vehicle.setPythonTag("avoidance", total_avoidance)
-            lidar_circle = vehicle.getPythonTag("lidar_circle")
-            if lidar_circle:
-                if multiplier < 1.0 or total_avoidance.length() > 0.001:
-                    lidar_circle.setColor(LColor(1, 0, 0, 1))
-                else:
-                    lidar_circle.setColor(LColor(0, 1, 0, 1))
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-        current_wait_text = (
-            f"Liegedauer (aktuell): {current_max_wait_time:.1f}s"
-            if current_max_wait_time > 0 else "Kein Paket an Annahmestation"
-        )
-        maximal_wait_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted_time}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-            f"{current_wait_text}\n"
-            f"{maximal_wait_text}\n"
-            f"Liegedauer (Durchschnitt): {avg_dwell_time:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(
-            station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1)
-        )
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    # Überarbeitete move_vehicle_to-Methode mit Lenkachse-Logik:
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        def move_task(task):
-            dt = globalClock.getDt()
-            sim_dt = dt * self.speed_factor
-            current_pos = vehicle.getPos()
-            # Vektor von Fahrzeug zum Ziel
-            to_target = target - current_pos
-
-            # Falls es einen Hindernisvermeidungsvektor gibt, diesen einbeziehen
-            avoidance = vehicle.getPythonTag("avoidance") if vehicle.hasPythonTag("avoidance") else Vec3(0, 0, 0)
-            if avoidance.length() > 0.001:
-                # Gewichtete Kombination von Zielrichtung und Vermeidung
-                combined = to_target + avoidance * 0.5
-                if combined.length() > 0.001:
-                    combined.normalize()
-                else:
-                    combined = to_target.normalized()
-                desired_direction = combined
-            else:
-                desired_direction = to_target.normalized()
-
-            distance = (target - current_pos).length()
-
-            # Aktualisiere Geschwindigkeit (Beschleunigung / Bremsen)
-            multiplier = vehicle.getPythonTag("speed_multiplier") if vehicle.hasPythonTag("speed_multiplier") else 1.0
-            effective_max_speed = self.base_speed * multiplier
-            current_speed = vehicle.getPythonTag("current_speed") if vehicle.hasPythonTag("current_speed") else 0.0
-
-            braking_distance = (current_speed ** 2) / (2 * abs(self.braking_deceleration)) if current_speed > 0 else 0
-            if distance <= braking_distance:
-                new_speed = current_speed + self.braking_deceleration * sim_dt
-                new_speed = max(new_speed, 0.0)
-            else:
-                new_speed = current_speed + self.acceleration * sim_dt
-                new_speed = min(new_speed, effective_max_speed)
-
-            # Lenkverhalten: Bestimme den gewünschten Heading aus der gewünschten Richtung.
-            current_heading = vehicle.getH()  # Aktuelle Ausrichtung in Grad
-            desired_heading = math.degrees(math.atan2(desired_direction.getY(), desired_direction.getX()))
-            # Berechne den Differenzwinkel, normalisiert auf den Bereich (-180, 180)
-            heading_diff = desired_heading - current_heading
-            while heading_diff > 180:
-                heading_diff -= 360
-            while heading_diff < -180:
-                heading_diff += 360
-
-            max_steering_change = self.max_steering_rate * sim_dt
-            if heading_diff > max_steering_change:
-                heading_change = max_steering_change
-            elif heading_diff < -max_steering_change:
-                heading_change = -max_steering_change
-            else:
-                heading_change = heading_diff
-
-            new_heading = current_heading + heading_change
-            vehicle.setH(new_heading)
-
-            # Berechne die Vorwärtsrichtung aus dem neuen Heading (Fahrzeug bewegt sich entlang seiner Längsachse)
-            rad = math.radians(new_heading)
-            forward_vector = Vec3(math.cos(rad), math.sin(rad), 0)
-
-            step_distance = new_speed * sim_dt
-            if distance <= step_distance:
-                vehicle.setPos(target)
-                vehicle.setPythonTag("current_speed", 0.0)
-                on_complete()
-                return Task.done
-
-            new_pos = current_pos + forward_vector * step_distance
-            vehicle.setPos(new_pos)
-            vehicle.setPythonTag("current_speed", new_speed)
-            return Task.cont
-
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        # Beginn eines neuen Auftrags: Phase "pickup" und Speichern des job_start-Zeitpunkts
-        vehicle.setPythonTag("job_start", self.sim_clock)
-        vehicle.setPythonTag("phase", "pickup")
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        # Verfügbare Pickup-Stationen, die momentan nicht belegt sind
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-
-        # Kombiniertes Ranking: Wartezeit minus ein Anteil an der Entfernung
-        distance_weight = 0.5  # Anpassbar
-        pickup_station = max(available_pickups, key=lambda s: (current_time - self.pickup_packages[s][1])
-                                                              - distance_weight * (
-                                                                  (s.getPos() - vehicle.getPos()).length()))
-        self.occupied_pickups.add(pickup_station)
-        # Zuerst zum Voranfahrpunkt, dann zum Station-Mittelpunkt und schlussendlich Feinausrichtung.
-        pickup_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        self.move_vehicle_to(vehicle, pickup_align,
-                             lambda: self.move_vehicle_to(vehicle, pickup_station.getPos(),
-                                                          lambda: self.align_vehicle_to_station(vehicle, pickup_station,
-                                                                                                lambda: self.after_pickup(
-                                                                                                    vehicle,
-                                                                                                    pickup_station))))
-
-    def after_pickup(self, vehicle, pickup_station):
-        self.pickup_package(vehicle, pickup_station)
-        # Nach erfolgreichem Pickup auf Dropoff-Phase setzen
-        vehicle.setPythonTag("phase", "dropoff")
-        self.depart_from_pickup(vehicle, pickup_station,
-                                lambda: self.start_dropoff_phase(vehicle))
-
-    def depart_from_pickup(self, vehicle, pickup_station, callback):
-        departure_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        departure_target = pickup_station.getPos() + Vec3(4, 0, 0)
-        self.move_vehicle_to(vehicle, departure_align,
-                             lambda: self.move_vehicle_to(vehicle, departure_target, callback))
-
-    def start_dropoff_phase(self, vehicle):
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.start_dropoff_phase(vehicle)
-            return
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-        # Analog: zuerst Voranfahrpunkt, dann Station, dann Feinausrichtung an der Linie
-        self.move_vehicle_to(vehicle, dropoff_align,
-                             lambda: self.move_vehicle_to(vehicle, dropoff_station.getPos(),
-                                                          lambda: self.align_vehicle_to_station(vehicle,
-                                                                                                dropoff_station,
-                                                                                                lambda: self.after_dropoff(
-                                                                                                    vehicle))))
-
-    def after_dropoff(self, vehicle):
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        self.drop_cargo(vehicle)
-        self.remove_cargo(vehicle, remove_dropoff=True)
-        if dropoff_station is not None:
-            departure_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-            departure_target = dropoff_station.getPos() + Vec3(-4, 0, 0)
-            self.move_vehicle_to(vehicle, departure_align,
-                                 lambda: self.move_vehicle_to(vehicle, departure_target,
-                                                              lambda: self.start_delivery_cycle(vehicle,
-                                                                                                departure_target)))
-        else:
-            self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle, remove_dropoff=True):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        if remove_dropoff:
-            dropoff_station = self.current_dropoffs.get(vehicle)
-            if dropoff_station in self.occupied_dropoffs:
-                self.occupied_dropoffs.remove(dropoff_station)
-            if vehicle in self.current_dropoffs:
-                del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-    def align_vehicle_to_station(self, vehicle, station, on_complete):
-        """
-        Diese Methode sorgt dafür, dass sich das Fahrzeug beim Anfahren an der Station
-        feinausrichtet – also sowohl der Mittelpunkt als auch der Alignment-Marker (relativ (0,1,0.1))
-        an den an der Station gezeichneten Linien einpendeln.
-        """
-        # Gewünschte Zielpositionen (absolut im Render-Koordinatensystem)
-        desired_center = station.getPos(self.render)
-        desired_align = station.getPos(self.render) + Vec3(0, 1, 0.1)
-
-        def alignment_task(task):
-            dt = globalClock.getDt() * self.speed_factor
-            current_center = vehicle.getPos(self.render)
-            # Berechne die aktuelle Position des Alignment-Markers; hier erfolgt die Transformation
-            current_align = current_center + vehicle.getQuat(self.render).xform(Vec3(0, 1, 0.1))
-            err_center = desired_center - current_center
-            err_align = desired_align - current_align
-            # Kombiniere beide Fehlerwerte
-            error = (err_center + err_align) * 0.5
-
-            if error.length() < 0.05:
-                vehicle.setPos(desired_center)
-                # Optional: Setze den Heading exakt so, dass der Alignment-Marker passt.
-                # Hier gehen wir davon aus, dass die gewünschte Richtung der Vektor (0,1,0) (bzw. mit z leicht versetzt) ist.
-                vehicle.setH(0)
-                on_complete()
-                return Task.done
-
-            # Neue Position proportional zum Fehler
-            new_center = current_center + error * dt
-
-            # Bestimme den gewünschten Heading: Hier orientieren wir uns an der Richtung vom gewünschten Mittelpunkt zum gewünschten Alignment.
-            desired_dir = (desired_align - desired_center).normalized()
-            # Aktuelle Richtung des Fahrzeugs (entspricht der Richtung des Alignment-Markers)
-            current_dir = vehicle.getQuat(self.render).xform(Vec3(0, 1, 0))
-            current_heading = math.degrees(math.atan2(current_dir.getY(), current_dir.getX()))
-            desired_heading = math.degrees(math.atan2(desired_dir.getY(), desired_dir.getX()))
-            heading_diff = desired_heading - current_heading
-            while heading_diff > 180:
-                heading_diff -= 360
-            while heading_diff < -180:
-                heading_diff += 360
-
-            # Wende einen proportionale Korrektur an
-            gain = 60.0  # Korrekturverstärkung (anpassbar)
-            new_heading = vehicle.getH() + gain * dt * (heading_diff / 180.0)
-
-            vehicle.setPos(new_center)
-            vehicle.setH(new_heading)
-            return Task.cont
-
-        self.taskMgr.add(alignment_task, f"AlignVehicle_{id(vehicle)}")
-
-
-app = LagerSimulation()
-app.run()
Index: KI/KI13.py
===================================================================
diff --git a/KI/KI13.py b/KI/KI13.py
deleted file mode 100644
--- a/KI/KI13.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,396 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode
-)
-
-# Globaler Clock
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit (1.5 m/s) und initialer Geschwindigkeitsfaktor 1.0
-        # (d.h. normal, 1.5 m/s bei Faktor 1.0).
-        self.base_speed = 1.5
-        self.speed_factor = 1.0
-        self.speed = self.base_speed * self.speed_factor
-
-        # Speichere den Zeitpunkt des Simulationsstarts (reale Zeit) für den dynamischen Start von Fahrzeug 2.
-        self.sim_start_time = globalClock.getFrameTime()
-
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pick = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pick)
-            drop = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(drop)
-
-        # Fahrzeuge initialisieren – zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}  # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}  # Fahrzeug -> aktuell reservierte Abgabestation
-
-        # Fahrzeug 1: startet sofort
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-
-        # Fahrzeug 2: soll 8 simulierte Sekunden später starten.
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)  # y-Offset von 2 Einheiten
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-
-        # Globaler Pool für Pickup-Pakete
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = globalClock.getFrameTime()
-
-        # Reservierungssätze
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider zur Anpassung des Geschwindigkeitsfaktors:
-        # Wertebereich: 0.1 bis 10, mit Startwert 1.0 (normale Simulationsgeschwindigkeit)
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Speed: {self.speed_factor:.1f} (eff: {self.speed:.1f} m/s)",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        # Task, der einmal pro Echtsekunde den Slider abfragt
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-
-        # Alle zeitbasierten Tasks nutzen sim_time zur Anpassung
-        self.taskMgr.doMethodLater(self.sim_time(1), self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-
-        # Starte den Lieferzyklus für Fahrzeug 1 sofort...
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-        # ... und starte Fahrzeug 2 dynamisch, sobald 8 simulierte Sekunden vergangen sind.
-        self.taskMgr.add(self.check_vehicle2_start, "CheckVehicle2StartTask")
-
-    def sim_time(self, t):
-        """
-        Berechnet den um den aktuellen Geschwindigkeitsfaktor skalierten Zeitwert.
-        Basiszeit t (in Sekunden) wird durch speed_factor geteilt.
-        """
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        """
-        Wird einmal pro Echtsekunde aufgerufen, um den Sliderwert abzufragen und dadurch
-        alle neuen Zeitwerte (über sim_time) dynamisch an den aktuellen Faktor anzupassen.
-        """
-        self.update_simulation_speed()
-        return Task.again
-
-    def check_vehicle2_start(self, task):
-        """
-        Überprüft einmal pro Frame, ob 8 simulierte Sekunden seit Simulationsbeginn vergangen sind.
-        Simulierte Zeit = (aktuelle reale Zeit - sim_start_time) * speed_factor.
-        Sobald dieser Wert >= 8 ist, wird der Liefervorgang von Fahrzeug 2 gestartet.
-        """
-        elapsed_sim = (globalClock.getFrameTime() - self.sim_start_time) * self.speed_factor
-        if elapsed_sim >= 8.0:
-            if not hasattr(self, 'vehicle2_started'):
-                self.vehicle2_started = True
-                self.start_delivery_cycle(self.vehicles[1], self.vehicles[1].getPos())
-            return Task.done
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        """
-        Aktualisiert den Geschwindigkeitsfaktor, berechnet die effektive Fahrzeuggeschwindigkeit
-        und passt das Label an. Diese Werte werden in allen neuen Tasks via sim_time() genutzt.
-        """
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed = self.base_speed * self.speed_factor
-        self.speed_label['text'] = f"Sim Speed: {self.speed_factor:.1f} (eff: {self.speed:.1f} m/s)"
-
-    def check_and_spawn_packages(self, task):
-        """
-        Überprüft alle Annahmestationen:
-          Falls an einer Station kein Paket vorhanden ist und seit dem letzten Spawn (last_removed)
-          mindestens die simulierte Basiswartezeit (1 s) vergangen ist, wird ein Paket erzeugt.
-        """
-        spawn_delay = self.sim_time(1)
-        current_time = globalClock.getFrameTime()
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if current_time - self.last_removed.get(station, current_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.again
-
-    def spawn_package_at_station(self, station):
-        """
-        Erzeugt an der gegebenen Annahmestation ein Paket (als Würfel), setzt es um +1 in Z
-        und hängt einen TextNode zur Anzeige der Wartezeit an.
-        """
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = globalClock.getFrameTime()
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        """
-        Aktualisiert fortlaufend den angezeigten Timer auf den Paketen.
-        Die simulierte verstrichene Zeit wird als (current_time - spawn_time) * speed_factor berechnet.
-        """
-        current_time = globalClock.getFrameTime()
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed_sim = (current_time - spawn_time) * self.speed_factor
-            tn = timer_np.node()
-            tn.setText(f"{elapsed_sim:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        """
-        Bewegt das Fahrzeug dynamisch in jedem Frame zum Ziel (target) unter Nutzung des aktuellen
-        Wertes von self.speed. Sobald das Ziel erreicht ist, wird on_complete() aufgerufen.
-        """
-
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            direction = target - current_pos
-            distance = direction.length()
-            step = self.speed * dt
-            if distance <= step:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-            else:
-                vehicle.setPos(current_pos + direction.normalized() * step)
-                return Task.cont
-
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        """
-        Führt für ein Fahrzeug den Liefervorgang aus:
-          1. Wählt aus dem globalen Pickup-Paket-Pool das älteste Paket (basierend auf simulierten Wartezeiten),
-             sofern dessen Pickup-Station frei ist.
-          2. Reserviert die Pickup-Station, fährt dorthin (mittels move_vehicle_to) und übergibt das Paket.
-          3. Wählt dann zufällig eine freie Abgabestation, reserviert sie und fährt dorthin.
-          4. Nach einer simulierten Wartezeit (1 s) wird das Paket abgesetzt, Reservierungen werden aufgehoben,
-             und der nächste Zyklus startet.
-        """
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-
-        if not self.pickup_packages:
-            self.taskMgr.doMethodLater(self.sim_time(1),
-                                       lambda t: self.start_delivery_cycle(vehicle, vehicle.getPos()),
-                                       "RetryCycle_" + str(id(vehicle)))
-            return
-
-        current_time = globalClock.getFrameTime()
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            self.taskMgr.doMethodLater(self.sim_time(1),
-                                       lambda t: self.start_delivery_cycle(vehicle, vehicle.getPos()),
-                                       "RetryCycle_" + str(id(vehicle)))
-            return
-
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        pickup_pos = pickup_station.getPos()
-
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.occupied_pickups.remove(pickup_station)
-            self.taskMgr.doMethodLater(self.sim_time(1),
-                                       lambda t: self.start_delivery_cycle(vehicle, vehicle.getPos()),
-                                       "RetryCycle_" + str(id(vehicle)))
-            return
-
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_pos = dropoff_station.getPos()
-
-        # Bewege das Fahrzeug dynamisch zur Pickup-Station
-        self.move_vehicle_to(vehicle, pickup_pos, lambda: self.after_pickup(vehicle, pickup_station, dropoff_pos))
-
-    def after_pickup(self, vehicle, pickup_station, dropoff_pos):
-        """
-        Wird aufgerufen, wenn das Fahrzeug die Pickup-Station erreicht hat.
-        Übergibt das Paket und bewegt das Fahrzeug dynamisch zur Abgabestation.
-        """
-        self.pickup_package(vehicle, pickup_station)
-        self.move_vehicle_to(vehicle, dropoff_pos, lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        """
-        Nachdem das Fahrzeug die Abgabestation erreicht hat, wird das Paket abgesetzt.
-        Nach einer simulierten Wartezeit von 1 Sekunde wird der aktuell transportierte
-        Auftrag abgeschlossen und der nächste Zyklus gestartet.
-        """
-        self.drop_cargo(vehicle)
-        self.taskMgr.doMethodLater(self.sim_time(1),
-                                   lambda t: self.finish_cycle(vehicle),
-                                   f"FinishCycle_{id(vehicle)}")
-
-    def finish_cycle(self, vehicle):
-        """
-        Entfernt das aktuell transportierte Paket und startet den nächsten Lieferzyklus.
-        """
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        """
-        Das Fahrzeug übernimmt an der angegebenen Pickup-Station das Paket.
-        Dabei wird der Timer-Text entfernt, der Eintrag aus dem Pickup-Pool gelöscht,
-        der Zeitpunkt aktualisiert und die Pickup-Reservierung aufgehoben.
-        """
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = globalClock.getFrameTime()
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        """
-        Das vom Fahrzeug transportierte Paket wird an der reservierten Abgabestation (Z+1) abgesetzt.
-        """
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-
-    def remove_cargo(self, vehicle):
-        """
-        Entfernt das aktuell transportierte Paket und gibt die reservierte Abgabestation frei.
-        """
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        if dropoff_station in self.occupied_dropoffs:
-            self.occupied_dropoffs.remove(dropoff_station)
-            del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        """
-        Erzeugt ein Bodenraster als Referenz.
-        """
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        """
-        Erzeugt ein Wireframe-Box-Modell als Station.
-        """
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        """
-        Erzeugt einen Würfel (als Paket), der etwas über dem Boden platziert wird.
-        """
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        """
-        Einfache Beleuchtung mittels Ambient- und Richtungslicht.
-        """
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-# Starte die Simulation
-app = LagerSimulation()
-app.run()
Index: KI/KI9.py
===================================================================
diff --git a/KI/KI9.py b/KI/KI9.py
deleted file mode 100644
--- a/KI/KI9.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,311 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode
-)
-# Globaler Clock über ClockObject
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.interval.IntervalGlobal import Sequence, Wait, LerpPosInterval, Func
-from direct.task import Task
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Fahrzeuggeschwindigkeit: 1.5 m/s * 5 = 7.5 m/s
-        self.speed = 1.5 * 5
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie (gleicher Abstand)
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            # Annahmestation links (rot) bei x = -9
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            # Abgabestation rechts (grün) bei x = 9
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeuge initialisieren – zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}             # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}   # Fahrzeug -> aktuell gewählte Abgabestation
-
-        # Fahrzeug 1
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-
-        # Fahrzeug 2 – leicht versetzt, damit sich die Modelle nicht überlappen.
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)  # y‑Offset von 2 Einheiten
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-
-        # Globaler Pool für alle Pickup‑Pakete:
-        # Schlüssel = Annahmestation, Wert = (Paket, Spawnzeit, Timer-TextNode)
-        self.pickup_packages = {}
-        # Für jede Station wird der Zeitpunkt des letzten Entfernens initialisiert.
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = globalClock.getFrameTime()
-
-        # Reservierungssets:
-        self.occupied_dropoffs = set()  # Für Drop-Offs (bereits vorhanden)
-        self.occupied_pickups = set()    # Neu: für Pickup-Stationen
-
-        # Starte einen Task, der regelmäßig prüft, ob an einer Annahmestation ein Paket fehlen soll.
-        # (Spawnzeit wurde hier nicht verändert – siehe unten in check_and_spawn_packages)
-        self.taskMgr.doMethodLater(1, self.check_and_spawn_packages, "CheckSpawnPackages")
-        # Task zum Aktualisieren der Timer-Anzeige über den Paketen.
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-
-        # Starte für Fahrzeug 1 den Auftrag sofort...
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-        # ... und für Fahrzeug 2 8 Sekunden später.
-        self.taskMgr.doMethodLater(8, lambda t, veh=self.vehicles[1]:
-                                     self.start_delivery_cycle(veh, veh.getPos()),
-                                     "StartVehicle2")
-
-    def check_and_spawn_packages(self, task):
-        """
-        Überprüft alle Annahmestationen:
-          Falls an einer Station noch kein Paket vorhanden ist und seit dem letzten
-          Entfernen mindestens 1 Sekunde vergangen sind, wird ein Paket erzeugt.
-        """
-        spawn_delay = 1  # 1 Sekunde Wartezeit pro Station
-        current_time = globalClock.getFrameTime()
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if current_time - self.last_removed.get(station, current_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.again
-
-    def spawn_package_at_station(self, station):
-        """
-        Erzeugt ein Paket (als Würfel) an der gegebenen Annahmestation.
-        Das Paket wird mit einem Z-Offset von +1 positioniert. Zusätzlich wird über dem Paket
-        ein TextNode angehängt, der später die Wartezeit anzeigt.
-        """
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = globalClock.getFrameTime()
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        """
-        Aktualisiert in jedem Frame den Text (Wartezeit) aller wartenden Pakete.
-        """
-        current_time = globalClock.getFrameTime()
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = current_time - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        """
-        Liefert für ein einzelnes Fahrzeug folgenden Ablauf:
-          1. Aus dem globalen Pool der Pickup‑Pakete wählt das Fahrzeug das Paket mit der
-             höchsten Wartezeit (also das älteste Paket, gemessen an der Spawnzeit) – jedoch
-             nur, wenn die entsprechende Annahmestation noch nicht reserviert ist.
-          2. Das Fahrzeug reserviert diese Pickup‑Station und fährt dorthin, um das Paket aufzunehmen.
-          3. Als nächstes wählt es unter den noch nicht besetzten Abgabestationen zufällig eine aus,
-             reserviert diese und fährt dorthin.
-          4. Nach 1 Sekunde Wartezeit wird das Paket abgesetzt und beide Reservierungen aufgehoben.
-          5. Der nächste Zyklus startet von der aktuellen Position des Fahrzeugs.
-        """
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-
-        if not self.pickup_packages:
-            self.taskMgr.doMethodLater(1,
-                lambda t: self.start_delivery_cycle(vehicle, vehicle.getPos()),
-                "RetryCycle_" + str(id(vehicle)))
-            return
-
-        current_time = globalClock.getFrameTime()
-        # Filtern: nur Pakete, deren Pickup-Station nicht bereits reserviert ist.
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            self.taskMgr.doMethodLater(1,
-                lambda t: self.start_delivery_cycle(vehicle, vehicle.getPos()),
-                "RetryCycle_" + str(id(vehicle)))
-            return
-
-        # Wähle das Paket mit der höchsten Wartezeit aus den verfügbaren Annahmestationen.
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        # Reserviere die Pickup-Station.
-        self.occupied_pickups.add(pickup_station)
-        pickup_pos = pickup_station.getPos()
-        seg1_duration = (pickup_pos - start_pos).length() / self.speed
-
-        # Wähle als Abgabestation nur aus denen, die noch nicht reserviert sind.
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            # Falls keine Abgabestation frei ist, gebe die Pickup-Reservierung wieder frei und versuche später.
-            self.occupied_pickups.remove(pickup_station)
-            self.taskMgr.doMethodLater(1,
-                lambda t: self.start_delivery_cycle(vehicle, vehicle.getPos()),
-                "RetryCycle_" + str(id(vehicle)))
-            return
-
-        dropoff_station = random.choice(available_dropoffs)
-        # Reserviere die Abgabestation.
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-
-        dropoff_pos = dropoff_station.getPos()
-        seg2_duration = (dropoff_pos - pickup_pos).length() / self.speed
-
-        cycle = Sequence(
-            LerpPosInterval(vehicle, duration=seg1_duration, pos=pickup_pos),
-            Func(self.pickup_package, vehicle, pickup_station),
-            LerpPosInterval(vehicle, duration=seg2_duration, pos=dropoff_pos),
-            Func(self.drop_cargo, vehicle),
-            Wait(1),
-            Func(self.remove_cargo, vehicle),
-            Func(self.start_delivery_cycle, vehicle, vehicle.getPos())
-        )
-        cycle.start()
-
-    def pickup_package(self, vehicle, station):
-        """
-        Das Fahrzeug übernimmt an der angegebenen Annahmestation das wartende Paket.
-        Dabei wird der Timer-Text entfernt, der Eintrag aus dem globalen Pool gelöscht,
-        und die Reservierung der Pickup‑Station aufgehoben (sowie der Zeitpunkt aktualisiert).
-        """
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = globalClock.getFrameTime()
-            # Aufheben der Pickup-Reservierung.
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        """
-        Das vom Fahrzeug transportierte Paket wird exakt auf den Würfel der reservierten
-        Abgabestation (mit einem Z-Offset von +1) abgesetzt.
-        """
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-
-    def remove_cargo(self, vehicle):
-        """
-        Entfernt das aktuell transportierte Paket des Fahrzeugs aus der Szene und gibt die
-        reservierte Abgabestation wieder frei.
-        """
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        if dropoff_station in self.occupied_dropoffs:
-            self.occupied_dropoffs.remove(dropoff_station)
-            del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        """
-        Erzeugt ein Wireframe-Box-Modell als Station.
-        """
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        """
-        Erzeugt einen Würfel (als Paket), der etwas über dem Boden platziert wird.
-        """
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        """
-        Einfaches Beleuchtungssetup: Ambient- und Richtungslicht.
-        """
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-# Starte die Simulation
-app = LagerSimulation()
-app.run()
Index: FFZ/FFZ5.py
===================================================================
diff --git a/FFZ/FFZ5.py b/FFZ/FFZ5.py
deleted file mode 100644
--- a/FFZ/FFZ5.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,309 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    CardMaker,
-    LineSegs,
-    Vec3
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import math  # Für die Sinusfunktion
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte für Simulationszeit und -geschwindigkeit
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kameraeinstellungen (Die Annahme: Fahrtrichtung entlang der Y-Achse)
-        self.cam.setPos(0, -30, 10)
-        self.cam.lookAt(0, 0, 0)
-
-        # Licht und Raster (Raster-Zellen: 0.1 x 0.1)
-        self.setup_light()
-        self.create_grid(center_extent=10, cell_size=0.1)
-
-        # Fahrzeug (stationär) erstellen und Referenz speichern
-        self.vehicle = self.create_vehicle()
-
-        # Slider zur Anpassung der Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Neuer Slider zur Steuerung der Forkhöhe (0 bis 1 Meter)
-        # Dieser Slider kann die automatische Animation überschreiben.
-        self.fork_slider = DirectSlider(
-            range=(0.0, 1.0),
-            value=0.0,
-            pageSize=0.01,
-            command=self.update_fork_height,
-            pos=(-0.7, 0, -0.85),
-            scale=0.3
-        )
-        self.fork_label = DirectLabel(
-            text="Fork Höhe: 0.00m",
-            pos=(-0.7, 0, -0.75),
-            scale=0.07
-        )
-
-        # Anzeige der Laufzeit
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktionalität
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben zum Aktualisieren: Simulationszeit, Anzeige und Kabel- (Fork-) Bewegung
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_cable, "UpdateCableTask")
-        # Die bisherige update_vehicle-Aufgabe wird nicht hinzugefügt, da das Fahrzeug stationär bleiben soll.
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_fork_height(self, height=0, *args):
-        try:
-            height = float(height)
-        except ValueError:
-            height = 0.0
-        self.fork_node.setZ(height)
-        self.fork_label['text'] = f"Fork Höhe: {height:.2f}m"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def create_grid(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            x += cell_size
-
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        grid_np = self.render.attachNewNode(node)
-        grid_np.setColor(0.7, 0.7, 0.7, 1)
-        return grid_np
-
-    def setup_light(self):
-        ambient_light = AmbientLight("ambient_light")
-        ambient_light.setColor((0.5, 0.5, 0.5, 1))
-        ambient_np = self.render.attachNewNode(ambient_light)
-        self.render.setLight(ambient_np)
-
-        directional_light = DirectionalLight("directional_light")
-        directional_light.setColor((1, 1, 1, 1))
-        directional_np = self.render.attachNewNode(directional_light)
-        directional_np.setPos(10, -10, 10)
-        self.render.setLight(directional_np)
-
-    def create_vehicle(self):
-        """
-        Erzeugt ein fahrerloses Transportfahrzeug als 3D-Modell, bestehend aus:
-          - Fahrmodul (Chassis): 1 x 0.5 x 1.2, von (0,0,0) bis (1,0.5,1.2)
-          - Gabelmodul (Fork): 1 x 1.2 x 0.2, hinten am Fahrmodul; freie Seite (globaly = -1.2)
-          - Mast: 1 x 0.1 x 1, oben auf dem Fahrmodul (ab z = 1.2) und in Y zentriert
-        """
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Fahrmodul (Chassis) – Farbe: Rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-
-        # Gabelmodul (Fork) – Farbe: Grau, Höhe 0.2
-        box_fork = self.create_box(1, 1.2, 0.2, (0.3, 0.3, 0.3, 1))
-        node_fork = vehicle_node.attachNewNode(box_fork)
-        node_fork.setTwoSided(True)
-        node_fork.setPos(0, -1.2, 0)
-        self.fork_node = node_fork  # Referenz für spätere Höhenanpassungen
-        self.add_rectangle_to_fork(node_fork)
-
-        # Mast – Farbe: Dunkles Grau (0.2, 0.2, 0.2, 1)
-        box_mast = self.create_box(1, 0.1, 1, (0.2, 0.2, 0.2, 1))
-        node_mast = vehicle_node.attachNewNode(box_mast)
-        node_mast.setTwoSided(True)
-        node_mast.setPos(0, 0.2, 1.2)
-
-        vehicle_node.setPos(-0.5, 0, 0)
-        return vehicle_node
-
-    def add_rectangle_to_fork(self, fork_node):
-        # Zeichne einen 1x1-Rahmen (ohne Füllung) und zwei Diagonalen
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)  # Orange
-
-        ls.moveTo(0, 0, 0.201)
-        ls.drawTo(1, 0, 0.201)
-        ls.drawTo(1, 1, 0.201)
-        ls.drawTo(0, 1, 0.201)
-        ls.drawTo(0, 0, 0.201)
-
-        ls.moveTo(0, 0, 0.201)
-        ls.drawTo(1, 1, 0.201)
-        ls.moveTo(1, 0, 0.201)
-        ls.drawTo(0, 1, 0.201)
-
-        fork_node.attachNewNode(ls.create())
-
-        # Marker am Schnittpunkt der Diagonalen:
-        # Schnittpunkt: (0.5, 0.5, 0.201) → Marker bei z = 0.701
-        point = loader.loadModel("models/smiley")
-        point.setScale(0.05)
-        point.setPos(0.5, 0.5, 0.701)
-        point.setColor(1, 1, 1, 0.5)  # Transparent
-        point.setTransparency(True)
-        point.reparentTo(fork_node)
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData('box', fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, 'vertex')
-        normal = GeomVertexWriter(vdata, 'normal')
-        col = GeomVertexWriter(vdata, 'color')
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def update_cable(self, task):
-        """
-        Animiert den Gabelmodul-Hebevorgang (Kabel) automatisch, sodass das Gabelmodul
-        periodisch (sinusförmig) hoch und runter fährt. Hier schwankt die Z-Position zwischen 0 und 1 Meter.
-        """
-        t = task.time
-        # Berechne einen neuen Höhenwert mit einer Sinusfunktion:
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)  # schwankt zwischen 0 und 1
-        self.fork_node.setZ(new_height)
-        self.fork_label['text'] = f"Fork Höhe: {new_height:.2f}m"
-        return Task.cont
-
-    # Wir entfernen update_vehicle, damit das Fahrzeug stationär bleibt.
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: Grundmodell/Gm12.py
===================================================================
diff --git a/Grundmodell/Gm12.py b/Grundmodell/Gm12.py
deleted file mode 100644
--- a/Grundmodell/Gm12.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,1247 +0,0 @@
-import random
-import math
-import tkinter as tk  # Für das extra Fenster der Auftragsübersicht
-from tkinter import ttk  # Für die tabellarische Darstellung (Treeview)
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5  # Wird in update_vehicle genutzt
-        self.state_timer = 0.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Paketspawning an den Annahmestationen:
-        # Mapping: station (Dummy-Node) -> (Paket, Spawnzeit, Timer Node)
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-        # Graph-Daten (Sim-Zeit, Pakete pro Minute, durchschnittliche Liegedauer)
-        self.graph_data = []
-        self.graph_opened = False
-
-        # Auftragsverwaltung: Speichere alle Aufträge (für die Anzeige) sowie in
-        # einer Queue (Liste) zur sequentiellen Abarbeitung.
-        self.orders = {}         # Für die Anzeige
-        self.orders_queue = []   # Für die Fahrzeugabwicklung (FIFO)
-        self.next_order_id = 1
-
-        # Tkinter-Fenster für Auftragsübersicht
-        self.order_win = None
-        self.order_tree = None
-
-        # Umgebung initialisieren
-        self.draw_origin()
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.create_wall()
-        self.create_annahme_stations()
-        self.create_abgabe_stations()  # Hier wird auch self.abgabe_stations angelegt.
-        self.create_garagen_stations()
-
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # Fahrzeuge in den Garagen erstellen (genau 5 Fahrzeuge)
-        self.create_garage_vehicles()
-
-        # NEU: Auftragssystem für das Testfahrzeug initialisieren
-        # Zustände: "idle", "to_pickup", "wait_pickup", "to_delivery", "deliver"
-        self.first_vehicle_order_state = "idle"
-        self.attached_package = None
-        self.current_order = None  # Der aktuell abgearbeitete Auftrag
-        self.taskMgr.add(self.vehicle_order_task, "VehicleOrderTask")
-
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-        self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    # ---------------------------
-    # SIMULATION UND UI-METHODEN
-    # ---------------------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    # ---------------------------
-    # METHODEN FÜR RASTER, LICHT, MAUER, URSPRUNG
-    # ---------------------------
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # STATIONSOBJEKTE UND ZUORDNUNG
-    # -----------------------------------
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        # Beispielhafte Station-Punkte (siehe dein ursprünglicher Code)
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basisstation (zum Beispiel Rahmen)
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Erzeuge den Marker (großer weißer Punkt) als Orientierung
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Erzeuge den grünen Punkt an der Station (als optionaler Punkt)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zeichne die weiße Linie an der Station.
-            # Die Linie beginnt bei: center + Vec3(0,0,-0.5) und verläuft 3 Meter in X-Richtung.
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            white_line_node = self.render.attachNewNode(line_seg.create())
-
-            # Speichere den Node der weißen Linie global
-            self.white_line = white_line_node
-
-            # Berechne den Mittelpunkt der weißen Linie
-            self.white_line_center = (start_line + end_line) * 0.5
-
-            # Berechne die Richtung der weißen Linie (als 2D-Vektor, normalisiert)
-            line_vec = end_line - start_line
-            self.station_white_direction = Vec2(line_vec.getX(), line_vec.getY()).normalized()
-
-            # Erzeuge den blauen Punkt – dieser dient als Ziel in Phase 1.
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            # Speichere global relevante Punkte für die erste Station
-            if i == 1:
-                self.blue_dot = blue_dot
-                self.station_green_dot = green_dot
-
-            # (Optional) Textanzeige der Stationsnummer:
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) – falls benötigt:
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        self.abgabe_stations = []  # Initialisiere die Liste der Abgabestationen
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basiskonstruktion der Abgabestation
-            node = self.create_abgabe_station(pt)
-            self.abgabe_stations.append(node)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Marker am Zentrum (unverändert)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Grüner Punkt: Ursprünglich center + Vec3(0, 0, 0.5)
-            # Jetzt um 1 Einheit in negativer Z-Richtung: center + Vec3(0, 0, -0.5)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Weiße Linie: Startet ebenfalls bei center + Vec3(0, 0, -0.5)
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            # Hier wird die Linie 3 Einheiten in negativer X-Richtung gezeichnet
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt an der Endposition der Linie
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            # Anzeige der Stationsnummer
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) auf den Stationen
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 3)
-        v5 = pos + Vec3(1, 0, 3)
-        v6 = pos + Vec3(1, 2, 3)
-        v7 = pos + Vec3(0, 2, 3)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 3)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        self.garagen_stations = []
-        self.garagen_parking_points = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            self.garagen_stations.append(pt)
-            # ParkpunktGarage: Verschoben um 0.5 in negativer Y-Richtung:
-            center = pt + Vec3(0.5, 0.5, 1.5)
-            ParkpunktGarage = center + Vec3(0, 0, 0.7)
-            self.garagen_parking_points.append(ParkpunktGarage)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def create_garage_vehicles(self):
-        """
-        Erzeugt nur das erste Fahrzeug in der Simulation.
-
-        Ursprünglich wurde für jeden Garagen-Parkpunkt ein Fahrzeug erstellt.
-        Mit dieser Anpassung wird nur das Fahrzeug am ersten Parkpunkt erzeugt,
-        alle weiteren Fahrzeuge werden nicht erzeugt.
-        """
-        self.garage_vehicles = []
-        if self.garagen_parking_points:
-            park = self.garagen_parking_points[0]  # Nur der erste Parkpunkt wird verwendet.
-            veh = self.create_vehicle(park_point=None)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            # Statt newPos.setZ(0.1) setzen wir den Z-Wert als Offset zum berechneten Wert:
-            newPos.setZ(newPos.getZ() + 0.1)
-            veh.setPos(newPos)
-            self.garage_vehicles.append(veh)
-
-            # Erzeuge Fahrzeugmarker
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # FAHRZEUGERSTELLUNG (FFZ20-INTEGRATION)
-    # -----------------------------------
-    def create_vehicle(self, park_point=None):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Chassis: 1 x 0.5 x 1.2, Farbe Rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # Fork (Gabel): Zwei Zähne
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-        self.fork_node = fork_node
-
-        # Berechne den Mittelpunkt der Gabel (mittels der linken und rechten Eckpunkte)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_corner_global = fork_node.getPos() + left_corner_local
-        right_corner_global = fork_node.getPos() + right_corner_local
-
-        ls_new = LineSegs()
-        ls_new.setThickness(2.0)
-        ls_new.setColor(1, 1, 1, 1)
-        ls_new.moveTo(left_corner_global)
-        ls_new.drawTo(right_corner_global)
-        vehicle_node.attachNewNode(ls_new.create())
-
-        midpoint = (left_corner_global + right_corner_global) * 0.5
-        white_line_vec = right_corner_global - left_corner_global
-        if white_line_vec.length() != 0:
-            white_line_dir = white_line_vec.normalized()
-        else:
-            white_line_dir = Vec3(0, 0, 0)
-        candidate = Vec3(-white_line_dir.getY(), white_line_dir.getX(), 0)
-        vehicle_pos = vehicle_node.getPos()
-        if candidate.dot(vehicle_pos - midpoint) < 0:
-            candidate = -candidate
-        if candidate.length() != 0:
-            perp_direction = candidate.normalized()
-        else:
-            perp_direction = Vec3(0, 0, 0)
-        line_length = 1.0
-        line_end = midpoint + perp_direction * line_length
-        ls_mid = LineSegs()
-        ls_mid.setThickness(2.0)
-        ls_mid.setColor(1, 1, 1, 1)
-        ls_mid.moveTo(midpoint)
-        ls_mid.drawTo(line_end)
-        vehicle_node.attachNewNode(ls_mid.create())
-
-        # Fahrzeug: Gabel – grüner Punkt (als Referenz)
-        green_point_global = midpoint + perp_direction * 0.5
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        self.fork_green = green_marker_np  # Global abgespeichert
-
-        # Mast: Erzeuge den Mast und hänge den Zylinder als Referenz an
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-
-        self.add_diagonals_to_mast(mast_node)
-        intersection = Vec3(0.5, 0.05, 1.0)
-
-        # Fahrzeug: Zylinder – Erzeuge den Zylinder und speichere ihn global
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-        self.vehicle_cylinder = cylinder_node  # Global abgespeichert
-
-        # Optional: Zusätzliche Fahrzeugbestandteile (wie Lidar) können hier ergänzt werden.
-
-        if park_point is None:
-            vehicle_node.setPos(intersection.x, intersection.y, 0)
-        else:
-            vehicle_node.setPos(park_point - intersection)
-
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    # -----------------------------------
-    # FEHLENDE METHODEN: Paketspawning, Würfelerzeugung u.a.
-    # -----------------------------------
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        if hasattr(self, "abgabe_stations") and self.abgabe_stations:
-            target_index = random.randint(1, len(self.abgabe_stations))
-        else:
-            target_index = 1
-
-        # Der Auftrag wird hier erstellt – und zwar genau dann, wenn ein Paket gespawnt wird.
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def update_order_table(self):
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen (z.B. "annahme_station_3") nur die Nummer.
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z.B. "Abgabestation 5") nur die Nummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Bestimme die Fahrzeugzuordnung.
-            # Wird "1" angezeigt, wenn der Auftrag aktuell (und noch nicht erledigt) dem Fahrzeug zugeordnet ist.
-            # Andernfalls wird ein "-" angezeigt.
-            if self.current_order is not None and order["id"] == self.current_order["id"] and order.get(
-                    "status") != "Erledigt":
-                vehicle_display = "1"
-            else:
-                vehicle_display = "-"
-
-            self.order_tree.insert("", tk.END, values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def check_and_spawn_packages(self, task):
-        # Maximale Anzahl an Aufträgen beschränken auf die Anzahl der Pakete in der Simulation
-        max_orders = len(self.pickup_packages)
-        if len(self.orders) >= max_orders:
-            return Task.cont
-
-        spawn_delay = 5.0  # 5 Sekunden Verzögerung zwischen Spawns
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0.0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Wir legen hier die Spalten in der gewünschten Reihenfolge an: Auftrags ID, Annahmestation, Ziel, Fahrzeug.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    # ---------------------------
-    # NEU: Fahrzeugauftrag abarbeiten – Auftrag abrufen und sequentiell abarbeiten
-    # ---------------------------
-    from panda3d.core import Vec2, Vec3, ClockObject
-    import math
-
-    def vehicle_order_task(self, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-
-        # Initialisiere den Zustand, falls noch nicht gesetzt
-        if not hasattr(self, "vehicle_state"):
-            self.vehicle_state = "translate"
-
-        if not self.garage_vehicles:
-            return task.cont
-
-        vehicle = self.garage_vehicles[0]
-
-        # PHASE 1: Translate – Fahre exakt in Richtung des blauen Markers (ohne Offset)
-        if self.vehicle_state == "translate":
-            blue_target = self.blue_dot.getPos(self.render)
-            local_mast = Vec3(0.5, 0.05, 1.0)
-            mast_global = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(local_mast)
-            target_xy = Vec2(blue_target.getX(), blue_target.getY())
-            mast_xy = Vec2(mast_global.getX(), mast_global.getY())
-            error_vector = target_xy - mast_xy
-            threshold = 0.05  # 5 cm Toleranz
-            if error_vector.length() > threshold:
-                direction = error_vector.normalized()
-                move_distance = 1.5 * dt
-                move_vec = direction * move_distance
-                current_pos = vehicle.getPos(self.render)
-                new_pos = Vec3(
-                    current_pos.getX() + move_vec.getX(),
-                    current_pos.getY() + move_vec.getY(),
-                    0
-                )
-                vehicle.setPos(new_pos)
-            else:
-                # Exaktes Ausrichten im XY-Bereich auf den blauen Marker
-                local_offset = vehicle.getQuat(self.render).xform(local_mast)
-                exact_pos = Vec3(
-                    blue_target.getX() - local_offset.getX(),
-                    blue_target.getY() - local_offset.getY(),
-                    0
-                )
-                vehicle.setPos(exact_pos)
-                self.vehicle_state = "rotate"  # Übergang in die Rotationsphase
-
-        # PHASE 2: Rotate – Richte das Fahrzeug in Richtung der Einfahrtrichtung aus
-        elif self.vehicle_state == "rotate":
-            desired_angle = math.degrees(math.atan2(self.station_white_direction.getY(),
-                                                    self.station_white_direction.getX()))
-            # Eventuell anpassen: hier ein 180°-Offset
-            desired_angle = (desired_angle + 180) % 360
-            current_heading = vehicle.getH()
-            angle_diff = (desired_angle - current_heading + 180) % 360 - 180
-            kp_heading = 0.5  # Proportionalbeiwert
-            new_heading = current_heading + kp_heading * angle_diff
-            vehicle.setH(new_heading)
-            if abs(angle_diff) < 1.0:
-                self.vehicle_state = "turn_right"
-
-        # PHASE 3: Turn Right – Drehe das Fahrzeug um 90° nach rechts
-        elif self.vehicle_state == "turn_right":
-            if not hasattr(self, "turn_right_init"):
-                self.turn_right_init = vehicle.getH()
-                self.turn_right_target = (self.turn_right_init + 90) % 360
-            current_heading = vehicle.getH()
-            angle_diff = (self.turn_right_target - current_heading + 180) % 360 - 180
-            kp_turn = 0.5
-            new_heading = current_heading + kp_turn * angle_diff
-            vehicle.setH(new_heading)
-            if abs(angle_diff) < 1.0:
-                self.vehicle_state = "approach"
-                del self.turn_right_init, self.turn_right_target
-
-        # PHASE 4: Approach – Fahre in die Station hinein
-        elif self.vehicle_state == "approach":
-            target = self.station_green_dot.getPos(self.render)
-            current = vehicle.getPos(self.render)
-            error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-            if error_vec.length() > 0.05:
-                direction = error_vec.normalized()
-                move_distance = 1.5 * dt
-                new_pos = Vec3(
-                    current.getX() + direction.getX() * move_distance,
-                    current.getY() + direction.getY() * move_distance,
-                    target.getZ()
-                )
-                vehicle.setPos(new_pos)
-            else:
-                self.vehicle_state = "pickup"  # Statt "done" jetzt in den Pickup-Zustand wechseln
-
-        # PHASE 5: Pickup – Hebe das Gabelmodul (fork_node) an und nimm das Paket auf
-        elif self.vehicle_state == "pickup":
-            # Fahre den Z-Wert der Gabel langsam auf 1 hoch
-            current_z = self.fork_node.getZ()
-            target_z = 1.0
-            raise_speed = 0.5  # Anhebegeschwindigkeit (Einheiten pro Sekunde)
-            if current_z < target_z:
-                new_z = min(target_z, current_z + raise_speed * dt)
-                self.fork_node.setZ(new_z)
-            else:
-                # Sobald die Gabel auf Höhe 1 ist, wird das Paket (sofern vorhanden) angehängt.
-                if not hasattr(self, "package_attached"):
-                    if self.current_order and "package" in self.current_order:
-                        package = self.current_order["package"]
-                        package.reparentTo(self.fork_node)
-                    self.package_attached = True
-                # Starte den Herausfahrvorgang: speichere Start- und Zielposition.
-                self.drive_out_start = vehicle.getPos(self.render)
-                # Beispiel: Fahre 5 Einheiten in Vorwärtsrichtung
-                self.drive_out_target = self.drive_out_start + vehicle.getQuat(self.render).getForward() * 5.0
-                self.vehicle_state = "drive_out"
-
-        # PHASE 6: Drive Out – Fahre langsam aus der Station heraus
-        elif self.vehicle_state == "drive_out":
-            current = vehicle.getPos(self.render)
-            if (current - self.drive_out_start).length() < 5.0:
-                move_distance = 0.5 * dt  # langsame Fahrt
-                forward = vehicle.getQuat(self.render).getForward()
-                new_pos = current + forward * move_distance
-                vehicle.setPos(new_pos)
-            else:
-                self.vehicle_state = "dropoff"
-
-        # PHASE 7: Dropoff – Senke die Gabel (mit Paket) wieder ab
-        elif self.vehicle_state == "dropoff":
-            current_z = self.fork_node.getZ()
-            if current_z > 0.0:
-                lower_speed = 0.5
-                new_z = max(0.0, current_z - lower_speed * dt)
-                self.fork_node.setZ(new_z)
-            else:
-                self.vehicle_state = "to_delivery"
-
-        # PHASE 8: To Delivery – Fahre zur Abgabestation
-        elif self.vehicle_state == "to_delivery":
-            # Hier nutzen wir beispielhaft das erste Element aus self.abgabe_stations
-            target = self.abgabe_stations[0].getPos(self.render)
-            current = vehicle.getPos(self.render)
-            error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-            if error_vec.length() > 0.05:
-                direction = error_vec.normalized()
-                move_distance = 1.5 * dt
-                new_pos = Vec3(
-                    current.getX() + direction.getX() * move_distance,
-                    current.getY() + direction.getY() * move_distance,
-                    target.getZ()
-                )
-                vehicle.setPos(new_pos)
-            else:
-                self.vehicle_state = "finished"
-
-        elif self.vehicle_state == "finished":
-            # Fahrzeug hat die Abgabestation erreicht – hier kann weitere Logik folgen.
-            pass
-
-        return task.cont
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: KI/KI25.py
===================================================================
diff --git a/KI/KI25.py b/KI/KI25.py
deleted file mode 100644
--- a/KI/KI25.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,529 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs
-)
-
-# Wir nutzen globalClock für dt.
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit
-        self.base_speed = 1.5
-        # Zeitskalierungsfaktor
-        self.speed_factor = 1.0
-        # Simulationszeitticker in simulierten Sekunden
-        self.sim_clock = 0.0
-        # Zähler der abgegebenen Pakete
-        self.delivered_packages = 0
-        # Speichert über die gesamte Simulation die maximal erreichte Liegedauer eines Pakets
-        self.max_overall_wait_time = 0.0
-        # Neue Attribute zur Erfassung der durchschnittlichen Liegedauer (in Sekunden)
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Zeitpunkt des Simulationsstarts (reale Zeit)
-        self.sim_start_real = globalClock.getFrameTime()
-
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-        # Erstelle 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeuge initialisieren – zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}  # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}  # Fahrzeug -> aktuell reservierte Abgabestation
-
-        # Fahrzeug 1: startet sofort.
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-        # Fahrzeugmittelpunkt markieren und Lidar-Kreis hinzufügen.
-        self.add_center_marker(vehicle1)
-        self.add_offset_circle(vehicle1, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Fahrzeug 2: startet 8 simulierte Sekunden später.
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)  # y-Offset von 2 Einheiten.
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-        self.add_center_marker(vehicle2)
-        self.add_offset_circle(vehicle2, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Globaler Pool für Pickup-Pakete und Zeitstempel (in simulierten Sekunden).
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider zur Anpassung des Zeitskalierungsfaktors.
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Info-Anzeige.
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tasks.
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_vehicle2_start, "CheckVehicle2StartTask")
-        # Task zur Aktualisierung der Lidar-Farbe und Kollisionsausweichlogik.
-        self.taskMgr.add(self.update_lidar_status, "UpdateLidarStatusTask")
-
-        # Starte Liefervorgänge.
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-        # Fahrzeug 2 startet, sobald 8 simulierte Sekunden erreicht sind (via Task).
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        """
-        Fügt dem Fahrzeug einen weißen Punkt als Markierung des Fahrzeugmittelpunkts hinzu.
-        """
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def add_offset_circle(self, vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5, num_segments=32):
-        """
-        Zeichnet einen Kreis als Visualisierung der Lidar-Grenze des Fahrzeugs.
-        Der Kreis wird relativ zum Fahrzeug angehängt und über den Offset positioniert.
-        """
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))  # Standard: grün.
-        for i in range(num_segments + 1):
-            angle = 2 * math.pi * i / num_segments
-            x = circle_radius * math.cos(angle)
-            y = circle_radius * math.sin(angle)
-            if i == 0:
-                ls.moveTo(x, y, 0)
-            else:
-                ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        circle_np = vehicle.attachNewNode(circle_geom)
-        circle_np.setPos(offset)
-        vehicle.setPythonTag("lidar_circle", circle_np)
-
-    def draw_coordinate_axes(self, axis_length=5):
-        """
-        Zeichnet ein einfaches Koordinatensystem (Achsen) im Ursprung.
-         - X-Achse in Rot,
-         - Y-Achse in Grün,
-         - Z-Achse in Blau.
-        Zusätzlich werden an den Endpunkten Labels positioniert.
-        """
-        ls = LineSegs()
-        ls.setThickness(2)
-        # X-Achse (Rot)
-        ls.setColor(1, 0, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        # Y-Achse (Grün)
-        ls.setColor(0, 1, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        # Z-Achse (Blau)
-        ls.setColor(0, 0, 1, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-
-        # Achsenbeschriftungen
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), (1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), (0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), (0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def update_lidar_status(self, task):
-        """
-        Aktualisiert die Lidar-Anzeige und berechnet eine zusätzliche Ausweichlogik.
-        Liegt ein anderes Fahrzeug im Abstand < 3 m, wird:
-          - Der Kreis rot gefärbt,
-          - Ein repulsiver Ausweichvektor berechnet,
-          - und der Geschwindigkeitsfaktor auf 0.5 gesetzt.
-        """
-        sensor_threshold = 3.0  # Summe der Lidar-Radien
-        for vehicle in self.vehicles:
-            if vehicle.hasPythonTag("lidar_circle"):
-                lidar_circle = vehicle.getPythonTag("lidar_circle")
-                pos = vehicle.getPos(self.render)
-                collision = False
-                avoidance_vec = Vec3(0, 0, 0)
-                for other in self.vehicles:
-                    if other is not vehicle:
-                        pos_other = other.getPos(self.render)
-                        diff = pos - pos_other
-                        distance = diff.length()
-                        if distance < sensor_threshold:
-                            collision = True
-                            if distance > 0:
-                                avoidance_vec += diff.normalized() * (sensor_threshold - distance)
-                if collision:
-                    lidar_circle.setColor(LColor(1, 0, 0, 1))  # rot
-                    vehicle.setPythonTag("avoidance", avoidance_vec)
-                    vehicle.setPythonTag("speed_multiplier", 0.5)
-                else:
-                    lidar_circle.setColor(LColor(0, 1, 0, 1))  # grün
-                    vehicle.setPythonTag("avoidance", Vec3(0, 0, 0))
-                    vehicle.setPythonTag("speed_multiplier", 1.0)
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-
-        if current_max_wait_time > 0:
-            current_wait_text = f"Liegedauer (aktuell): {current_max_wait_time:.1f}s"
-        else:
-            current_wait_text = "Kein Paket an Annahmestation"
-
-        maximal_wait_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-
-        # Berechne den Durchschnitt der Liegedauer (in Sekunden)
-        if self.picked_up_count > 0:
-            avg_dwell_time = self.total_dwell_time / self.picked_up_count
-        else:
-            avg_dwell_time = 0.0
-
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-
-        if self.sim_clock > 0:
-            delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0)
-        else:
-            delivered_per_minute = 0
-
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted_time}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-            f"{current_wait_text}\n"
-            f"{maximal_wait_text}\n"
-            f"Liegedauer (Durchschnitt): {avg_dwell_time:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def check_vehicle2_start(self, task):
-        if self.sim_clock >= 8.0 and not hasattr(self, 'vehicle2_started'):
-            self.vehicle2_started = True
-            self.start_delivery_cycle(self.vehicles[1], self.vehicles[1].getPos())
-            return Task.done
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(
-            station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1)
-        )
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        """
-        Bewegt ein Fahrzeug schrittweise in Richtung des Zielpunkts.
-        Hier fließt neben der direkten Zielrichtung auch der berechnete Ausweichvektor ein.
-        """
-
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            to_target = target - current_pos
-            distance = to_target.length()
-            # Bestimme den individuellen Geschwindigkeitsfaktor (Standard 1.0)
-            multiplier = 1.0
-            if vehicle.hasPythonTag("speed_multiplier"):
-                multiplier = vehicle.getPythonTag("speed_multiplier")
-            effective_speed = self.base_speed * self.speed_factor * multiplier
-            step_distance = effective_speed * dt
-
-            if distance <= step_distance:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-
-            # Hole den Ausweichvektor (falls vorhanden)
-            avoidance = Vec3(0, 0, 0)
-            if vehicle.hasPythonTag("avoidance"):
-                avoidance = vehicle.getPythonTag("avoidance")
-            if avoidance.length() > 0.001:
-                combined = to_target.normalized() + avoidance.normalized() * 0.5
-                combined.normalize()
-                new_direction = combined
-            else:
-                new_direction = to_target.normalized()
-            vehicle.setPos(current_pos + new_direction * step_distance)
-            return Task.cont
-
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        pickup_pos = pickup_station.getPos()
-
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.occupied_pickups.remove(pickup_station)
-
-            def wait_for_dropoff(task):
-                if any(ds not in self.occupied_dropoffs for ds in self.abgabe_stationen):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_dropoff, f"WaitDropoff_{id(vehicle)}")
-            return
-
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_pos = dropoff_station.getPos()
-
-        self.move_vehicle_to(vehicle, pickup_pos, lambda: self.after_pickup(vehicle, pickup_station, dropoff_pos))
-
-    def after_pickup(self, vehicle, pickup_station, dropoff_pos):
-        self.pickup_package(vehicle, pickup_station)
-        self.move_vehicle_to(vehicle, dropoff_pos, lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        self.drop_cargo(vehicle)
-        start_wait = self.sim_clock
-
-        def wait_task(task):
-            if self.sim_clock - start_wait >= self.sim_time(1):
-                self.finish_cycle(vehicle)
-                return Task.done
-            return Task.cont
-
-        self.taskMgr.add(wait_task, f"WaitAfterDrop_{id(vehicle)}")
-
-    def finish_cycle(self, vehicle):
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            # Erfasse die Liegedauer (Wartezeit) des Pakets und aktualisiere Gesamt- und Zählerwerte.
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        if dropoff_station in self.occupied_dropoffs:
-            self.occupied_dropoffs.remove(dropoff_station)
-            del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
Index: Feld/Feld1.py
===================================================================
diff --git a/Feld/Feld1.py b/Feld/Feld1.py
deleted file mode 100644
--- a/Feld/Feld1.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,151 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte für Simulationszeit und -geschwindigkeit
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        # Erzeuge Licht und Bodenraster
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Slider zur Anpassung der Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Anzeige der Kennzahlen (hier: Laufzeit)
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktionalität: Mausrad heran-/herauszoomen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben: Simulationszeit aktualisieren und Kennzahlen anzeigen
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-
-        # Zeichne horizontale Linien
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        # Zeichne vertikale Linien
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: Grundmodell/Gm4.py
===================================================================
diff --git a/Grundmodell/Gm4.py b/Grundmodell/Gm4.py
deleted file mode 100644
--- a/Grundmodell/Gm4.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,613 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Für das Paketspawning an den Annahmestationen
-        self.pickup_packages = {}  # station (NodePath) -> (Paket, Spawnzeit, Timer Node)
-        self.last_removed = {}  # station -> Zeitpunkt der letzten Entfernung
-
-        # Für Graph-Daten und Steuerung
-        self.graph_data = []  # Tupel: (Sim-Zeit, Pakete pro Minute, Durchschnittliche Liegedauer)
-        self.graph_opened = False
-
-        # Ursprung (Koordinatenachsen)
-        self.draw_origin()
-
-        # Kameraeinstellungen: Das ganze Feld soll gut sichtbar sein.
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # Licht und Bodenraster erzeugen
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-
-        # Erzeuge die Mauer (das umschließende Rechteck)
-        self.create_wall()
-
-        # Erzeuge Annahme-, Abgabe- und Garagenstationen
-        self.create_annahme_stations()
-        self.create_abgabe_stations()
-        self.create_garagen_stations()
-
-        # UI: Slider und Info-Anzeige zur Simulationssteuerung
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktion: Mit dem Mausrad hereinz- bzw. herauszoomen.
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        # Graph in extra Fenster per Taste "g" öffnen
-        self.accept("g", self.open_graph)
-
-        # Tasks: Aktualisierung der Simulationszeit, Info-Anzeige, Paketspawning, Paket-Timer und Graph-Daten
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-
-        # Bestimme aktuelle maximale Liegedauer aller wartenden Pakete
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        # X-Achse (rot)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        # Y-Achse (grün)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        # Z-Achse (blau)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # Original Funktion: Annahme-Station (ohne Z-Verschiebung)
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_annahme_station(pt)
-            # Dummy-Node als Referenz für das Paketspawning
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-            # Ursprünglicher Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Zusätzlicher grüner Punkt: 0.5 in positive Z-Richtung vom Mittelpunkt
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, 0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zusätzliche Linie: 3 Meter in positive X-Richtung vom grünen Punkt; Farbe nun weiß
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, 0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt am Ende der Linie
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            # Dekorative Kreuze hinzufügen
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-    # Original Funktion: Abgabestation (ohne Z-Verschiebung)
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_abgabe_station(pt)
-            # Ursprünglicher Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Zusätzlicher grüner Punkt: 0.5 in positive Z-Richtung vom Mittelpunkt
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, 0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zusätzliche Linie: 3 Meter in negative X-Richtung vom grünen Punkt; Farbe nun weiß
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, 0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt am Ende der Linie
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            # Dekorative Kreuze hinzufügen
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 2)
-        v5 = pos + Vec3(1, 0, 2)
-        v6 = pos + Vec3(1, 2, 2)
-        v7 = pos + Vec3(0, 2, 2)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        # Dekorative Kreuze auf geschlossenen Seiten (nicht auf dem Dach)
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 2)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            center = pt + Vec3(0.5, 1, 1)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    # Methoden für Paketspawning und Timer
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        cube = self.loader.loadModel("models/box")
-        cube.setScale(1, 1, 1)
-        cube.setPos(x, y, z + 1)
-        cube.setColor(farbe)
-        cube.reparentTo(self.render)
-        return cube
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)  # 1 Sekunde Simulationszeit
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-    def update_package_timers(self, task):
-        to_remove = []
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            elapsed = self.sim_clock - spawn_time
-            timer_np.node().setText(f"{elapsed:.1f}s")
-            # Wenn das Paket zu lange an der Station liegt (z. B. 5s), entferne es und aktualisiere Kennzahlen.
-            if elapsed >= 5.0:
-                package.removeNode()
-                self.total_dwell_time += elapsed
-                self.picked_up_count += 1
-                self.delivered_packages += 1
-                to_remove.append(station)
-        for station in to_remove:
-            if station in self.pickup_packages:
-                del self.pickup_packages[station]
-            self.last_removed[station] = self.sim_clock
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor != 0 else t
-
-    # Methoden für graphische Darstellung der Kennzahlen
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.setTitle("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.setTitle("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: Feld/Feld3.py
===================================================================
diff --git a/Feld/Feld3.py b/Feld/Feld3.py
deleted file mode 100644
--- a/Feld/Feld3.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,294 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec3,
-    LineSegs
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import math
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte für Simulationszeit und -geschwindigkeit
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Zeichne den Ursprung (Koordinatenachsen) ein
-        self.draw_origin()
-
-        # Kameraeinstellungen: So, dass das gesamte Feld gut sichtbar ist.
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # Erzeuge Licht und Bodenraster
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-
-        # Erzeuge die Mauer (flush, bündig ein Rechteck abschließend)
-        # Die vier Eckpunkte: (0,0,0), (0,60,0), (22,60,0) und (22,0,0)
-        self.create_wall()
-
-        # Erzeuge Annahmestationen, die an den vorgegebenen Punkten platziert werden.
-        self.create_annahme_stations()
-
-        # Slider zur Anpassung der Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Anzeige der Kennzahlen (z. B. Laufzeit)
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktion: Mit Mausrad hereinz- bzw. herauszoomen.
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben: Simulationszeit fortlaufend aktualisieren.
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-
-    def draw_origin(self):
-        """Zeichnet die drei Achsen im Ursprung zur Orientierung."""
-        ls = LineSegs()
-        ls.setThickness(2)
-        # X-Achse (rot)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        # Y-Achse (grün)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        # Z-Achse (blau)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        # Horizontale Linien
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        # Vertikale Linien
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        """
-        Erzeugt vier Wandsegmente, die ein Rechteck abschließen.
-        Die vier Eckpunkte lauten exakt:
-            p1 = (0, 0, 0)
-            p2 = (0, 60, 0)
-            p3 = (22, 60, 0)
-            p4 = (22, 0, 0)
-        Der innere Rand der Mauer liegt genau auf diesen Punkten.
-        """
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        """
-        Fügt ein Wandsegment hinzu – so, dass dessen innere Kante exakt
-        die Verbindung zwischen 'start' und 'end' bildet.
-        Die vier Eckpunkte der Mauer werden in Clockwise-Reihenfolge angegeben.
-        """
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-
-        d = seg_vector.normalized()
-        # Für in Clockwise angegebene Eckpunkte (innerer Bereich rechts) berechnen wir:
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        # Pivot-Korrektur: Zentriere das Modell anhand der TightBounds.
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def create_annahme_station(self, pos):
-        """
-        Erzeugt eine Annahmestation als 1×1×1-Würfel aus Linien (Gitter) in Grün.
-        Die Seite in positiver X-Richtung (x = 1) bleibt geöffnet.
-        'pos' wird als untere linke Ecke des Würfels verwendet.
-        """
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        # Lokale Eckpunkte des Würfels relativ zu pos:
-        v0 = pos + Vec3(0, 0, 0)   # unten, links, hinten
-        v1 = pos + Vec3(1, 0, 0)   # unten, rechts, hinten
-        v2 = pos + Vec3(1, 1, 0)   # unten, rechts, vorne
-        v3 = pos + Vec3(0, 1, 0)   # unten, links, vorne
-        v4 = pos + Vec3(0, 0, 1)   # oben, links, hinten
-        v5 = pos + Vec3(1, 0, 1)   # oben, rechts, hinten
-        v6 = pos + Vec3(1, 1, 1)   # oben, rechts, vorne
-        v7 = pos + Vec3(0, 1, 1)   # oben, links, vorne
-
-        # Zeichne die Kanten des unteren Quadrats (z=0)
-        ls.moveTo(v0)
-        ls.drawTo(v1)    # v0->v1 (wird gezeichnet, da nur einer Endpoint x=1 ist)
-        # v1->v2: beide Punkte haben x==1 → diese Kante bleibt offen
-        ls.moveTo(v2)
-        ls.drawTo(v3)    # v2->v3
-        ls.moveTo(v3)
-        ls.drawTo(v0)    # v3->v0
-
-        # Zeichne die Kanten des oberen Quadrats (z=1)
-        ls.moveTo(v4)
-        ls.drawTo(v5)    # v4->v5 (wird gezeichnet, da v4.x=0, v5.x=1)
-        # v5->v6: beide Punkte haben x==1 → diese Kante wird weggelassen
-        ls.moveTo(v6)
-        ls.drawTo(v7)    # v6->v7
-        ls.moveTo(v7)
-        ls.drawTo(v4)    # v7->v4
-
-        # Zeichne die vertikalen Kanten (nur die, bei denen nicht beide Enden x==1 sind)
-        ls.moveTo(v0)
-        ls.drawTo(v4)    # v0->v4
-        ls.moveTo(v3)
-        ls.drawTo(v7)    # v3->v7
-
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        """
-        Platziert Annahmestationen an den vorgegebenen Positionen:
-          (1, 5, 0), (1, 10, 0), (1, 15, 0), (1, 20, 0), (1, 25, 0),
-          (1, 30, 0), (1, 35, 0), (1, 40, 0), (1, 45, 0) und (1, 50, 0).
-        """
-        station_points = [
-            Vec3(1, 5, 0), Vec3(1, 10, 0), Vec3(1, 15, 0),
-            Vec3(1, 20, 0), Vec3(1, 25, 0), Vec3(1, 30, 0),
-            Vec3(1, 35, 0), Vec3(1, 40, 0), Vec3(1, 45, 0),
-            Vec3(1, 50, 0)
-        ]
-        for pt in station_points:
-            self.create_annahme_station(pt)
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: KI/KI27.py
===================================================================
diff --git a/KI/KI27.py b/KI/KI27.py
deleted file mode 100644
--- a/KI/KI27.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,565 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs
-)
-
-# Wir nutzen globalClock für dt.
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit
-        self.base_speed = 1.5
-        # Zeitskalierungsfaktor
-        self.speed_factor = 1.0
-        # Simulationszeitticker in simulierten Sekunden
-        self.sim_clock = 0.0
-        # Zähler der abgegebenen Pakete
-        self.delivered_packages = 0
-        # Speichert über die gesamte Simulation die maximal erreichte Liegedauer eines Pakets
-        self.max_overall_wait_time = 0.0
-        # Neue Attribute zur Erfassung der durchschnittlichen Liegedauer (in Sekunden)
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Zeitpunkt des Simulationsstarts (reale Zeit)
-        self.sim_start_real = globalClock.getFrameTime()
-
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-        # Erstelle 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Zeichne für jede Annahmestation eine Linie, die 2 Meter in positive x-Richtung verläuft.
-        for station in self.annahme_stationen:
-            station_pos = station.getPos()
-            ls_pickup = LineSegs()
-            ls_pickup.setThickness(3.0)
-            ls_pickup.setColor(LColor(1, 1, 1, 1))  # Weiß
-            ls_pickup.moveTo(station_pos)
-            ls_pickup.drawTo(station_pos + Vec3(2, 0, 0))
-            self.render.attachNewNode(ls_pickup.create())
-
-        # Zeichne für jede Abgabestation eine Linie, die 2 Meter in negative x-Richtung verläuft.
-        for station in self.abgabe_stationen:
-            station_pos = station.getPos()
-            ls_dropoff = LineSegs()
-            ls_dropoff.setThickness(3.0)
-            ls_dropoff.setColor(LColor(1, 1, 1, 1))
-            ls_dropoff.moveTo(station_pos)
-            ls_dropoff.drawTo(station_pos + Vec3(-2, 0, 0))
-            self.render.attachNewNode(ls_dropoff.create())
-
-        # Fahrzeuge initialisieren – zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}  # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}  # Fahrzeug -> aktuell reservierte Abgabestation
-
-        # Fahrzeug 1: startet sofort.
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-        # Fahrzeugmittelpunkt markieren und Lidar-Kreis hinzufügen.
-        self.add_center_marker(vehicle1)
-        self.add_offset_circle(vehicle1, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Fahrzeug 2: startet 8 simulierte Sekunden später.
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)  # y-Offset von 2 Einheiten.
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-        self.add_center_marker(vehicle2)
-        self.add_offset_circle(vehicle2, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Globaler Pool für Pickup-Pakete und Zeitstempel (in simulierten Sekunden).
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider zur Anpassung des Zeitskalierungsfaktors.
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Info-Anzeige.
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tasks.
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_vehicle2_start, "CheckVehicle2StartTask")
-        # Task zur Aktualisierung der Lidar-Farbe und Kollisionsausweichlogik.
-        self.taskMgr.add(self.update_lidar_status, "UpdateLidarStatusTask")
-
-        # Starte Liefervorgänge.
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-        # Fahrzeug 2 startet, sobald 8 simulierte Sekunden erreicht sind (via Task).
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        """
-        Fügt dem Fahrzeug einen weißen Punkt als Markierung des Fahrzeugmittelpunkts hinzu.
-        """
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def add_offset_circle(self, vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5, num_segments=32):
-        """
-        Zeichnet einen Kreis als Visualisierung der Lidar-Grenze des Fahrzeugs.
-        Der Kreis wird relativ zum Fahrzeug angehängt und über den Offset positioniert.
-        """
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))  # Standard: grün.
-        for i in range(num_segments + 1):
-            angle = 2 * math.pi * i / num_segments
-            x = circle_radius * math.cos(angle)
-            y = circle_radius * math.sin(angle)
-            if i == 0:
-                ls.moveTo(x, y, 0)
-            else:
-                ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        circle_np = vehicle.attachNewNode(circle_geom)
-        circle_np.setPos(offset)
-        vehicle.setPythonTag("lidar_circle", circle_np)
-
-    def draw_coordinate_axes(self, axis_length=5):
-        """
-        Zeichnet ein einfaches Koordinatensystem (Achsen) im Ursprung.
-         - X-Achse in Rot,
-         - Y-Achse in Grün,
-         - Z-Achse in Blau.
-        Zusätzlich werden an den Endpunkten Labels positioniert.
-        """
-        ls = LineSegs()
-        ls.setThickness(2)
-        # X-Achse (Rot)
-        ls.setColor(1, 0, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        # Y-Achse (Grün)
-        ls.setColor(0, 1, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        # Z-Achse (Blau)
-        ls.setColor(0, 0, 1, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-
-        # Achsenbeschriftungen
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), (1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), (0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), (0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def update_lidar_status(self, task):
-        """
-        Aktualisiert die Lidar-Anzeige und berechnet eine zusätzliche Ausweichlogik.
-        Liegt ein anderes Fahrzeug im Abstand < 3 m, wird:
-          - Der Kreis rot gefärbt,
-          - Ein repulsiver Ausweichvektor berechnet,
-          - und der Geschwindigkeitsfaktor auf 0.5 gesetzt.
-        """
-        sensor_threshold = 3.0  # Summe der Lidar-Radien
-        for vehicle in self.vehicles:
-            if vehicle.hasPythonTag("lidar_circle"):
-                lidar_circle = vehicle.getPythonTag("lidar_circle")
-                pos = vehicle.getPos(self.render)
-                collision = False
-                avoidance_vec = Vec3(0, 0, 0)
-                for other in self.vehicles:
-                    if other is not vehicle:
-                        pos_other = other.getPos(self.render)
-                        diff = pos - pos_other
-                        distance = diff.length()
-                        if distance < sensor_threshold:
-                            collision = True
-                            if distance > 0:
-                                avoidance_vec += diff.normalized() * (sensor_threshold - distance)
-                if collision:
-                    lidar_circle.setColor(LColor(1, 0, 0, 1))  # rot
-                    vehicle.setPythonTag("avoidance", avoidance_vec)
-                    vehicle.setPythonTag("speed_multiplier", 0.5)
-                else:
-                    lidar_circle.setColor(LColor(0, 1, 0, 1))  # grün
-                    vehicle.setPythonTag("avoidance", Vec3(0, 0, 0))
-                    vehicle.setPythonTag("speed_multiplier", 1.0)
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-
-        if current_max_wait_time > 0:
-            current_wait_text = f"Liegedauer (aktuell): {current_max_wait_time:.1f}s"
-        else:
-            current_wait_text = "Kein Paket an Annahmestation"
-
-        maximal_wait_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-
-        # Berechne den Durchschnitt der Liegedauer (in Sekunden)
-        if self.picked_up_count > 0:
-            avg_dwell_time = self.total_dwell_time / self.picked_up_count
-        else:
-            avg_dwell_time = 0.0
-
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-
-        if self.sim_clock > 0:
-            delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0)
-        else:
-            delivered_per_minute = 0
-
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted_time}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-            f"{current_wait_text}\n"
-            f"{maximal_wait_text}\n"
-            f"Liegedauer (Durchschnitt): {avg_dwell_time:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def check_vehicle2_start(self, task):
-        if self.sim_clock >= 8.0 and not hasattr(self, 'vehicle2_started'):
-            self.vehicle2_started = True
-            self.start_delivery_cycle(self.vehicles[1], self.vehicles[1].getPos())
-            return Task.done
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(
-            station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1)
-        )
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        """
-        Bewegt ein Fahrzeug schrittweise in Richtung des Zielpunkts.
-        Hier fließt neben der direkten Zielrichtung auch der berechnete Ausweichvektor ein.
-        """
-
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            to_target = target - current_pos
-            distance = to_target.length()
-            # Bestimme den individuellen Geschwindigkeitsfaktor (Standard 1.0)
-            multiplier = 1.0
-            if vehicle.hasPythonTag("speed_multiplier"):
-                multiplier = vehicle.getPythonTag("speed_multiplier")
-            effective_speed = self.base_speed * self.speed_factor * multiplier
-            step_distance = effective_speed * dt
-
-            if distance <= step_distance:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-
-            # Hole den Ausweichvektor (falls vorhanden)
-            avoidance = Vec3(0, 0, 0)
-            if vehicle.hasPythonTag("avoidance"):
-                avoidance = vehicle.getPythonTag("avoidance")
-            if avoidance.length() > 0.001:
-                combined = to_target.normalized() + avoidance.normalized() * 0.5
-                combined.normalize()
-                new_direction = combined
-            else:
-                new_direction = to_target.normalized()
-            vehicle.setPos(current_pos + new_direction * step_distance)
-            return Task.cont
-
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-
-        # Für Pickup: Zuerst soll das Fahrzeug zur Ausrichtungsposition (auf der Linie) fahren,
-        # bevor es zur tatsächlichen Station vorfährt.
-        pickup_align = pickup_station.getPos() + Vec3(2, 0, 0)
-
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.occupied_pickups.remove(pickup_station)
-
-            def wait_for_dropoff(task):
-                if any(ds not in self.occupied_dropoffs for ds in self.abgabe_stationen):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_dropoff, f"WaitDropoff_{id(vehicle)}")
-            return
-
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-
-        # Für Drop‑Off: Analog: Ausrichtungsposition auf der Linie.
-        dropoff_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-
-        # Ablauf Pickup: Zuerst Alignment, dann tatsächliche Station zum Aufnehmen.
-        self.move_vehicle_to(vehicle, pickup_align,
-                             lambda: self.move_vehicle_to(vehicle, pickup_station.getPos(),
-                                                          lambda: self.after_pickup(vehicle, pickup_station,
-                                                                                    dropoff_align)
-                                                          )
-                             )
-
-    def after_pickup(self, vehicle, pickup_station, dropoff_align):
-        self.pickup_package(vehicle, pickup_station)
-        # Ablauf Drop‑Off: Zuerst zu Ausrichtungsposition fahren, dann zur eigentlichen Drop‑Off-Station.
-        dropoff_station = self.current_dropoffs[vehicle]
-        self.move_vehicle_to(vehicle, dropoff_align,
-                             lambda: self.move_vehicle_to(vehicle, dropoff_station.getPos(),
-                                                          lambda: self.after_dropoff(vehicle)
-                                                          )
-                             )
-
-    def after_dropoff(self, vehicle):
-        self.drop_cargo(vehicle)
-        start_wait = self.sim_clock
-
-        def wait_task(task):
-            if self.sim_clock - start_wait >= self.sim_time(1):
-                self.finish_cycle(vehicle)
-                return Task.done
-            return Task.cont
-
-        self.taskMgr.add(wait_task, f"WaitAfterDrop_{id(vehicle)}")
-
-    def finish_cycle(self, vehicle):
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            # Erfasse die Liegedauer (Wartezeit) des Pakets und aktualisiere Gesamt- und Zählerwerte.
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        if dropoff_station in self.occupied_dropoffs:
-            self.occupied_dropoffs.remove(dropoff_station)
-            del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
Index: Grundmodell/Gm3.py
===================================================================
diff --git a/Grundmodell/Gm3.py b/Grundmodell/Gm3.py
deleted file mode 100644
--- a/Grundmodell/Gm3.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,599 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Für das Paketspawning an den Annahmestationen
-        self.pickup_packages = {}  # station (NodePath) -> (Paket, Spawnzeit, Timer Node)
-        self.last_removed = {}  # station -> Zeitpunkt der letzten Entfernung
-
-        # Für Graph-Daten und Steuerung
-        self.graph_data = []  # Tupel: (Sim-Zeit, Pakete pro Minute, Durchschnittliche Liegedauer)
-        self.graph_opened = False
-
-        # Ursprung (Koordinatenachsen)
-        self.draw_origin()
-
-        # Kameraeinstellungen: Das ganze Feld soll gut sichtbar sein.
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # Licht und Bodenraster erzeugen
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-
-        # Erzeuge die Mauer (das umschließende Rechteck)
-        self.create_wall()
-
-        # Erzeuge Annahme-, Abgabe- und Garagenstationen
-        self.create_annahme_stations()
-        self.create_abgabe_stations()
-        self.create_garagen_stations()
-
-        # UI: Slider und Info-Anzeige zur Simulationssteuerung
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktion: Mit dem Mausrad hereinz- bzw. herauszoomen.
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        # Graph in extra Fenster per Taste "g" öffnen
-        self.accept("g", self.open_graph)
-
-        # Tasks: Aktualisierung der Simulationszeit, Info-Anzeige, Paketspawning, Paket-Timer und Graph-Daten
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-
-        # Bestimme aktuelle maximale Liegedauer aller wartenden Pakete
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        # X-Achse (rot)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        # Y-Achse (grün)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        # Z-Achse (blau)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # Original Funktion: Annahme-Station (ohne Z-Verschiebung)
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_annahme_station(pt)
-            # Dummy-Node als Referenz für das Paketspawning
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-            # Ursprünglicher Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Zusätzlicher grüner Punkt: 0.5 in positive Z-Richtung vom Mittelpunkt
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, 0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zusätzliche grüne Linie: 3 Meter in positive X-Richtung vom grünen Punkt
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(0, 1, 0, 1))
-            start_line = center + Vec3(0, 0, 0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            # Dekorative Kreuze hinzufügen
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-    # Original Funktion: Abgabestation (ohne Z-Verschiebung)
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_abgabe_station(pt)
-            # Ursprünglicher Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Zusätzlicher grüner Punkt: 0.5 in positive Z-Richtung vom Mittelpunkt
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, 0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zusätzliche Linie: 3 Meter in negative X-Richtung vom grünen Punkt
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(0, 1, 0, 1))
-            start_line = center + Vec3(0, 0, 0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            # Dekorative Kreuze hinzufügen
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 2)
-        v5 = pos + Vec3(1, 0, 2)
-        v6 = pos + Vec3(1, 2, 2)
-        v7 = pos + Vec3(0, 2, 2)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        # Dekorative Kreuze auf geschlossenen Seiten (nicht auf dem Dach)
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 2)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            center = pt + Vec3(0.5, 1, 1)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    # Methoden für Paketspawning und Timer
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        cube = self.loader.loadModel("models/box")
-        cube.setScale(1, 1, 1)
-        cube.setPos(x, y, z + 1)
-        cube.setColor(farbe)
-        cube.reparentTo(self.render)
-        return cube
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)  # 1 Sekunde Simulationszeit
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-    def update_package_timers(self, task):
-        to_remove = []
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            elapsed = self.sim_clock - spawn_time
-            timer_np.node().setText(f"{elapsed:.1f}s")
-            # Wenn das Paket zu lange an der Station liegt (z. B. 5s), entferne es und aktualisiere Kennzahlen.
-            if elapsed >= 5.0:
-                package.removeNode()
-                self.total_dwell_time += elapsed
-                self.picked_up_count += 1
-                self.delivered_packages += 1
-                to_remove.append(station)
-        for station in to_remove:
-            if station in self.pickup_packages:
-                del self.pickup_packages[station]
-            self.last_removed[station] = self.sim_clock
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor != 0 else t
-
-    # Methoden für graphische Darstellung der Kennzahlen
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.setTitle("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.setTitle("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: TestFFZ/TestFFZ3.py
===================================================================
diff --git a/TestFFZ/TestFFZ3.py b/TestFFZ/TestFFZ3.py
deleted file mode 100644
--- a/TestFFZ/TestFFZ3.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,511 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs,
-    CardMaker
-)
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-# Globaler Clock (wird für die Zeitberechnung genutzt)
-globalClock = ClockObject.getGlobalClock()
-
-
-# =============================================================================
-# Klasse für die statische Oberfläche (Boden, Licht, Stationen, GUI usw.)
-# =============================================================================
-class SimulationSurface(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisparameter und Statistik
-        self.base_speed = 1.5  # Maximalgeschwindigkeit (m/s)
-        self.speed_factor = 1.0
-        self.sim_clock = 0.0
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-        self.sim_start_real = globalClock.getFrameTime()
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        # Umgebung und statische Elemente aufbauen
-        self.setup_environment()
-        self.setup_stations()
-        self.setup_UI()
-        self.setup_tasks()
-        self.setup_graph()
-
-        # Mausevents für Zoom
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-    def setup_environment(self):
-        self.erzeuge_licht()
-        self.boden = self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-    def setup_stations(self):
-        # Erzeuge Pickup-Station bei x=-9 und Drop-Station bei x=9
-        self.pickup_station = self.erzeuge_gitterbox(-9, 0, 0, LColor(1, 0, 0, 1))
-        self.drop_station = self.erzeuge_gitterbox(9, 0, 0, LColor(0, 1, 0, 1))
-        # Zeichne Align-Punkte zur Orientierung
-        ls1 = LineSegs()
-        ls1.setThickness(3.0)
-        ls1.setColor(LColor(1, 1, 1, 1))
-        p1 = self.pickup_station.getPos()
-        ls1.moveTo(p1)
-        ls1.drawTo(p1 + Vec3(2, 0, 0))
-        self.render.attachNewNode(ls1.create())
-
-        ls2 = LineSegs()
-        ls2.setThickness(3.0)
-        ls2.setColor(LColor(1, 1, 1, 1))
-        p2 = self.drop_station.getPos()
-        ls2.moveTo(p2)
-        ls2.drawTo(p2 + Vec3(-2, 0, 0))
-        self.render.attachNewNode(ls2.create())
-
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-    def setup_UI(self):
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-    def setup_tasks(self):
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-
-    def setup_graph(self):
-        self.graph_opened = False
-        self.accept("g", self.open_graph)
-        self.graph_data = []  # Für spätere Graph-Aktualisierungen
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in [self.pickup_station, self.drop_station]:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            current_max = max(current_max, elapsed)
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        current_text = f"Liegedauer (aktuell): {current_max:.1f}s" if current_max > 0 else "Kein Paket"
-        maximal_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-        avg_val = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        delivered = self.delivered_packages
-        ppm = delivered / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\nAbgegebene Pakete: {delivered}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n{current_text}\n{maximal_text}\n"
-            f"Durchschn. Liegedauer: {avg_val:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n = 0
-        mi = -center_extent - 0.5
-        ma = center_extent + 0.5
-        y = mi
-        while y <= ma:
-            writer.addData3(mi, y, 0)
-            writer.addData3(ma, y, 0)
-            lines.addVertices(n, n + 1)
-            n += 2
-            y += cell_size
-        x = mi
-        while x <= ma:
-            writer.addData3(x, mi, 0)
-            writer.addData3(x, ma, 0)
-            lines.addVertices(n, n + 1)
-            n += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        box = self.loader.loadModel("models/box")
-        box.setScale(1, 1, 1)
-        box.setPos(x, y, z)
-        box.setColor(farbe)
-        box.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        box.reparentTo(self.render)
-        return box
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        cube = self.loader.loadModel("models/box")
-        cube.setScale(1, 1, 1)
-        cube.setPos(x, y, z + 1)
-        cube.setColor(farbe)
-        cube.reparentTo(self.render)
-        return cube
-
-    def draw_coordinate_axes(self, axis_length=5):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), LColor(1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), LColor(0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), LColor(0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        curr = lens.getFov()[0]
-        new = max(10, curr - 5)
-        lens.setFov(new)
-        print(f"Zoom In: FOV von {curr} auf {new}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        curr = lens.getFov()[0]
-        new = min(100, curr + 5)
-        lens.setFov(new)
-        print(f"Zoom Out: FOV von {curr} auf {new}")
-
-
-# =============================================================================
-# Fahrzeuglogik mit integriertem Lidarsensor, physikalisch korrekter Brems-/Beschleunigungslogik,
-# kontrolliertem Anfahren/Losfahren der Station und Erkennung von Fahrzeugen im Sensorbereich.
-# =============================================================================
-class VehicleController:
-    def __init__(self, surface: SimulationSurface):
-        self.surface = surface
-        self.vehicles = []         # Liste der Fahrzeuge
-        self.cargos = {}           # Fahrzeug -> aktuelles Paket
-        self.current_dropoffs = {}
-        self.create_vehicles()
-
-    def create_vehicles(self):
-        roles = ["pickup_to_dropoff", "dropoff_to_pickup"]
-        start_positions = [self.surface.pickup_station.getPos(), self.surface.drop_station.getPos()]
-        for i in range(2):
-            vehicle = self.surface.loader.loadModel("models/box")
-            vehicle.setScale(1, 1, 0.5)
-            if i % 2 == 0:
-                vehicle.setColor(LColor(0, 0, 1, 1))
-            else:
-                vehicle.setColor(LColor(0, 0, 0.8, 1))
-            vehicle.setPos(start_positions[i])
-            vehicle.reparentTo(self.surface.render)
-            vehicle.setPythonTag("role", roles[i])
-            # Phase "pickup" – das Fahrzeug fährt auf die Station zu
-            vehicle.setPythonTag("phase", "pickup")
-            # Startet mit 0 m/s
-            vehicle.setPythonTag("speed", 0.0)
-            self.add_center_marker(vehicle)
-            self.attach_lidar_sensor(vehicle, offset=Vec3(0.5, 0.5, 0), radius=2.5)
-            self.vehicles.append(vehicle)
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        marker = self.surface.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def attach_lidar_sensor(self, vehicle, offset=Vec3(0.5, 0.5, 0), radius=2.5):
-        sensor_np = vehicle.attachNewNode("lidar_sensor")
-        sensor_np.setPos(offset)
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 1, 0, 1))
-        segments = 64
-        ls.moveTo(radius * math.cos(0), radius * math.sin(0), 0)
-        for i in range(1, segments + 1):
-            angle = (2 * math.pi * i) / segments
-            x = radius * math.cos(angle)
-            y = radius * math.sin(angle)
-            ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        sensor_np.attachNewNode(circle_geom)
-
-    def get_source_target(self, vehicle):
-        role = vehicle.getPythonTag("role")
-        if role == "pickup_to_dropoff":
-            return self.surface.pickup_station, self.surface.drop_station
-        else:
-            return self.surface.drop_station, self.surface.pickup_station
-
-    def check_vehicle_in_sensor(self, vehicle):
-        """Überprüft, ob ein anderes Fahrzeug in den Lidar-Kreis des gegebenen Fahrzeugs gefahren ist."""
-        sensor_offset = Vec3(0.5, 0.5, 0)
-        sensor_center = vehicle.getPos() + sensor_offset
-        sensor_radius = 2.5
-        for other in self.vehicles:
-            if other is not vehicle:
-                # Abstand zwischen dem Mittelpunkt des Sensors und dem anderen Fahrzeug
-                if (other.getPos() - sensor_center).length() < sensor_radius:
-                    return True
-        return False
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        # Parameter in m/s und m/s²
-        max_speed = 1.5
-        accel = 2.5
-        decel = 2.5
-
-        def move_task(task):
-            dt_real = globalClock.getDt()
-            dt = dt_real * self.surface.speed_factor
-
-            pos = vehicle.getPos()
-            to_target = target - pos
-            distance = to_target.length()
-
-            # Stoppe, wenn das Fahrzeug nahezu am Ziel ist
-            if distance < 0.05:
-                vehicle.setPos(target)
-                on_complete()
-                vehicle.setPythonTag("speed", 0.0)
-                return Task.done
-
-            current_speed = vehicle.getPythonTag("speed")
-
-            # Beim Losfahren (Phase "deliver"): solange Dwell-Time nicht abgelaufen, steht das Fahrzeug still
-            if vehicle.getPythonTag("phase") == "deliver":
-                departure_ready_time = vehicle.getPythonTag("departure_ready_time")
-                if self.surface.sim_clock < departure_ready_time:
-                    vehicle.setPythonTag("speed", 0.0)
-                    return Task.cont
-
-            # Zuerst prüfen: Fährt ein anderes Fahrzeug in den Lidar-Kreis?
-            if self.check_vehicle_in_sensor(vehicle):
-                # Wenn ja: Override – fahr mit maximaler Verzögerung ab
-                new_speed = max(current_speed - decel * dt, 0)
-            else:
-                # Berechne den verbleibenden Abstand entlang der x-Achse
-                distance_remaining = abs(pos.getX() - target.getX())
-                if distance_remaining <= (current_speed ** 2) / (2 * decel):
-                    new_speed = max(current_speed - decel * dt, 0)
-                else:
-                    new_speed = min(current_speed + accel * dt, max_speed)
-
-            movement = to_target.normalized() * new_speed * dt
-            vehicle.setPos(pos + movement)
-            vehicle.setPythonTag("speed", new_speed)
-            return Task.cont
-
-        self.surface.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        # Phase "pickup": Anfahren der Station
-        vehicle.setPythonTag("job_start", self.surface.sim_clock)
-        vehicle.setPythonTag("phase", "pickup")
-        source, target = self.get_source_target(vehicle)
-        if source not in self.surface.pickup_packages:
-            self.surface.spawn_package_at_station(source)
-        self.move_vehicle_to(vehicle, source.getPos(),
-                             lambda: self.after_pickup(vehicle, source, target))
-
-    def after_pickup(self, vehicle, source, target):
-        self.pickup_package(vehicle, source)
-        # Wechsel zu Phase "deliver" (Losfahren)
-        vehicle.setPythonTag("phase", "deliver")
-        vehicle.setPythonTag("departure_station", source)
-        dwell_delay = 1.0
-        vehicle.setPythonTag("departure_ready_time", self.surface.sim_clock + dwell_delay)
-        self.move_vehicle_to(vehicle, target.getPos(),
-                             lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        self.drop_cargo(vehicle)
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, source):
-        if source in self.surface.pickup_packages:
-            package, spawn_time, timer_np = self.surface.pickup_packages.pop(source)
-            timer_np.removeNode()
-            dwell = self.surface.sim_clock - spawn_time
-            self.surface.total_dwell_time += dwell
-            self.surface.picked_up_count += 1
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.surface.last_removed[source] = self.surface.sim_clock
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.surface.render)
-            _, target = self.get_source_target(vehicle)
-            targetPos = target.getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.surface.delivered_packages += 1
-
-    def remove_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-
-
-# =============================================================================
-# Hauptprogramm: Erzeuge Oberfläche und starte die Fahrzeuglogik
-# =============================================================================
-if __name__ == "__main__":
-    surface = SimulationSurface()
-    vehicle_controller = VehicleController(surface)
-    for vehicle in vehicle_controller.vehicles:
-        vehicle_controller.start_delivery_cycle(vehicle, vehicle.getPos())
-    surface.run()
Index: Grundmodell/Gm26.py
===================================================================
diff --git a/Grundmodell/Gm26.py b/Grundmodell/Gm26.py
deleted file mode 100644
--- a/Grundmodell/Gm26.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,1919 +0,0 @@
-import random
-import math
-import tkinter as tk  # Für das extra Fenster der Auftragsübersicht
-from tkinter import ttk  # Für die tabellarische Darstellung (Treeview)
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-import matplotlib
-matplotlib.use("TkAgg")  # oder ein anderes geeignetes Backend
-import multiprocessing
-from multiprocessing import Queue, Process
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-import time
-import ctypes
-from PyQt5 import QtWidgets, QtCore
-import pyqtgraph as pg
-from direct.gui.DirectGui import DirectButton
-
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-from direct.task.TaskManagerGlobal import taskMgr
-from functools import partial
-
-class LagerSimulation(ShowBase):
-    def __init__(self, graph_queue=None):
-        super().__init__()
-        self.paused = False
-        # Pause-Knopf neben dem Slider platzieren – z.B. rechts davon.
-        self.pause_button = DirectButton(
-            text="Pause",
-            command=self.toggle_pause,
-            pos=(-0.5, 0, -0.85),  # Leicht links vom Slider
-            scale=0.07
-        )
-
-        # Speichere die Queue als Attribut
-        self.graph_process = None  # Hier wird der Graphing-Prozess gespeichert.
-        self.graph_queue = None  # Die Queue für den Datenaustausch.
-
-        self.tk_root = tk.Tk()
-        self.tk_root.withdraw()
-
-        self.taskMgr.add(self._tk_update, "tkUpdateTask")
-        self.taskMgr.add(self.update_delivery_timers, "UpdateDeliveryTimersTask")
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5  # Wird in update_vehicle genutzt
-        self.state_timer = 0.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Kennzahlen für Lieferzeiten
-        self.total_delivery_time = 0.0
-        self.total_delivery_count = 0
-        self.max_overall_delivery_time = 0.0
-
-        # Paketspawning an den Annahmestationen:
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-        # Fahrzeug-spezifische Zuordnung: Fahrzeug -> transportiertes Paket
-        self.cargos = {}
-
-        # NEU: Initialisiere die belegten Annahmestationen
-        self.occupied_pickups = set()  # Oder: [] für eine Liste
-
-        # Graph-Daten (Sim-Zeit, Pakete pro Minute, durchschnittliche Liegedauer)
-        self.graph_data = []
-        self.graph_opened = False
-
-        # Auftragsverwaltung: Speichere alle Aufträge (für die Anzeige) sowie in
-        # einer Queue (Liste) zur sequentiellen Abarbeitung.
-        self.orders = {}
-        self.orders_queue = []
-        self.next_order_id = 1
-
-        # Tkinter-Fenster für Auftragsübersicht
-        self.order_win = None
-        self.order_tree = None
-
-        # Umgebung initialisieren
-        self.draw_origin()
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.create_wall()
-        self.create_annahme_stations()
-        self.create_abgabe_stations()  # Hier wird auch self.abgabe_stations angelegt.
-        self.create_garagen_stations()
-
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # Fahrzeuge in den Garagen erstellen (genau 5 Fahrzeuge)
-        self.create_garage_vehicles()
-
-        # NEU: Testvariablen
-        self.first_vehicle_order_state = "idle"
-        self.attached_package = None
-        self.current_order = None  # wird durch Fahrzeuge individuell genutzt
-
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tastenzuordnungen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-        # Taste C öffnet das Fahrzeug-Kontrollfenster
-        self.accept("c", self.show_vehicle_control)
-
-        # Task-Manager
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClock")
-        # Task, der regelmäßig Graphdaten sendet
-        self.taskMgr.add(self.update_graph_data, "UpdateGraphDataTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        self.sim_clock += dt
-        return Task.cont
-
-    def toggle_pause(self):
-        if not self.paused:
-            # Speichern des aktuellen speed_factor, damit wir ihn beim Resume wiederherstellen können
-            self.previous_speed_factor = self.speed_factor
-            self.speed_factor = 0  # Simulation einfrieren: alle dt-basierte Updates ergeben 0
-            self.pause_button['text'] = "Weiter"
-            self.paused = True
-            print("Gesamte Simulation angehalten")
-        else:
-            # Wiederaufnahme der Simulation: speed_factor auf den vorherigen Wert zurücksetzen
-            self.speed_factor = self.previous_speed_factor if hasattr(self, 'previous_speed_factor') else 1.0
-            self.pause_button['text'] = "Pause"
-            self.paused = False
-            print("Simulation läuft wieder")
-
-    def open_graph(self):
-        # Starte den Graphprozess per Taste G (nur, wenn er noch nicht läuft)
-        if self.graph_process is None or not self.graph_process.is_alive():
-            from multiprocessing import Queue, Process
-            self.graph_queue = Queue()
-
-            # Sende alle bisher gesammelten Daten in die Queue:
-            for data in self.graph_data:
-                try:
-                    self.graph_queue.put(data, block=False)
-                except Exception:
-                    pass
-
-            from graph_pyqt import graph_process_pyqt
-            self.graph_process = Process(target=graph_process_pyqt, args=(self.graph_queue,))
-            self.graph_process.start()
-            print("Graphprozess gestartet.")
-        else:
-            print("Graphprozess läuft bereits.")
-
-    def update_graph_data(self, task):
-        if self.sim_clock > 0:
-            ppm = self.delivered_packages / (self.sim_clock / 60)
-        else:
-            ppm = 0.0
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        avg_delivery = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        new_data = (self.sim_clock, ppm, avg_dwell, avg_delivery)
-        # Speichere alle Daten ab Simulationsbeginn:
-        self.graph_data.append(new_data)
-
-        # Zusätzlich: Falls der Graphprozess aktiv ist, schicke den neuen Datensatz auch an die Queue
-        if self.graph_queue is not None:
-            try:
-                self.graph_queue.put(new_data, block=False)
-            except Exception:
-                pass
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-
-        # Bestimme die maximale Liegedauer aktueller Pakete an den Annahmestationen
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-
-        # Lieferzeit-Kennzahlen ermitteln: für Fahrzeuge, die aktuell ein Paket tragen
-        current_delivery_time = 0.0
-        for veh in self.garage_vehicles:
-            if veh.getPythonTag("package_attached"):
-                ds = veh.getPythonTag("delivery_start_time")
-                if ds:
-                    elapsed_delivery = self.sim_clock - ds
-                    current_delivery_time = max(current_delivery_time, elapsed_delivery)
-        avg_delivery_time = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        # Aktualisiere den Info-Label-Text
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s\n"
-            f"Lieferzeit (aktuell): {current_delivery_time:.1f}s\n"
-            f"Lieferzeit (maximal): {self.max_overall_delivery_time:.1f}s\n"
-            f"Durchschn. Lieferzeit: {avg_delivery_time:.1f}s"
-        )
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        # dt jetzt skaliert mit der Simulationsgeschwindigkeit
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    # ---------------------------
-    # METHODEN FÜR RASTER, LICHT, MAUER, URSPRUNG
-    # ---------------------------
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # STATIONSOBJEKTE UND ZUORDNUNG
-    # -----------------------------------
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        """
-        Erzeugt die Annahmestationen und erstellt für jede Station:
-          - Einen weißen Marker zur Orientierung
-          - Einen grünen Punkt (optional)
-          - Eine weiße Linie, an deren Endpunkt ein blauer Marker als Ziel in der "Translate‑Phase" dient
-
-        Zusätzlich wird ein Dictionary self.station_blue_dots aufgebaut, in dem jedem Annahmestations‑Node
-        der zugehörige blaue Marker zugeordnet wird. Außerdem wird für die erste Station die globale Variable
-        self.station_white_direction festgelegt.
-        """
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        self.station_blue_dots = {}
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basisstation (zum Beispiel als Rahmen)
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Erzeuge den weißen Marker als Orientierung
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Erzeuge den grünen Punkt (optional)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zeichne die weiße Linie: Sie beginnt bei center + Vec3(0, 0, -0.5) und verläuft 3 Meter in X‑Richtung.
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Erzeuge den blauen Marker, der als Ziel in der Translate‑Phase dient
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            # Speichere den blauen Marker im Dictionary, sodass er später erzeugt werden kann
-            self.station_blue_dots[station_dummy] = blue_dot
-
-            # Optionale Textanzeige der Stationsnummer
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) – falls benötigt:
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-            # Für die erste Station (oder den ersten relevanten Pickup) setzen wir globale Referenzen,
-            # die in vehicle_order_task benötigt werden.
-            if i == 1:
-                self.blue_dot = blue_dot
-                self.station_green_dot = green_dot
-                # Berechne den Mittelpunkt der weißen Linie als Referenz (optional)
-                self.white_line_center = (start_line + end_line) * 0.5
-                line_vec = end_line - start_line
-                if line_vec.length() != 0:
-                    self.station_white_direction = Vec2(line_vec.getX(), line_vec.getY()).normalized()
-                else:
-                    self.station_white_direction = Vec2(1, 0)  # Fallback-Wert
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        self.abgabe_stations = []  # Liste der Abgabestationen
-        self.abgabe_blue_dots = []  # Liste zum Speichern der blauen Marker für die Abgabe
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basiskonstruktion der Abgabestation
-            node = self.create_abgabe_station(pt)
-            self.abgabe_stations.append(node)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Marker am Zentrum (weiß)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Grüner Punkt: center + Vec3(0, 0, -0.5)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Weiße Linie: Startet bei center + Vec3(0, 0, -0.5)
-            # und verläuft 3 Meter in negativer X-Richtung
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt: wird an der Endposition der Linie erzeugt
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            # Speichere den blauen Marker für spätere Navigation der Abgabestation
-            self.abgabe_blue_dots.append(blue_dot)
-
-            # Anzeige der Stationsnummer (textuell)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) auf der Station
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 3)
-        v5 = pos + Vec3(1, 0, 3)
-        v6 = pos + Vec3(1, 2, 3)
-        v7 = pos + Vec3(0, 2, 3)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 3)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        self.garagen_stations = []
-        self.garagen_parking_points = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            self.garagen_stations.append(pt)
-            # ParkpunktGarage: Verschoben um 0.5 in negativer Y-Richtung:
-            center = pt + Vec3(0.5, 0.5, 1.5)
-            ParkpunktGarage = center + Vec3(0, 0, 0.7)
-            self.garagen_parking_points.append(ParkpunktGarage)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def create_garage_vehicles(self):
-        self.garage_vehicles = []
-        vehicle_id_counter = 1
-        for park in self.garagen_parking_points:
-            veh = self.create_vehicle(park_point=park)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            newPos.setZ(0)
-            veh.setPos(newPos)
-
-            # Fahrzeuge starten im Standby (idle)
-            veh.setPythonTag("current_order", None)
-            veh.setPythonTag("order_state", "idle")
-            veh.setPythonTag("package_attached", False)
-            veh.setPythonTag("vehicle_id", vehicle_id_counter)
-            # Speichere den Parkpunkt als Rückkehrziel
-            veh.setPythonTag("garage_target", park)
-            # Speichere auch das Anfangs-Heading, um es später beim Parken wiederherzustellen.
-            veh.setPythonTag("start_heading", veh.getH())
-            vehicle_id_counter += 1
-
-            self.garage_vehicles.append(veh)
-
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-            # Füge einen Textknoten hinzu, der die Fahrzeugnummer vorne auf dem Fahrzeug anzeigt.
-            # Wir suchen den Mast-Knoten.
-            mast = veh.find("**/mast")
-            if not mast.isEmpty():
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)  # Schwarz
-                tn.setAlign(TextNode.ACenter)
-                text_np = mast.attachNewNode(tn)
-                # Positioniere den Text relativ zum Mast: Wir nutzen den Vektor "intersection"
-                # und versetzen ihn in Z-Richtung um 0.2 Einheiten oberhalb des Zylinders.
-                text_np.setPos(intersection.x, intersection.y, intersection.z + 0.2)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-            else:
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)
-                tn.setAlign(TextNode.ACenter)
-                text_np = veh.attachNewNode(tn)
-                text_np.setPos(0, 1.2, 1.5)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-
-            self.taskMgr.add(partial(self.vehicle_order_task, veh),
-                             f"VehicleOrderTask_{veh.getPythonTag('vehicle_id')}")
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # FAHRZEUGERSTELLUNG (FFZ20-INTEGRATION)
-    # -----------------------------------
-    def create_vehicle(self, park_point=None):
-        # Erzeuge den übergeordneten Fahrzeug-Knoten
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # --------------------------
-        # Chassis erstellen (1 x 0.5 x 1.2, Farbe Rot)
-        # --------------------------
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # --------------------------
-        # Gabel (Fork) erstellen: Zwei Zähne
-        # --------------------------
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-
-        # Speichere den Gabel-Knoten als Python-Tag am Fahrzeug
-        vehicle_node.setPythonTag("fork_node", fork_node)
-
-        # --------------------------
-        # Erzeuge den grünen Referenzmarker (für die Gabel)
-        # --------------------------
-        ls_new = LineSegs()
-        ls_new.setThickness(2.0)
-        ls_new.setColor(1, 1, 1, 1)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_corner_global = fork_node.getPos() + left_corner_local
-        right_corner_global = fork_node.getPos() + right_corner_local
-        ls_new.moveTo(left_corner_global)
-        ls_new.drawTo(right_corner_global)
-        vehicle_node.attachNewNode(ls_new.create())
-        midpoint = (left_corner_global + right_corner_global) * 0.5
-        white_line_vec = right_corner_global - left_corner_global
-        white_line_dir = white_line_vec.normalized() if white_line_vec.length() != 0 else Vec3(0, 0, 0)
-        candidate = Vec3(-white_line_dir.getY(), white_line_dir.getX(), 0)
-        perp_direction = candidate.normalized() if candidate.length() != 0 else Vec3(0, 0, 0)
-        green_point_global = midpoint + perp_direction * 0.5
-
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        vehicle_node.setPythonTag("fork_green", green_marker_np)
-
-        # --------------------------
-        # Mast und weitere Fahrzeugteile
-        # --------------------------
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-        self.add_diagonals_to_mast(mast_node)
-
-        # --------------------------
-        # Lenkachse erzeugen:
-        # Anstatt den Zylinder direkt bei (0.5, 0.05, 1.0) anzubringen,
-        # erstellen wir einen Pivot-Knoten (steering_axis) mit Z=0.
-        # --------------------------
-        steering_axis = mast_node.attachNewNode("steering_axis")
-        steering_axis.setPos(0.5, 0.05, -1.2)  # Global: 1.2 + (-1.2) = 0
-        steering_axis.setH(90)
-        vehicle_node.setPythonTag("steering_axis", steering_axis)
-
-        # Erzeuge den Zylinder, der die Lenkachse (auch als visuelles Element) darstellt
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(steering_axis)
-        cylinder_node.setPos(0, 0, 0)
-        self.vehicle_cylinder = steering_axis
-
-        # Hier fügen wir den Pfeil an der Lenkachse hinzu – er soll immer in die vorwärtsgerichtete (lokale X-) Richtung zeigen.
-        self.add_steering_arrow(steering_axis, color=(0, 1, 0, 1))
-        # --------------------------
-        # Fahrzeugpositionierung am Parkpunkt
-        # --------------------------
-        if park_point is None:
-            vehicle_node.setPos(0, 0, 0)
-        else:
-            intersection = Vec3(0.5, 0.05, 1.0)
-            vehicle_node.setPos(park_point - vehicle_node.getQuat().xform(intersection))
-        return vehicle_node
-
-    def add_steering_arrow(self, steering_axis, color=(0, 1, 0, 1)):
-        """
-        Erzeugt einen Pfeil, der die Vorwärtsrichtung (lokale X-Achse) des Lenkpivots anzeigt.
-        Der Pfeil wird als Kind des übergebenen steering_axis-Node angehängt und passt sich
-        automatisch dessen Rotation an.
-        """
-        arrow_ls = LineSegs()
-        arrow_ls.setThickness(2.0)
-        arrow_ls.setColor(*color)
-
-        # Zeichne eine Linie von (0,0,0) bis (2,0,0) – das ist die Basis des Pfeils
-        arrow_ls.moveTo(0, 0, 0)
-        arrow_ls.drawTo(2, 0, 0)
-
-        # Zeichne den Pfeilkopf: zwei kurze schräge Linien am Ende der Pfeillinie
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, 0.3, 0)
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, -0.3, 0)
-
-        arrow_np = steering_axis.attachNewNode(arrow_ls.create())
-        arrow_np.setPos(0, 0, 0)  # Falls nötig, hier noch zusätzlichen Offset anpassen
-        return arrow_np
-
-    def rotate_around_pivot(self, vehicle, pivot, delta_angle):
-        """
-        Dreht das Fahrzeug (vehicle) um den gegebenen Pivotpunkt (pivot) um delta_angle (in Grad).
-        Dabei wird die Position des Fahrzeugs neu berechnet, sodass es um den Pivot rotiert.
-        """
-        # Aktuelle globale Fahrzeugposition
-        pos = vehicle.getPos(self.render)
-        # Globaler Pivotpunkt
-        pivot_pos = pivot.getPos(self.render)
-        # Berechne den Vektor vom Pivot zum Fahrzeug
-        rel = pos - pivot_pos
-        # Wandle den Drehwinkel in Bogenmaß um
-        rad = math.radians(delta_angle)
-        cos_val = math.cos(rad)
-        sin_val = math.sin(rad)
-        # Drehe den relativen Vektor
-        new_x = rel.getX() * cos_val - rel.getY() * sin_val
-        new_y = rel.getX() * sin_val + rel.getY() * cos_val
-        new_rel = Vec3(new_x, new_y, rel.getZ())
-        # Neue globale Fahrzeugposition
-        new_pos = pivot_pos + new_rel
-        vehicle.setPos(new_pos)
-        # Aktualisiere auch das Heading des Fahrzeugs (aufaddieren des Drehwinkels)
-        vehicle.setH(vehicle.getH() + delta_angle)
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        # Verwende die simulative Zeit, die bereits in update_sim_clock hochgezählt wird
-        t = self.sim_clock
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    # -----------------------------------
-    # FEHLENDE METHODEN: Paketspawning, Würfelerzeugung u.a.
-    # -----------------------------------
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Bestimme zufällig eine Abgabestation als Ziel
-        if hasattr(self, "abgabe_stations") and self.abgabe_stations:
-            target_index = random.randint(1, len(self.abgabe_stations))
-        else:
-            target_index = 1
-
-        # Erstelle den Auftrag zur Annahmestation
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def update_order_table(self):
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen die Stationsnummer (oder verwende "N/A").
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z.B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige den zugewiesenen Fahrzeugnamen an (oder "-" falls noch keiner zugeordnet wurde).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END,
-                                   values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = 5.0  # 5 Sekunden Verzögerung zwischen Spawns
-        for station in self.annahme_stations:
-            # Wenn aktuell kein Paket an der Station ist
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                # Prüfe, ob seit der letzten Entnahme mindestens 5 Sekunden vergangen sind
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2, self.ax3) = plt.subplots(3, 1, figsize=(8, 9))
-
-        # Erster Plot: Pakete pro Minute
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-
-        # Zweiter Plot: Durchschnittliche Liegedauer
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-
-        # Dritter Plot: Durchschnittliche Lieferzeit
-        self.line3, = self.ax3.plot([], [], marker="o", color="green", label="Durchschnittliche Lieferzeit (s)")
-        self.ax3.set_xlabel("Simulationszeit (s)")
-        self.ax3.set_ylabel("Lieferzeit (s)")
-        self.ax3.set_title("Durchschnittliche Lieferzeit")
-        self.ax3.legend()
-        self.ax3.grid(True)
-
-        plt.show(block=False)
-        # Starte im Tkinter-Hauptloop eine periodische Aktualisierung:
-        self.tk_root.after(500, self.tk_graph_update)  # alle 500ms
-
-    def tk_graph_update(self):
-        # GIL sichern: Gibt einen Statuswert zurück, der später wieder freigegeben wird.
-        gil_state = ctypes.pythonapi.PyGILState_Ensure()
-        try:
-            times = [data[0] for data in self.graph_data]
-            rates = [data[1] for data in self.graph_data]
-            dwell = [data[2] for data in self.graph_data]
-            delivery = [data[3] for data in self.graph_data]
-
-            self.line1.set_data(times, rates)
-            self.ax1.relim()
-            self.ax1.autoscale_view()
-
-            self.line2.set_data(times, dwell)
-            self.ax2.relim()
-            self.ax2.autoscale_view()
-
-            self.line3.set_data(times, delivery)
-            self.ax3.relim()
-            self.ax3.autoscale_view()
-
-            self.fig.canvas.draw_idle()
-            self.fig.canvas.flush_events()
-        finally:
-            ctypes.pythonapi.PyGILState_Release(gil_state)
-
-        # Nächsten Aufruf in 500ms einplanen
-        self.tk_root.after(500, self.tk_graph_update)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Hier werden nur die gewünschten Spalten "ID", "Annahmestation", "Ziel" und "Fahrzeug" definiert.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    def pickup_package(self, vehicle, station):
-        # Falls das Fahrzeug bereits ein Paket trägt, abbrechen.
-        if vehicle.getPythonTag("package_attached"):
-            return
-
-        # Führe den Pickup nur aus, wenn an der Station ein Paket vorhanden ist.
-        if station in self.pickup_packages:
-            # Hole das Paket, den Spawn-Zeitpunkt und den zugehörigen Timer-Knoten.
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            # Entferne den Timer-Knoten, sodass der angezeigte Zähler nicht weiter aktualisiert wird.
-            timer_np.removeNode()
-            # Berechne die Liegedauer (Differenz zwischen aktueller Simulationszeit und Spawn-Zeit).
-            dwell_time = self.sim_clock - spawn_time
-            # Aktualisiere globale Kennzahlen.
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Suche in den Aufträgen nach dem Auftrag, dessen Paket mit diesem Paket übereinstimmt,
-            # und speichere den errechneten Endwert (fixe Liegedauer) sowie den Status.
-            for order_id, order in self.orders.items():
-                if order.get("package") == package:
-                    order["dwell_time"] = dwell_time
-                    order["status"] = "Abgeholt"
-                    break
-
-            # Hole Referenzen zum Gabel-Knoten und zum grünen Marker des Fahrzeugs.
-            fork_node = vehicle.getPythonTag("fork_node")
-            fork_green = vehicle.getPythonTag("fork_green")
-            green_point_pos = fork_green.getPos(fork_node)
-
-            # Übergib das Paket an den Gabel-Knoten (sodass es optisch dem Fahrzeug zugeordnet wird)
-            # und positioniere es relativ zum grünen Marker.
-            package.wrtReparentTo(fork_node)
-            package.setPos(green_point_pos.getX() + 0.5,
-                           green_point_pos.getY() - 0.5,
-                           green_point_pos.getZ() + 1)
-            self.cargos[vehicle] = package
-
-            # Starte den Lieferzeit-Timer: Speichere den Zeitpunkt, an dem das Paket abgeholt wurde,
-            # und hänge einen neuen Timer-Knoten an das Paket.
-            vehicle.setPythonTag("delivery_start_time", self.sim_clock)
-            from panda3d.core import TextNode
-            delivery_timer_text = TextNode("delivery_timer")
-            delivery_timer_text.setText("0.0s")
-            delivery_timer_np = package.attachNewNode(delivery_timer_text)
-            delivery_timer_np.setScale(0.5)
-            delivery_timer_np.setPos(0, 0, 1.2)
-            package.setPythonTag("delivery_timer", delivery_timer_np)
-
-            # Aktualisiere den Zeitpunkt, zu dem an dieser Station zuletzt ein Paket entfernt wurde.
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-
-            # Berechne Lieferzeit:
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start is not None:
-                delivery_time = self.sim_clock - delivery_start
-                self.total_delivery_time += delivery_time
-                self.total_delivery_count += 1
-                self.max_overall_delivery_time = max(self.max_overall_delivery_time, delivery_time)
-                vehicle.clearPythonTag("delivery_start_time")
-
-            # Entferne den Lieferzeit-Timer vom Paket
-            delivery_timer_np = cargo.getPythonTag("delivery_timer")
-            if delivery_timer_np:
-                delivery_timer_np.removeNode()
-
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden das Paket entfernt
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def update_delivery_timers(self, task):
-        for vehicle, package in list(self.cargos.items()):
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start:
-                elapsed_delivery = self.sim_clock - delivery_start
-                delivery_timer_np = package.getPythonTag("delivery_timer")
-                if delivery_timer_np and not delivery_timer_np.isEmpty():
-                    delivery_timer_np.node().setText(f"{elapsed_delivery:.1f}s")
-        return Task.cont
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-
-    def select_next_order(self, vehicle):
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        for order in waiting_orders:
-            dwell_time = self.sim_clock - order.get("spawn_time", self.sim_clock)
-            order["dwell_time"] = dwell_time
-
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        vehicle_pos = vehicle.getPos(self.render)
-
-        def distance_to_station(order):
-            station = order.get("pickup_station")
-            if station:
-                station_pos = station.getPos(self.render)
-                return (station_pos - vehicle_pos).length()
-            return float('inf')
-
-        candidates.sort(key=distance_to_station)
-        chosen_order = candidates[0]
-        chosen_order["vehicle"] = f"Fahrzeug {vehicle.getPythonTag('vehicle_id')}"
-        return chosen_order
-
-    def vehicle_order_task(self, vehicle, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        state = vehicle.getPythonTag("order_state")
-        current_order = vehicle.getPythonTag("current_order")
-
-        # ------------------ Phase 1: Translate (Fahrt zum Pickup) ------------------
-        if state == "translate":
-            # Falls noch kein Auftrag vorhanden, einen zuweisen
-            if current_order is None:
-                next_order = self.select_next_order(vehicle)
-                if next_order is not None:
-                    vehicle.setPythonTag("current_order", next_order)
-                    next_order["status"] = "In Bearbeitung"
-                    print(
-                        f"Auftrag {next_order['id']} wird zugewiesen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}.")
-                else:
-                    print("Kein Auftrag verfügbar – Fallback zum globalen Ziel.")
-                current_order = vehicle.getPythonTag("current_order")
-
-            # Ziel: Pickup-Station (über den blauen Marker)
-            if current_order is not None:
-                pickup_station = current_order.get("pickup_station")
-                if pickup_station in self.station_blue_dots:
-                    target = self.station_blue_dots[pickup_station].getPos(self.render)
-                else:
-                    target = self.blue_dot.getPos(self.render)
-            else:
-                # Fallback: setze target auf einen Standardwert (zum Beispiel den blauen Marker)
-                target = self.blue_dot.getPos(self.render)
-
-            current_pos = vehicle.getPos(self.render)
-
-            # Hole den globalen Heading-Wert des Lenkpivots (steering_axis)
-            pivot = vehicle.getPythonTag("steering_axis")
-            global_hpr = pivot.getNetTransform().getHpr()  # Liefert Vec3(H, P, R)
-            global_heading = global_hpr.getX()  # Hier ist der Heading in Grad
-            current_heading_rad = math.radians(global_heading)
-
-            # Berechne den gewünschten Heading (zum Ziel) anhand der X/Y-Differenz
-            desired_heading_rad = math.atan2(target.getY() - current_pos.getY(),
-                                             target.getX() - current_pos.getX())
-            # Ermittele den Fehler (normalisiert zwischen -pi und pi)
-            heading_error = desired_heading_rad - current_heading_rad
-            while heading_error > math.pi:
-                heading_error -= 2 * math.pi
-            while heading_error < -math.pi:
-                heading_error += 2 * math.pi
-
-            gain = 1.0
-            max_delta = gain * dt
-            delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-            delta_heading_deg = math.degrees(delta_heading_rad)
-
-            # Drehe das Fahrzeug um den Pivot
-            self.rotate_around_pivot(vehicle, pivot, delta_heading_deg)
-
-            # Aktualisiere die Fahrzeugposition basierend auf der neuen globalen Heading-Ausrichtung
-            # Hole erneut den globalen Heading-Wert des Pivot (nach Rotation)
-            global_hpr = pivot.getNetTransform().getHpr()
-            new_global_heading = global_hpr.getX()  # in Grad
-            new_heading_rad = math.radians(new_global_heading)
-            speed = 1.5  # Geschwindigkeit anpassen
-            new_x = current_pos.getX() + speed * math.cos(new_heading_rad) * dt
-            new_y = current_pos.getY() + speed * math.sin(new_heading_rad) * dt
-            new_pos = Vec3(new_x, new_y, 0)
-            vehicle.setPos(new_pos)
-
-            # Wenn das Fahrzeug nahe genug am Ziel ist, wechsle den Zustand
-            distance_to_target = math.sqrt((target.getX() - new_pos.getX()) ** 2 +
-                                           (target.getY() - new_pos.getY()) ** 2)
-            if distance_to_target < 0.1:
-                vehicle.setPos(target)
-                vehicle.setPythonTag("order_state", "rotate")
-
-
-        # ------------------ Phase 2: Rotate ------------------
-        elif state == "rotate":
-            desired_angle = math.degrees(math.atan2(self.station_white_direction.getY(),
-                                                    self.station_white_direction.getX()))
-            desired_angle = (desired_angle + 180) % 360
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_angle - current_heading + 180) % 360) - 180
-            kp_heading = 0.5
-            new_heading = current_heading + kp_heading * angle_diff
-            vehicle.setH(new_heading)
-            if abs(angle_diff) < 1.0:
-                vehicle.setPythonTag("order_state", "turn_right")
-
-        # ------------------ Phase 3: Turn Right ------------------
-        elif state == "turn_right":
-            if vehicle.getPythonTag("turn_right_init") is None:
-                vehicle.setPythonTag("turn_right_init", vehicle.getH() % 360)
-                vehicle.setPythonTag("turn_right_target", (vehicle.getPythonTag("turn_right_init") + 90) % 360)
-                print("Phase 3: Initialisiert für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "Start Heading =", vehicle.getPythonTag("turn_right_init"),
-                      "Target Heading =", vehicle.getPythonTag("turn_right_target"))
-            current_heading = vehicle.getH() % 360
-            turn_right_target = vehicle.getPythonTag("turn_right_target")
-            angle_diff = ((turn_right_target - current_heading + 180) % 360) - 180
-            kp_turn = 0.5
-            turn_rate = kp_turn * angle_diff
-            new_heading = current_heading + turn_rate * dt
-            vehicle.setH(new_heading)
-            print("Phase 3: Fahrzeug", vehicle.getPythonTag("vehicle_id"), "- Aktuelles Heading =", current_heading,
-                  "Winkelabweichung =", angle_diff, "Neues Heading =", new_heading)
-            if abs(angle_diff) < 1.0:
-                print("Phase 3: Drehung abgeschlossen für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      ". Übergang in 'approach'.")
-                vehicle.setPythonTag("order_state", "approach")
-                vehicle.clearPythonTag("turn_right_init")
-                vehicle.clearPythonTag("turn_right_target")
-
-        # ------------------ Phase 4: Approach ------------------
-        elif state == "approach":
-            if current_order is not None:
-                pickup_station = current_order.get("pickup_station")
-                target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-            else:
-                target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-            current = vehicle.getPos(self.render)
-            error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-            if error_vec.length() > 0.05:
-                direction = error_vec.normalized()
-                move_distance = 1.5 * dt
-                new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                               current.getY() + direction.getY() * move_distance, target.getZ())
-                vehicle.setPos(new_pos)
-            else:
-                vehicle.setPos(target)
-                vehicle.setPythonTag("order_state", "pickup")
-
-        # ------------------ Phase 5: Pickup ------------------
-        elif state == "pickup":
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            target_z = 1.0
-            raise_speed = 0.5
-            if current_z < target_z:
-                fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-            else:
-                if current_order is None:
-                    if self.orders_queue:
-                        vehicle.setPythonTag("current_order", self.orders_queue.pop(0))
-                    else:
-                        print("Keine verfügbaren Aufträge für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                              ". Überspringe Pickup-Phase.")
-                        vehicle.setPythonTag("order_state", "drive_out")
-                        return task.cont
-                # Nur wenn noch kein Paket am Fahrzeug befestigt ist:
-                if not vehicle.getPythonTag("package_attached"):
-                    pickup_station = vehicle.getPythonTag("current_order")["pickup_station"]
-                    self.pickup_package(vehicle, pickup_station)
-                    vehicle.setPythonTag("package_attached", True)
-                # Setze drive_out_target, falls noch nicht vorhanden
-                if vehicle.getPythonTag("drive_out_target") is None:
-                    vehicle.setPythonTag("drive_out_target",
-                                         vehicle.getPos(self.render) + vehicle.getQuat(self.render).getForward() * 5.0)
-                vehicle.setPythonTag("order_state", "drive_out")
-
-        # ------------------ Phase 6: Drive Out ------------------
-        elif state == "drive_out":
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            if current_z > 0.0:
-                lower_speed = 0.5
-                fork_node.setZ(max(0.0, current_z - lower_speed * dt))
-            current_pos = vehicle.getPos(self.render)
-            drive_out_target = vehicle.getPythonTag("drive_out_target")
-            if drive_out_target is None:
-                drive_out_target = current_pos + vehicle.getQuat(self.render).getForward() * 5.0
-                vehicle.setPythonTag("drive_out_target", drive_out_target)
-            diff = drive_out_target - current_pos
-            if diff.length() > 0.1:
-                move_distance = 0.5 * dt
-                step = diff.normalized() * move_distance
-                new_pos = current_pos + step
-                new_pos.setZ(0)  # Sicherstellen, dass das Fahrzeug auf dem Boden bleibt
-                vehicle.setPos(new_pos)
-            else:
-                vehicle.setPythonTag("order_state", "to_delivery")
-                vehicle.setPythonTag("drive_out_target", None)
-
-        # ------------------ Phase 7: To Delivery (Fahrt zur Abgabestation) ------------------
-        elif state == "to_delivery":
-            # Prüfe, ob ein Auftrag vorhanden ist
-            if current_order is None:
-                return Task.cont  # oder setze einen Default-Zielwert
-
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                target = self.abgabe_blue_dots[0].getPos(self.render)
-
-            current_pos = vehicle.getPos(self.render)
-
-            # Globalen Heading-Wert vom Pivot verwenden:
-            pivot = vehicle.getPythonTag("steering_axis")
-            global_hpr = pivot.getNetTransform().getHpr()
-            global_heading = global_hpr.getX()  # in Grad
-            current_heading_rad = math.radians(global_heading)
-
-            # Bestimme den gewünschten Heading zur Abgabestation anhand von X/Y
-            desired_heading_rad = math.atan2(target.getY() - current_pos.getY(),
-                                             target.getX() - current_pos.getX())
-            heading_error = desired_heading_rad - current_heading_rad
-            while heading_error > math.pi:
-                heading_error -= 2 * math.pi
-            while heading_error < -math.pi:
-                heading_error += 2 * math.pi
-
-            gain = 1.0
-            max_delta = gain * dt
-            delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-            delta_heading_deg = math.degrees(delta_heading_rad)
-
-            # Drehe das Fahrzeug um den Pivot
-            self.rotate_around_pivot(vehicle, pivot, delta_heading_deg)
-
-            # Aktualisiere die Position basierend auf der globalen Heading-Ausrichtung des Pivot
-            global_hpr = pivot.getNetTransform().getHpr()
-            new_global_heading = global_hpr.getX()
-            new_heading_rad = math.radians(new_global_heading)
-            speed = 1.5
-            new_x = current_pos.getX() + speed * math.cos(new_heading_rad) * dt
-            new_y = current_pos.getY() + speed * math.sin(new_heading_rad) * dt
-            new_pos = Vec3(new_x, new_y, 0)
-            vehicle.setPos(new_pos)
-
-            distance_to_target = math.sqrt((target.getX() - new_pos.getX()) ** 2 +
-                                           (target.getY() - new_pos.getY()) ** 2)
-            if distance_to_target < 0.5:
-                print(
-                    f"Phase 7 abgeschlossen: Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den blauen Punkt erreicht.")
-                vehicle.setPythonTag("order_state", "align_delivery")
-
-        # ------------------ Phase 8: Align Delivery ------------------
-        elif state == "align_delivery":
-            desired_heading = 90.0
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_heading - current_heading + 180) % 360) - 180
-            print("Phase 8: Align Delivery | Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                  "Current Heading: {:.2f}°, Desired: {:.2f}°, Diff: {:.2f}°".format(current_heading, desired_heading,
-                                                                                     angle_diff))
-            fixed_turn_speed = 90.0
-            turn_amount = fixed_turn_speed * dt
-            if abs(angle_diff) < 1.0:
-                vehicle.setH(desired_heading)
-                print("Phase 8 abgeschlossen: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "ausgerichtet (Heading = {:.2f}°).".format(desired_heading))
-                vehicle.setPythonTag("order_state", "delivery_center")
-            else:
-                if angle_diff > 0:
-                    new_heading = current_heading + turn_amount
-                else:
-                    new_heading = current_heading - turn_amount
-                new_heading %= 360
-                vehicle.setH(new_heading)
-                print("Phase 8: Rotating - Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "New Heading set to {:.2f}°".format(new_heading))
-
-        # ------------------ Phase 9: Delivery Approach ------------------
-        elif state == "delivery_center":
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current = vehicle.getPos(self.render)
-            target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-            print("Phase 9: Zielpunkt der Abgabestation für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                  "=", target_point)
-            error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-            tolerance = 0.05
-            move_distance = 1.5 * dt
-            if error_vec.length() > tolerance:
-                direction = error_vec.normalized()
-                new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                               current.getY() + direction.getY() * move_distance, current.getZ())
-                vehicle.setPos(new_pos)
-                print("Phase 9: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "bewegt sich von", current, "nach", new_pos)
-            else:
-                vehicle.setPos(target_point)
-                print("Phase 9: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "hat den Zielpunkt erreicht.")
-                vehicle.setPythonTag("order_state", "drop")
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_fork_z = fork_node.getZ()
-            if current_fork_z < 1.0:
-                new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-                fork_node.setZ(new_fork_z)
-                print("Phase 9: Gabel wird angehoben für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "(Z =", new_fork_z, ").")
-
-        # ------------------ Phase 10: Dropoff ------------------
-        elif state == "drop":
-            if vehicle.getPythonTag("package_attached"):
-                delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-                self.drop_cargo(vehicle)
-                print("Phase 10: Paket abgesetzt für Fahrzeug", vehicle.getPythonTag("vehicle_id"))
-                vehicle.setPythonTag("package_attached", False)
-            else:
-                fork_node = vehicle.getPythonTag("fork_node")
-                current_z = fork_node.getZ()
-                if current_z > 0.0:
-                    lower_speed = 0.5
-                    new_z = max(0.0, current_z - lower_speed * dt)
-                    fork_node.setZ(new_z)
-                    print("Phase 10: Gabel wird abgesenkt für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          ", aktueller Z-Wert =", new_z)
-                else:
-                    print("Phase 10: Dropoff vollständig abgeschlossen für Fahrzeug",
-                          vehicle.getPythonTag("vehicle_id"))
-                    # Prüfe, ob Standby angefordert wurde:
-                    if vehicle.getPythonTag("standby_pending"):
-                        vehicle.setPythonTag("order_state", "return_to_garage")
-                        print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} kehrt zur Garage zurück (Standby).")
-                    else:
-                        vehicle.setPythonTag("order_state", "translate")
-                    current_order["status"] = "Abgegeben"
-                    current_order["delivered_at"] = self.sim_clock
-                    vehicle.setPythonTag("current_order", None)
-
-        # ------------------ Neue Phase: Return to Garage (Standby) ------------------
-        elif state == "return_to_garage":
-            garage_target = vehicle.getPythonTag("garage_target")
-            if garage_target is None:
-                garage_target = self.garagen_parking_points[0]
-            current_pos = vehicle.getPos(self.render)
-            diff = garage_target - current_pos
-            if diff.length() > 0.1:
-                move_distance = 1.0 * dt
-                new_pos = current_pos + diff.normalized() * move_distance
-                new_pos.setZ(0)  # Sicherstellen, dass das Fahrzeug am Boden bleibt.
-                vehicle.setPos(new_pos)
-            else:
-                # Setze das Ausgangs-Heading wieder zurück
-                if vehicle.hasPythonTag("start_heading"):
-                    vehicle.setH(vehicle.getPythonTag("start_heading"))
-                vehicle.setPythonTag("order_state", "idle")
-                vehicle.setPythonTag("standby_pending", False)
-                print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} ist in der Garage (Standby).")
-
-        # ------------------ Phase 11: Exit Station and Start Next Order ------------------
-        elif state == "phase11":
-            if vehicle.getPythonTag("last_delivery_marker") is not None:
-                target_point = vehicle.getPythonTag("last_delivery_marker")
-            else:
-                delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    target_point = self.abgabe_blue_dots[0].getPos(self.render)
-                print("Phase 11: Zielpunkt (blauer Marker) für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "=", target_point)
-                current_pos = vehicle.getPos(self.render)
-                diff = target_point - current_pos
-                if diff.length() > 0.1:
-                    move_distance = 0.5 * dt
-                    step = diff.normalized() * move_distance
-                    vehicle.setPos(current_pos + step)
-                    print("Phase 11: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          "fährt aus der Station, neue Position =", current_pos + step)
-                else:
-                    vehicle.setPos(target_point)
-                    print("Phase 11: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          "hat den blauen Marker erreicht. Nächster Auftrag wird gestartet.")
-                    vehicle.setPythonTag("order_state", "next_order")
-
-        return task.cont
-
-    # Neue Methode: Kontrollfenster zur Fahrzeugsteuerung
-    def show_vehicle_control(self):
-        # Falls das Fenster bereits existiert, bringe es einfach in den Vordergrund,
-        # ohne die Radiobuttons neu zu initialisieren.
-        if hasattr(self, "control_win") and self.control_win.winfo_exists():
-            self.control_win.deiconify()
-            self.control_win.lift()
-            self.control_win.focus_force()
-            return
-
-        # Erstelle das Kontrollfenster als Toplevel des persistenten tk_root.
-        self.control_win = tk.Toplevel(self.tk_root)
-        self.control_win.title("Fahrzeugsteuerung")
-        # Beim Schließen soll das Fenster nicht zerstört, sondern nur versteckt werden
-        self.control_win.protocol("WM_DELETE_WINDOW", self.control_win.withdraw)
-        # Sorge dafür, dass das Fenster initial über allem liegt
-        self.control_win.attributes("-topmost", True)
-        self.control_win.after(100, lambda: self.control_win.attributes("-topmost", False))
-
-        # Erzeuge das Dictionary für die StringVar-Zuordnungen für die Fahrzeuge.
-        self.vehicle_state_vars = {}
-        row = 0
-        for veh in self.garage_vehicles:
-            frame = tk.Frame(self.control_win)
-            frame.grid(row=row, column=0, sticky="w", padx=5, pady=2)
-            vid = veh.getPythonTag("vehicle_id")
-            label = tk.Label(frame, text=f"Fahrzeug {vid}")
-            label.pack(side=tk.LEFT)
-            # Initialisiere die Radiobutton-Variable anhand des aktuellen Fahrzeugzustandes.
-            state = veh.getPythonTag("order_state")
-            if state is None:
-                state = "idle"
-            var = tk.StringVar(value=state)
-            self.vehicle_state_vars[veh] = var
-            rb_active = tk.Radiobutton(frame, text="Aufträge bearbeiten", variable=var, value="translate")
-            rb_active.pack(side=tk.LEFT)
-            rb_standby = tk.Radiobutton(frame, text="Standby", variable=var, value="idle")
-            rb_standby.pack(side=tk.LEFT)
-            row += 1
-        update_btn = tk.Button(self.control_win, text="Übernehmen", command=self.update_vehicle_control)
-        update_btn.grid(row=row, column=0, pady=5)
-
-    def update_vehicle_control(self):
-        for veh, var in self.vehicle_state_vars.items():
-            new_state = var.get()
-            if new_state == "idle" and veh.getPythonTag("current_order") is not None:
-                veh.setPythonTag("standby_pending", True)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Standby angefordert (Auftrag wird fortgesetzt).")
-            else:
-                veh.setPythonTag("standby_pending", False)
-                veh.setPythonTag("order_state", new_state)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Zustand auf {new_state} gesetzt.")
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-
-if __name__ == "__main__":
-    # Wichtig: setze auf Windows die Startmethode auf "spawn"
-    multiprocessing.set_start_method('spawn')
-
-    # Erzeuge eine Queue, auch wenn sie später eventuell neu erstellt wird, wenn "G" gedrückt wird.
-    graph_q = Queue()
-    app = LagerSimulation(graph_q)
-    app.run()
-
-    # Beim Schließen der Simulation den Graphprozess ggf. beenden
-    if app.graph_process is not None:
-        app.graph_process.terminate()
-        app.graph_process.join()
-
-
Index: Grundmodell Erweitert Split/GES8.py
===================================================================
diff --git a/Grundmodell Erweitert Split/GES8.py b/Grundmodell Erweitert Split/GES8.py
deleted file mode 100644
--- a/Grundmodell Erweitert Split/GES8.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,2327 +0,0 @@
-# Standardbibliothek
-import random
-import math
-import time
-import ctypes
-import multiprocessing
-from multiprocessing import Queue, Process
-from functools import partial
-import tkinter as tk
-from tkinter import ttk
-
-# Drittanbieter
-import matplotlib
-import matplotlib.pyplot as plt
-from PyQt5 import QtWidgets, QtCore
-import pyqtgraph as pg
-
-# Panda3D und Direct (Engine-spezifische Importe)
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.task import Task
-from direct.task.TaskManagerGlobal import taskMgr
-from direct.gui.DirectGui import DirectButton, DirectSlider, DirectLabel
-
-from direct.showbase.ShowBase import ShowBase
-from environment_visualization import EnvironmentVisualizer
-
-class LagerSimulation(ShowBase):
-    def __init__(self, graph_queue=None):
-        # Basisinitialisierung (ShowBase, etc.)
-        super().__init__()
-
-        # ------------------------------------------------------------------------
-        # 1. Umgebung aufbauen: Verwende den extrahierten EnvironmentVisualizer
-        # ------------------------------------------------------------------------
-        self.env_viz = EnvironmentVisualizer(self.render, self.loader)
-
-        # Rufe die Methoden des Visualizers auf, um die Umgebung zu erstellen.
-        self.env_viz.draw_origin()
-        self.env_viz.erzeuge_licht()
-        self.env_viz.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.env_viz.create_wall()
-        self.env_viz.create_annahme_stations()
-        self.env_viz.create_abgabe_stations()
-        self.env_viz.create_garagen_stations()
-
-        # Um in anderen Methoden (z. B. für Paket- oder Auftrags-Handling) auf die Stationen
-        # und deren Marker zugreifen zu können, übergeben wir die entsprechenden Listen.
-        self.annahme_stations = self.env_viz.annahme_stations
-        self.station_blue_dots = self.env_viz.station_blue_dots
-        self.abgabe_stations = self.env_viz.abgabe_stations
-        self.abgabe_blue_dots = self.env_viz.abgabe_blue_dots
-        self.garagen_stations = self.env_viz.garagen_stations
-        self.garagen_parking_points = self.env_viz.garagen_parking_points
-
-        # Verbindungslinien
-        #self.env_viz.connect_annahme_abgabe_blue_dots(color=LColor(1, 1, 1, 1), thickness=2.0)
-
-
-        #self.env_viz.connect_garagen_blue_dots(line_color=LColor(1, 1, 1, 1), thickness=2.0, text_color=LColor(0, 0, 1, 1))
-        #self.env_viz.connect_annahme_stations(color=LColor(1, 1, 1, 1), thickness=2.0)
-        #self.env_viz.connect_abgabe_stations(color=LColor(1, 1, 1, 1), thickness=2.0)
-
-        # Erzeuge den fixierten blauen Punkt (wird nur einmal erzeugt)
-        #self.fixed_blue_dot = self.env_viz.create_fixed_blue_dot()
-        # Erstelle die Verbindungslinie, die den blauen Marker der 10. Abgabestation mit dem fixierten Punkt verbindet
-        #self.fixed_connection_line = self.env_viz.create_fixed_connection_line()
-        # Erzeuge die Verbindungslinie von dem fixierten Punkt zur 5. Garage.
-        #self.garage5_connection_line = self.env_viz.create_garage5_connection_line()
-
-        #self.first_garage_to_10_annahme_connection = self.env_viz.create_connection_line_first_garage_to_10_annahme()
-
-        #self.yellow_station_points = self.env_viz.create_yellow_station_points(offset=3.0, scale=0.1)
-        #self.yellow_abgabe_points = self.env_viz.create_yellow_abgabe_points(offset=3.0, scale=0.1)
-        #self.yellow_garage_points = self.env_viz.create_yellow_garage_points(offset=3.0, scale=0.1)
-
-        self.pickup_offset = Vec3(0.5, -0.5, 0)
-
-        # Falls du weitere Referenzen (wie self.blue_dot, self.station_green_dot) brauchst, ebenfalls setzen.
-        if hasattr(self.env_viz, 'blue_dot'):
-            self.blue_dot = self.env_viz.blue_dot
-        if hasattr(self.env_viz, 'station_green_dot'):
-            self.station_green_dot = self.env_viz.station_green_dot
-
-        # ------------------------------------------------------------------------
-        # 2. Restliche Initialisierung (Simulationsvariablen, UI, Tasks, etc.)
-        # (Der restliche Code bleibt weitgehend unverändert.)
-        # ------------------------------------------------------------------------
-
-        self.paused = False
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5
-
-        # Weitere Attribute, z. B. für KPIs, Paket- und Auftragsverwaltung usw.
-        self.delivered_packages = 0
-        self.pickup_packages = {}
-        self.last_removed = {}
-        self.orders = {}
-        self.orders_queue = []
-        self.next_order_id = 1
-        # (Weitere Initialisierungen kommen hier…)
-        self.cargos = {}
-        # Falls du auch weitere Attribute benötigst, wie beispielsweise eine Liste der belegten Pickup-Stations:
-        self.occupied_pickups = set()
-
-        self.max_overall_wait_time = 0.0  # Maximale Wartezeit der Pakete
-        self.total_dwell_time = 0.0  # Summe aller Liegedauern abgeholter Pakete
-        self.picked_up_count = 0  # Anzahl abgeholter Pakete
-        self.total_delivery_time = 0.0  # Summe aller Lieferzeiten
-        self.total_delivery_count = 0  # Anzahl der Lieferungen
-        self.max_overall_delivery_time = 0.0
-
-        self.graph_queue = None
-        self.graph_data = []
-        self.graph_process = None
-
-        # Beispiel: Initialisierung des Tkinter-Fensters
-        self.tk_root = tk.Tk()
-        self.tk_root.withdraw()
-
-        # Weiterer Code: Kamera, Lichter (falls weiterhin benötigt – ansonsten übernehmen wir vollständig den Visualizer)
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # UI-bezogene Attribute initialisieren:
-        self.order_win = None
-        self.order_tree = None
-        self.graph_queue = None
-        self.graph_data = []
-
-        # TensorFlow-Modell und RL-Agent initialisieren (wie gehabt)
-        try:
-            import tensorflow as tf
-            self.tf_model = tf.keras.models.load_model("mein_model.keras")
-            print("TensorFlow Modell erfolgreich geladen.")
-        except Exception as e:
-            print(f"Fehler beim Laden des TensorFlow Modells: {e}")
-            self.tf_model = None
-
-        state_bins = ((10, 10), (10, 10))
-        action_space = [0, 1, 2]
-        self.rl_agent = RLAgent(state_bins, action_space, learning_rate=0.1, discount_factor=0.9, epsilon=0.2)
-        self.training_data = []  # Trainingsdatenliste
-
-        # Spawn-Einstellungen (Standardwerte)
-        self.package_spawn_delay = 5.0
-        self.package_spawn_distribution = "uniform"
-        # Hier speichern wir die Variablen für die Stationen als Dictionary (Index -> BooleanVar)
-        self.spawn_station_vars = {}
-        # Falls du beispielsweise 10 Annahmestationen hast:
-        for i in range(10):
-            self.spawn_station_vars[i] = tk.BooleanVar(value=False)
-
-        # Fahrzeuge in den Garagen instanziieren:
-        self.create_garage_vehicles()
-        # --- UI-Elemente für Simulationssteuerung ---
-        # Slider für Simulationsgeschwindigkeit
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        self.paused = False
-        # Pause-Knopf neben dem Slider platzieren – z.B. rechts davon.
-        self.pause_button = DirectButton(
-            text="Pause",
-            command=self.toggle_pause,
-            pos=(-0.5, 0, -0.85),  # Leicht links vom Slider
-            scale=0.07
-        )
-        self.taskMgr.add(self.update_rl_on_collisions, "CollisionUpdateTask")
-
-        # --- Tastenzuordnungen ---
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-        # Taste "c" öffnet das Fahrzeug-Kontrollfenster
-        self.accept("c", self.show_vehicle_control)
-
-        # --- Tasks (TaskMgr) hinzufügen ---
-        self.taskMgr.add(self._tk_update, "tkUpdateTask")
-        self.taskMgr.add(self.update_delivery_timers, "UpdateDeliveryTimersTask")
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClock")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_graph_data, "UpdateGraphDataTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-    # ---------------1. Initialisierung & Simulationssteuerung---------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        self.sim_clock += dt
-        return Task.cont
-
-    def toggle_pause(self):
-        if not self.paused:
-            # Speichern des aktuellen speed_factor, damit wir ihn beim Resume wiederherstellen können
-            self.previous_speed_factor = self.speed_factor
-            self.speed_factor = 0  # Simulation einfrieren: alle dt-basierte Updates ergeben 0
-            self.pause_button['text'] = "Weiter"
-            self.paused = True
-            print("Gesamte Simulation angehalten")
-        else:
-            # Wiederaufnahme der Simulation: speed_factor auf den vorherigen Wert zurücksetzen
-            self.speed_factor = self.previous_speed_factor if hasattr(self, 'previous_speed_factor') else 1.0
-            self.pause_button['text'] = "Pause"
-            self.paused = False
-            print("Simulation läuft wieder")
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-
-    def update_vehicle(self, task):
-        # dt jetzt skaliert mit der Simulationsgeschwindigkeit
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-    # ---------------2. Graphik & UI (GUI-/Tk-/Matplotlib-Funktionen)---------------
-    def open_graph(self):
-        # Starte den Graphprozess per Taste G (nur, wenn er noch nicht läuft)
-        if self.graph_process is None or not self.graph_process.is_alive():
-            from multiprocessing import Queue, Process
-            self.graph_queue = Queue()
-
-            # Sende alle bisher gesammelten Daten in die Queue:
-            for data in self.graph_data:
-                try:
-                    self.graph_queue.put(data, block=False)
-                except Exception:
-                    pass
-
-            from graph_pyqt import graph_process_pyqt
-            self.graph_process = Process(target=graph_process_pyqt, args=(self.graph_queue,))
-            self.graph_process.start()
-
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2, self.ax3) = plt.subplots(3, 1, figsize=(8, 9))
-
-        # Erster Plot: Pakete pro Minute
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-
-        # Zweiter Plot: Durchschnittliche Liegedauer
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-
-        # Dritter Plot: Durchschnittliche Lieferzeit
-        self.line3, = self.ax3.plot([], [], marker="o", color="green", label="Durchschnittliche Lieferzeit (s)")
-        self.ax3.set_xlabel("Simulationszeit (s)")
-        self.ax3.set_ylabel("Lieferzeit (s)")
-        self.ax3.set_title("Durchschnittliche Lieferzeit")
-        self.ax3.legend()
-        self.ax3.grid(True)
-
-        plt.show(block=False)
-        # Starte im Tkinter-Hauptloop eine periodische Aktualisierung:
-        self.tk_root.after(500, self.tk_graph_update)  # alle 500ms
-
-    def tk_graph_update(self):
-        # GIL sichern: Gibt einen Statuswert zurück, der später wieder freigegeben wird.
-        gil_state = ctypes.pythonapi.PyGILState_Ensure()
-        try:
-            times = [data[0] for data in self.graph_data]
-            rates = [data[1] for data in self.graph_data]
-            dwell = [data[2] for data in self.graph_data]
-            delivery = [data[3] for data in self.graph_data]
-
-            self.line1.set_data(times, rates)
-            self.ax1.relim()
-            self.ax1.autoscale_view()
-
-            self.line2.set_data(times, dwell)
-            self.ax2.relim()
-            self.ax2.autoscale_view()
-
-            self.line3.set_data(times, delivery)
-            self.ax3.relim()
-            self.ax3.autoscale_view()
-
-            self.fig.canvas.draw_idle()
-            self.fig.canvas.flush_events()
-        finally:
-            ctypes.pythonapi.PyGILState_Release(gil_state)
-
-        # Nächsten Aufruf in 500ms einplanen
-        self.tk_root.after(500, self.tk_graph_update)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-
-        # Bestimme die maximale Liegedauer aktueller Pakete an den Annahmestationen
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-
-        # Lieferzeit-Kennzahlen ermitteln: für Fahrzeuge, die aktuell ein Paket tragen
-        current_delivery_time = 0.0
-        for veh in self.garage_vehicles:
-            if veh.getPythonTag("package_attached"):
-                ds = veh.getPythonTag("delivery_start_time")
-                if ds:
-                    elapsed_delivery = self.sim_clock - ds
-                    current_delivery_time = max(current_delivery_time, elapsed_delivery)
-        avg_delivery_time = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        # Aktualisiere den Info-Label-Text
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s\n"
-            f"Lieferzeit (aktuell): {current_delivery_time:.1f}s\n"
-            f"Lieferzeit (maximal): {self.max_overall_delivery_time:.1f}s\n"
-            f"Durchschn. Lieferzeit: {avg_delivery_time:.1f}s"
-        )
-        return Task.cont
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def update_graph_data(self, task):
-        if self.sim_clock > 0:
-            ppm = self.delivered_packages / (self.sim_clock / 60)
-        else:
-            ppm = 0.0
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        avg_delivery = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        standard_data = (self.sim_clock, ppm, avg_dwell, avg_delivery)
-        self.graph_data.append(standard_data)
-
-        # Sende die Standarddaten an die Queue
-        if self.graph_queue is not None:
-            try:
-                self.graph_queue.put(standard_data, block=False)
-            except Exception:
-                pass
-
-        # Erzeuge zusätzlich Fahrzeug-Rating-Daten.
-        # Hier als Beispiel: Zufällige Bewertungen für 5 Fahrzeuge;
-        # in deinem System müsstest du diese Werte natürlich aus deinen Messungen oder Berechnungen ableiten.
-        vehicle_ratings = [random.uniform(0, 100) for _ in range(5)]
-        rating_data = (self.sim_clock, *vehicle_ratings)
-
-        # Sende die Rating-Daten
-        if self.graph_queue is not None:
-            try:
-                self.graph_queue.put(rating_data, block=False)
-            except Exception:
-                pass
-
-        return Task.cont
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Hier werden nur die gewünschten Spalten "ID", "Annahmestation", "Ziel" und "Fahrzeug" definiert.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    #-------Fahrzeugsteuerung(Bedienfenster)-------
-    def update_vehicle_control(self):
-        for veh, var in self.vehicle_state_vars.items():
-            new_state = var.get()
-            if new_state == "idle" and veh.getPythonTag("current_order") is not None:
-                veh.setPythonTag("standby_pending", True)
-            else:
-                veh.setPythonTag("standby_pending", False)
-                veh.setPythonTag("order_state", new_state)
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-    def update_cable(self, task):
-        # Verwende die simulative Zeit, die bereits in update_sim_clock hochgezählt wird
-        t = self.sim_clock
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    def create_garage_vehicles(self):
-        self.garage_vehicles = []
-        vehicle_id_counter = 1
-        for park in self.garagen_parking_points:
-            veh = self.create_vehicle(park_point=park)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            newPos.setZ(0)
-            veh.setPos(newPos)
-
-            # Fahrzeuge starten im Standby (idle)
-            veh.setPythonTag("current_order", None)
-            veh.setPythonTag("order_state", "idle")
-            veh.setPythonTag("package_attached", False)
-            veh.setPythonTag("vehicle_id", vehicle_id_counter)
-            # Speichere den Parkpunkt als Rückkehrziel
-            veh.setPythonTag("garage_target", park)
-            # Speichere auch das Anfangs-Heading, um es später beim Parken wiederherzustellen.
-            veh.setPythonTag("start_heading", veh.getH())
-            vehicle_id_counter += 1
-
-            self.garage_vehicles.append(veh)
-
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-            # Füge einen Textknoten hinzu, der die Fahrzeugnummer vorne auf dem Fahrzeug anzeigt.
-            # Wir suchen den Mast-Knoten.
-            mast = veh.find("**/mast")
-            if not mast.isEmpty():
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)  # Schwarz
-                tn.setAlign(TextNode.ACenter)
-                text_np = mast.attachNewNode(tn)
-                # Positioniere den Text relativ zum Mast: Wir nutzen den Vektor "intersection"
-                # und versetzen ihn in Z-Richtung um 0.2 Einheiten oberhalb des Zylinders.
-                text_np.setPos(intersection.x, intersection.y, intersection.z + 0.2)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-            else:
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)
-                tn.setAlign(TextNode.ACenter)
-                text_np = veh.attachNewNode(tn)
-                text_np.setPos(0, 1.2, 1.5)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-
-            self.taskMgr.add(partial(self.vehicle_order_task, veh),
-                             f"VehicleOrderTask_{veh.getPythonTag('vehicle_id')}")
-
-    # --------------- Erstellung des Fahrzeugs---------------
-    def create_vehicle(self, park_point=None):
-        # Erzeuge den übergeordneten Fahrzeug-Knoten
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # --------------------------
-        # Chassis erstellen (1 x 0.5 x 1.2, Farbe Rot)
-        # --------------------------
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # --------------------------
-        # Gabel (Fork) erstellen: Zwei Zähne
-        # --------------------------
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        vehicle_node.setPythonTag("fork_node", fork_node)
-
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-
-        # --------------------------
-        # Statt weißer Kante von der Gabel: bereits eingezeichnete grüne Mittellinie verwenden.
-        # In diesem Beispiel nehmen wir an, dass du schon eine „mittlere“ Linie gezeichnet hast.
-        # Zeichne die grüne Mittellinie, z. B. von einem Punkt an der Gabel (als Ausgangspunkt)
-        # bis zu einem Referenzpunkt – hier nutzen wir einen zuvor festgelegten Offset.
-        #
-        # Wir definieren:
-        #   - Den Ausgangspunkt als den grün markierten Punkt, der den mittleren Punkt der Gabel repräsentieren soll.
-        #   - Den Zielpunkt als den Referenzpunkt, der als Idealwert in create_vehicle bestimmt wurde.
-        # In unserem Beispiel berechnen wir den Zielpunkt einmalig aus den lokalen Offsets an der weißen Kante.
-        # (Diese Werte kannst du bei Bedarf anpassen.)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_global = fork_node.getPos(self.render) + left_corner_local
-        right_global = fork_node.getPos(self.render) + right_corner_local
-        # Berechne den idealen (statischen) Mittelpunkt als Referenz – dieser wird nur einmal gesetzt.
-        midpoint_white = (left_global + right_global) * 0.5
-        # Nun lege den grünen Marker so, dass er exakt in der Mitte der Gabel liegt.
-        # Hier entspricht der grüne Punkt der Mittellinie der Gabel.
-        green_point_global = midpoint_white  # Hier wird angenommen, dass der ideale Mittelpunkt gleich dem Referenzpunkt ist.
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        vehicle_node.setPythonTag("fork_green", green_marker_np)
-
-        # Zeichne die grüne Mittellinie.
-        # Als Beispiel: Zeichne eine Linie vom grünen Marker in Richtung +Y (relativ zum Fahrzeug),
-        # weil du den idealen Zustand so festgelegt hast, dass genau diese Linie mit der Station übereinstimmen soll.
-        ls_mid = LineSegs()
-        ls_mid.setThickness(2.0)
-        ls_mid.setColor(0, 1, 0, 1)  # grün
-        # Starte die Linie am grünen Marker.
-        ls_mid.moveTo(green_point_global)
-        # Zeichne beispielsweise eine Linie 1 Einheit lang in +Y-Richtung:
-        ls_mid.drawTo(green_point_global + Vec3(0, 1, 0))
-        fork_center_line = vehicle_node.attachNewNode(ls_mid.create())
-        # Speichere den NodePath der grünen Mittellinie
-        vehicle_node.setPythonTag("fork_center_line", fork_center_line)
-
-        # --------------------------
-        # Restliche Fahrzeugteile (Mast, Lenkachse, etc.)
-        # --------------------------
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-        self.add_diagonals_to_mast(mast_node)
-
-        intersection = Vec3(0.5, 0.05, 1.0)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        # --------------------------
-        # Lenkachse erzeugen (Pivot-Node)
-        # --------------------------
-        steering_axis = mast_node.attachNewNode("steering_axis")
-        steering_axis.setPos(0.5, 0.25, -1.2)
-        steering_axis.setH(90)
-        vehicle_node.setPythonTag("steering_axis", steering_axis)
-
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(steering_axis)
-        cylinder_node.setPos(0, 0, 0)
-        self.vehicle_cylinder = steering_axis
-        self.add_steering_arrow(steering_axis, color=(0, 1, 0, 1))
-
-        # --------------------------
-        # Positioniere das Fahrzeug am Parkpunkt
-        # --------------------------
-        if park_point is None:
-            vehicle_node.setPos(0, 0, 0)
-        else:
-            intersection = Vec3(0, 0, 1.0)
-            vehicle_node.setPos(park_point - vehicle_node.getQuat().xform(intersection))
-
-        # ********** Ursprung (Koordinatensystem) am Fahrzeug einzeichnen **********
-        ls_x = LineSegs()
-        ls_x.setThickness(2)
-        ls_x.setColor(LColor(1, 0, 0, 1))
-        ls_x.moveTo(0, 0, 0)
-        ls_x.drawTo(1, 0, 0)
-        vehicle_node.attachNewNode(ls_x.create())
-
-        ls_y = LineSegs()
-        ls_y.setThickness(2)
-        ls_y.setColor(LColor(0, 1, 0, 1))
-        ls_y.moveTo(0, 0, 0)
-        ls_y.drawTo(0, 1, 0)
-        vehicle_node.attachNewNode(ls_y.create())
-
-        ls_z = LineSegs()
-        ls_z.setThickness(2)
-        ls_z.setColor(LColor(0, 0, 1, 1))
-        ls_z.moveTo(0, 0, 0)
-        ls_z.drawTo(0, 0, 1)
-        vehicle_node.attachNewNode(ls_z.create())
-
-        from panda3d.core import TextNode
-        tn_x = TextNode("label_x")
-        tn_x.setText("X")
-        tn_x.setTextColor(1, 0, 0, 1)
-        label_x = vehicle_node.attachNewNode(tn_x)
-        label_x.setScale(0.3)
-        label_x.setPos(2.0, 0, 0)
-
-        tn_y = TextNode("label_y")
-        tn_y.setText("Y")
-        tn_y.setTextColor(0, 1, 0, 1)
-        label_y = vehicle_node.attachNewNode(tn_y)
-        label_y.setScale(0.3)
-        label_y.setPos(0, 2.0, 0)
-
-        tn_z = TextNode("label_z")
-        tn_z.setText("Z")
-        tn_z.setTextColor(0, 0, 1, 1)
-        label_z = vehicle_node.attachNewNode(tn_z)
-        label_z.setScale(0.3)
-        label_z.setPos(0, 0, 2.0)
-
-        return vehicle_node
-
-    def add_steering_arrow(self, steering_axis, color=(0, 1, 0, 1)):
-        """
-        Erzeugt einen Pfeil, der die Vorwärtsrichtung (lokale X-Achse) des Lenkpivots anzeigt.
-        Der Pfeil wird als Kind des übergebenen steering_axis-Node angehängt und passt sich
-        automatisch dessen Rotation an.
-        """
-        arrow_ls = LineSegs()
-        arrow_ls.setThickness(2.0)
-        arrow_ls.setColor(*color)
-
-        # Zeichne eine Linie von (0,0,0) bis (2,0,0) – das ist die Basis des Pfeils
-        arrow_ls.moveTo(0, 0, 0)
-        arrow_ls.drawTo(2, 0, 0)
-
-        # Zeichne den Pfeilkopf: zwei kurze schräge Linien am Ende der Pfeillinie
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, 0.3, 0)
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, -0.3, 0)
-
-        arrow_np = steering_axis.attachNewNode(arrow_ls.create())
-        arrow_np.setPos(0, 0, 0)  # Falls nötig, hier noch zusätzlichen Offset anpassen
-        return arrow_np
-
-    def rotate_around_pivot(self, vehicle, pivot, delta_angle):
-        """
-        Dreht das Fahrzeug (vehicle) um den gegebenen Pivotpunkt (pivot) um delta_angle (in Grad).
-        Dabei wird die Position des Fahrzeugs neu berechnet, sodass es um den Pivot rotiert.
-        """
-        # Aktuelle globale Fahrzeugposition
-        pos = vehicle.getPos(self.render)
-        # Globaler Pivotpunkt
-        pivot_pos = pivot.getPos(self.render)
-        # Berechne den Vektor vom Pivot zum Fahrzeug
-        rel = pos - pivot_pos
-        # Wandle den Drehwinkel in Bogenmaß um
-        rad = math.radians(delta_angle)
-        cos_val = math.cos(rad)
-        sin_val = math.sin(rad)
-        # Drehe den relativen Vektor
-        new_x = rel.getX() * cos_val - rel.getY() * sin_val
-        new_y = rel.getX() * sin_val + rel.getY() * cos_val
-        new_rel = Vec3(new_x, new_y, rel.getZ())
-        # Neue globale Fahrzeugposition
-        new_pos = pivot_pos + new_rel
-        vehicle.setPos(new_pos)
-        # Aktualisiere auch das Heading des Fahrzeugs (aufaddieren des Drehwinkels)
-        vehicle.setH(vehicle.getH() + delta_angle)
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    # ---------------6. Paket- & Auftragsverwaltung---------------
-        # Beispiel einer Methode, die weiterhin auf die extrahierten Umgebungselemente zugreift:
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Je nach gewählter Verteilung kannst du hier Anpassungen vornehmen.
-        # Für den Moment wählen wir einfach zufällig aus allen Abgabestationen,
-        # falls keine spezielle Logik für die Verteilung implementiert ist.
-        target_index = random.randint(1, len(self.abgabe_stations))
-
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def check_and_spawn_packages(self, task):
-        # Verwende den neuen Delay-Wert aus den Einstellungen
-        spawn_delay = self.package_spawn_delay
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-        # Beispiel für eine vorhandene Methode, die auf die Umgebungselemente zugreift:
-    def update_order_table(self):
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen die Stationsnummer (oder verwende "N/A").
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z.B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige den zugewiesenen Fahrzeugnamen an (oder "-" falls noch keiner zugeordnet wurde).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END,
-                                   values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if hasattr(self, 'order_win') and self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                break
-
-    # ---------------7. Cargo-Handling (Pickup, Drop & Timer)---------------
-    def pickup_package(self, vehicle, station):
-        # Falls das Fahrzeug bereits ein Paket trägt, abbrechen.
-        if vehicle.getPythonTag("package_attached"):
-            return
-
-        # Führe den Pickup nur aus, wenn an der Station ein Paket vorhanden ist.
-        if station in self.pickup_packages:
-            # Hole das Paket, den Spawn-Zeitpunkt und den zugehörigen Timer-Knoten.
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            # Entferne den Timer-Knoten, sodass der angezeigte Zähler nicht weiter aktualisiert wird.
-            timer_np.removeNode()
-            # Berechne die Liegedauer (Differenz zwischen aktueller Simulationszeit und Spawn-Zeit).
-            dwell_time = self.sim_clock - spawn_time
-            # Aktualisiere globale Kennzahlen.
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Suche in den Aufträgen nach dem Auftrag, dessen Paket mit diesem Paket übereinstimmt,
-            # und speichere den errechneten Endwert (fixe Liegedauer) sowie den Status.
-            for order_id, order in self.orders.items():
-                if order.get("package") == package:
-                    order["dwell_time"] = dwell_time
-                    order["status"] = "Abgeholt"
-                    break
-
-            # Hole Referenzen zum Gabel-Knoten und zum grünen Marker des Fahrzeugs.
-            fork_node = vehicle.getPythonTag("fork_node")
-            fork_green = vehicle.getPythonTag("fork_green")
-            green_point_pos = fork_green.getPos(fork_node)
-
-            # Übergib das Paket an den Gabel-Knoten (sodass es optisch dem Fahrzeug zugeordnet wird)
-            # und positioniere es relativ zum grünen Marker.
-            package.wrtReparentTo(fork_node)
-            package.setPos(green_point_pos.getX() + 0.5,
-                           green_point_pos.getY() + 0,
-                           green_point_pos.getZ() + 1)
-            self.cargos[vehicle] = package
-
-            # Starte den Lieferzeit-Timer: Speichere den Zeitpunkt, an dem das Paket abgeholt wurde,
-            # und hänge einen neuen Timer-Knoten an das Paket.
-            vehicle.setPythonTag("delivery_start_time", self.sim_clock)
-            from panda3d.core import TextNode
-            delivery_timer_text = TextNode("delivery_timer")
-            delivery_timer_text.setText("0.0s")
-            delivery_timer_np = package.attachNewNode(delivery_timer_text)
-            delivery_timer_np.setScale(0.5)
-            delivery_timer_np.setPos(0, 0, 1.2)
-            package.setPythonTag("delivery_timer", delivery_timer_np)
-
-            # Aktualisiere den Zeitpunkt, zu dem an dieser Station zuletzt ein Paket entfernt wurde.
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-
-            # Berechne Lieferzeit:
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start is not None:
-                delivery_time = self.sim_clock - delivery_start
-                self.total_delivery_time += delivery_time
-                self.total_delivery_count += 1
-                self.max_overall_delivery_time = max(self.max_overall_delivery_time, delivery_time)
-                vehicle.clearPythonTag("delivery_start_time")
-
-            # Entferne den Lieferzeit-Timer vom Paket
-            delivery_timer_np = cargo.getPythonTag("delivery_timer")
-            if delivery_timer_np:
-                delivery_timer_np.removeNode()
-
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden das Paket entfernt
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def update_delivery_timers(self, task):
-        for vehicle, package in list(self.cargos.items()):
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start:
-                elapsed_delivery = self.sim_clock - delivery_start
-                delivery_timer_np = package.getPythonTag("delivery_timer")
-                if delivery_timer_np and not delivery_timer_np.isEmpty():
-                    delivery_timer_np.node().setText(f"{elapsed_delivery:.1f}s")
-        return Task.cont
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-
-    # ---------------8. Auftrags-/Fahrzeuglogik---------------
-    def select_next_order(self, vehicle):
-        # Sammle alle Aufträge, die noch "Wartend" sind
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        # Aktualisiere die Dwell-Zeit für jeden Auftrag
-        for order in waiting_orders:
-            order["dwell_time"] = self.sim_clock - order.get("spawn_time", self.sim_clock)
-
-        # Wähle den Auftrag mit der maximalen Dwell-Zeit (evtl. mit etwas Toleranz)
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        # Finde aus den Kandidaten den Auftrag, dessen Pickup-Station (order["pickup_station"])
-        # am nächsten zur aktuellen Fahrzeugposition liegt.
-        vehicle_pos = vehicle.getPos(self.render)
-        candidates.sort(key=lambda order: (order["pickup_station"].getPos(self.render) - vehicle_pos).length())
-        return candidates[0]
-
-    def show_vehicle_control(self):
-        # Falls das Fenster bereits existiert, wiederverwenden
-        if hasattr(self, "control_win") and self.control_win.winfo_exists():
-            self.control_win.deiconify()
-            self.control_win.lift()
-            self.control_win.focus_force()
-            return
-
-        self.control_win = tk.Toplevel(self.tk_root)
-        self.control_win.title("Kontrollfenster")
-        self.control_win.protocol("WM_DELETE_WINDOW", self.control_win.withdraw)
-        self.control_win.attributes("-topmost", True)
-        self.control_win.after(100, lambda: self.control_win.attributes("-topmost", False))
-
-        # ---------------- Fahrzeugsteuerung ----------------
-        # Zunächst einen Button einfügen, der ALLE Fahrzeuge auf "Aufträge bearbeiten" setzt.
-        all_vehicles_btn = tk.Button(
-            self.control_win,
-            text="Alle Fahrzeuge auf 'Aufträge bearbeiten' setzen",
-            command=lambda: [self.vehicle_state_vars[veh].set("translate") for veh in self.garage_vehicles]
-        )
-        all_vehicles_btn.grid(row=0, column=0, sticky="w", padx=5, pady=5)
-
-        # Nun die einzelnen Fahrzeugzeilen – starte ab Zeile 1
-        self.vehicle_state_vars = {}
-        row = 1
-        for veh in self.garage_vehicles:
-            frame = tk.Frame(self.control_win)
-            frame.grid(row=row, column=0, sticky="w", padx=5, pady=2)
-            vid = veh.getPythonTag("vehicle_id")
-            label = tk.Label(frame, text=f"Fahrzeug {vid}")
-            label.pack(side=tk.LEFT)
-            state = veh.getPythonTag("order_state") or "idle"
-            var = tk.StringVar(value=state)
-            self.vehicle_state_vars[veh] = var
-            rb_active = tk.Radiobutton(frame, text="Aufträge bearbeiten", variable=var, value="translate")
-            rb_active.pack(side=tk.LEFT)
-            rb_standby = tk.Radiobutton(frame, text="Standby", variable=var, value="idle")
-            rb_standby.pack(side=tk.LEFT)
-            row += 1
-
-        update_btn = tk.Button(self.control_win, text="Übernehmen", command=self.update_vehicle_control)
-        update_btn.grid(row=row, column=0, pady=5)
-        row += 1
-
-        # ---------------- Spawn-Einstellungen ----------------
-        spawn_frame = tk.LabelFrame(self.control_win, text="Spawn Einstellungen", padx=5, pady=5)
-        spawn_frame.grid(row=row, column=0, sticky="w", padx=5, pady=5)
-
-        # Eingabe der Spawnverzögerung
-        tk.Label(spawn_frame, text="Spawnverzögerung (Sekunden):").grid(row=0, column=0, sticky="w")
-        self.spawn_delay_var = tk.DoubleVar(value=self.package_spawn_delay)
-        delay_entry = tk.Entry(spawn_frame, textvariable=self.spawn_delay_var, width=6)
-        delay_entry.grid(row=0, column=1, sticky="w")
-
-        # Direkt in diesem Spawn-Feld: Button, der alle Annahmestationen auswählt
-        btn_select_all_stations = tk.Button(
-            spawn_frame,
-            text="Alle Annahmestationen auswählen",
-            command=lambda: [self.spawn_station_vars[i].set(True) for i in self.spawn_station_vars]
-        )
-        btn_select_all_stations.grid(row=0, column=2, padx=5)
-
-        # Auswahl der Annahmestationen (Checkbuttons)
-        tk.Label(spawn_frame, text="Annahmestationen:").grid(row=1, column=0, sticky="w", pady=(5, 0))
-        stations_frame = tk.Frame(spawn_frame)
-        stations_frame.grid(row=2, column=0, columnspan=3, sticky="w")
-        for i in range(min(10, len(self.annahme_stations))):
-            cb = tk.Checkbutton(stations_frame, text=f"Annahmestation {i + 1}",
-                                variable=self.spawn_station_vars[i])
-            cb.pack(anchor="w")
-
-        def apply_spawn_from_control():
-            self.package_spawn_delay = self.spawn_delay_var.get()
-            selected = []
-            for i, var in self.spawn_station_vars.items():
-                if var.get():
-                    selected.append(self.annahme_stations[i])
-            self.package_spawn_stations = selected
-            # Spawne nur an Stationen, an denen noch kein Paket existiert:
-            for station in self.package_spawn_stations:
-                if station not in self.pickup_packages:
-                    self.spawn_package_at_station(station)
-            # Option: spawn_win schließen oder offen lassen
-            # self.control_win.withdraw()
-
-        apply_btn = tk.Button(
-            spawn_frame,
-            text="Einstellungen übernehmen und spawnen",
-            command=apply_spawn_from_control
-        )
-        apply_btn.grid(row=3, column=0, columnspan=3, pady=5)
-
-    def show_spawn_control(self):
-        spawn_win = tk.Toplevel(self.tk_root)
-        spawn_win.title("Paketspawn Einstellungen")
-
-        # Eingabefeld für Spawnverzögerung
-        tk.Label(spawn_win, text="Spawnverzögerung (Sekunden):").pack(pady=2)
-        delay_entry = tk.Entry(spawn_win)
-        delay_entry.insert(0, str(self.package_spawn_delay))
-        delay_entry.pack(pady=2)
-
-        # (Dropdown für Spawn-Verteilung wurde entfernt)
-
-        # Checkbuttons für die Auswahl der Annahmestationen
-        tk.Label(spawn_win, text="Annahmestationen auswählen (1-10):").pack(pady=2)
-        stations_frame = tk.Frame(spawn_win)
-        stations_frame.pack(pady=2)
-
-        station_vars = {}
-        for idx, station in enumerate(self.annahme_stations):
-            var = tk.BooleanVar(value=False)
-            station_label = f"Annahmestation {idx + 1}"
-            cb = tk.Checkbutton(stations_frame, text=station_label, variable=var)
-            cb.pack(anchor="w")
-            station_vars[idx] = var
-
-        def apply_spawn_settings():
-            try:
-                new_delay = float(delay_entry.get())
-            except ValueError:
-                new_delay = self.package_spawn_delay
-            new_stations = []
-            for idx, var in station_vars.items():
-                if var.get():
-                    new_stations.append(self.annahme_stations[idx])
-
-            self.package_spawn_delay = new_delay
-            self.package_spawn_stations = new_stations
-
-            # Spawne nur dort Pakete, wo noch kein Paket vorhanden ist:
-            for station in self.package_spawn_stations:
-                if station not in self.pickup_packages:
-                    self.spawn_package_at_station(station)
-
-            spawn_win.destroy()
-
-        tk.Button(spawn_win, text="Einstellungen speichern", command=apply_spawn_settings).pack(pady=5)
-
-    def vehicle_in_collision(self, vehicle):
-        """
-        Prüft, ob das angegebene Fahrzeug in einer Kollision mit einem anderen Fahrzeug liegt.
-        Verwendet dafür die bereits vorhandene Methode check_collisions.
-        """
-        collisions = self.check_collisions()
-        for pair in collisions:
-            if vehicle in pair:
-                return True
-        return False
-
-    import concurrent.futures
-    import numpy as np
-
-    def vehicle_order_task(self, vehicle, task):
-        import numpy as np  # NumPy importieren, damit np bekannt ist
-
-        # Skalierter Zeitschritt
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        state = vehicle.getPythonTag("order_state")
-        if state is None or state == "idle":
-            return task.cont
-
-        # Frame-Zähler zur Frequenzsteuerung
-        frame_count = vehicle.getPythonTag("frame_count") or 0
-        frame_count += 1
-        vehicle.setPythonTag("frame_count", frame_count)
-
-        model_delta_angle = 0.0
-        # Führe die Modellinferenz nur alle 30 Frames aus.
-        if self.tf_model is not None and (frame_count % 30 == 0):
-            sensor_data = self.collect_sensor_data(vehicle)
-            # Sicherstellen, dass sensor_data die Form (20,20,1) hat:
-            if sensor_data.ndim == 2:
-                sensor_data = np.expand_dims(sensor_data, axis=-1)
-            if sensor_data.ndim == 3:
-                input_data = np.expand_dims(sensor_data, axis=0)  # Form: (1,20,20,1)
-            elif sensor_data.ndim == 4:
-                input_data = sensor_data
-            else:
-                raise ValueError("Unbekannte Eingabeform – es werden Daten der Form (20,20,1) erwartet.")
-
-            # Asynchroner Aufruf der Inferenz: Erstelle (einmal) einen ThreadPoolExecutor, falls noch nicht vorhanden.
-            if not hasattr(self, "tf_executor"):
-                import concurrent.futures
-                self.tf_executor = concurrent.futures.ThreadPoolExecutor(max_workers=4)
-
-            if not vehicle.hasPythonTag("tf_future"):
-                future = self.tf_executor.submit(self.tf_model.predict, input_data)
-                vehicle.setPythonTag("tf_future", future)
-            else:
-                future = vehicle.getPythonTag("tf_future")
-                if future.done():
-                    try:
-                        result = future.result()
-                        model_delta_angle = result[0][0]
-                    except Exception:
-                        model_delta_angle = 0.0
-                    vehicle.clearPythonTag("tf_future")
-                else:
-                    model_delta_angle = 0.0
-
-        # Berechne den idealen Korrekturwinkel
-        ideal_correction = self.compute_ideal_steering_correction(vehicle)
-
-        if state == "translate" and (frame_count % 30 == 0):
-            sensor_data = self.collect_sensor_data(vehicle)
-            self.log_training_sample(sensor_data, ideal_correction)
-
-        # Aufruf zustandsabhängiger Handler
-        if state == "translate":
-            self.handle_translate_phase(vehicle, dt)
-        elif state == "rotate":
-            self.handle_rotate_phase(vehicle, dt)
-        elif state == "approach":
-            self.handle_approach_phase(vehicle, dt)
-        elif state == "pickup":
-            self.handle_pickup_phase(vehicle, dt)
-        elif state == "drive_out":
-            self.handle_drive_out_phase(vehicle, dt)
-        elif state == "to_delivery":
-            self.handle_to_delivery_phase(vehicle, dt)
-        elif state == "align_delivery":
-            self.handle_align_delivery_phase(vehicle, dt)
-        elif state == "delivery_center":
-            self.handle_delivery_center_phase(vehicle, dt)
-        elif state == "drop":
-            self.handle_drop_phase(vehicle, dt)
-        elif state == "delivery_exit":
-            self.handle_drive_out_phase_delivery(vehicle, dt)
-        elif state == "return_to_garage":
-            self.handle_return_to_garage_phase(vehicle, dt)
-        else:
-            vehicle.setPythonTag("order_state", "translate")
-
-        # Kollisionsprüfung: Nur alle 2 Frames ausführen.
-        if frame_count % 2 == 0:
-            colliding = False
-            collision_duration = 0.0
-            for pair in self.check_collisions():
-                if vehicle in pair:
-                    colliding = True
-                    if not vehicle.hasPythonTag("collision_start_time"):
-                        vehicle.setPythonTag("collision_start_time", self.sim_clock)
-                    else:
-                        collision_duration = self.sim_clock - vehicle.getPythonTag("collision_start_time")
-                    break
-            if not colliding and vehicle.hasPythonTag("collision_start_time"):
-                vehicle.clearPythonTag("collision_start_time")
-
-            if not colliding or collision_duration < 0.1:
-                rating = 10
-                avoidance_angle = 0.0
-            elif collision_duration < 0.3:
-                rating = -10
-                avoidance_angle = self.compute_avoidance_angle(vehicle)
-            elif collision_duration < 1.0:
-                rating = -15
-                avoidance_angle = self.compute_avoidance_angle(vehicle)
-            else:
-                rating = -20
-                avoidance_angle = self.compute_avoidance_angle(vehicle)
-
-            if colliding:
-                ideal_correction += avoidance_angle
-                adjusted_speed = self.collision_avoidance_adjustment(vehicle, base_speed=1.5)
-            else:
-                adjusted_speed = 1.5
-
-            if self.graph_queue is not None:
-                try:
-                    self.graph_queue.put(("rating", vehicle.getPythonTag("vehicle_id"), self.sim_clock, rating),
-                                         block=False)
-                except Exception:
-                    pass
-
-        # Begrenze die Fahrzeugposition auf das Spielfeld.
-        pos = vehicle.getPos(self.render)
-        min_x, max_x = -68, 68
-        min_y, max_y = -68, 68
-        vehicle.setPos(
-            max(min_x, min(pos.getX(), max_x)),
-            max(min_y, min(pos.getY(), max_y)),
-            pos.getZ()
-        )
-
-        return task.cont
-
-    # -------------------- Handler für einzelne Phasen --------------------
-
-    def handle_translate_phase(self, vehicle, dt):
-        import math
-        from panda3d.core import Vec3
-        current_order = vehicle.getPythonTag("current_order")
-        station_occupied = False
-        if current_order is not None and "pickup_station" in current_order:
-            pickup_station = current_order["pickup_station"]
-            occupant = pickup_station.getPythonTag("occupied_by")
-            if occupant is None:
-                pickup_station.setPythonTag("occupied_by", vehicle)
-
-            elif occupant != vehicle:
-                station_occupied = True
-        base_speed = 1.5 if not station_occupied else 0.0
-        adjusted_speed = self.collision_avoidance_adjustment(vehicle, base_speed)
-        if current_order is None:
-            next_order = self.select_next_order(vehicle)
-            if next_order is not None:
-                next_order["status"] = "In Bearbeitung"
-                next_order["vehicle"] = f"Fahrzeug {vehicle.getPythonTag('vehicle_id')}"
-                vehicle.setPythonTag("current_order", next_order)
-            current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None:
-            pickup_station = current_order.get("pickup_station")
-            if pickup_station in self.station_blue_dots:
-                target = self.station_blue_dots[pickup_station].getPos(self.render)
-            else:
-                target = self.blue_dot.getPos(self.render)
-        else:
-            target = self.blue_dot.getPos(self.render)
-        current_pos = vehicle.getPos(self.render)
-        pivot = vehicle.getPythonTag("steering_axis")
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-        heading_error = desired_heading_rad - current_heading_rad
-        while heading_error > math.pi:
-            heading_error -= 2 * math.pi
-        while heading_error < -math.pi:
-            heading_error += 2 * math.pi
-        gain = 1.0
-        max_delta = gain * dt
-        delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-        self.rotate_around_pivot(vehicle, pivot, math.degrees(delta_heading_rad))
-        global_hpr = pivot.getNetTransform().getHpr()
-        new_heading_rad = math.radians(global_hpr.getX())
-        new_x = current_pos.getX() + adjusted_speed * math.cos(new_heading_rad) * dt
-        new_y = current_pos.getY() + adjusted_speed * math.sin(new_heading_rad) * dt
-        new_pos = Vec3(new_x, new_y, 0)
-        vehicle.setPos(new_pos)
-        new_offset_pos = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        if (target - new_offset_pos).length() < 0.1:
-            vehicle.setPythonTag("order_state", "rotate")
-        return Task.cont
-
-    def handle_rotate_phase(self, vehicle, dt):
-        import math
-        from panda3d.core import Vec3  # Nur Vec3 importieren, Task nicht
-
-        # 1. Hole den grünen Referenzpunkt (fork_green) der Gabel.
-        fork_green = vehicle.getPythonTag("fork_green")
-        if not fork_green or fork_green.isEmpty():
-            return Task.cont
-
-        # 2. Hole den aktuellen Auftrag und die zugehörige Pickup-Station.
-        current_order = vehicle.getPythonTag("current_order")
-        if not current_order or "pickup_station" not in current_order:
-            return Task.cont
-        station = current_order["pickup_station"]
-
-        # Hole den Referenzpunkt der Station (white_center) und prüfe auf den Richtungsvektor (optional)
-        white_center = station.getPythonTag("white_center")
-        if white_center is None:
-            return Task.cont
-        target = white_center  # Das Ziel ist der Mittelpunkt der weißen Linie
-
-        # 3. Berechne den Drehpunkt des Fahrzeugs.
-        pivot = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-
-        # 4. Wenn der Abstand vom Pivot zum Ziel sehr gering ist, setze die exakte Ausrichtung.
-        distance = (target - pivot).length()
-        stop_threshold = 0.5  # Schwellenwert – je nach Modelldimension anpassen
-        if distance < stop_threshold:
-            desired_vector = target - pivot
-            desired_angle = (math.degrees(math.atan2(desired_vector.getY(), desired_vector.getX())) + 90) % 360
-            vehicle.setH(self.render, desired_angle)
-            # Richte den grünen Richtungspfeil (fork_center_line) aus, falls vorhanden.
-            white_direction = station.getPythonTag("white_direction")
-            if white_direction is not None:
-                desired_arrow_angle = math.degrees(math.atan2(white_direction.getY(), white_direction.getX()))
-                arrow_relative = (desired_arrow_angle - desired_angle + 180) % 360 - 180
-                fork_center_line = vehicle.getPythonTag("fork_center_line")
-                if fork_center_line:
-                    fork_center_line.setH(arrow_relative)
-            vehicle.setPythonTag("order_state", "approach")
-            return Task.cont
-
-        # 5. Berechne den gewünschten globalen Winkel vom Pivot zum Ziel (inklusive +90°-Offset).
-        desired_vector = target - pivot
-        desired_angle = (math.degrees(math.atan2(desired_vector.getY(), desired_vector.getX())) + 90) % 360
-
-        # 6. Ermittle den aktuellen Fahrzeugheading in Weltkoordinaten und berechne die Differenz.
-        current_heading = vehicle.getH(self.render)
-        angle_diff = (desired_angle - current_heading + 180) % 360 - 180
-
-        if abs(angle_diff) < 2.0:
-            vehicle.setH(self.render, desired_angle)
-            white_direction = station.getPythonTag("white_direction")
-            if white_direction is not None:
-                desired_arrow_angle = math.degrees(math.atan2(white_direction.getY(), white_direction.getX()))
-                arrow_relative = (desired_arrow_angle - desired_angle + 180) % 360 - 180
-                fork_center_line = vehicle.getPythonTag("fork_center_line")
-                if fork_center_line:
-                    fork_center_line.setH(arrow_relative)
-            vehicle.setPythonTag("order_state", "approach")
-            return Task.cont
-
-        # 7. Begrenze den Drehwinkel pro Frame.
-        max_rotation_speed = 20.9  # Grad pro Sekunde
-        max_delta = max_rotation_speed * dt
-        delta_angle = max(-max_delta, min(max_delta, angle_diff))
-
-        # 8. Drehe das Fahrzeug schrittweise um delta_angle über einen temporären Pivot.
-        temp_pivot = self.render.attachNewNode("temp_pivot")
-        temp_pivot.setPos(pivot)
-        self.rotate_around_pivot(vehicle, temp_pivot, delta_angle)
-        temp_pivot.removeNode()
-
-        return Task.cont
-
-    def handle_approach_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None:
-            pickup_station = current_order.get("pickup_station")
-            target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-        else:
-            target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-        current = vehicle.getPos(self.render)
-        error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-        if error_vec.length() > 0.05:
-            direction = error_vec.normalized()
-            move_distance = 1.5 * dt
-            new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                           current.getY() + direction.getY() * move_distance, target.getZ())
-            vehicle.setPos(new_pos)
-        else:
-            vehicle.setPos(target)
-            vehicle.setPythonTag("order_state", "pickup")
-
-    def handle_pickup_phase(self, vehicle, dt):
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        target_z = 1.0
-        raise_speed = 0.5
-        if current_z < target_z:
-            fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-        else:
-            if vehicle.getPythonTag("current_order") is None:
-                if self.orders_queue:
-                    vehicle.setPythonTag("current_order", self.orders_queue.pop(0))
-                else:
-                    vehicle.setPythonTag("order_state", "drive_out")
-                    return
-            if not vehicle.getPythonTag("package_attached"):
-                pickup_station = vehicle.getPythonTag("current_order")["pickup_station"]
-                self.pickup_package(vehicle, pickup_station)
-                vehicle.setPythonTag("package_attached", True)
-            if vehicle.getPythonTag("drive_out_target") is None:
-                vehicle.setPythonTag("drive_out_target",
-                                     vehicle.getPos(self.render) + vehicle.getQuat(self.render).getForward() * 5.0)
-            vehicle.setPythonTag("order_state", "drive_out")
-
-    def handle_drive_out_phase(self, vehicle, dt):
-        from panda3d.core import Vec3
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        if current_z > 0:
-            lower_speed = 0.5
-            fork_node.setZ(max(0, current_z - lower_speed * dt))
-        current_pos = vehicle.getPos(self.render)
-        drive_out_target = vehicle.getPythonTag("drive_out_target")
-        if drive_out_target is None:
-            drive_out_target = current_pos + vehicle.getQuat(self.render).getForward() * 5.0
-            vehicle.setPythonTag("drive_out_target", drive_out_target)
-        diff = drive_out_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            # Sobald das Fahrzeug seinen Drive-Out erreicht hat, geben wir den Lock an der Pickup-Station frei
-            current_order = vehicle.getPythonTag("current_order")
-            if current_order is not None and "pickup_station" in current_order:
-                pickup_station = current_order["pickup_station"]
-                # Ersetze clearPythonTag durch setPythonTag(..., None) für die Freigabe
-                pickup_station.setPythonTag("occupied_by", None)
-            vehicle.setPythonTag("order_state", "to_delivery")
-            vehicle.setPythonTag("drive_out_target", None)
-        return Task.cont
-
-    def handle_to_delivery_phase(self, vehicle, dt):
-        import math
-        from panda3d.core import Vec3
-
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is None:
-            return Task.cont
-
-        # Bestimme den Zielindex aus dem String (z.B. "Abgabestation 3")
-        try:
-            target_index = int(current_order.get("ziel", "Abgabestation 1").split()[-1])
-        except Exception:
-            target_index = 1
-
-        # Statt direkt die Position abzufragen, verweisen wir auf den gesamten NodePath
-        if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-            delivery_station = self.abgabe_blue_dots[target_index - 1]
-        else:
-            delivery_station = self.abgabe_blue_dots[0]
-
-        # Jetzt holen wir die Position vom NodePath
-        target = delivery_station.getPos(self.render)
-        current_pos = vehicle.getPos(self.render)
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-
-        # Prüfe, ob an der Abgabestation bereits ein Fahrzeug blockiert:
-        if self.is_delivery_station_occupied(delivery_station, exclude_vehicle=vehicle):
-            return Task.cont
-
-        # Berechne den gewünschten Basiswinkel vom Offset-Punkt zum Ziel.
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-        pivot = vehicle.getPythonTag("steering_axis")
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-        heading_error = desired_heading_rad - current_heading_rad
-        while heading_error > math.pi:
-            heading_error -= 2 * math.pi
-        while heading_error < -math.pi:
-            heading_error += 2 * math.pi
-
-        gain = 1.0
-        max_delta = gain * dt
-        delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-        self.rotate_around_pivot(vehicle, pivot, math.degrees(delta_heading_rad))
-
-        global_hpr = pivot.getNetTransform().getHpr()
-        new_heading_rad = math.radians(global_hpr.getX())
-        adjusted_speed = self.collision_avoidance_adjustment(vehicle, base_speed=1.5)
-        new_x = current_pos.getX() + adjusted_speed * math.cos(new_heading_rad) * dt
-        new_y = current_pos.getY() + adjusted_speed * math.sin(new_heading_rad) * dt
-        new_pos = Vec3(new_x, new_y, current_pos.getZ())
-        vehicle.setPos(new_pos)
-
-        new_offset_pos = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        if (target - new_offset_pos).length() < 0.1:
-            vehicle.setPythonTag("order_state", "align_delivery")
-        return Task.cont
-
-    def handle_align_delivery_phase(self, vehicle, dt):
-        import math
-        from panda3d.core import Vec3
-
-        # 1. Ermittle den Basiszielwinkel aus der weißen Linie der Abgabestation.
-        try:
-            base_target_heading = self.abgabe_white_line.getH(self.render) % 360
-        except Exception as e:
-            base_target_heading = 90.0
-
-        # 2. Berechne den gewünschten Endwinkel.
-        # Ursprünglich wurde desired_heading so gesetzt:
-        #    (base_target_heading + 90 + 180) % 360
-        # Um 90° mehr gegen den Uhrzeigersinn zu drehen, addieren wir zusätzlich 90°:
-        desired_heading = (base_target_heading + 90 + 180 + 90) % 360
-        # Das entspricht (base_target_heading + 360) % 360, also einfach:
-        desired_heading = base_target_heading % 360
-
-        # 3. Berechne den Pivot-Punkt so wie in handle_rotate_phase,
-        # damit das Fahrzeug auf der Stelle rotiert.
-        pivot = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-
-        # 4. Ermittle den aktuellen globalen Heading des Fahrzeugs.
-        current_heading = vehicle.getH(self.render) % 360
-
-        # 5. Berechne den minimalen Winkelunterschied (normiert auf [-180, 180]).
-        error = (desired_heading - current_heading + 180) % 360 - 180
-
-
-        # 6. Wenn der Fehler sehr klein ist (< 1°), setze den Endwinkel und wechsle in den nächsten Zustand.
-        if abs(error) < 1.0:
-            vehicle.setH(self.render, desired_heading)
-            vehicle.setPythonTag("order_state", "delivery_center")
-            return Task.cont
-
-        # 7. Begrenze den Drehschritt basierend auf einer maximalen Drehgeschwindigkeit.
-        turn_speed = 90.0  # Grad pro Sekunde
-        max_turn = turn_speed * dt
-        turn_angle = max(-max_turn, min(max_turn, error))
-
-        # 8. Rotiere das Fahrzeug schrittweise um turn_angle mit Hilfe eines temporären Pivots.
-        temp_pivot = self.render.attachNewNode("temp_pivot")
-        temp_pivot.setPos(pivot)
-        self.rotate_around_pivot(vehicle, temp_pivot, turn_angle)
-        temp_pivot.removeNode()
-
-        return Task.cont
-
-    def handle_delivery_center_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is None:
-            return
-        delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-        try:
-            target_index = int(delivery_target_str.split()[-1])
-        except ValueError:
-            target_index = 1
-        if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-            blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-        else:
-            blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-        current = vehicle.getPos(self.render)
-        target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-        error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-        tolerance = 0.05
-        move_distance = 1.5 * dt
-        if error_vec.length() > tolerance:
-            direction = error_vec.normalized()
-            new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                           current.getY() + direction.getY() * move_distance, current.getZ())
-            vehicle.setPos(new_pos)
-        else:
-            vehicle.setPos(target_point)
-            vehicle.setPythonTag("order_state", "drop")
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_fork_z = fork_node.getZ()
-        if current_fork_z < 1.0:
-            new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-            fork_node.setZ(new_fork_z)
-
-    def handle_drop_phase(self, vehicle, dt):
-        # Falls das Fahrzeug ein Paket trägt, wird dieses abgesetzt.
-        if vehicle.getPythonTag("package_attached"):
-            self.drop_cargo(vehicle)
-            vehicle.setPythonTag("package_attached", False)
-        else:
-            # Falls die Gabel noch abgesenkt werden muss:
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            if current_z > 0:
-                lower_speed = 0.5
-                fork_node.setZ(max(0, current_z - lower_speed * dt))
-
-        # Setze den Zustand nun auf "delivery_exit", damit das Fahrzeug aus dem Lieferbereich herausfährt.
-        vehicle.setPythonTag("order_state", "delivery_exit")
-        # Optional: den Auftrag als "Abgegeben" markieren und löschen.
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None:
-            current_order["status"] = "Abgegeben"
-            current_order["delivered_at"] = self.sim_clock
-        vehicle.clearPythonTag("current_order")
-
-        return Task.cont
-
-    def handle_drive_out_phase_delivery(self, vehicle, dt):
-        from panda3d.core import Vec3
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        if current_z > 0:
-            lower_speed = 0.5
-            fork_node.setZ(max(0, current_z - lower_speed * dt))
-        current_pos = vehicle.getPos(self.render)
-        drive_out_target = vehicle.getPythonTag("drive_out_target")
-        if drive_out_target is None:
-            drive_out_target = current_pos + vehicle.getQuat(self.render).getForward() * 5.0
-            vehicle.setPythonTag("drive_out_target", drive_out_target)
-        diff = drive_out_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            # Sobald das Fahrzeug seinen Drive-Out im Lieferbereich erreicht hat, geben wir den Lock frei
-            current_order = vehicle.getPythonTag("current_order")
-            if current_order is not None:
-                try:
-                    target_index = int(current_order.get("ziel", "Abgabestation 1").split()[-1])
-                except Exception:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_stations):
-                    delivery_station = self.abgabe_stations[target_index - 1]
-                else:
-                    delivery_station = self.abgabe_stations[0]
-                # Freigabe des Locks an der Delivery-Station
-                delivery_station.setPythonTag("occupied_by", None)
-            vehicle.setPythonTag("order_state", "translate")
-            vehicle.setPythonTag("drive_out_target", None)
-        return Task.cont
-
-    def handle_phase11(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if vehicle.getPythonTag("last_delivery_marker") is not None:
-            target_point = vehicle.getPythonTag("last_delivery_marker")
-        else:
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                target_point = self.abgabe_blue_dots[0].getPos(self.render)
-        current_pos = vehicle.getPos(self.render)
-        diff = target_point - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            vehicle.setPos(new_pos)
-        else:
-            vehicle.setPos(target_point)
-            vehicle.setPythonTag("order_state", "next_order")
-
-    def handle_return_to_garage_phase(self, vehicle, dt):
-        garage_target = vehicle.getPythonTag("garage_target")
-        if garage_target is None:
-            garage_target = self.garagen_parking_points[0]
-        current_pos = vehicle.getPos(self.render)
-        diff = garage_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 1.0 * dt
-            new_pos = current_pos + diff.normalized() * move_distance
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            if vehicle.hasPythonTag("start_heading"):
-                vehicle.setH(vehicle.getPythonTag("start_heading"))
-            vehicle.setPythonTag("order_state", "idle")
-            vehicle.setPythonTag("standby_pending", False)
-
-    def collect_sensor_data(self, vehicle, sensor_range=5, grid_resolution=0.5):
-        """
-        Erzeugt ein einfaches 2D-Occupancy-Grid, das den Bereich um das Fahrzeug simuliert.
-
-        Parameter:
-          sensor_range: Radius (in Welt-Einheiten) um das Fahrzeug.
-          grid_resolution: Größe der einzelnen Zellen im Grid.
-
-        Rückgabe:
-          Ein NumPy-Array (2D) mit 0 (frei) als Platzhalter.
-        """
-        import numpy as np
-        grid_size = int((sensor_range * 2) / grid_resolution)
-        sensor_grid = np.zeros((grid_size, grid_size))
-        # --- Hier kannst du später echte Kollisionsabfragen oder Ray-Casting integrieren ---
-        return sensor_grid
-
-    def compute_ideal_steering_correction(self, vehicle):
-        """
-        Berechnet einen idealen Korrekturwinkel (in Grad) für die Navigation in der 'translate'-Phase.
-        Es wird ein vereinfachtes Modell genutzt, das den Unterschied zwischen dem gewünschten und dem aktuellen
-        Heading (über die Fahrzeug-Steuerachse) ermittelt.
-        """
-        import math
-
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None and "pickup_station" in current_order:
-            pickup_station = current_order["pickup_station"]
-            if pickup_station in self.station_blue_dots:
-                target = self.station_blue_dots[pickup_station].getPos(self.render)
-            else:
-                target = self.blue_dot.getPos(self.render)
-        else:
-            target = self.blue_dot.getPos(self.render)
-
-        current_pos = vehicle.getPos(self.render)
-        # Bestimme einen Offset-Punkt, basierend auf der bereits existierenden pickup_offset
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        # Berechne den gewünschten Heading-Winkel (in Radiant): Richtung von offset_pos zu target
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-
-        # Hole den aktuellen Heading-Wert vom Steuerachsen-Node (pivot)
-        pivot = vehicle.getPythonTag("steering_axis")
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-
-        ideal_correction_rad = desired_heading_rad - current_heading_rad
-        # Winkelbereich anpassen [-pi, pi]
-        while ideal_correction_rad > math.pi:
-            ideal_correction_rad -= 2 * math.pi
-        while ideal_correction_rad < -math.pi:
-            ideal_correction_rad += 2 * math.pi
-
-        return math.degrees(ideal_correction_rad)
-
-    def compute_avoidance_angle(self, current_vehicle, safe_distance=3.0):
-        """
-        Berechnet einen zusätzlichen Ausweichwinkel (in Grad) basierend auf den
-        Positionen anderer Fahrzeuge. Fahrzeuge, die sehr nah sind, sollen einen
-        höheren Einfluss haben. Der Rückgabewert wird mit einem Gewichtungsfaktor
-        multipliziert, sodass der Ausweichimpuls moderat bleibt.
-        """
-        import math
-        from panda3d.core import Vec2
-
-        current_pos = current_vehicle.getPos(self.render)
-        avoidance_vector = Vec2(0, 0)
-
-        # Schleife über alle Fahrzeuge (außer dem eigenen)
-        for other in self.garage_vehicles:
-            if other == current_vehicle:
-                continue
-            other_pos = other.getPos(self.render)
-            diff = Vec2(current_pos.getX() - other_pos.getX(),
-                        current_pos.getY() - other_pos.getY())
-            dist = diff.length()
-            if dist > 0 and dist < safe_distance:
-                # Je näher das Fahrzeug, desto größer der Einfluss (gewichtete Summe)
-                weight = (safe_distance - dist) / safe_distance
-                avoidance_vector += diff.normalized() * weight
-
-        # Falls kein Fahrzeug in der Nähe ist, wird kein Ausweichwinkel angewendet.
-        if avoidance_vector.length() == 0:
-            return 0.0
-
-        # Berechne den Winkel, den der resultierende Ausweichvektor vorgibt.
-        avoidance_angle = math.degrees(math.atan2(avoidance_vector.getY(), avoidance_vector.getX()))
-        # Mit einem Faktor abschwächen, um den Einfluss zu mildern.
-        weight_factor = 0.5  # Passe diesen Faktor bei Bedarf an (0 = kein Ausweichen, 1 = voll)
-        return avoidance_angle * weight_factor
-
-    def log_training_sample(self, sensor_data, ideal_angle):
-        """
-        Speichert ein Trainingssample bestehend aus den gesammelten Sensorwerten und dem idealen Korrekturwinkel.
-        """
-        self.training_data.append((sensor_data.copy(), ideal_angle))
-        # Optional: Gib eine Debug-Ausgabe aus, um das Logging zu überwachen.
-
-    def apply_safety_rules(self, vehicle, sensor_data, model_delta_angle, ideal_correction):
-        """
-        Kombiniert den vom Modell (model_delta_angle) und den ideal berechneten Korrekturwert (ideal_correction)
-        nur dann mit einem festen Sicherheitswert, wenn die Sensordaten einen kritischen Occupancy-Level anzeigen.
-
-        Falls der Occupancy-Level niedrig ist, wird ausschließlich der ideal vorhandene Korrekturwert verwendet.
-        """
-        import numpy as np
-        # Beispiel: Untersuche die mittlere Zeile des sensor_data-Grids als Indikator für frontale Hindernisse
-        middle_row = sensor_data[sensor_data.shape[0] // 2]
-        occupancy_level = np.sum(middle_row)
-
-        # Definiere einen kritischen Schwellenwert (diesen Wert ggf. anpassen)
-        threshold = 1.0
-
-        if occupancy_level > threshold:
-            # Hier legen wir fest, dass in kritischen Situationen der Sicherheitswert stärker gewichtet wird.
-            safety_correction = 15.0  # z. B. 15° als feste Korrektur (Wert anpassen)
-            # Gewichteter Ansatz: Sicherheitskorrektur dominiert, während ein kleiner Anteil des idealen Wertes einfließt.
-            final_angle = 0.7 * safety_correction + 0.3 * ideal_correction
-        else:
-            # Wenn kein kritischer Wert vorliegt, einfach den ideal berechneten Korrekturwert verwenden.
-            final_angle = ideal_correction
-
-        return final_angle
-
-    def collision_avoidance_adjustment(self, current_vehicle, base_speed, safe_distance=3.0):
-        """
-        Berechnet eine angepasste Geschwindigkeit für ein Fahrzeug (current_vehicle), sodass
-        dessen Basisgeschwindigkeit (base_speed) entsprechend reduziert wird, wenn andere Fahrzeuge
-        in der Nähe sind. Wenn der Abstand zu einem anderen Fahrzeug unter 1 Einheit liegt, wird
-        die Geschwindigkeit auf 0 gesetzt.
-
-        Parameter:
-          current_vehicle: Das Fahrzeug, dessen Geschwindigkeit angepasst werden soll.
-          base_speed: Die Basisgeschwindigkeit (ohne Kollisionseffekt).
-          safe_distance: Der Abstand, unterhalb dessen Fahrzeuge ihre Geschwindigkeit reduzieren.
-
-        Rückgabe:
-          Die angepasste Geschwindigkeit.
-        """
-        current_pos = current_vehicle.getPos(self.render)
-        adjusted_speed = base_speed
-        for veh in self.garage_vehicles:
-            if veh == current_vehicle:
-                continue
-            other_pos = veh.getPos(self.render)
-            distance = (current_pos - other_pos).length()
-            if distance < safe_distance:
-                # Wenn Fahrzeuge extrem nahe kommen, wird die Geschwindigkeit auf 0 gesetzt.
-                if distance < 1.0:
-                    candidate_speed = 0.0
-                else:
-                    # Lineare Reduktion: Je näher das Fahrzeug, desto geringer die erlaubte Geschwindigkeit.
-                    candidate_speed = base_speed * (distance / safe_distance)
-                # Wähle den minimalen Wert
-                if candidate_speed < adjusted_speed:
-                    adjusted_speed = candidate_speed
-        return adjusted_speed
-
-    def check_collisions(self):
-        """
-        Prüft, ob Fahrzeuge in Kollisionsnähe liegen.
-        Der Schwellenwert wurde von 1.0 auf 1.5 erhöht, um den tatsächlichen Fahrzeugumfang (statt nur den Ursprung) besser abzubilden.
-        """
-        collision_threshold = 1.5  # Kann bei Bedarf weiter angepasst werden
-        collisions = []
-        for i in range(len(self.garage_vehicles)):
-            veh1 = self.garage_vehicles[i]
-            pos1 = veh1.getPos(self.render)
-            for j in range(i + 1, len(self.garage_vehicles)):
-                veh2 = self.garage_vehicles[j]
-                pos2 = veh2.getPos(self.render)
-                distance = (pos1 - pos2).length()
-                if distance < collision_threshold:
-                    collisions.append((veh1, veh2))
-        return collisions
-
-    def update_rl_on_collisions(self, task):
-        """
-        Diese Methode wird regelmäßig (als Task) aufgerufen und:
-          - Ermittelt alle kollidierenden Fahrzeugpaare über check_collisions().
-          - Baut für jedes Paar in self.collision_start_times die Kollisionsdauer auf.
-          - Falls eine Kollision länger als 5.0 Sekunden anhält, wird der Zustand der beteiligten Fahrzeuge auf "drive_out" gesetzt.
-        """
-        collisions = self.check_collisions()
-        current_time = self.sim_clock
-
-        if not hasattr(self, "collision_start_times"):
-            self.collision_start_times = {}
-
-        current_collision_keys = set()
-        for veh1, veh2 in collisions:
-            key = frozenset({veh1, veh2})
-            current_collision_keys.add(key)
-            if key not in self.collision_start_times:
-                self.collision_start_times[key] = current_time
-            else:
-                duration = current_time - self.collision_start_times[key]
-                # Eine „lang anhaltende“ Kollision (über 5 Sekunden) löst das Aufgeben der Fahrtrichtung aus.
-                if duration > 5.0:
-                    if veh1.getPythonTag("order_state") != "drive_out":
-                        veh1.setPythonTag("order_state", "drive_out")
-                    if veh2.getPythonTag("order_state") != "drive_out":
-                        veh2.setPythonTag("order_state", "drive_out")
-                    if key in self.collision_start_times:
-                        del self.collision_start_times[key]
-
-        # Entferne veraltete Einträge, die nicht mehr kollidieren
-        keys_to_remove = [key for key in self.collision_start_times if key not in current_collision_keys]
-        for key in keys_to_remove:
-            del self.collision_start_times[key]
-
-        return task.cont
-
-    def is_station_occupied(self, station, exclude_vehicle=None, occupancy_threshold=1.0):
-        # Bestimme den Zielpunkt der Station – falls über station_blue_dots verfügbar.
-        if hasattr(self, 'station_blue_dots') and station in self.station_blue_dots:
-            station_pos = self.station_blue_dots[station].getPos(self.render)
-        else:
-            station_pos = station.getPos(self.render)
-        for veh in self.garage_vehicles:
-            if veh == exclude_vehicle:
-                continue
-            current_order = veh.getPythonTag("current_order")
-            if current_order is not None and current_order.get("pickup_station") == station:
-                # Blockiere die Station, solange das Fahrzeug nicht den Zustand erreicht hat,
-                # der anzeigt, dass es die Station verlassen hat.
-                if veh.getPythonTag("order_state") not in ["to_delivery", "idle", "next_order"]:
-                    return True
-            # Zusätzlich: Blockiere, wenn ganz nahe am Station-Zielpunkt
-            if (veh.getPos(self.render) - station_pos).length() < occupancy_threshold:
-                return True
-        return False
-
-    def is_delivery_station_occupied(self, station, exclude_vehicle=None, occupancy_threshold=1.0):
-        occupant = station.getPythonTag("occupied_by")
-        if occupant is not None and occupant != exclude_vehicle:
-            return True
-        # Optional: Falls du noch eine physikalische Näheprüfung implementieren möchtest, kannst du dies ergänzen.
-        return False
-
-    def compute_collision_duration(self, vehicle):
-        """
-        Berechnet für das angegebene Fahrzeug den maximalen Kollisionszeitraum,
-        basierend auf den in self.collision_start_times gespeicherten Kollisionspaaren.
-        Gibt 0 zurück, wenn das Fahrzeug in keinem Kollisionsereignis beteiligt ist.
-        """
-        durations = []
-        if not hasattr(self, "collision_start_times"):
-            return 0
-        current_time = self.sim_clock
-        for pair, start_time in self.collision_start_times.items():
-            if vehicle in pair:
-                durations.append(current_time - start_time)
-        if durations:
-            return max(durations)
-        return 0
-
-class RLAgent:
-    def __init__(self, state_bins, action_space, learning_rate=0.1, discount_factor=0.9, epsilon=0.2):
-        """
-        state_bins: Tuple oder Liste, um kontinuierliche Zustände zu diskretisieren (z.B. (max_distance, num_bins))
-        action_space: Liste diskreter Aktionen (z.B. [0, 1, 2] --> 0: keine Bremsung, 1: leicht, 2: stark)
-        """
-        self.state_bins = state_bins
-        self.action_space = action_space
-        self.lr = learning_rate
-        self.gamma = discount_factor
-        self.epsilon = epsilon
-        # Initialisiere Q-Tabelle als Dictionary: key: (discretisierter_state), value: Liste von Q-Werten pro Aktion
-        self.q_table = {}
-
-    def discretize_state(self, state):
-        """
-        Nimmt einen Zustandsvektor (z.B. [distance, speed]) und gibt einen diskreten Zustand zurück.
-        Hier ein Beispiel: Falls state[0] = Abstand und state[1] = Geschwindigkeit.
-        """
-        # Beispiel: Wir nehmen an, dass state_bins = ((max_distance, num_bins), (max_speed, num_bins))
-        discrete_state = []
-        for i, (max_val, bins) in enumerate(self.state_bins):
-            # Begrenze state[i] um max_val:
-            val = min(state[i], max_val)
-            bin_size = max_val / bins
-            discrete_state.append(int(val // bin_size))
-        return tuple(discrete_state)
-
-    def select_action(self, state):
-        discrete_state = self.discretize_state(state)
-        if discrete_state not in self.q_table:
-            self.q_table[discrete_state] = [0.0 for _ in self.action_space]
-        # Epsilon-greedy Auswahl:
-        if random.random() < self.epsilon:
-            return random.choice(self.action_space)
-        else:
-            q_values = self.q_table[discrete_state]
-            return self.action_space[np.argmax(q_values)]
-
-    def update(self, state, action, reward, next_state):
-        s = self.discretize_state(state)
-        s_next = self.discretize_state(next_state)
-        if s not in self.q_table:
-            self.q_table[s] = [0.0 for _ in self.action_space]
-        if s_next not in self.q_table:
-            self.q_table[s_next] = [0.0 for _ in self.action_space]
-        a_index = self.action_space.index(action)
-        # Q-Learning Update-Regel:
-        best_next = max(self.q_table[s_next])
-        self.q_table[s][a_index] += self.lr * (reward + self.gamma * best_next - self.q_table[s][a_index])
-
-    def preprocess_input_data(input_data):
-        """
-        Transformiert die Eingabedaten von der Form (batch_size, 20, 20, 1)
-        in einen Tensor der Form (batch_size, 10).
-
-        Vorgehen:
-          1. Jedes Beispiel (20x20x1) wird zunächst zu einem Vektor der Länge 400
-             abgeflacht.
-          2. Dieser Vektor wird in 10 gleich lange Blöcke (je 40 Werte) unterteilt.
-          3. Aus jedem Block wird der Mittelwert berechnet – das Ergebnis ist ein 10-dimensionaler Vektor.
-
-        Parameter:
-          • input_data: NumPy-Array mit Shape (batch_size, 20, 20, 1)
-
-        Rückgabe:
-          • NumPy-Array der Shape (batch_size, 10)
-        """
-        batch_size = input_data.shape[0]
-        # Abflachen jedes Bildes (20*20=400)
-        flattened = input_data.reshape(batch_size, -1)  # Shape: (batch_size, 400)
-        # Neuformen in Blöcke der Größe 40: Shape (batch_size, 10, 40)
-        reshaped = flattened.reshape(batch_size, 10, -1)
-        # Mittelwert je Block berechnen -> Ergebnis: (batch_size, 10)
-        features = np.mean(reshaped, axis=2)
-        return features
-
-    import numpy as np
-
-    def predict_vehicle_rating(self, input_data):
-        """
-        Diese Methode nimmt den Eingabetensor in der Form
-          (batch_size, 20, 20, 1)
-        und transformiert ihn in einen Tensor der Form
-          (batch_size, 10)
-        – indem jedes Beispiel ersteinmal abgeflacht und in 10 gleiche Blöcke (je 40 Werte)
-        unterteilt wird; der Mittelwert jedes Blocks wird als repräsentatives Feature
-        verwendet.
-
-        Anschließend wird der vorverarbeitete Tensor an das Keras‑Modell übergeben,
-        sodass der ValueError aufgrund inkompatibler Eingabeformen nicht mehr auftritt.
-
-        Vorgehen:
-          1. Abflachen jedes Beispiels von (20, 20, 1) zu einem Vektor der Länge 400.
-          2. Neuformen des 400-dimensionalen Vektors in (10, 40).
-          3. Berechnung des Mittelwerts in jeder der 10 Gruppen (Block), wodurch ein
-             10-dimensionaler Vektor entsteht.
-
-        Parameter:
-          • input_data: NumPy‑Array, erwartet die Form (batch_size, 20, 20, 1)
-
-        Rückgabe:
-          • prediction: Das Ergebnis von self.tf_model.predict() auf den vorverarbeiteten
-            Daten (Form (batch_size, 10))
-        """
-        # Schritt 1: Bestimme die Batch-Größe und flache die Bilder ab.
-        batch_size = input_data.shape[0]
-        flattened = input_data.reshape(batch_size, -1)  # Resultat: (batch_size, 400)
-
-        # Schritt 2: Unterteile den 400-dimensionalen Vektor in 10 Blöcke (je 40 Werte).
-        reshaped = flattened.reshape(batch_size, 10, 40)  # (batch_size, 10, 40)
-
-        # Schritt 3: Berechne den Mittelwert jedes Blocks (entsteht ein Vektor der Länge 10).
-        processed_data = np.mean(reshaped, axis=2)  # (batch_size, 10)
-
-        # Übergabe der vorverarbeiteten Daten an das Modell.
-        prediction = self.tf_model.predict(processed_data)
-        return prediction
-
-
-if __name__ == "__main__":
-    # Wichtig: setze auf Windows die Startmethode auf "spawn"
-    multiprocessing.set_start_method('spawn')
-
-    # Erzeuge eine Queue, auch wenn sie später eventuell neu erstellt wird, wenn "G" gedrückt wird.
-    graph_q = Queue()
-    app = LagerSimulation(graph_q)
-    app.run()
-
-    # Beim Schließen der Simulation den Graphprozess ggf. beenden
-    if app.graph_process is not None:
-        app.graph_process.terminate()
-        app.graph_process.join()
\ No newline at end of file
Index: Grundmodell/Gm24.py
===================================================================
diff --git a/Grundmodell/Gm24.py b/Grundmodell/Gm24.py
deleted file mode 100644
--- a/Grundmodell/Gm24.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,1613 +0,0 @@
-import random
-import math
-import tkinter as tk  # Für das extra Fenster der Auftragsübersicht
-from tkinter import ttk  # Für die tabellarische Darstellung (Treeview)
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-from direct.task.TaskManagerGlobal import taskMgr
-
-
-from functools import partial
-
-
-
-
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        self.tk_root = tk.Tk()
-        self.tk_root.withdraw()
-
-        self.taskMgr.add(self._tk_update, "tkUpdateTask")
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5  # Wird in update_vehicle genutzt
-        self.state_timer = 0.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Paketspawning an den Annahmestationen:
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-        # Fahrzeug-spezifische Zuordnung: Fahrzeug -> transportiertes Paket
-        self.cargos = {}
-
-        # NEU: Initialisiere die belegten Annahmestationen
-        self.occupied_pickups = set()  # Oder: [] für eine Liste
-
-        # Graph-Daten (Sim-Zeit, Pakete pro Minute, durchschnittliche Liegedauer)
-        self.graph_data = []
-        self.graph_opened = False
-
-        # Auftragsverwaltung: Speichere alle Aufträge (für die Anzeige) sowie in
-        # einer Queue (Liste) zur sequentiellen Abarbeitung.
-        self.orders = {}
-        self.orders_queue = []
-        self.next_order_id = 1
-
-        # Tkinter-Fenster für Auftragsübersicht
-        self.order_win = None
-        self.order_tree = None
-
-        # Umgebung initialisieren
-        self.draw_origin()
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.create_wall()
-        self.create_annahme_stations()
-        self.create_abgabe_stations()  # Hier wird auch self.abgabe_stations angelegt.
-        self.create_garagen_stations()
-
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # Fahrzeuge in den Garagen erstellen (genau 5 Fahrzeuge)
-        self.create_garage_vehicles()
-
-        # NEU: Testvariablen
-        self.first_vehicle_order_state = "idle"
-        self.attached_package = None
-        self.current_order = None  # wird durch Fahrzeuge individuell genutzt
-
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tastenzuordnungen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-        # Taste C öffnet das Fahrzeug-Kontrollfenster
-        self.accept("c", self.show_vehicle_control)
-
-        # Task-Manager
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-        self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    # ---------------------------
-    # SIMULATION UND UI-METHODEN
-    # ---------------------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        # dt jetzt skaliert mit der Simulationsgeschwindigkeit
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    # ---------------------------
-    # METHODEN FÜR RASTER, LICHT, MAUER, URSPRUNG
-    # ---------------------------
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # STATIONSOBJEKTE UND ZUORDNUNG
-    # -----------------------------------
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        """
-        Erzeugt die Annahmestationen und erstellt für jede Station:
-          - Einen weißen Marker zur Orientierung
-          - Einen grünen Punkt (optional)
-          - Eine weiße Linie, an deren Endpunkt ein blauer Marker als Ziel in der "Translate‑Phase" dient
-
-        Zusätzlich wird ein Dictionary self.station_blue_dots aufgebaut, in dem jedem Annahmestations‑Node
-        der zugehörige blaue Marker zugeordnet wird. Außerdem wird für die erste Station die globale Variable
-        self.station_white_direction festgelegt.
-        """
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        self.station_blue_dots = {}
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basisstation (zum Beispiel als Rahmen)
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Erzeuge den weißen Marker als Orientierung
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Erzeuge den grünen Punkt (optional)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zeichne die weiße Linie: Sie beginnt bei center + Vec3(0, 0, -0.5) und verläuft 3 Meter in X‑Richtung.
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Erzeuge den blauen Marker, der als Ziel in der Translate‑Phase dient
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            # Speichere den blauen Marker im Dictionary, sodass er später erzeugt werden kann
-            self.station_blue_dots[station_dummy] = blue_dot
-
-            # Optionale Textanzeige der Stationsnummer
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) – falls benötigt:
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-            # Für die erste Station (oder den ersten relevanten Pickup) setzen wir globale Referenzen,
-            # die in vehicle_order_task benötigt werden.
-            if i == 1:
-                self.blue_dot = blue_dot
-                self.station_green_dot = green_dot
-                # Berechne den Mittelpunkt der weißen Linie als Referenz (optional)
-                self.white_line_center = (start_line + end_line) * 0.5
-                line_vec = end_line - start_line
-                if line_vec.length() != 0:
-                    self.station_white_direction = Vec2(line_vec.getX(), line_vec.getY()).normalized()
-                else:
-                    self.station_white_direction = Vec2(1, 0)  # Fallback-Wert
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        self.abgabe_stations = []  # Liste der Abgabestationen
-        self.abgabe_blue_dots = []  # Liste zum Speichern der blauen Marker für die Abgabe
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basiskonstruktion der Abgabestation
-            node = self.create_abgabe_station(pt)
-            self.abgabe_stations.append(node)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Marker am Zentrum (weiß)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Grüner Punkt: center + Vec3(0, 0, -0.5)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Weiße Linie: Startet bei center + Vec3(0, 0, -0.5)
-            # und verläuft 3 Meter in negativer X-Richtung
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt: wird an der Endposition der Linie erzeugt
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            # Speichere den blauen Marker für spätere Navigation der Abgabestation
-            self.abgabe_blue_dots.append(blue_dot)
-
-            # Anzeige der Stationsnummer (textuell)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) auf der Station
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 3)
-        v5 = pos + Vec3(1, 0, 3)
-        v6 = pos + Vec3(1, 2, 3)
-        v7 = pos + Vec3(0, 2, 3)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 3)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        self.garagen_stations = []
-        self.garagen_parking_points = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            self.garagen_stations.append(pt)
-            # ParkpunktGarage: Verschoben um 0.5 in negativer Y-Richtung:
-            center = pt + Vec3(0.5, 0.5, 1.5)
-            ParkpunktGarage = center + Vec3(0, 0, 0.7)
-            self.garagen_parking_points.append(ParkpunktGarage)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def create_garage_vehicles(self):
-        self.garage_vehicles = []
-        vehicle_id_counter = 1
-        for park in self.garagen_parking_points:
-            veh = self.create_vehicle(park_point=park)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            newPos.setZ(0)
-            veh.setPos(newPos)
-
-            # Fahrzeuge starten im Standby (idle)
-            veh.setPythonTag("current_order", None)
-            veh.setPythonTag("order_state", "idle")
-            veh.setPythonTag("package_attached", False)
-            veh.setPythonTag("vehicle_id", vehicle_id_counter)
-            # Speichere den Parkpunkt als Rückkehrziel
-            veh.setPythonTag("garage_target", park)
-            # Speichere auch das Anfangs-Heading, um es später beim Parken wiederherzustellen.
-            veh.setPythonTag("start_heading", veh.getH())
-            vehicle_id_counter += 1
-
-            self.garage_vehicles.append(veh)
-
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-            # Füge einen Textknoten hinzu, der die Fahrzeugnummer vorne auf dem Fahrzeug anzeigt.
-            # Wir suchen den Mast-Knoten.
-            mast = veh.find("**/mast")
-            if not mast.isEmpty():
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)  # Schwarz
-                tn.setAlign(TextNode.ACenter)
-                text_np = mast.attachNewNode(tn)
-                # Positioniere den Text relativ zum Mast: Wir nutzen den Vektor "intersection"
-                # und versetzen ihn in Z-Richtung um 0.2 Einheiten oberhalb des Zylinders.
-                text_np.setPos(intersection.x, intersection.y, intersection.z + 0.2)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-            else:
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)
-                tn.setAlign(TextNode.ACenter)
-                text_np = veh.attachNewNode(tn)
-                text_np.setPos(0, 1.2, 1.5)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-
-            self.taskMgr.add(partial(self.vehicle_order_task, veh),
-                             f"VehicleOrderTask_{veh.getPythonTag('vehicle_id')}")
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # FAHRZEUGERSTELLUNG (FFZ20-INTEGRATION)
-    # -----------------------------------
-    def create_vehicle(self, park_point=None):
-        # Erzeuge den übergeordneten Fahrzeug-Knoten
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # --------------------------
-        # Chassis erstellen (1 x 0.5 x 1.2, Farbe Rot)
-        # --------------------------
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # --------------------------
-        # Gabel (Fork) erstellen: Zwei Zähne
-        # --------------------------
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-
-        # Speichere den Gabel-Knoten als Python-Tag am Fahrzeug
-        vehicle_node.setPythonTag("fork_node", fork_node)
-
-        # --------------------------
-        # Erzeuge den grünen Referenzmarker (Gabel – grüner Punkt)
-        # --------------------------
-        ls_new = LineSegs()
-        ls_new.setThickness(2.0)
-        ls_new.setColor(1, 1, 1, 1)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_corner_global = fork_node.getPos() + left_corner_local
-        right_corner_global = fork_node.getPos() + right_corner_local
-        ls_new.moveTo(left_corner_global)
-        ls_new.drawTo(right_corner_global)
-        vehicle_node.attachNewNode(ls_new.create())
-        midpoint = (left_corner_global + right_corner_global) * 0.5
-        white_line_vec = right_corner_global - left_corner_global
-        white_line_dir = white_line_vec.normalized() if white_line_vec.length() != 0 else Vec3(0, 0, 0)
-        candidate = Vec3(-white_line_dir.getY(), white_line_dir.getX(), 0)
-        perp_direction = candidate.normalized() if candidate.length() != 0 else Vec3(0, 0, 0)
-        green_point_global = midpoint + perp_direction * 0.5
-
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        # Speichere den grünen Marker ebenfalls als Python-Tag
-        vehicle_node.setPythonTag("fork_green", green_marker_np)
-
-        # --------------------------
-        # Mast und weitere Fahrzeugteile
-        # --------------------------
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-        self.add_diagonals_to_mast(mast_node)
-        intersection = Vec3(0.5, 0.05, 1.0)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-        self.vehicle_cylinder = cylinder_node
-
-        # --------------------------
-        # Fahrzeugpositionierung am Parkpunkt
-        # --------------------------
-        if park_point is None:
-            vehicle_node.setPos(intersection.x, intersection.y, 0)
-        else:
-            vehicle_node.setPos(park_point - vehicle_node.getQuat().xform(intersection))
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        # Verwende die simulative Zeit, die bereits in update_sim_clock hochgezählt wird
-        t = self.sim_clock
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    # -----------------------------------
-    # FEHLENDE METHODEN: Paketspawning, Würfelerzeugung u.a.
-    # -----------------------------------
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Bestimme zufällig eine Abgabestation als Ziel
-        if hasattr(self, "abgabe_stations") and self.abgabe_stations:
-            target_index = random.randint(1, len(self.abgabe_stations))
-        else:
-            target_index = 1
-
-        # Erstelle den Auftrag zur Annahmestation
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def update_order_table(self):
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen die Stationsnummer.
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z.B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Berechne die Liegedauer
-            spawn_time = order.get("spawn_time", self.sim_clock)
-            dwell_time = self.sim_clock - spawn_time
-            dwell_display = f"{dwell_time:.1f}s"
-
-            # Zeige in der letzten Spalte den zugewiesenen Fahrzeugnamen an (oder "-" falls noch keiner zugeordnet wurde).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END,
-                                   values=(order_id, pickup_number, target_number, dwell_display, vehicle_display))
-        self.order_win.update()
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = 5.0  # 5 Sekunden Verzögerung zwischen Spawns
-        for station in self.annahme_stations:
-            # Wenn aktuell kein Paket an der Station ist
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                # Prüfe, ob seit der letzten Entnahme mindestens 5 Sekunden vergangen sind
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0.0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Definiere die Spalten in der gewünschten Reihenfolge
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Liegedauer", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Liegedauer", text="Liegedauer")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Liegedauer", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    def pickup_package(self, vehicle, station):
-        # Wenn bereits ein Paket vorhanden ist, dann abbrechen.
-        if vehicle.getPythonTag("package_attached"):
-            return
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            fork_node = vehicle.getPythonTag("fork_node")
-            fork_green = vehicle.getPythonTag("fork_green")
-            green_point_pos = fork_green.getPos(fork_node)
-
-            package.wrtReparentTo(fork_node)
-            package.setPos(green_point_pos.getX() + 0.5,
-                           green_point_pos.getY() - 0.5,
-                           green_point_pos.getZ() + 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    from direct.task.TaskManagerGlobal import taskMgr  # Sicherstellen, dass taskMgr verfügbar ist
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden removeCargoTask aufruft,
-            # und übergib dabei das cargo als extra Argument:
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return Task.done
-
-    def select_next_order(self, vehicle):
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        for order in waiting_orders:
-            dwell_time = self.sim_clock - order.get("spawn_time", self.sim_clock)
-            order["dwell_time"] = dwell_time
-
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        vehicle_pos = vehicle.getPos(self.render)
-
-        def distance_to_station(order):
-            station = order.get("pickup_station")
-            if station:
-                station_pos = station.getPos(self.render)
-                return (station_pos - vehicle_pos).length()
-            return float('inf')
-
-        candidates.sort(key=distance_to_station)
-        chosen_order = candidates[0]
-        chosen_order["vehicle"] = f"Fahrzeug {vehicle.getPythonTag('vehicle_id')}"
-        return chosen_order
-
-    def vehicle_order_task(self, vehicle, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-
-        # Wenn das Fahrzeug im "idle"-Zustand steht, soll es nichts tun.
-        if vehicle.getPythonTag("order_state") == "idle":
-            return task.cont
-
-        state = vehicle.getPythonTag("order_state")
-        current_order = vehicle.getPythonTag("current_order")
-
-        # ------------------ Phase 1: Translate ------------------
-        if state == "translate":
-            if current_order is None:
-                next_order = self.select_next_order(vehicle)
-                if next_order is not None:
-                    vehicle.setPythonTag("current_order", next_order)
-                    next_order["status"] = "In Bearbeitung"
-                    print(
-                        f"Auftrag {next_order['id']} wird zugewiesen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}.")
-                else:
-                    print("Kein Auftrag verfügbar – Fallback zum globalen Ziel.")
-            current_order = vehicle.getPythonTag("current_order")
-            if current_order is not None:
-                pickup_station = current_order.get("pickup_station")
-                if pickup_station in self.station_blue_dots:
-                    blue_target = self.station_blue_dots[pickup_station].getPos(self.render)
-                else:
-                    blue_target = self.blue_dot.getPos(self.render)
-            else:
-                blue_target = self.blue_dot.getPos(self.render)
-            local_mast = Vec3(0.5, 0.05, 1.0)
-            mast_global = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(local_mast)
-            target_xy = Vec2(blue_target.getX(), blue_target.getY())
-            mast_xy = Vec2(mast_global.getX(), mast_global.getY())
-            error_vector = target_xy - mast_xy
-            threshold = 0.05
-            if error_vector.length() > threshold:
-                direction = error_vector.normalized()
-                move_distance = 1.5 * dt
-                current_pos = vehicle.getPos(self.render)
-                new_pos = Vec3(current_pos.getX() + direction.getX() * move_distance,
-                               current_pos.getY() + direction.getY() * move_distance, 0)
-                vehicle.setPos(new_pos)
-            else:
-                local_offset = vehicle.getQuat(self.render).xform(local_mast)
-                exact_pos = Vec3(blue_target.getX() - local_offset.getX(),
-                                 blue_target.getY() - local_offset.getY(), 0)
-                vehicle.setPos(exact_pos)
-                vehicle.setPythonTag("order_state", "rotate")
-
-        # ------------------ Phase 2: Rotate ------------------
-        elif state == "rotate":
-            desired_angle = math.degrees(math.atan2(self.station_white_direction.getY(),
-                                                    self.station_white_direction.getX()))
-            desired_angle = (desired_angle + 180) % 360
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_angle - current_heading + 180) % 360) - 180
-            kp_heading = 0.5
-            new_heading = current_heading + kp_heading * angle_diff
-            vehicle.setH(new_heading)
-            if abs(angle_diff) < 1.0:
-                vehicle.setPythonTag("order_state", "turn_right")
-
-        # ------------------ Phase 3: Turn Right ------------------
-        elif state == "turn_right":
-            if vehicle.getPythonTag("turn_right_init") is None:
-                vehicle.setPythonTag("turn_right_init", vehicle.getH() % 360)
-                vehicle.setPythonTag("turn_right_target", (vehicle.getPythonTag("turn_right_init") + 90) % 360)
-                print("Phase 3: Initialisiert für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "Start Heading =", vehicle.getPythonTag("turn_right_init"),
-                      "Target Heading =", vehicle.getPythonTag("turn_right_target"))
-            current_heading = vehicle.getH() % 360
-            turn_right_target = vehicle.getPythonTag("turn_right_target")
-            angle_diff = ((turn_right_target - current_heading + 180) % 360) - 180
-            kp_turn = 0.5
-            turn_rate = kp_turn * angle_diff
-            new_heading = current_heading + turn_rate * dt
-            vehicle.setH(new_heading)
-            print("Phase 3: Fahrzeug", vehicle.getPythonTag("vehicle_id"), "- Aktuelles Heading =", current_heading,
-                  "Winkelabweichung =", angle_diff, "Neues Heading =", new_heading)
-            if abs(angle_diff) < 1.0:
-                print("Phase 3: Drehung abgeschlossen für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      ". Übergang in 'approach'.")
-                vehicle.setPythonTag("order_state", "approach")
-                vehicle.clearPythonTag("turn_right_init")
-                vehicle.clearPythonTag("turn_right_target")
-
-        # ------------------ Phase 4: Approach ------------------
-        elif state == "approach":
-            if current_order is not None:
-                pickup_station = current_order.get("pickup_station")
-                target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-            else:
-                target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-            current = vehicle.getPos(self.render)
-            error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-            if error_vec.length() > 0.05:
-                direction = error_vec.normalized()
-                move_distance = 1.5 * dt
-                new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                               current.getY() + direction.getY() * move_distance, target.getZ())
-                vehicle.setPos(new_pos)
-            else:
-                vehicle.setPos(target)
-                vehicle.setPythonTag("order_state", "pickup")
-
-        # ------------------ Phase 5: Pickup ------------------
-        elif state == "pickup":
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            target_z = 1.0
-            raise_speed = 0.5
-            if current_z < target_z:
-                fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-            else:
-                if current_order is None:
-                    if self.orders_queue:
-                        vehicle.setPythonTag("current_order", self.orders_queue.pop(0))
-                    else:
-                        print("Keine verfügbaren Aufträge für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                              ". Überspringe Pickup-Phase.")
-                        vehicle.setPythonTag("order_state", "drive_out")
-                        return task.cont
-                # Nur wenn noch kein Paket am Fahrzeug befestigt ist:
-                if not vehicle.getPythonTag("package_attached"):
-                    pickup_station = vehicle.getPythonTag("current_order")["pickup_station"]
-                    self.pickup_package(vehicle, pickup_station)
-                    vehicle.setPythonTag("package_attached", True)
-                # Setze drive_out_target, falls noch nicht vorhanden
-                if vehicle.getPythonTag("drive_out_target") is None:
-                    vehicle.setPythonTag("drive_out_target",
-                                         vehicle.getPos(self.render) + vehicle.getQuat(self.render).getForward() * 5.0)
-                vehicle.setPythonTag("order_state", "drive_out")
-
-        # ------------------ Phase 6: Drive Out ------------------
-        elif state == "drive_out":
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            if current_z > 0.0:
-                lower_speed = 0.5
-                fork_node.setZ(max(0.0, current_z - lower_speed * dt))
-            current_pos = vehicle.getPos(self.render)
-            drive_out_target = vehicle.getPythonTag("drive_out_target")
-            if drive_out_target is None:
-                drive_out_target = current_pos + vehicle.getQuat(self.render).getForward() * 5.0
-                vehicle.setPythonTag("drive_out_target", drive_out_target)
-            diff = drive_out_target - current_pos
-            if diff.length() > 0.1:
-                move_distance = 0.5 * dt
-                step = diff.normalized() * move_distance
-                new_pos = current_pos + step
-                new_pos.setZ(0)  # Sicherstellen, dass das Fahrzeug auf dem Boden bleibt
-                vehicle.setPos(new_pos)
-            else:
-                vehicle.setPythonTag("order_state", "to_delivery")
-                vehicle.setPythonTag("drive_out_target", None)
-
-        # ------------------ Phase 7: To Delivery ------------------
-        elif state == "to_delivery":
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current_pos = vehicle.getPos(self.render)
-            diff = blue_target - current_pos
-            threshold = 0.5
-            move_distance = 1.5 * dt
-            if move_distance > diff.length():
-                vehicle.setPos(blue_target)
-            else:
-                vehicle.setPos(current_pos + diff.normalized() * move_distance)
-            if (blue_target - vehicle.getPos(self.render)).length() <= threshold:
-                print("Phase 7 abgeschlossen: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "hat den blauen Punkt der Abgabestation erreicht.")
-                vehicle.setPythonTag("order_state", "align_delivery")
-
-        # ------------------ Phase 8: Align Delivery ------------------
-        elif state == "align_delivery":
-            desired_heading = 90.0
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_heading - current_heading + 180) % 360) - 180
-            print("Phase 8: Align Delivery | Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                  "Current Heading: {:.2f}°, Desired: {:.2f}°, Diff: {:.2f}°".format(current_heading, desired_heading,
-                                                                                     angle_diff))
-            fixed_turn_speed = 90.0
-            turn_amount = fixed_turn_speed * dt
-            if abs(angle_diff) < 1.0:
-                vehicle.setH(desired_heading)
-                print("Phase 8 abgeschlossen: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "ausgerichtet (Heading = {:.2f}°).".format(desired_heading))
-                vehicle.setPythonTag("order_state", "delivery_center")
-            else:
-                if angle_diff > 0:
-                    new_heading = current_heading + turn_amount
-                else:
-                    new_heading = current_heading - turn_amount
-                new_heading %= 360
-                vehicle.setH(new_heading)
-                print("Phase 8: Rotating - Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "New Heading set to {:.2f}°".format(new_heading))
-
-        # ------------------ Phase 9: Delivery Approach ------------------
-        elif state == "delivery_center":
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current = vehicle.getPos(self.render)
-            target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-            print("Phase 9: Zielpunkt der Abgabestation für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                  "=", target_point)
-            error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-            tolerance = 0.05
-            move_distance = 1.5 * dt
-            if error_vec.length() > tolerance:
-                direction = error_vec.normalized()
-                new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                               current.getY() + direction.getY() * move_distance, current.getZ())
-                vehicle.setPos(new_pos)
-                print("Phase 9: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "bewegt sich von", current, "nach", new_pos)
-            else:
-                vehicle.setPos(target_point)
-                print("Phase 9: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "hat den Zielpunkt erreicht.")
-                vehicle.setPythonTag("order_state", "drop")
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_fork_z = fork_node.getZ()
-            if current_fork_z < 1.0:
-                new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-                fork_node.setZ(new_fork_z)
-                print("Phase 9: Gabel wird angehoben für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "(Z =", new_fork_z, ").")
-
-        # ------------------ Phase 10: Dropoff ------------------
-        elif state == "drop":
-            if vehicle.getPythonTag("package_attached"):
-                delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-                self.drop_cargo(vehicle)
-                print("Phase 10: Paket abgesetzt für Fahrzeug", vehicle.getPythonTag("vehicle_id"))
-                vehicle.setPythonTag("package_attached", False)
-            else:
-                fork_node = vehicle.getPythonTag("fork_node")
-                current_z = fork_node.getZ()
-                if current_z > 0.0:
-                    lower_speed = 0.5
-                    new_z = max(0.0, current_z - lower_speed * dt)
-                    fork_node.setZ(new_z)
-                    print("Phase 10: Gabel wird abgesenkt für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          ", aktueller Z-Wert =", new_z)
-                else:
-                    print("Phase 10: Dropoff vollständig abgeschlossen für Fahrzeug",
-                          vehicle.getPythonTag("vehicle_id"))
-                    # Prüfe, ob Standby angefordert wurde:
-                    if vehicle.getPythonTag("standby_pending"):
-                        vehicle.setPythonTag("order_state", "return_to_garage")
-                        print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} kehrt zur Garage zurück (Standby).")
-                    else:
-                        vehicle.setPythonTag("order_state", "translate")
-                    current_order["status"] = "Abgegeben"
-                    current_order["delivered_at"] = self.sim_clock
-                    vehicle.setPythonTag("current_order", None)
-
-        # ------------------ Neue Phase: Return to Garage (Standby) ------------------
-        elif state == "return_to_garage":
-            garage_target = vehicle.getPythonTag("garage_target")
-            if garage_target is None:
-                garage_target = self.garagen_parking_points[0]
-            current_pos = vehicle.getPos(self.render)
-            diff = garage_target - current_pos
-            if diff.length() > 0.1:
-                move_distance = 1.0 * dt
-                new_pos = current_pos + diff.normalized() * move_distance
-                new_pos.setZ(0)  # Sicherstellen, dass das Fahrzeug am Boden bleibt.
-                vehicle.setPos(new_pos)
-            else:
-                # Setze das Ausgangs-Heading wieder zurück
-                if vehicle.hasPythonTag("start_heading"):
-                    vehicle.setH(vehicle.getPythonTag("start_heading"))
-                vehicle.setPythonTag("order_state", "idle")
-                vehicle.setPythonTag("standby_pending", False)
-                print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} ist in der Garage (Standby).")
-
-        # ------------------ Phase 11: Exit Station and Start Next Order ------------------
-        elif state == "phase11":
-            if vehicle.getPythonTag("last_delivery_marker") is not None:
-                target_point = vehicle.getPythonTag("last_delivery_marker")
-            else:
-                delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    target_point = self.abgabe_blue_dots[0].getPos(self.render)
-                print("Phase 11: Zielpunkt (blauer Marker) für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "=", target_point)
-                current_pos = vehicle.getPos(self.render)
-                diff = target_point - current_pos
-                if diff.length() > 0.1:
-                    move_distance = 0.5 * dt
-                    step = diff.normalized() * move_distance
-                    vehicle.setPos(current_pos + step)
-                    print("Phase 11: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          "fährt aus der Station, neue Position =", current_pos + step)
-                else:
-                    vehicle.setPos(target_point)
-                    print("Phase 11: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          "hat den blauen Marker erreicht. Nächster Auftrag wird gestartet.")
-                    vehicle.setPythonTag("order_state", "next_order")
-
-        return task.cont
-
-    # Neue Methode: Kontrollfenster zur Fahrzeugsteuerung
-    def show_vehicle_control(self):
-        # Falls das Fenster bereits existiert, bringe es einfach in den Vordergrund,
-        # ohne die Radiobuttons neu zu initialisieren.
-        if hasattr(self, "control_win") and self.control_win.winfo_exists():
-            self.control_win.deiconify()
-            self.control_win.lift()
-            self.control_win.focus_force()
-            return
-
-        # Erstelle das Kontrollfenster als Toplevel des persistenten tk_root.
-        self.control_win = tk.Toplevel(self.tk_root)
-        self.control_win.title("Fahrzeugsteuerung")
-        # Beim Schließen soll das Fenster nicht zerstört, sondern nur versteckt werden
-        self.control_win.protocol("WM_DELETE_WINDOW", self.control_win.withdraw)
-        # Sorge dafür, dass das Fenster initial über allem liegt
-        self.control_win.attributes("-topmost", True)
-        self.control_win.after(100, lambda: self.control_win.attributes("-topmost", False))
-
-        # Erzeuge das Dictionary für die StringVar-Zuordnungen für die Fahrzeuge.
-        self.vehicle_state_vars = {}
-        row = 0
-        for veh in self.garage_vehicles:
-            frame = tk.Frame(self.control_win)
-            frame.grid(row=row, column=0, sticky="w", padx=5, pady=2)
-            vid = veh.getPythonTag("vehicle_id")
-            label = tk.Label(frame, text=f"Fahrzeug {vid}")
-            label.pack(side=tk.LEFT)
-            # Initialisiere die Radiobutton-Variable anhand des aktuellen Fahrzeugzustandes.
-            state = veh.getPythonTag("order_state")
-            if state is None:
-                state = "idle"
-            var = tk.StringVar(value=state)
-            self.vehicle_state_vars[veh] = var
-            rb_active = tk.Radiobutton(frame, text="Aufträge bearbeiten", variable=var, value="translate")
-            rb_active.pack(side=tk.LEFT)
-            rb_standby = tk.Radiobutton(frame, text="Standby", variable=var, value="idle")
-            rb_standby.pack(side=tk.LEFT)
-            row += 1
-        update_btn = tk.Button(self.control_win, text="Übernehmen", command=self.update_vehicle_control)
-        update_btn.grid(row=row, column=0, pady=5)
-
-    def update_vehicle_control(self):
-        for veh, var in self.vehicle_state_vars.items():
-            new_state = var.get()
-            if new_state == "idle" and veh.getPythonTag("current_order") is not None:
-                veh.setPythonTag("standby_pending", True)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Standby angefordert (Auftrag wird fortgesetzt).")
-            else:
-                veh.setPythonTag("standby_pending", False)
-                veh.setPythonTag("order_state", new_state)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Zustand auf {new_state} gesetzt.")
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: KI/KI14.py
===================================================================
diff --git a/KI/KI14.py b/KI/KI14.py
deleted file mode 100644
--- a/KI/KI14.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,427 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode
-)
-
-# Wir nutzen weiterhin globalClock für dt, aber nicht für die Zeitmessung in der Simulation.
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Die Basisgeschwindigkeit ändert sich nicht: 1.5 m/s.
-        self.base_speed = 1.5
-        # Der Multiplikator (speed_factor) regelt ausschließlich den Zeitablauf.
-        # Startwert 1.0 entspricht normaler Simulation.
-        self.speed_factor = 1.0
-        # Wir definieren keinen "effektiven" Speed direkt – die physikalische Bewegung
-        # wird in move_vehicle_to frame-by-frame dynamisch berechnet.
-
-        # Eigene Simulationstime (in sim-Sekunden) – startet bei 0
-        self.sim_time = 0.0
-
-        # Speichere außerdem den Zeitpunkt, zu dem die Simulation (real) gestartet wurde,
-        # um z. B. den Start von Fahrzeug 2 relativ zur Simulation zu steuern.
-        self.sim_start_real = globalClock.getFrameTime()
-
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erzeuge 5 Annahme-(rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeuge initialisieren – zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}  # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}  # Fahrzeug -> aktuell reservierte Abgabestation
-
-        # Fahrzeug 1: startet sofort
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-
-        # Fahrzeug 2: startet später (genauer: 8 simulierte Sekunden später)
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-
-        # Globaler Pool für Pickup-Pakete: Wir speichern den Zeitpunkt (sim_time) des Spawns.
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_time
-
-        # Reservierungssets für Stationen:
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider zur Anpassung des Multiplikators (nur für Zeiten!):
-        # Wertebereich: 0.1 bis 10.0, Startwert: 1.0.
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        # Das Label gibt den aktuellen Multiplikator und die „effektiven“ Parameter aus.
-        # In unserem Fall bleibt die Basisgeschwindigkeit konstant – nur die Zeitparameter (Wartezeiten)
-        # werden skaliert.
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Starte einen Task, der den eigenen Simulationstime (self.sim_time) frame-by-frame aktualisiert.
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-
-        # Tasks, die kontinuierlich agieren, nutzen nun self.sim_time.
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_vehicle2_start, "CheckVehicle2StartTask")
-
-        # Fahrzeug 1 startet den Liefervorgang sofort.
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-        # Fahrzeug 2 wird über den Task gestartet, sobald 8 simulierte Sekunden vergangen sind.
-
-    def update_sim_clock(self, task):
-        """
-        Aktualisiert in jedem Frame die Simulationstime (self.sim_time).
-        Diese wird um (dt * speed_factor) erhöht – so läuft die Simulation
-        beim Erhöhen des Faktors schneller (alle Zeiten verkürzen sich in Realzeit).
-        """
-        dt = globalClock.getDt()
-        self.sim_time += dt * self.speed_factor
-        return Task.cont
-
-    def check_slider_task(self, task):
-        """
-        Liest einmal pro Echtsekunde den Slider aus und aktualisiert so den Multiplikator.
-        Bereits laufende Tasks nutzen den aktuellen self.sim_time, sodass die Simulation
-        insgesamt beschleunigt oder verlangsamt wird.
-        """
-        self.update_simulation_speed()
-        return Task.again
-
-    def check_vehicle2_start(self, task):
-        """
-        Überprüft laufend, ob 8 simulierte Sekunden seit Start der Simulation vergangen sind.
-        Sobald das der Fall ist, wird Fahrzeug 2 gestartet (falls es noch nicht gestartet wurde).
-        """
-        if (self.sim_time - 0) >= 8.0 and not hasattr(self, 'vehicle2_started'):
-            self.vehicle2_started = True
-            self.start_delivery_cycle(self.vehicles[1], self.vehicles[1].getPos())
-            return Task.done
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        """
-        Wird aufgerufen, wenn der Slider bewegt wird.
-        Der Multiplikator (speed_factor) wird aktualisiert – dabei werden
-        keine anderen berechneten Werte direkt modifiziert, sondern nur die Zeitabläufe (über self.sim_time).
-        """
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        """
-        Überprüft kontinuierlich die Annahmestationen.
-        Wenn an einer Station kein Paket vorhanden ist und
-        (self.sim_time - last_removed) >= 1 (Basiswartezeit),
-        wird ein neues Paket erzeugt.
-        """
-        spawn_delay = 1  # 1 simulierte Sekunde
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_time - self.last_removed.get(station, self.sim_time)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        """
-        Erzeugt an der angegebenen Annahmestation ein Paket (als Würfel),
-        setzt seinen Spawnzeitpunkt (self.sim_time) und hängt einen Timer-Text an.
-        """
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = self.sim_time
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        """
-        Aktualisiert in jedem Frame den angezeigten Timer der Pakete.
-        Es wird die simulierte verstrichene Zeit berechnet:
-            elapsed = self.sim_time - spawn_time.
-        """
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_time - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        """
-        Bewegt das Fahrzeug frame-by-frame dynamisch zum Ziel.
-        Dabei wird in jedem Frame der Schritt berechnet als:
-          step = (base_speed * speed_factor) * dt.
-        Dadurch werden Änderungen am Regler (speed_factor) sofort wirksam.
-        """
-
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            direction = target - current_pos
-            distance = direction.length()
-            # Effektive Geschwindigkeit = base_speed * speed_factor
-            step = (self.base_speed * self.speed_factor) * dt
-            if distance <= step:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-            else:
-                vehicle.setPos(current_pos + direction.normalized() * step)
-                return Task.cont
-
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        """
-        Führt für ein Fahrzeug den Liefervorgang aus:
-          1. Wählt (aus dem globalen Pool) das Paket mit der höchsten simulierten Wartezeit,
-             sofern dessen Pickup-Station verfügbar ist.
-          2. Reserviert die Pickup-Station und bewegt das Fahrzeug (mit move_vehicle_to) dorthin.
-          3. Anschließend wählt es zufällig eine freie Dropoff-Station, reserviert sie und fährt dorthin.
-          4. Sobald das Fahrzeug dort ist, wird nach einer Wartezeit von 1 simulierten Sekunde das Paket abgesetzt.
-          5. Danach startet der nächste Zyklus.
-        """
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-
-        current_time = self.sim_time
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        pickup_pos = pickup_station.getPos()
-
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.occupied_pickups.remove(pickup_station)
-
-            def wait_for_dropoff(task):
-                if any(ds not in self.occupied_dropoffs for ds in self.abgabe_stationen):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_dropoff, f"WaitDropoff_{id(vehicle)}")
-            return
-
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_pos = dropoff_station.getPos()
-
-        # Starte die Bewegung zur Pickup-Station.
-        self.move_vehicle_to(vehicle, pickup_pos, lambda: self.after_pickup(vehicle, pickup_station, dropoff_pos))
-
-    def after_pickup(self, vehicle, pickup_station, dropoff_pos):
-        """
-        Wird aufgerufen, sobald das Fahrzeug die Pickup-Station erreicht hat.
-        Das Paket wird übernommen, anschließend bewegt sich das Fahrzeug zur Dropoff-Station.
-        """
-        self.pickup_package(vehicle, pickup_station)
-        self.move_vehicle_to(vehicle, dropoff_pos, lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        """
-        Nachdem das Fahrzeug die Dropoff-Station erreicht hat, wird das Paket abgesetzt.
-        Nach einer Wartezeit von 1 simulierten Sekunde wird der aktuelle Vorgang abgeschlossen.
-        """
-        self.drop_cargo(vehicle)
-        start_wait = self.sim_time
-
-        def wait_task(task):
-            if self.sim_time - start_wait >= 1:
-                self.finish_cycle(vehicle)
-                return Task.done
-            return Task.cont
-
-        self.taskMgr.add(wait_task, f"WaitAfterDrop_{id(vehicle)}")
-
-    def finish_cycle(self, vehicle):
-        """
-        Entfernt das transportierte Paket und startet den nächsten Liefervorgang für das Fahrzeug.
-        """
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        """
-        Das Fahrzeug übernimmt an der angegebenen Pickup-Station das Paket.
-        Dabei wird der zugehörige Timer entfernt, der Eintrag gelöscht, und die Reservierung aufgehoben.
-        """
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_time
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        """
-        Das vom Fahrzeug transportierte Paket wird an der Dropoff-Station (Z+1) abgesetzt.
-        """
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-
-    def remove_cargo(self, vehicle):
-        """
-        Entfernt das aktuell transportierte Paket und gibt die Dropoff-Reservierung frei.
-        """
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        if dropoff_station in self.occupied_dropoffs:
-            self.occupied_dropoffs.remove(dropoff_station)
-            del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        """
-        Erzeugt ein Bodenraster als Referenz.
-        """
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        """
-        Erzeugt ein Wireframe-Box-Modell als Station.
-        """
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        """
-        Erzeugt einen Würfel (als Paket), der etwas über dem Boden platziert wird.
-        """
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        """
-        Einfache Beleuchtung mittels Ambient- und Richtungslicht.
-        """
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-# Starte die Simulation
-app = LagerSimulation()
-app.run()
Index: KI/KI8.py
===================================================================
diff --git a/KI/KI8.py b/KI/KI8.py
deleted file mode 100644
--- a/KI/KI8.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,292 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode
-)
-# Globaler Clock über ClockObject
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.interval.IntervalGlobal import Sequence, Wait, LerpPosInterval, Func
-from direct.task import Task
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Fahrzeuggeschwindigkeit: 1.5 m/s * 5 = 7.5 m/s
-        self.speed = 1.5 * 5
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie (gleicher Abstand)
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            # Annahmestation links (rot) bei x = -9
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            # Abgabestation rechts (grün) bei x = 9
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeuge initialisieren – zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}             # Dictionary: Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}   # Dictionary: Fahrzeug -> aktuell gewählte Abgabestation
-
-        # Fahrzeug 1
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-
-        # Fahrzeug 2 – leicht versetzt, damit die Modelle nicht exakt übereinander liegen.
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)  # y-Offset von 2 Einheiten
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-
-        # Globaler Pool für alle Pickup-Pakete:
-        # Schlüssel = Annahmestation, Wert = (Paket, Spawnzeit, Timer-TextNode)
-        self.pickup_packages = {}
-        # Für jede Station wird der Zeitpunkt des letzten Entfernens initialisiert.
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = globalClock.getFrameTime()
-
-        # Set für aktuell reservierte Abgabestationen.
-        self.occupied_dropoffs = set()
-
-        # Starte einen Task, der regelmäßig prüft, ob an einer Annahmestation ein Paket fehlen soll.
-        # Hier wurde spawn_delay von 5 auf 1 Sekunde gesetzt:
-        self.taskMgr.doMethodLater(1, self.check_and_spawn_packages, "CheckSpawnPackages")
-        # Task zum Aktualisieren der Timer-Anzeige über den Paketen.
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-
-        # Starte für Fahrzeug 1 den Auftrag sofort...
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-        # ... und für Fahrzeug 2 8 Sekunden später.
-        self.taskMgr.doMethodLater(8, lambda t, veh=self.vehicles[1]:
-                                     self.start_delivery_cycle(veh, veh.getPos()),
-                                     "StartVehicle2")
-
-    def check_and_spawn_packages(self, task):
-        """
-        Überprüft alle Annahmestationen:
-          Falls an einer Station noch kein Paket vorhanden ist und seit dem letzten
-          Entfernen mindestens 1 Sekunde vergangen sind, wird ein Paket erzeugt.
-        """
-        spawn_delay = 1  # 1 Sekunde Wartezeit pro Station
-        current_time = globalClock.getFrameTime()
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if current_time - self.last_removed.get(station, current_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.again
-
-    def spawn_package_at_station(self, station):
-        """
-        Erzeugt ein Paket (als Würfel) an der gegebenen Annahmestation.
-        Das Paket wird mit einem Z-Offset von +1 positioniert. Zusätzlich wird über dem Paket
-        ein TextNode angehängt, der später die Wartezeit anzeigt.
-        """
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = globalClock.getFrameTime()
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        """
-        Aktualisiert in jedem Frame den Text (Wartezeit) aller wartenden Pakete.
-        """
-        current_time = globalClock.getFrameTime()
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = current_time - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        """
-        Liefert für ein einzelnes Fahrzeug folgenden Ablauf:
-          1. Aus dem globalen Pool der Pickup-Pakete wählt das Fahrzeug das Paket mit der
-             höchsten Wartezeit (also das älteste Paket, gemessen an der Spawnzeit).
-          2. Das Fahrzeug fährt zur entsprechenden Annahmestation, nimmt das Paket auf,
-             wählt zufällig eine Abgabestation und liefert das Paket dort ab.
-          3. Nach 1 Sekunde Wartezeit wird das Paket entfernt.
-          4. Der nächste Zyklus startet von der aktuellen Position des Fahrzeugs.
-        """
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-
-        if not self.pickup_packages:
-            self.taskMgr.doMethodLater(1,
-                                       lambda t: self.start_delivery_cycle(vehicle, vehicle.getPos()),
-                                       "RetryCycle_" + str(id(vehicle)))
-            return
-
-        current_time = globalClock.getFrameTime()
-        # Jedes Fahrzeug wählt das Paket mit der höchsten Wartezeit aus dem globalen Pool.
-        pickup_station = max(self.pickup_packages, key=lambda s: current_time - self.pickup_packages[s][1])
-        pickup_pos = pickup_station.getPos()
-        seg1_duration = (pickup_pos - start_pos).length() / self.speed
-
-        # Wähle als Abgabestation nur aus jenen, die noch nicht reserviert sind.
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.taskMgr.doMethodLater(1,
-                                       lambda t: self.start_delivery_cycle(vehicle, vehicle.getPos()),
-                                       "RetryCycle_" + str(id(vehicle)))
-            return
-
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-
-        dropoff_pos = dropoff_station.getPos()
-        seg2_duration = (dropoff_pos - pickup_pos).length() / self.speed
-
-        cycle = Sequence(
-            LerpPosInterval(vehicle, duration=seg1_duration, pos=pickup_pos),
-            Func(self.pickup_package, vehicle, pickup_station),
-            LerpPosInterval(vehicle, duration=seg2_duration, pos=dropoff_pos),
-            Func(self.drop_cargo, vehicle),
-            Wait(1),
-            Func(self.remove_cargo, vehicle),
-            Func(self.start_delivery_cycle, vehicle, vehicle.getPos())
-        )
-        cycle.start()
-
-    def pickup_package(self, vehicle, station):
-        """
-        Das Fahrzeug übernimmt an der gegebenen Annahmestation das Paket.
-        Dabei wird der Timer-Text entfernt, der Eintrag aus dem globalen Pool gelöscht,
-        und der Zeitpunkt der Entfernung (last_removed) aktualisiert.
-        """
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = globalClock.getFrameTime()
-
-    def drop_cargo(self, vehicle):
-        """
-        Das vom Fahrzeug transportierte Paket wird exakt auf den Würfel der
-        (zufällig ausgewählten) Abgabestation (mit einem Z-Offset von +1) abgesetzt.
-        """
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-
-    def remove_cargo(self, vehicle):
-        """
-        Entfernt das aktuell transportierte Paket des Fahrzeugs aus der Szene und gibt
-        die reservierte Abgabestation wieder frei.
-        """
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        if dropoff_station in self.occupied_dropoffs:
-            self.occupied_dropoffs.remove(dropoff_station)
-            del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        """
-        Erzeugt ein Wireframe-Box-Modell als Station.
-        """
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        """
-        Erzeugt einen Würfel (als Paket), der etwas über dem Boden platziert wird.
-        """
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        """
-        Einfaches Beleuchtungssetup: Ambient- und Richtungslicht.
-        """
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-# Starte die Simulation
-app = LagerSimulation()
-app.run()
Index: KI/KI15.py
===================================================================
diff --git a/KI/KI15.py b/KI/KI15.py
deleted file mode 100644
--- a/KI/KI15.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,364 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode
-)
-
-# Wir nutzen globalClock für dt
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit bleibt konstant: 1.5 m/s.
-        self.base_speed = 1.5
-        # Der Multiplikator (speed_factor) steuert den Zeitskalierungsfaktor.
-        # Startwert 1.0 => normale Simulation.
-        self.speed_factor = 1.0
-
-        # Eigener Simulationszeitticker (in simulierten Sekunden)
-        self.sim_clock = 0.0
-        # Zähler der abgegebenen Pakete
-        self.delivered_packages = 0
-
-        # Zeitpunkt des Simulationsstart (reale Zeit)
-        self.sim_start_real = globalClock.getFrameTime()
-
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeuge initialisieren – zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}  # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}  # Fahrzeug -> aktuell reservierte Abgabestation
-
-        # Fahrzeug 1: startet sofort
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-
-        # Fahrzeug 2: startet 8 simulierte Sekunden später
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)  # y-Offset von 2 Einheiten
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-
-        # Globaler Pool für Pickup-Pakete und Zeitstempel (in simulierten Sekunden)
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider zur Anpassung des Multiplikators (Zeitskalierung)
-        # Wertebereich: 0.1 bis 10, Startwert: 1.0
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Info-Anzeige rechts: Laufzeit der Simulation und Summe abgegebener Pakete
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tasks:
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_vehicle2_start, "CheckVehicle2StartTask")
-
-        # Fahrzeug 1 startet den Liefervorgang sofort
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-        # Fahrzeug 2 startet, sobald 8 simulierte Sekunden erreicht sind (über Task)
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        # Erhöhe die interne Simulationszeit um dt * speed_factor.
-        # Höherer Faktor => Simulation läuft schneller (mehr simulierte Sekunden pro realer Sekunde)
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        self.info_label['text'] = f"Laufzeit: {self.sim_clock:.1f} s\nAbgegebene Pakete: {self.delivered_packages}"
-        return Task.cont
-
-    def sim_time(self, t):
-        """
-        Skalierung eines Basiszeitwerts t (in Sekunden) anhand des Multiplikators.
-        Wir verwenden hier die Formel: t / speed_factor.
-        Dadurch wird bei einem kleineren Faktor (z. B. 0.1) t größer (Simulation wird verlangsamt),
-        und bei einem höheren Faktor (z. B. 10) t kleiner (Simulation beschleunigt).
-        """
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def check_vehicle2_start(self, task):
-        """
-        Überprüft kontinuierlich, ob 8 simulierte Sekunden vergangen sind.
-        Sobald self.sim_clock >= 8, wird Fahrzeug 2 gestartet.
-        """
-        if self.sim_clock >= 8.0 and not hasattr(self, 'vehicle2_started'):
-            self.vehicle2_started = True
-            self.start_delivery_cycle(self.vehicles[1], self.vehicles[1].getPos())
-            return Task.done
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        # Basiswartezeit von 1 simulierten Sekunde:
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            direction = target - current_pos
-            distance = direction.length()
-            # Effektiver Schritt = (base_speed * speed_factor) * dt.
-            # Höherer Multiplikator => Fahrzeuge bewegen sich in realer Zeit schneller.
-            step = (self.base_speed * self.speed_factor) * dt
-            if distance <= step:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-            else:
-                vehicle.setPos(current_pos + direction.normalized() * step)
-                return Task.cont
-
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        pickup_pos = pickup_station.getPos()
-
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.occupied_pickups.remove(pickup_station)
-
-            def wait_for_dropoff(task):
-                if any(ds not in self.occupied_dropoffs for ds in self.abgabe_stationen):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_dropoff, f"WaitDropoff_{id(vehicle)}")
-            return
-
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_pos = dropoff_station.getPos()
-
-        self.move_vehicle_to(vehicle, pickup_pos, lambda: self.after_pickup(vehicle, pickup_station, dropoff_pos))
-
-    def after_pickup(self, vehicle, pickup_station, dropoff_pos):
-        self.pickup_package(vehicle, pickup_station)
-        self.move_vehicle_to(vehicle, dropoff_pos, lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        self.drop_cargo(vehicle)
-        start_wait = self.sim_clock
-
-        def wait_task(task):
-            if self.sim_clock - start_wait >= self.sim_time(1):
-                self.finish_cycle(vehicle)
-                return Task.done
-            return Task.cont
-
-        self.taskMgr.add(wait_task, f"WaitAfterDrop_{id(vehicle)}")
-
-    def finish_cycle(self, vehicle):
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        if dropoff_station in self.occupied_dropoffs:
-            self.occupied_dropoffs.remove(dropoff_station)
-            del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
-
Index: KI/KI38.py
===================================================================
diff --git a/KI/KI38.py b/KI/KI38.py
deleted file mode 100644
--- a/KI/KI38.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,662 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Matplotlib zum Plotten importieren
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs,
-    CardMaker
-)
-
-# Wir nutzen globalClock für dt.
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit & Zeitskalierungsfaktor
-        self.base_speed = 1.5  # Maximale Geschwindigkeit in m/s
-        self.speed_factor = 1.0
-
-        # Neue Parameter: Beschleunigung und Bremsverzögerung (Simulationseinheiten)
-        self.acceleration = 2.5  # m/s²
-        self.braking_deceleration = -2.5  # m/s² (negativ)
-
-        # Simulationszeitticker & Statistik
-        self.sim_clock = 0.0
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        self.sim_start_real = globalClock.getFrameTime()
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Zeichne für jede Annahmestation den Align-Punkt (2 m in positive X-Richtung)
-        for station in self.annahme_stationen:
-            station_pos = station.getPos()
-            ls_pickup = LineSegs()
-            ls_pickup.setThickness(3.0)
-            ls_pickup.setColor(LColor(1, 1, 1, 1))
-            ls_pickup.moveTo(station_pos)
-            ls_pickup.drawTo(station_pos + Vec3(2, 0, 0))
-            self.render.attachNewNode(ls_pickup.create())
-
-        # Zeichne für jede Abgabestation den Align-Punkt (2 m in negative X-Richtung)
-        for station in self.abgabe_stationen:
-            station_pos = station.getPos()
-            ls_dropoff = LineSegs()
-            ls_dropoff.setThickness(3.0)
-            ls_dropoff.setColor(LColor(1, 1, 1, 1))
-            ls_dropoff.moveTo(station_pos)
-            ls_dropoff.drawTo(station_pos + Vec3(-2, 0, 0))
-            self.render.attachNewNode(ls_dropoff.create())
-
-        # --- Anfahrstationen (Startstationen) für die Fahrzeuge ---
-        # Diese Stationen sollen bei Y = 15 nebeneinander mit 4 Meter Abstand in X-Richtung liegen.
-        self.anfahrstationen = []
-        num_departure = 2  # Zu Beginn nur 2 Fahrzeuge
-        spacing_departure = 4.0
-        start_x = -spacing_departure * (num_departure - 1) / 2
-        for i in range(num_departure):
-            pos = Vec3(start_x + i * spacing_departure, 15, 0)
-            station = self.erzeuge_gitterbox(pos.getX(), pos.getY(), pos.getZ(), LColor(0.8, 0.8, 0, 1))
-            self.anfahrstationen.append(station)
-
-        # Fahrzeuge erstellen, jeweils eines pro Anfahrstation (insgesamt 2 Fahrzeuge)
-        self.vehicles = []
-        self.cargos = {}  # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}  # Fahrzeug -> zugewiesene Dropoff-Station
-        for i, start_station in enumerate(self.anfahrstationen):
-            vehicle = self.loader.loadModel("models/box")
-            # Änderung: Fahrzeuge doppelt so lang (x-Achse verdoppelt)
-            vehicle.setScale(2, 1, 0.5)
-            if i % 2 == 0:
-                vehicle.setColor(LColor(0, 0, 1, 1))
-            else:
-                vehicle.setColor(LColor(0, 0, 0.8, 1))
-            vehicle.setPos(start_station.getPos())
-            vehicle.reparentTo(self.render)
-            # Initialisiere die aktuelle Geschwindigkeit
-            vehicle.setPythonTag("current_speed", 0.0)
-            # Beim Start wird die Phase "pickup" gesetzt
-            vehicle.setPythonTag("phase", "pickup")
-            self.add_center_marker(vehicle)
-            self.add_offset_circle(vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-            self.vehicles.append(vehicle)
-
-        # Reste der Pick-up-/Drop-off-Logik
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Erfassung von Daten für Graphen (einmal pro Simulationssekunde)
-        self.graph_data = []
-        self.taskMgr.doMethodLater(1, self.record_graph_data, "RecordGraphDataTask")
-
-        # Graphen öffnen per Taste "G" (nach Schließen wieder möglich)
-        self.graph_opened = False
-        self.accept("g", self.open_graph)
-
-        # Zoom-Funktionalität: Mit Mausrad hereinz- bzw. herauszoomen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_lidar_status, "UpdateLidarStatusTask")
-
-        # Liefervorgang starten (Pickup-Phase) für jedes Fahrzeug mit gestaggertem Start
-        for i, vehicle in enumerate(self.vehicles):
-            self.taskMgr.doMethodLater(i * 0.5,
-                                       lambda task, v=vehicle: self.start_delivery_cycle(v, v.getPos()),
-                                       f"StartDeliveryCycleTask_{i}"
-                                       )
-
-    def zoom_in(self):
-        # Hereinzoomen: Field-of-View (FOV) verkleinern (nicht unter 10°)
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        # Herauszoomen: FOV vergrößern (nicht über 100°)
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.setTitle("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def record_graph_data(self, task):
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0
-        self.graph_data.append((self.sim_clock, delivered_per_minute, avg_dwell_time))
-        return Task.again
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def add_offset_circle(self, vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5, num_segments=32):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        for i in range(num_segments + 1):
-            angle = 2 * math.pi * i / num_segments
-            x = circle_radius * math.cos(angle)
-            y = circle_radius * math.sin(angle)
-            if i == 0:
-                ls.moveTo(x, y, 0)
-            else:
-                ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        circle_np = vehicle.attachNewNode(circle_geom)
-        circle_np.setPos(offset)
-        vehicle.setPythonTag("lidar_circle", circle_np)
-
-    def draw_coordinate_axes(self, axis_length=5):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(1, 0, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        ls.setColor(0, 1, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        ls.setColor(0, 0, 1, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), (1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), (0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), (0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def update_lidar_status(self, task):
-        sensor_threshold = 3.0
-        for vehicle in self.vehicles:
-            pos = vehicle.getPos(self.render)
-            total_avoidance = Vec3(0, 0, 0)
-            # Standardmäßig volle Geschwindigkeit
-            multiplier = 1.0
-            phase = vehicle.getPythonTag("phase") if vehicle.hasPythonTag("phase") else "pickup"
-            # Dynamische Hindernisse: Andere Fahrzeuge
-            for other in self.vehicles:
-                if other is vehicle:
-                    continue
-                pos_other = other.getPos(self.render)
-                diff = pos - pos_other
-                d = diff.length()
-                if d < sensor_threshold:
-                    other_phase = other.getPythonTag("phase") if other.hasPythonTag("phase") else "pickup"
-                    # Priorität: Falls ein Fahrzeug in Pickup einem in Dropoff gegenübersteht
-                    if phase == "pickup" and other_phase == "dropoff":
-                        candidate = 0.1
-                        avoidance_weight = 2.0
-                    # Falls beide Fahrzeuge in Dropoff sind, entscheidet der Abstand zur Dropoff-Station
-                    elif phase == "dropoff" and other_phase == "dropoff":
-                        my_dropoff = self.current_dropoffs.get(vehicle)
-                        other_dropoff = self.current_dropoffs.get(other)
-                        if my_dropoff and other_dropoff:
-                            my_distance = (pos - my_dropoff.getPos()).length()
-                            other_distance = (pos_other - other_dropoff.getPos()).length()
-                            if my_distance > other_distance:
-                                candidate = 0.1
-                                avoidance_weight = 2.0
-                            else:
-                                candidate = 1.0
-                                avoidance_weight = 1.0
-                        else:
-                            candidate = 1.0
-                            avoidance_weight = 1.0
-                    else:
-                        candidate = 1.0
-                        avoidance_weight = 1.0
-                    multiplier = min(multiplier, candidate)
-                    if d > 0:
-                        total_avoidance += diff.normalized() * (sensor_threshold - d) * avoidance_weight
-
-            # Statische Hindernisse (Annahme-, Abgabe- und Anfahrstationen)
-            static_obstacles = self.annahme_stationen + self.abgabe_stationen + self.anfahrstationen
-            for obst in static_obstacles:
-                pos_obst = obst.getPos(self.render)
-                diff = pos - pos_obst
-                d = diff.length()
-                if d < sensor_threshold:
-                    candidate = 0.1
-                    avoidance_weight = 2.0
-                    multiplier = min(multiplier, candidate)
-                    if d > 0:
-                        total_avoidance += diff.normalized() * (sensor_threshold - d) * avoidance_weight
-
-            vehicle.setPythonTag("speed_multiplier", multiplier)
-            vehicle.setPythonTag("avoidance", total_avoidance)
-            lidar_circle = vehicle.getPythonTag("lidar_circle")
-            if lidar_circle:
-                if multiplier < 1.0 or total_avoidance.length() > 0.001:
-                    lidar_circle.setColor(LColor(1, 0, 0, 1))
-                else:
-                    lidar_circle.setColor(LColor(0, 1, 0, 1))
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-        current_wait_text = (
-            f"Liegedauer (aktuell): {current_max_wait_time:.1f}s"
-            if current_max_wait_time > 0 else "Kein Paket an Annahmestation"
-        )
-        maximal_wait_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted_time}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-            f"{current_wait_text}\n"
-            f"{maximal_wait_text}\n"
-            f"Liegedauer (Durchschnitt): {avg_dwell_time:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(
-            station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1)
-        )
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        def move_task(task):
-            dt = globalClock.getDt()
-            # Nutze sim_dt als simulierte Zeit (dt * Speed Factor)
-            sim_dt = dt * self.speed_factor
-            current_pos = vehicle.getPos()
-            to_target = target - current_pos
-            distance = to_target.length()
-
-            # Geschwindigkeitsbegrenzung anhand des aktuellen avoidance multipliers
-            multiplier = vehicle.getPythonTag("speed_multiplier") if vehicle.hasPythonTag("speed_multiplier") else 1.0
-            effective_max_speed = self.base_speed * multiplier  # in m/s im Simulationszeitmaßstab
-
-            current_speed = vehicle.getPythonTag("current_speed") if vehicle.hasPythonTag("current_speed") else 0.0
-
-            # Berechne den notwendigen Bremsweg: v² / (2 * |a|)
-            braking_distance = (current_speed * current_speed) / (
-                        2 * abs(self.braking_deceleration)) if current_speed > 0 else 0
-
-            if distance <= braking_distance:
-                # Bremsvorgang
-                new_speed = current_speed + self.braking_deceleration * sim_dt
-                new_speed = max(new_speed, 0.0)
-            else:
-                # Beschleunigen bis zur maximalen effektiven Geschwindigkeit
-                new_speed = current_speed + self.acceleration * sim_dt
-                new_speed = min(new_speed, effective_max_speed)
-
-            step_distance = new_speed * sim_dt
-
-            if distance <= step_distance:
-                vehicle.setPos(target)
-                vehicle.setPythonTag("current_speed", 0.0)
-                on_complete()
-                return Task.done
-
-            avoidance = vehicle.getPythonTag("avoidance") if vehicle.hasPythonTag("avoidance") else Vec3(0, 0, 0)
-            if avoidance.length() > 0.001:
-                combined = to_target.normalized() + avoidance.normalized() * 0.5
-                if combined.length() > 0.001:
-                    combined.normalize()
-                else:
-                    combined = to_target.normalized()
-                new_direction = combined
-            else:
-                new_direction = to_target.normalized()
-
-            new_pos = current_pos + new_direction * step_distance
-            vehicle.setPos(new_pos)
-            vehicle.setPythonTag("current_speed", new_speed)
-            return Task.cont
-
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        # Beginn eines neuen Auftrags: Phase "pickup" und Speichern des job_start-Zeitpunkts
-        vehicle.setPythonTag("job_start", self.sim_clock)
-        vehicle.setPythonTag("phase", "pickup")
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        # Verfügbare Pickup-Stationen, die momentan nicht belegt sind
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-
-        # Kombiniertes Ranking: Wartezeit minus ein Anteil an der Entfernung
-        distance_weight = 0.5  # Anpassbar
-        pickup_station = max(available_pickups, key=lambda s: (current_time - self.pickup_packages[s][1]) - distance_weight * (s.getPos() - vehicle.getPos()).length())
-        self.occupied_pickups.add(pickup_station)
-        pickup_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        self.move_vehicle_to(vehicle, pickup_align,
-                             lambda: self.move_vehicle_to(vehicle, pickup_station.getPos(),
-                                                          lambda: self.after_pickup(vehicle, pickup_station)
-                                                          )
-                             )
-
-    def after_pickup(self, vehicle, pickup_station):
-        self.pickup_package(vehicle, pickup_station)
-        # Nach erfolgreichem Pickup Phase auf "dropoff" setzen
-        vehicle.setPythonTag("phase", "dropoff")
-        self.depart_from_pickup(vehicle, pickup_station,
-                                lambda: self.start_dropoff_phase(vehicle)
-                                )
-
-    def depart_from_pickup(self, vehicle, pickup_station, callback):
-        departure_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        departure_target = pickup_station.getPos() + Vec3(4, 0, 0)
-        self.move_vehicle_to(vehicle, departure_align,
-                             lambda: self.move_vehicle_to(vehicle, departure_target, callback)
-                             )
-
-    def start_dropoff_phase(self, vehicle):
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.start_dropoff_phase(vehicle)
-            return
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-        self.move_vehicle_to(vehicle, dropoff_align,
-                             lambda: self.move_vehicle_to(vehicle, dropoff_station.getPos(),
-                                                          lambda: self.after_dropoff(vehicle)
-                                                          )
-                             )
-
-    def after_dropoff(self, vehicle):
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        self.drop_cargo(vehicle)
-        self.remove_cargo(vehicle, remove_dropoff=True)
-        if dropoff_station is not None:
-            departure_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-            departure_target = dropoff_station.getPos() + Vec3(-4, 0, 0)
-            self.move_vehicle_to(vehicle, departure_align,
-                                 lambda: self.move_vehicle_to(vehicle, departure_target,
-                                                              lambda: self.start_delivery_cycle(vehicle, departure_target)
-                                                              )
-                                 )
-        else:
-            self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle, remove_dropoff=True):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        if remove_dropoff:
-            dropoff_station = self.current_dropoffs.get(vehicle)
-            if dropoff_station in self.occupied_dropoffs:
-                self.occupied_dropoffs.remove(dropoff_station)
-            if vehicle in self.current_dropoffs:
-                del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
-
-#Hier ist in die Fahrlogik die sequenzielle abarbeitung inkludiert. Nicht nur der Zeitfaktor, auc hder Weg spielt eine Rolle
Index: FFZ/FFZ6.py
===================================================================
diff --git a/FFZ/FFZ6.py b/FFZ/FFZ6.py
deleted file mode 100644
--- a/FFZ/FFZ6.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,289 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    CardMaker,
-    LineSegs,
-    Vec3
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import math
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte für Simulationszeit und -geschwindigkeit
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kameraeinstellungen (Ann. Fahrtrichtung entlang der Y-Achse)
-        self.cam.setPos(0, -30, 10)
-        self.cam.lookAt(0, 0, 0)
-
-        # Licht und Raster
-        self.setup_light()
-        self.create_grid(center_extent=10, cell_size=0.1)
-
-        # Fahrzeug erstellen und Referenz speichern
-        self.vehicle = self.create_vehicle()
-
-        # Slider zur Anpassung der Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Slider zur Steuerung der Forkhöhe (0 bis 1 Meter)
-        self.fork_slider = DirectSlider(
-            range=(0.0, 1.0),
-            value=0.0,
-            pageSize=0.01,
-            command=self.update_fork_height,
-            pos=(-0.7, 0, -0.85),
-            scale=0.3
-        )
-        self.fork_label = DirectLabel(
-            text="Fork Höhe: 0.00m",
-            pos=(-0.7, 0, -0.75),
-            scale=0.07
-        )
-
-        # Laufzeitanzeige
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktionalität via Mausrad
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben zum Aktualisieren der Simulationszeit, Anzeige und (falls gewünscht) Kabelbewegung
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_cable, "UpdateCableTask")
-        # update_vehicle wird hier nicht aufgerufen, da das Fahrzeug stationär bleiben soll.
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    # Aktualisiert die Höhe des gesamten Fork-Node (bewegt beide Zähne)
-    def update_fork_height(self, height=0, *args):
-        try:
-            height = float(height)
-        except ValueError:
-            height = 0.0
-        self.fork_node.setZ(height)
-        self.fork_label['text'] = f"Fork Höhe: {height:.2f}m"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def create_grid(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            x += cell_size
-
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        grid_np = self.render.attachNewNode(node)
-        grid_np.setColor(0.7, 0.7, 0.7, 1)
-        return grid_np
-
-    def setup_light(self):
-        ambient_light = AmbientLight("ambient_light")
-        ambient_light.setColor((0.5, 0.5, 0.5, 1))
-        ambient_np = self.render.attachNewNode(ambient_light)
-        self.render.setLight(ambient_np)
-
-        directional_light = DirectionalLight("directional_light")
-        directional_light.setColor((1, 1, 1, 1))
-        directional_np = self.render.attachNewNode(directional_light)
-        directional_np.setPos(10, -10, 10)
-        self.render.setLight(directional_np)
-
-    def create_vehicle(self):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Fahrmodul (Chassis) – Farbe: Rot, Dimensionen: 1x0.5x1.2
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-
-        # Gabelmodul (Fork) – Neuer Aufbau als zwei separate Zähne:
-        # Erstelle einen Eltern-Knoten für die Gabel
-        fork_node = vehicle_node.attachNewNode("fork")
-        # Positioniere den Fork-Knoten so, dass die freie Seite (global y = -1.2) genutzt wird
-        fork_node.setPos(0, -1.2, 0)
-
-        # Linker Zahn: Größe 0.2 x 1.2 x 0.2
-        left_tooth = self.create_box(0.2, 1.2, 0.2, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)  # Linker Zahn von X=0 bis X=0.2
-
-        # Rechter Zahn: Größe 0.2 x 1.2 x 0.2
-        right_tooth = self.create_box(0.2, 1.2, 0.2, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)  # Rechter Zahn von X=0.8 bis X=1.0
-
-        # Speichere den Fork-Knoten, damit update_fork_height ihn bewegen kann
-        self.fork_node = fork_node
-
-        # (Optional: Überschüssiger Overlay wurde entfernt, da die Phantasieform der Zähne bereits
-        # klar ist)
-
-        # Mast – Farbe: Dunkles Grau, Dimensionen: 1 x 0.1 x 1, platziert ab z=1.2
-        box_mast = self.create_box(1, 0.1, 1, (0.2, 0.2, 0.2, 1))
-        node_mast = vehicle_node.attachNewNode(box_mast)
-        node_mast.setTwoSided(True)
-        node_mast.setPos(0, 0.2, 1.2)
-
-        vehicle_node.setPos(-0.5, 0, 0)
-        return vehicle_node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        # Unterseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        # Oberseite
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        # Vorderseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        # Rückseite
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        # Linke Seite
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        # Rechte Seite
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def update_cable(self, task):
-        """
-        Animiert das Heben und Senken des Gabelmoduls (Kabel), sodass sich die Z-Position
-        periodisch (sinusförmig) zwischen 0 und 1 Meter ändert.
-        """
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)  # Werte zwischen 0 und 1
-        self.fork_node.setZ(new_height)
-        self.fork_label['text'] = f"Fork Höhe: {new_height:.2f}m"
-        return Task.cont
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: Grundmodell/Gm19.py
===================================================================
diff --git a/Grundmodell/Gm19.py b/Grundmodell/Gm19.py
deleted file mode 100644
--- a/Grundmodell/Gm19.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,1512 +0,0 @@
-import random
-import math
-import tkinter as tk  # Für das extra Fenster der Auftragsübersicht
-from tkinter import ttk  # Für die tabellarische Darstellung (Treeview)
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-from direct.task.TaskManagerGlobal import taskMgr
-
-
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        self.vehicle_states = {}
-
-        super().__init__()
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5  # Wird in update_vehicle genutzt
-        self.state_timer = 0.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Paketspawning an den Annahmestationen:
-        # Mapping: station (Dummy-Node) -> (Paket, Spawnzeit, Timer Node)
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-        # Neues Attribut: Verknüpfung Fahrzeug -> transportiertes Paket
-        self.cargos = {}
-
-        # NEU: Initialisiere die belegten Annahmestationen
-        self.occupied_pickups = set()  # Oder: [] für eine Liste
-
-        # Graph-Daten (Sim-Zeit, Pakete pro Minute, durchschnittliche Liegedauer)
-        self.graph_data = []
-        self.graph_opened = False
-
-        # Auftragsverwaltung: Speichere alle Aufträge (für die Anzeige) sowie in
-        # einer Queue (Liste) zur sequentiellen Abarbeitung.
-        self.orders = {}         # Für die Anzeige
-        self.orders_queue = []   # Für die Fahrzeugabwicklung (FIFO)
-        self.next_order_id = 1
-
-        # Tkinter-Fenster für Auftragsübersicht
-        self.order_win = None
-        self.order_tree = None
-
-        # Umgebung initialisieren
-        self.draw_origin()
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.create_wall()
-        self.create_annahme_stations()
-        self.create_abgabe_stations()  # Hier wird auch self.abgabe_stations angelegt.
-        self.create_garagen_stations()
-
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # Fahrzeuge in den Garagen erstellen (genau 5 Fahrzeuge)
-        self.create_garage_vehicles()
-
-        # NEU: Auftragssystem für das Testfahrzeug initialisieren
-        # Zustände: "idle", "to_pickup", "wait_pickup", "to_delivery", "deliver"
-        self.first_vehicle_order_state = "idle"
-        self.attached_package = None
-        self.current_order = None  # Der aktuell abgearbeitete Auftrag
-        self.taskMgr.add(self.vehicle_order_task, "VehicleOrderTask")
-
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-        self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-        # Weitere Initialisierungen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        self.create_garage_vehicles()
-
-    # ---------------------------
-    # SIMULATION UND UI-METHODEN
-    # ---------------------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        # dt jetzt skaliert mit der Simulationsgeschwindigkeit
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    # ---------------------------
-    # METHODEN FÜR RASTER, LICHT, MAUER, URSPRUNG
-    # ---------------------------
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # STATIONSOBJEKTE UND ZUORDNUNG
-    # -----------------------------------
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        """
-        Erzeugt die Annahmestationen und erstellt für jede Station:
-          - Einen weißen Marker zur Orientierung
-          - Einen grünen Punkt (optional)
-          - Eine weiße Linie, an deren Endpunkt ein blauer Marker als Ziel in der "Translate‑Phase" dient
-
-        Zusätzlich wird ein Dictionary self.station_blue_dots aufgebaut, in dem jedem Annahmestations‑Node
-        der zugehörige blaue Marker zugeordnet wird. Außerdem wird für die erste Station die globale Variable
-        self.station_white_direction festgelegt.
-        """
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        self.station_blue_dots = {}
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basisstation (zum Beispiel als Rahmen)
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Erzeuge den weißen Marker als Orientierung
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Erzeuge den grünen Punkt (optional)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zeichne die weiße Linie: Sie beginnt bei center + Vec3(0, 0, -0.5) und verläuft 3 Meter in X‑Richtung.
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Erzeuge den blauen Marker, der als Ziel in der Translate‑Phase dient
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            # Speichere den blauen Marker im Dictionary, sodass er später erzeugt werden kann
-            self.station_blue_dots[station_dummy] = blue_dot
-
-            # Optionale Textanzeige der Stationsnummer
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) – falls benötigt:
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-            # Für die erste Station (oder den ersten relevanten Pickup) setzen wir globale Referenzen,
-            # die in vehicle_order_task benötigt werden.
-            if i == 1:
-                self.blue_dot = blue_dot
-                self.station_green_dot = green_dot
-                # Berechne den Mittelpunkt der weißen Linie als Referenz (optional)
-                self.white_line_center = (start_line + end_line) * 0.5
-                line_vec = end_line - start_line
-                if line_vec.length() != 0:
-                    self.station_white_direction = Vec2(line_vec.getX(), line_vec.getY()).normalized()
-                else:
-                    self.station_white_direction = Vec2(1, 0)  # Fallback-Wert
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        self.abgabe_stations = []  # Liste der Abgabestationen
-        self.abgabe_blue_dots = []  # Liste zum Speichern der blauen Marker für die Abgabe
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basiskonstruktion der Abgabestation
-            node = self.create_abgabe_station(pt)
-            self.abgabe_stations.append(node)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Marker am Zentrum (weiß)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Grüner Punkt: center + Vec3(0, 0, -0.5)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Weiße Linie: Startet bei center + Vec3(0, 0, -0.5)
-            # und verläuft 3 Meter in negativer X-Richtung
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt: wird an der Endposition der Linie erzeugt
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            # Speichere den blauen Marker für spätere Navigation der Abgabestation
-            self.abgabe_blue_dots.append(blue_dot)
-
-            # Anzeige der Stationsnummer (textuell)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) auf der Station
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 3)
-        v5 = pos + Vec3(1, 0, 3)
-        v6 = pos + Vec3(1, 2, 3)
-        v7 = pos + Vec3(0, 2, 3)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 3)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        self.garagen_stations = []
-        self.garagen_parking_points = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            self.garagen_stations.append(pt)
-            # ParkpunktGarage: Verschoben um 0.5 in negativer Y-Richtung:
-            center = pt + Vec3(0.5, 0.5, 1.5)
-            ParkpunktGarage = center + Vec3(0, 0, 0.7)
-            self.garagen_parking_points.append(ParkpunktGarage)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def create_garage_vehicles(self):
-        self.garage_vehicles = []
-        for park in self.garagen_parking_points:
-            veh = self.create_vehicle(park_point=park)
-            veh.setH(veh.getH() + 180)
-            # ... (Positionierung, Marker etc.)
-            self.garage_vehicles.append(veh)
-            # Initialisiere Zustandsdaten für das Fahrzeug:
-            self.vehicle_states[veh] = {
-                "state": "idle",  # oder direkt "translate", wenn es loslegen soll
-                "current_order": None,
-                "package_attached": False,
-                # Hier kommen auch weitere fahrzeugbezogene Variablen rein, z.B.:
-                "turn_right_init": None,
-                "turn_right_target": None,
-                "drive_out_start": None,
-                "drive_out_target": None,
-                # usw.
-            }
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # FAHRZEUGERSTELLUNG (FFZ20-INTEGRATION)
-    # -----------------------------------
-    def create_vehicle(self, park_point=None):
-        # Erzeuge den übergeordneten Fahrzeug-Knoten
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # --------------------------
-        # Chassis erstellen (1 x 0.5 x 1.2, Farbe Rot)
-        # --------------------------
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # --------------------------
-        # Gabel (Fork) erstellen: Zwei Zähne
-        # --------------------------
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-
-        # Speichere den Gabel-Knoten als Python-Tag am Fahrzeug
-        vehicle_node.setPythonTag("fork_node", fork_node)
-
-        # --------------------------
-        # Erzeuge den grünen Referenzmarker (Gabel – grüner Punkt)
-        # --------------------------
-        ls_new = LineSegs()
-        ls_new.setThickness(2.0)
-        ls_new.setColor(1, 1, 1, 1)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_corner_global = fork_node.getPos() + left_corner_local
-        right_corner_global = fork_node.getPos() + right_corner_local
-        ls_new.moveTo(left_corner_global)
-        ls_new.drawTo(right_corner_global)
-        vehicle_node.attachNewNode(ls_new.create())
-        midpoint = (left_corner_global + right_corner_global) * 0.5
-        white_line_vec = right_corner_global - left_corner_global
-        white_line_dir = white_line_vec.normalized() if white_line_vec.length() != 0 else Vec3(0, 0, 0)
-        candidate = Vec3(-white_line_dir.getY(), white_line_dir.getX(), 0)
-        perp_direction = candidate.normalized() if candidate.length() != 0 else Vec3(0, 0, 0)
-        green_point_global = midpoint + perp_direction * 0.5
-
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        # Speichere den grünen Marker ebenfalls als Python-Tag
-        vehicle_node.setPythonTag("fork_green", green_marker_np)
-
-        # --------------------------
-        # Mast und weitere Fahrzeugteile
-        # --------------------------
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-        self.add_diagonals_to_mast(mast_node)
-        intersection = Vec3(0.5, 0.05, 1.0)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-        self.vehicle_cylinder = cylinder_node
-
-        # --------------------------
-        # Fahrzeugpositionierung am Parkpunkt
-        # --------------------------
-        if park_point is None:
-            vehicle_node.setPos(intersection.x, intersection.y, 0)
-        else:
-            vehicle_node.setPos(park_point - vehicle_node.getQuat().xform(intersection))
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        # Verwende die simulative Zeit, die bereits in update_sim_clock hochgezählt wird
-        t = self.sim_clock
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    # -----------------------------------
-    # FEHLENDE METHODEN: Paketspawning, Würfelerzeugung u.a.
-    # -----------------------------------
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Bestimme zufällig eine Abgabestation als Ziel
-        if hasattr(self, "abgabe_stations") and self.abgabe_stations:
-            target_index = random.randint(1, len(self.abgabe_stations))
-        else:
-            target_index = 1
-
-        # Erstelle den Auftrag zur Annahmestation
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def update_order_table(self):
-        """
-        Aktualisiert die Auftragsübersicht in der Tkinter-Tabelle und zeigt in der
-        letzten Spalte den zugewiesenen Fahrzeugnamen (oder "-" falls noch keiner zugeordnet wurde).
-        """
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen (z. B. "annahme_station_3") die Stationsnummer.
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z. B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige in der letzten Spalte den zugewiesenen Fahrzeugnamen an (oder "-" falls noch kein Fahrzeug zugewiesen ist).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END, values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = 5.0  # 5 Sekunden Verzögerung zwischen Spawns
-        for station in self.annahme_stations:
-            # Wenn aktuell kein Paket an der Station ist
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                # Prüfe, ob seit der letzten Entnahme mindestens 5 Sekunden vergangen sind
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0.0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Wir legen hier die Spalten in der gewünschten Reihenfolge an: Auftrags ID, Annahmestation, Ziel, Fahrzeug.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Hole die fahrzeugspezifischen Knoten mittels getPythonTag
-            fork_node = vehicle.getPythonTag("fork_node")
-            fork_green = vehicle.getPythonTag("fork_green")
-
-            # Hole die Position des grünen Markers relativ zum Gabelknoten
-            green_point_pos = fork_green.getPos(fork_node)
-
-            # Reparent das Paket zur Gabel des Fahrzeugs und positioniere es entsprechend
-            package.wrtReparentTo(fork_node)
-            package.setPos(
-                green_point_pos.getX() + 0.5,  # Offset in X-Richtung
-                green_point_pos.getY() - 0.5,  # Offset in Y-Richtung
-                green_point_pos.getZ() + 1  # Z-Offset, sodass das Paket oberhalb liegt
-            )
-
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    from direct.task.TaskManagerGlobal import taskMgr  # Sicherstellen, dass taskMgr verfügbar ist
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden removeCargoTask aufruft,
-            # und übergib dabei das cargo als extra Argument:
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return Task.done
-
-    def select_next_order(self):
-        """
-        Wählt den nächsten (dringendsten) Auftrag anhand folgender Kriterien:
-          - Zuerst: Auftrag mit der höchsten Liegedauer (je länger ein Paket liegt, desto dringlicher)
-          - Bei Gleichstand: Auftrag, bei dem die Entfernung zur Annahmestation des Fahrzeugs am geringsten ist.
-
-        Der ausgewählte Auftrag wird außerdem mit einer Fahrzeugzuordnung (hier "Fahrzeug 1") versehen.
-        """
-        # Filtern aller Aufträge mit dem Status "Wartend"
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        # Berechne für jeden Auftrag die Liegedauer
-        for order in waiting_orders:
-            dwell_time = self.sim_clock - order.get("spawn_time", self.sim_clock)
-            order["dwell_time"] = dwell_time
-
-        # Bestimme den maximalen Liegedauerwert
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01  # Kleine Toleranz zur Berücksichtigung von Rundungsfehlern
-
-        # Finde alle Aufträge, deren Liegedauer nahezu dem Maximum entspricht
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        # Wir nehmen als Referenz das erste Fahrzeug aus der Liste self.garage_vehicles
-        if not self.garage_vehicles:
-            return None
-        vehicle = self.garage_vehicles[0]
-        vehicle_pos = vehicle.getPos(self.render)
-
-        def distance_to_station(order):
-            station = order.get("pickup_station")
-            if station:
-                station_pos = station.getPos(self.render)
-                return (station_pos - vehicle_pos).length()
-            return float('inf')
-
-        # Sortiere die Kandidaten nach dem Abstand der Pickup-Station zum Fahrzeug
-        candidates.sort(key=distance_to_station)
-        chosen_order = candidates[0]
-        chosen_order["vehicle"] = "Fahrzeug 1"  # Hier kannst du ggf. die passende Fahrzeug-ID hinterlegen
-        return chosen_order
-
-    def assign_order_to_vehicle(self, vehicle, order):
-        # Markiere den Auftrag mit dem Fahrzeug (für eventuelle Anzeigen oder spätere Referenzen)
-        order["vehicle"] = f"Fahrzeug {self.garage_vehicles.index(vehicle) + 1}"
-        # Optional: Speichere den Auftrag direkt am Fahrzeug, z.B. als Python-Tag
-        vehicle.setPythonTag("current_order", order)
-
-        # Entferne das Fahrzeug, falls es schon in der Liste ist, und füge es an erster Stelle ein.
-        if vehicle in self.garage_vehicles:
-            self.garage_vehicles.remove(vehicle)
-        self.garage_vehicles.insert(0, vehicle)
-
-        print(f"Auftrag {order['id']} wurde {order['vehicle']} zugeordnet.")
-
-    def finish_order_for_vehicle(self, vehicle):
-        # Setze den globalen Auftragseintrag des Fahrzeugs zurück (z. B. über einen Python-Tag oder eine eigene Datenstruktur)
-        vehicle.clearPythonTag("current_order")
-
-        # Verschiebe das Fahrzeug an das Ende der Liste, damit es auf den nächsten Auftrag wartet.
-        if vehicle in self.garage_vehicles:
-            self.garage_vehicles.remove(vehicle)
-        self.garage_vehicles.append(vehicle)
-
-        print(f"{vehicle.getName()} hat seinen Auftrag abgeschlossen und steht nun wieder in der Warteschlange.")
-
-    def vehicle_order_task(self, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        if not hasattr(self, 'vehicle_state'):
-            self.vehicle_state = "translate"
-
-        if not self.garage_vehicles:
-            return task.cont
-
-        # Wir nehmen hier vorerst das erste Fahrzeug aus der Garage
-        vehicle = self.garage_vehicles[0]
-
-        # ------------------ Phase 1: Translate ------------------
-        if self.vehicle_state == "translate":
-            if self.current_order is None:
-                next_order = self.select_next_order()
-                if next_order is not None:
-                    self.current_order = next_order
-                    self.current_order["status"] = "In Bearbeitung"
-                    print(f"Auftrag {self.current_order['id']} wird zugewiesen.")
-                else:
-                    print("Kein Auftrag verfügbar – Fallback zum globalen Ziel.")
-            if self.current_order is not None:
-                pickup_station = self.current_order.get("pickup_station")
-                if pickup_station in self.station_blue_dots:
-                    blue_target = self.station_blue_dots[pickup_station].getPos(self.render)
-                else:
-                    blue_target = self.blue_dot.getPos(self.render)
-            else:
-                blue_target = self.blue_dot.getPos(self.render)
-
-            local_mast = Vec3(0.5, 0.05, 1.0)
-            mast_global = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(local_mast)
-            target_xy = Vec2(blue_target.getX(), blue_target.getY())
-            mast_xy = Vec2(mast_global.getX(), mast_global.getY())
-            error_vector = target_xy - mast_xy
-            threshold = 0.05  # 5 cm Toleranz
-            if error_vector.length() > threshold:
-                direction = error_vector.normalized()
-                move_distance = 1.5 * dt
-                current_pos = vehicle.getPos(self.render)
-                new_pos = Vec3(current_pos.getX() + direction.getX() * move_distance,
-                               current_pos.getY() + direction.getY() * move_distance,
-                               0)
-                vehicle.setPos(new_pos)
-            else:
-                local_offset = vehicle.getQuat(self.render).xform(local_mast)
-                exact_pos = Vec3(blue_target.getX() - local_offset.getX(),
-                                 blue_target.getY() - local_offset.getY(),
-                                 0)
-                vehicle.setPos(exact_pos)
-                self.vehicle_state = "rotate"
-
-        # ------------------ Phase 2: Rotate ------------------
-        elif self.vehicle_state == "rotate":
-            desired_angle = math.degrees(math.atan2(self.station_white_direction.getY(),
-                                                    self.station_white_direction.getX()))
-            desired_angle = (desired_angle + 180) % 360
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_angle - current_heading + 180) % 360) - 180
-            kp_heading = 0.5
-            new_heading = current_heading + kp_heading * angle_diff
-            vehicle.setH(new_heading)
-            if abs(angle_diff) < 1.0:
-                self.vehicle_state = "turn_right"
-
-        # ------------------ Phase 3: Turn Right ------------------
-        elif self.vehicle_state == "turn_right":
-            if not hasattr(self, "turn_right_init"):
-                self.turn_right_init = vehicle.getH() % 360
-                self.turn_right_target = (self.turn_right_init + 90) % 360
-                print("Phase 3: Initialisiert. Start Heading =", self.turn_right_init,
-                      "Target Heading =", self.turn_right_target)
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((self.turn_right_target - current_heading + 180) % 360) - 180
-            kp_turn = 0.5
-            turn_rate = kp_turn * angle_diff
-            new_heading = current_heading + turn_rate * dt
-            vehicle.setH(new_heading)
-            print("Phase 3: Aktuelles Heading =", current_heading,
-                  "Winkelabweichung =", angle_diff,
-                  "Neues Heading =", new_heading)
-            if abs(angle_diff) < 1.0:
-                print("Phase 3: Drehung abgeschlossen. Übergang in 'approach'.")
-                self.vehicle_state = "approach"
-                del self.turn_right_init, self.turn_right_target
-
-                # ------------------ [Phase 4: Approach] ------------------
-        elif self.vehicle_state == "approach":
-                if self.current_order is not None:
-                    # Verwende den in self.current_order gespeicherten Pickup-Knoten.
-                    pickup_station = self.current_order.get("pickup_station")
-                    # Berechne den Zielpunkt: Position der Pickup-Station plus Offset:
-                    # 1.2 in X‑Richtung und 1 in Y‑Richtung
-                    target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-                else:
-                    # Fallback: Falls kein Auftrag vorliegt, benutze den global gesetzten green_dot plus Offset
-                    target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-
-                current = vehicle.getPos(self.render)
-                error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-                if error_vec.length() > 0.05:
-                    direction = error_vec.normalized()
-                    move_distance = 1.5 * dt
-                    new_pos = Vec3(
-                        current.getX() + direction.getX() * move_distance,
-                        current.getY() + direction.getY() * move_distance,
-                        target.getZ()
-                    )
-                    vehicle.setPos(new_pos)
-                else:
-                    self.vehicle_state = "pickup"
-
-        # ------------------ Phase 5: Pickup ------------------
-        elif self.vehicle_state == "pickup":
-            # Hier greifen wir auf den fahrzeugspezifischen Gabel-Knoten zu
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            target_z = 1.0  # Höhe der Gabel beim Aufnehmen
-            raise_speed = 0.5
-            if current_z < target_z:
-                fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-            else:
-                if self.current_order is None:
-                    if self.orders_queue:
-                        self.current_order = self.orders_queue.pop(0)
-                    else:
-                        print("Keine verfügbaren Aufträge. Überspringe Pickup-Phase.")
-                        self.vehicle_state = "drive_out"
-                        return task.cont
-                pickup_station = self.current_order["pickup_station"]
-                self.pickup_package(vehicle, pickup_station)
-                self.package_attached = True
-                self.drive_out_start = vehicle.getPos(self.render)
-                self.drive_out_target = self.drive_out_start + vehicle.getQuat(self.render).getForward() * 5.0
-                self.vehicle_state = "drive_out"
-
-        # ------------------ Phase 6: Drive Out ------------------
-        elif self.vehicle_state == "drive_out":
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            if current_z > 0.0:
-                lower_speed = 0.5
-                fork_node.setZ(max(0.0, current_z - lower_speed * dt))
-            current_pos = vehicle.getPos(self.render)
-            diff = self.drive_out_target - current_pos
-            if diff.length() > 0.1:
-                move_distance = 0.5 * dt
-                step = diff.normalized() * move_distance
-                vehicle.setPos(current_pos + step)
-            else:
-                self.vehicle_state = "to_delivery"
-
-        # ------------------ Phase 7: To Delivery ------------------
-        elif self.vehicle_state == "to_delivery":
-            delivery_target_str = self.current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current_pos = vehicle.getPos(self.render)
-            diff = blue_target - current_pos
-            threshold = 0.5  # großzügig
-            move_distance = 1.5 * dt
-            if move_distance > diff.length():
-                vehicle.setPos(blue_target)
-            else:
-                vehicle.setPos(current_pos + diff.normalized() * move_distance)
-            if (blue_target - vehicle.getPos(self.render)).length() <= threshold:
-                print("Phase 7 abgeschlossen: Fahrzeug hat den blauen Punkt der Abgabestation erreicht.")
-                self.vehicle_state = "align_delivery"
-
-        # ------------------ Phase 8: Align Delivery ------------------
-        elif self.vehicle_state == "align_delivery":
-            desired_heading = 90.0
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_heading - current_heading + 180) % 360) - 180
-            print("Phase 8: Align Delivery | Current Heading: {:.2f}°, Desired: {:.2f}°, Diff: {:.2f}°".format(
-                current_heading, desired_heading, angle_diff))
-            fixed_turn_speed = 90.0  # Grad pro Sekunde
-            turn_amount = fixed_turn_speed * dt
-            if abs(angle_diff) < 1.0:
-                vehicle.setH(desired_heading)
-                print("Phase 8 abgeschlossen: Fahrzeug ausgerichtet (Heading = {:.2f}°).".format(desired_heading))
-                self.vehicle_state = "delivery_center"
-            else:
-                if angle_diff > 0:
-                    new_heading = current_heading + turn_amount
-                else:
-                    new_heading = current_heading - turn_amount
-                new_heading %= 360
-                vehicle.setH(new_heading)
-                print("Phase 8: Rotating - New Heading set to {:.2f}°".format(new_heading))
-
-        # ------------------ Phase 9: Delivery Approach ------------------
-        elif self.vehicle_state == "delivery_center":
-            delivery_target_str = self.current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current = vehicle.getPos(self.render)
-            target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-            print("Phase 9: Zielpunkt der Abgabestation =", target_point)
-            error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-            tolerance = 0.05
-            move_distance = 1.5 * dt
-            if error_vec.length() > tolerance:
-                direction = error_vec.normalized()
-                new_pos = Vec3(
-                    current.getX() + direction.getX() * move_distance,
-                    current.getY() + direction.getY() * move_distance,
-                    current.getZ()
-                )
-                vehicle.setPos(new_pos)
-                print("Phase 9: Fahrzeug bewegt sich von", current, "nach", new_pos)
-            else:
-                vehicle.setPos(target_point)
-                print("Phase 9: Fahrzeug hat den Zielpunkt erreicht.")
-                self.vehicle_state = "drop"
-            current_fork_z = vehicle.getPythonTag("fork_node").getZ()
-            if current_fork_z < 1.0:
-                new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-                vehicle.getPythonTag("fork_node").setZ(new_fork_z)
-                print("Phase 9: Gabel wird angehoben (Z =", new_fork_z, ").")
-
-        # ------------------ Phase 10: Dropoff ------------------
-        elif self.vehicle_state == "drop":
-            if self.package_attached:
-                delivery_target_str = self.current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-                self.drop_cargo(vehicle)
-                print("Phase 10: Paket abgesetzt.")
-                self.package_attached = False
-            else:
-                fork_node = vehicle.getPythonTag("fork_node")
-                current_z = fork_node.getZ()
-                if current_z > 0.0:
-                    lower_speed = 0.5
-                    new_z = max(0.0, current_z - lower_speed * dt)
-                    fork_node.setZ(new_z)
-                    print("Phase 10: Gabel wird abgesenkt, aktueller Z-Wert =", new_z)
-                else:
-                    print("Phase 10: Dropoff vollständig abgeschlossen.")
-                    self.vehicle_state = "translate"
-                    self.current_order["status"] = "Erledigt"
-                    self.current_order["delivered_at"] = self.sim_clock
-                    self.current_order = None
-
-        # ------------------ Phase 11: Exit Station and Start Next Order ------------------
-        elif self.vehicle_state == "phase11":
-            if hasattr(self, "last_delivery_marker"):
-                target_point = self.last_delivery_marker
-            else:
-                delivery_target_str = self.current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    target_point = self.abgabe_blue_dots[0].getPos(self.render)
-                print("Phase 11: Zielpunkt (blauer Marker) =", target_point)
-                current_pos = vehicle.getPos(self.render)
-                diff = target_point - current_pos
-                if diff.length() > 0.1:
-                    move_distance = 0.5 * dt
-                    step = diff.normalized() * move_distance
-                    vehicle.setPos(current_pos + step)
-                    print("Phase 11: Fahrzeug fährt aus der Station, neue Position =", current_pos + step)
-                else:
-                    vehicle.setPos(target_point)
-                    print("Phase 11: Fahrzeug hat den blauen Marker erreicht. Nächster Auftrag wird gestartet.")
-                    self.vehicle_state = "next_order"
-        return task.cont
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: KI/KI7.py
===================================================================
diff --git a/KI/KI7.py b/KI/KI7.py
deleted file mode 100644
--- a/KI/KI7.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,273 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode
-)
-# Globaler Clock über ClockObject
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.interval.IntervalGlobal import Sequence, Wait, LerpPosInterval, Func
-from direct.task import Task
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Fahrzeuggeschwindigkeit: 1.5 m/s * 5 = 7.5 m/s
-        self.speed = 1.5 * 5
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie (gleicher Abstand)
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            # Annahmestation links (rot) bei x = -9
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            # Abgabestation rechts (grün) bei x = 9
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeuge initialisieren – wir erzeugen zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}             # Dictionary: Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}   # Dictionary: Fahrzeug -> aktuelle Abgabestation
-
-        # Fahrzeug 1
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-
-        # Fahrzeug 2 – leicht versetzt, damit die Modelle nicht exakt übereinander liegen.
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)  # y-Offset von 2 Einheiten
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-
-        # Globaler Pool für alle Pickup-Pakete:
-        # Schlüssel = Annahmestation, Wert = (Paket, Spawnzeit, Timer-TextNode)
-        self.pickup_packages = {}
-        # Für jede Station wird der Zeitpunkt des letzten Entfernens initialisiert.
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = globalClock.getFrameTime()
-
-        # Starte einen Task, der regelmäßig prüft, ob an einer Annahmestation ein Paket fehlen soll.
-        self.taskMgr.doMethodLater(1, self.check_and_spawn_packages, "CheckSpawnPackages")
-        # Task zum Aktualisieren der Timer-Anzeige über den Paketen.
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-
-        # Starte für jedes Fahrzeug einen eigenen, unabhängigen Lieferzyklus.
-        for v in self.vehicles:
-            self.start_delivery_cycle(v, v.getPos())
-
-    def check_and_spawn_packages(self, task):
-        """
-        Überprüft alle Annahmestationen:
-        Falls an einer Station noch kein Paket vorhanden ist und seit dem letzten Entfernen
-        mindestens 5 Sekunden vergangen sind, wird ein Paket erzeugt.
-        """
-        spawn_delay = 5  # 5 Sekunden Wartezeit pro Station
-        current_time = globalClock.getFrameTime()
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if current_time - self.last_removed.get(station, current_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.again
-
-    def spawn_package_at_station(self, station):
-        """
-        Erzeugt ein Paket (als Würfel) an der gegebenen Annahmestation.
-        Das Paket wird um +1 in Z positioniert. Zudem wird ein TextNode über dem Paket
-        zur Timer-Anzeige angehängt. Die Tuple (Paket, Spawnzeit, Timer-TextNode) wird im
-        globalen Pickup-Pool gespeichert.
-        """
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(),
-                                        LColor(1, 1, 0, 1))
-        spawn_time = globalClock.getFrameTime()
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        """
-        Aktualisiert in jedem Frame den Text (Wartezeit) aller wartenden Pakete.
-        """
-        current_time = globalClock.getFrameTime()
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = current_time - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        """
-        Liefert für ein einzelnes Fahrzeug folgenden Ablauf:
-          1. Ist der globale Pool der Pickup-Pakete nicht leer, wählt das Fahrzeug das Paket
-             mit der höchsten Wartezeit (also das älteste, gemessen an der Spawnzeit).
-          2. Das Fahrzeug fährt zur entsprechenden Annahmestation, nimmt das Paket auf,
-             wählt zufällig eine Abgabestation und liefert das Paket dort ab.
-          3. Nach 1 Sekunde wird das Paket entfernt und der nächste Auftrag
-             startet – unabhängig von anderen Fahrzeugen.
-        """
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-
-        if not self.pickup_packages:
-            self.taskMgr.doMethodLater(1,
-                lambda t: self.start_delivery_cycle(vehicle, vehicle.getPos()),
-                "RetryCycle_" + str(id(vehicle)))
-            return
-
-        current_time = globalClock.getFrameTime()
-        # Jedes Fahrzeug wählt das Paket mit der höchsten Wartezeit aus dem globalen Pool.
-        pickup_station = max(self.pickup_packages, key=lambda s: current_time - self.pickup_packages[s][1])
-        pickup_pos = pickup_station.getPos()
-        seg1_duration = (pickup_pos - start_pos).length() / self.speed
-
-        # Zufällige Auswahl einer Abgabestation.
-        dropoff_station = random.choice(self.abgabe_stationen)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_pos = dropoff_station.getPos()
-        seg2_duration = (dropoff_pos - pickup_pos).length() / self.speed
-
-        cycle = Sequence(
-            LerpPosInterval(vehicle, duration=seg1_duration, pos=pickup_pos),
-            Func(self.pickup_package, vehicle, pickup_station),
-            LerpPosInterval(vehicle, duration=seg2_duration, pos=dropoff_pos),
-            Func(self.drop_cargo, vehicle),
-            Wait(1),
-            Func(self.remove_cargo, vehicle),
-            Func(self.start_delivery_cycle, vehicle, vehicle.getPos())
-        )
-        cycle.start()
-
-    def pickup_package(self, vehicle, station):
-        """
-        Das Fahrzeug übernimmt das Paket der angegebenen Annahmestation.
-        Dabei wird der Timer-Text entfernt, das Paket aus dem globalen Pool gelöscht
-        und der Zeitpunkt der Entfernung in last_removed aktualisiert.
-        """
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = globalClock.getFrameTime()
-
-    def drop_cargo(self, vehicle):
-        """
-        Das vom Fahrzeug transportierte Paket wird exakt auf den Würfel der
-        (zufällig ausgewählten) Abgabestation (mit Z-Offset +1) abgesetzt.
-        """
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-
-    def remove_cargo(self, vehicle):
-        """
-        Entfernt das aktuell transportierte Paket des Fahrzeugs aus der Szene.
-        """
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        """
-        Erzeugt ein Wireframe-Box-Modell als Station.
-        """
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        """
-        Erzeugt einen Würfel (als Paket), der etwas über dem Boden platziert wird.
-        """
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        """
-        Einfaches Beleuchtungssetup: Ambient- und Richtungslicht.
-        """
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-# Starte die Simulation
-app = LagerSimulation()
-app.run()
Index: FFZ/FFZ15.py
===================================================================
diff --git a/FFZ/FFZ15.py b/FFZ/FFZ15.py
deleted file mode 100644
--- a/FFZ/FFZ15.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,504 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    LineSegs,
-    Vec3,
-    NodePath
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import random
-import math
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        # Fahrzeug startet mit 1.5 m/s (Standardgeschwindigkeit)
-        self.current_speed = 1.5
-        # Wir speichern außerdem unsere Hindernisse in einer Liste
-        self.obstacles = []
-
-        # Kameraeinstellungen (Fahrtrichtung: entlang der Y-Achse)
-        self.cam.setPos(0, -30, 10)
-        self.cam.lookAt(0, 0, 0)
-
-        # Licht und Raster
-        self.setup_light()
-        self.create_grid(center_extent=10, cell_size=0.1)
-
-        # Zufällige Hindernisse erzeugen
-        self.create_obstacles()
-
-        # Fahrzeug erstellen (mit Chassis, Fork, Mast, etc.)
-        self.vehicle = self.create_vehicle()
-
-        # Slider für Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Slider zur manuellen Einstellung der Forkhöhe (0 bis 1 m)
-        self.fork_slider = DirectSlider(
-            range=(0.0, 1.0),
-            value=0.0,
-            pageSize=0.01,
-            command=self.update_fork_height,
-            pos=(-0.7, 0, -0.85),
-            scale=0.3
-        )
-        self.fork_label = DirectLabel(
-            text="Fork Höhe: 0.00m",
-            pos=(-0.7, 0, -0.75),
-            scale=0.07
-        )
-
-        # Laufzeitanzeige
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom via Mausrad
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben: Simulationszeit, Anzeige und Fahrzeugbewegung (inkl. Hindernisvermeidung)
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_vehicle, "UpdateVehicleTask")
-        # Optional: Der Task für die Fork-Animation (update_cable) kann hinzugefügt werden,
-        # wenn die Fork zusätzlich oszillieren soll.
-        # self.taskMgr.add(self.update_cable, "UpdateCableTask")
-
-    def create_obstacles(self):
-        """Erstellt zufällige Hindernisse (Boxen) und platziert sie auf der Ebene (Z=0)."""
-        for i in range(10):
-            w = random.uniform(0.3, 0.7)
-            d = random.uniform(0.3, 0.7)
-            h = 0.5
-            box = self.create_box(w, d, h, (0.5, 0.5, 0.5, 1))
-            obstacle = self.render.attachNewNode(box)
-            x = random.uniform(-5, 5)
-            y = random.uniform(-5, 5)
-            obstacle.setPos(x, y, 0)
-            self.obstacles.append(obstacle)
-
-    def update_vehicle(self, task):
-        """Bewegt das Fahrzeug vorwärts, passt die Geschwindigkeit gemäß Beschleunigung/Verzögerung an
-           und weicht Hindernissen aus."""
-        dt = ClockObject.getGlobalClock().getDt()
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        # Hindernisvermeidung: Berechne einen Vermeidungsvektor
-        avoid_vector = Vec3(0, 0, 0)
-        obstacle_detected = False
-        for obstacle in self.obstacles:
-            obs_pos = obstacle.getPos(self.render)
-            diff = pos - obs_pos
-            dist = diff.length()
-            # Wenn ein Hindernis in einem Radius von 3 Einheiten liegt und vor dem Fahrzeug ist:
-            if dist < 3.0 and diff.dot(forward) > 0:
-                obstacle_detected = True
-                strength = (3.0 - dist) / 3.0
-                avoid_vector += diff.normalized() * strength
-
-        # Bestimme die Zielgeschwindigkeit:
-        # Ohne Hindernis soll 1.5 m/s, mit Hindernis 0.5 m/s gelten.
-        if obstacle_detected:
-            target_speed = 0.5
-        else:
-            target_speed = 1.5
-
-        # Passe die aktuelle Geschwindigkeit mit einer Beschleunigungsrate von 2 m/s^2 an:
-        acceleration_rate = 2.0
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acceleration_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acceleration_rate * dt, target_speed)
-
-        # Bei Hindernisvermeidung lenken: Wenn ein Vermeidungsvektor vorhanden ist,
-        # berechne eine gewünschte Richtung
-        if avoid_vector.length() > 0:
-            desired_dir = (forward + avoid_vector).normalized()
-            # Bestimme den gewünschten Heading in Grad (nur in der XY-Ebene)
-            desired_heading = math.degrees(math.atan2(desired_dir.getX(), desired_dir.getY()))
-            current_heading = self.vehicle.getH()
-            # Glätte die Änderung (Interpolation)
-            new_heading = current_heading + 0.1 * (desired_heading - current_heading)
-            self.vehicle.setH(new_heading)
-            forward = self.vehicle.getQuat().getForward()
-
-        # Aktualisiere die Fahrzeugposition basierend auf der aktuellen Geschwindigkeit
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_fork_height(self, height=0, *args):
-        try:
-            height = float(height)
-        except ValueError:
-            height = 0.0
-        self.fork_node.setZ(height)
-        self.fork_label['text'] = f"Fork Höhe: {height:.2f}m"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def create_grid(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            x += cell_size
-
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        grid_np = self.render.attachNewNode(node)
-        grid_np.setColor(0.7, 0.7, 0.7, 1)
-        return grid_np
-
-    def setup_light(self):
-        ambient_light = AmbientLight("ambient_light")
-        ambient_light.setColor((0.5, 0.5, 0.5, 1))
-        ambient_np = self.render.attachNewNode(ambient_light)
-        self.render.setLight(ambient_np)
-
-        directional_light = DirectionalLight("directional_light")
-        directional_light.setColor((1, 1, 1, 1))
-        directional_np = self.render.attachNewNode(directional_light)
-        directional_np.setPos(10, -10, 10)
-        self.render.setLight(directional_np)
-
-    def create_vehicle(self):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Fahrmodul (Chassis): 1 x 0.5 x 1.2 in Rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        # Schwarze Kanten für das Chassis
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # Gabelmodul (Fork): Zwei Zähne (je 0.2 x 1.2 x 0.1)
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-        self.fork_node = fork_node
-
-        # Mast: Rahmen aus vier Balken
-        mast_node = vehicle_node.attachNewNode("mast")
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-
-        # Diagonalen auf der oberen Fläche des Mastes
-        self.add_diagonals_to_mast(mast_node)
-        # Definiere den Schnittpunkt der Diagonalen in lokalen Mast-Koordinaten
-        intersection = Vec3(0.5, 0.05, 1.0)
-
-        # Gelber Zylinder: Durchmesser 0.1, Höhe 0.1, Farbe Gelb (1,1,0,1)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        # Lidar-Kreis: Der Mittelpunkt soll 1 m in negativer Z-Richtung liegen (also z = -1)
-        lidar_center = Vec3(intersection.x, intersection.y, -1)
-        self.add_lidar_circle(mast_node, lidar_center, 2)
-
-        # Setze den Fahrzeugknoten so, dass er auf der Ebene sitzt (Z=0).
-        vehicle_node.setPos(0, 0, 0)
-
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)  # Orange
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)  # Grün
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        # Top center
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        # Top circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        # Bottom center
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        # Bottom circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        # Top fan
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        # Bottom fan
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        # Side faces
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        # Unterseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        # Oberseite
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        # Vorderseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        # Rückseite
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        # Linke Seite
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        # Rechte Seite
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base+1, base+2)
-            tris.closePrimitive()
-            tris.addVertices(base, base+2, base+3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        # Unterkante
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        # Oberkante
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        # Vertikale Kanten
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: Grundmodell/Gm13.py
===================================================================
diff --git a/Grundmodell/Gm13.py b/Grundmodell/Gm13.py
deleted file mode 100644
--- a/Grundmodell/Gm13.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,1277 +0,0 @@
-import random
-import math
-import tkinter as tk  # Für das extra Fenster der Auftragsübersicht
-from tkinter import ttk  # Für die tabellarische Darstellung (Treeview)
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5  # Wird in update_vehicle genutzt
-        self.state_timer = 0.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Paketspawning an den Annahmestationen:
-        # Mapping: station (Dummy-Node) -> (Paket, Spawnzeit, Timer Node)
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-        # Neues Attribut: Verknüpfung Fahrzeug -> transportiertes Paket
-        self.cargos = {}
-
-        # NEU: Initialisiere die belegten Annahmestationen
-        self.occupied_pickups = set()  # Oder: [] für eine Liste
-
-        # Graph-Daten (Sim-Zeit, Pakete pro Minute, durchschnittliche Liegedauer)
-        self.graph_data = []
-        self.graph_opened = False
-
-        # Auftragsverwaltung: Speichere alle Aufträge (für die Anzeige) sowie in
-        # einer Queue (Liste) zur sequentiellen Abarbeitung.
-        self.orders = {}         # Für die Anzeige
-        self.orders_queue = []   # Für die Fahrzeugabwicklung (FIFO)
-        self.next_order_id = 1
-
-        # Tkinter-Fenster für Auftragsübersicht
-        self.order_win = None
-        self.order_tree = None
-
-        # Umgebung initialisieren
-        self.draw_origin()
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.create_wall()
-        self.create_annahme_stations()
-        self.create_abgabe_stations()  # Hier wird auch self.abgabe_stations angelegt.
-        self.create_garagen_stations()
-
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # Fahrzeuge in den Garagen erstellen (genau 5 Fahrzeuge)
-        self.create_garage_vehicles()
-
-        # NEU: Auftragssystem für das Testfahrzeug initialisieren
-        # Zustände: "idle", "to_pickup", "wait_pickup", "to_delivery", "deliver"
-        self.first_vehicle_order_state = "idle"
-        self.attached_package = None
-        self.current_order = None  # Der aktuell abgearbeitete Auftrag
-        self.taskMgr.add(self.vehicle_order_task, "VehicleOrderTask")
-
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-        self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    # ---------------------------
-    # SIMULATION UND UI-METHODEN
-    # ---------------------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    # ---------------------------
-    # METHODEN FÜR RASTER, LICHT, MAUER, URSPRUNG
-    # ---------------------------
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # STATIONSOBJEKTE UND ZUORDNUNG
-    # -----------------------------------
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        # Beispielhafte Station-Punkte (siehe dein ursprünglicher Code)
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basisstation (zum Beispiel Rahmen)
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Erzeuge den Marker (großer weißer Punkt) als Orientierung
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Erzeuge den grünen Punkt an der Station (als optionaler Punkt)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zeichne die weiße Linie an der Station.
-            # Die Linie beginnt bei: center + Vec3(0,0,-0.5) und verläuft 3 Meter in X-Richtung.
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            white_line_node = self.render.attachNewNode(line_seg.create())
-
-            # Speichere den Node der weißen Linie global
-            self.white_line = white_line_node
-
-            # Berechne den Mittelpunkt der weißen Linie
-            self.white_line_center = (start_line + end_line) * 0.5
-
-            # Berechne die Richtung der weißen Linie (als 2D-Vektor, normalisiert)
-            line_vec = end_line - start_line
-            self.station_white_direction = Vec2(line_vec.getX(), line_vec.getY()).normalized()
-
-            # Erzeuge den blauen Punkt – dieser dient als Ziel in Phase 1.
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            # Speichere global relevante Punkte für die erste Station
-            if i == 1:
-                self.blue_dot = blue_dot
-                self.station_green_dot = green_dot
-
-            # (Optional) Textanzeige der Stationsnummer:
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) – falls benötigt:
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        self.abgabe_stations = []  # Initialisiere die Liste der Abgabestationen
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basiskonstruktion der Abgabestation
-            node = self.create_abgabe_station(pt)
-            self.abgabe_stations.append(node)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Marker am Zentrum (unverändert)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Grüner Punkt: Ursprünglich center + Vec3(0, 0, 0.5)
-            # Jetzt um 1 Einheit in negativer Z-Richtung: center + Vec3(0, 0, -0.5)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Weiße Linie: Startet ebenfalls bei center + Vec3(0, 0, -0.5)
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            # Hier wird die Linie 3 Einheiten in negativer X-Richtung gezeichnet
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt an der Endposition der Linie
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            # Anzeige der Stationsnummer
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) auf den Stationen
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 3)
-        v5 = pos + Vec3(1, 0, 3)
-        v6 = pos + Vec3(1, 2, 3)
-        v7 = pos + Vec3(0, 2, 3)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 3)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        self.garagen_stations = []
-        self.garagen_parking_points = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            self.garagen_stations.append(pt)
-            # ParkpunktGarage: Verschoben um 0.5 in negativer Y-Richtung:
-            center = pt + Vec3(0.5, 0.5, 1.5)
-            ParkpunktGarage = center + Vec3(0, 0, 0.7)
-            self.garagen_parking_points.append(ParkpunktGarage)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def create_garage_vehicles(self):
-        """
-        Erzeugt nur das erste Fahrzeug in der Simulation.
-
-        Ursprünglich wurde für jeden Garagen-Parkpunkt ein Fahrzeug erstellt.
-        Mit dieser Anpassung wird nur das Fahrzeug am ersten Parkpunkt erzeugt,
-        alle weiteren Fahrzeuge werden nicht erzeugt.
-        """
-        self.garage_vehicles = []
-        if self.garagen_parking_points:
-            park = self.garagen_parking_points[0]  # Nur der erste Parkpunkt wird verwendet.
-            veh = self.create_vehicle(park_point=None)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            # Statt newPos.setZ(0.1) setzen wir den Z-Wert als Offset zum berechneten Wert:
-            newPos.setZ(newPos.getZ() + 0.1)
-            veh.setPos(newPos)
-            self.garage_vehicles.append(veh)
-
-            # Erzeuge Fahrzeugmarker
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # FAHRZEUGERSTELLUNG (FFZ20-INTEGRATION)
-    # -----------------------------------
-    def create_vehicle(self, park_point=None):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Chassis: 1 x 0.5 x 1.2, Farbe Rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # Fork (Gabel): Zwei Zähne
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-        self.fork_node = fork_node
-
-        # Berechne den Mittelpunkt der Gabel (mittels der linken und rechten Eckpunkte)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_corner_global = fork_node.getPos() + left_corner_local
-        right_corner_global = fork_node.getPos() + right_corner_local
-
-        ls_new = LineSegs()
-        ls_new.setThickness(2.0)
-        ls_new.setColor(1, 1, 1, 1)
-        ls_new.moveTo(left_corner_global)
-        ls_new.drawTo(right_corner_global)
-        vehicle_node.attachNewNode(ls_new.create())
-
-        midpoint = (left_corner_global + right_corner_global) * 0.5
-        white_line_vec = right_corner_global - left_corner_global
-        if white_line_vec.length() != 0:
-            white_line_dir = white_line_vec.normalized()
-        else:
-            white_line_dir = Vec3(0, 0, 0)
-        candidate = Vec3(-white_line_dir.getY(), white_line_dir.getX(), 0)
-        vehicle_pos = vehicle_node.getPos()
-        if candidate.dot(vehicle_pos - midpoint) < 0:
-            candidate = -candidate
-        if candidate.length() != 0:
-            perp_direction = candidate.normalized()
-        else:
-            perp_direction = Vec3(0, 0, 0)
-        line_length = 1.0
-        line_end = midpoint + perp_direction * line_length
-        ls_mid = LineSegs()
-        ls_mid.setThickness(2.0)
-        ls_mid.setColor(1, 1, 1, 1)
-        ls_mid.moveTo(midpoint)
-        ls_mid.drawTo(line_end)
-        vehicle_node.attachNewNode(ls_mid.create())
-
-        # Fahrzeug: Gabel – grüner Punkt (als Referenz)
-        green_point_global = midpoint + perp_direction * 0.5
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        self.fork_green = green_marker_np  # Global abgespeichert
-
-        # Mast: Erzeuge den Mast und hänge den Zylinder als Referenz an
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-
-        self.add_diagonals_to_mast(mast_node)
-        intersection = Vec3(0.5, 0.05, 1.0)
-
-        # Fahrzeug: Zylinder – Erzeuge den Zylinder und speichere ihn global
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-        self.vehicle_cylinder = cylinder_node  # Global abgespeichert
-
-        # Optional: Zusätzliche Fahrzeugbestandteile (wie Lidar) können hier ergänzt werden.
-
-        if park_point is None:
-            vehicle_node.setPos(intersection.x, intersection.y, 0)
-        else:
-            vehicle_node.setPos(park_point - intersection)
-
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    # -----------------------------------
-    # FEHLENDE METHODEN: Paketspawning, Würfelerzeugung u.a.
-    # -----------------------------------
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        if hasattr(self, "abgabe_stations") and self.abgabe_stations:
-            target_index = random.randint(1, len(self.abgabe_stations))
-        else:
-            target_index = 1
-
-        # Der Auftrag wird hier erstellt – und zwar genau dann, wenn ein Paket gespawnt wird.
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def update_order_table(self):
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen (z.B. "annahme_station_3") nur die Nummer.
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z.B. "Abgabestation 5") nur die Nummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Bestimme die Fahrzeugzuordnung.
-            # Wird "1" angezeigt, wenn der Auftrag aktuell (und noch nicht erledigt) dem Fahrzeug zugeordnet ist.
-            # Andernfalls wird ein "-" angezeigt.
-            if self.current_order is not None and order["id"] == self.current_order["id"] and order.get(
-                    "status") != "Erledigt":
-                vehicle_display = "1"
-            else:
-                vehicle_display = "-"
-
-            self.order_tree.insert("", tk.END, values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def check_and_spawn_packages(self, task):
-        # Maximale Anzahl an Aufträgen beschränken auf die Anzahl der Pakete in der Simulation
-        max_orders = len(self.pickup_packages)
-        if len(self.orders) >= max_orders:
-            return Task.cont
-
-        spawn_delay = 5.0  # 5 Sekunden Verzögerung zwischen Spawns
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0.0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Wir legen hier die Spalten in der gewünschten Reihenfolge an: Auftrags ID, Annahmestation, Ziel, Fahrzeug.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Setze das Paket relativ zum Gabelmodul mit einem Offset in X- und Y-Richtung
-            green_point_pos = self.fork_green.getPos(self.fork_node)
-            package.wrtReparentTo(self.fork_node)
-            package.setPos(
-                green_point_pos.getX() + 0.5,  # Versatz um +0.5 in X-Richtung
-                green_point_pos.getY() + -0.5,  # Versatz um +0.5 in Y-Richtung
-                green_point_pos.getZ() + 1  # Z-Offset, um das Paket oberhalb der Gabel zu platzieren
-            )
-
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    # ---------------------------
-    # NEU: Fahrzeugauftrag abarbeiten – Auftrag abrufen und sequentiell abarbeiten
-    # ---------------------------
-    from panda3d.core import Vec2, Vec3, ClockObject
-    import math
-
-    def vehicle_order_task(self, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-
-        # Initialisiere den Zustand, falls noch nicht gesetzt
-        if not hasattr(self, "vehicle_state"):
-            self.vehicle_state = "translate"
-        # Initialisiere package_attached
-        if not hasattr(self, "package_attached"):
-            self.package_attached = False
-
-        if not self.garage_vehicles:
-            return task.cont
-
-        vehicle = self.garage_vehicles[0]
-
-        # PHASE 1: Translate – Fahre exakt in Richtung des blauen Markers (ohne Offset)
-        if self.vehicle_state == "translate":
-            blue_target = self.blue_dot.getPos(self.render)
-            local_mast = Vec3(0.5, 0.05, 1.0)
-            mast_global = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(local_mast)
-            target_xy = Vec2(blue_target.getX(), blue_target.getY())
-            mast_xy = Vec2(mast_global.getX(), mast_global.getY())
-            error_vector = target_xy - mast_xy
-            threshold = 0.05  # 5 cm Toleranz
-            if error_vector.length() > threshold:
-                direction = error_vector.normalized()
-                move_distance = 1.5 * dt
-                move_vec = direction * move_distance
-                current_pos = vehicle.getPos(self.render)
-                new_pos = Vec3(
-                    current_pos.getX() + move_vec.getX(),
-                    current_pos.getY() + move_vec.getY(),
-                    0
-                )
-                vehicle.setPos(new_pos)
-            else:
-                # Exaktes Ausrichten im XY-Bereich auf den blauen Marker
-                local_offset = vehicle.getQuat(self.render).xform(local_mast)
-                exact_pos = Vec3(
-                    blue_target.getX() - local_offset.getX(),
-                    blue_target.getY() - local_offset.getY(),
-                    0
-                )
-                vehicle.setPos(exact_pos)
-                self.vehicle_state = "rotate"  # Übergang in die Rotationsphase
-
-        # PHASE 2: Rotate – Richte das Fahrzeug in Richtung der Einfahrtrichtung aus
-        elif self.vehicle_state == "rotate":
-            desired_angle = math.degrees(math.atan2(self.station_white_direction.getY(),
-                                                    self.station_white_direction.getX()))
-            # Eventuell anpassen: hier ein 180°-Offset
-            desired_angle = (desired_angle + 180) % 360
-            current_heading = vehicle.getH()
-            angle_diff = (desired_angle - current_heading + 180) % 360 - 180
-            kp_heading = 0.5  # Proportionalbeiwert
-            new_heading = current_heading + kp_heading * angle_diff
-            vehicle.setH(new_heading)
-            if abs(angle_diff) < 1.0:
-                self.vehicle_state = "turn_right"
-
-        # PHASE 3: Turn Right – Drehe das Fahrzeug um 90° nach rechts
-        elif self.vehicle_state == "turn_right":
-            if not hasattr(self, "turn_right_init"):
-                self.turn_right_init = vehicle.getH()
-                self.turn_right_target = (self.turn_right_init + 90) % 360
-            current_heading = vehicle.getH()
-            angle_diff = (self.turn_right_target - current_heading + 180) % 360 - 180
-            kp_turn = 0.5
-            new_heading = current_heading + kp_turn * angle_diff
-            vehicle.setH(new_heading)
-            if abs(angle_diff) < 1.0:
-                self.vehicle_state = "approach"
-                del self.turn_right_init, self.turn_right_target
-
-        # PHASE 4: Approach – Fahre versetzt in die Station hinein
-        elif self.vehicle_state == "approach":
-            # Zielpunkt der Station mit einem Offset in X- und Y-Richtung von 0.5
-            target = self.station_green_dot.getPos(self.render) + Vec3(0.5, 0.5, 0)
-            current = vehicle.getPos(self.render)
-            error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-            if error_vec.length() > 0.05:
-                direction = error_vec.normalized()
-                move_distance = 1.5 * dt
-                new_pos = Vec3(
-                    current.getX() + direction.getX() * move_distance,
-                    current.getY() + direction.getY() * move_distance,
-                    target.getZ()  # Z bleibt unverändert
-                )
-                vehicle.setPos(new_pos)
-            else:
-                self.vehicle_state = "pickup"  # Wechsel in den Pickup-Zustand
-
-        # PHASE 5: Pickup – Paket aufnehmen
-        if self.vehicle_state == "pickup":
-            # Fahre die Gabel hoch
-            current_z = self.fork_node.getZ()
-            target_z = 1.0  # Höhe der angehobenen Gabel
-            raise_speed = 0.5  # Geschwindigkeit des Hebens
-            if current_z < target_z:
-                self.fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-            else:
-                # Überprüfe, ob ein Auftrag existiert
-                if self.current_order is None:
-                    if self.orders_queue:  # Stelle sicher, dass Aufträge in der Warteschlange vorhanden sind
-                        self.current_order = self.orders_queue.pop(0)  # Nimm den nächsten Auftrag aus der Warteschlange
-                    else:
-                        print("Keine verfügbaren Aufträge. Überspringe Pickup-Phase.")
-                        self.vehicle_state = "drive_out"  # Fahre ohne Paket aus der Station
-                        return task.cont
-
-                # Jetzt kann auf die Werte von `self.current_order` zugegriffen werden
-                pickup_station = self.current_order["pickup_station"]
-                self.pickup_package(vehicle, pickup_station)
-                self.package_attached = True
-                self.drive_out_start = vehicle.getPos(self.render)
-                self.drive_out_target = self.drive_out_start + vehicle.getQuat(self.render).getForward() * 5.0
-                self.vehicle_state = "drive_out"
-
-        # =========================
-        # Phase 6: Drive Out – Langsam herausfahren in positiver X-Richtung
-        # =========================
-        if self.vehicle_state == "drive_out":
-            current_z = self.fork_node.getZ()
-            if current_z > 0.0:
-                # Gabel langsam senken
-                lower_speed = 0.5  # Geschwindigkeit des Senkens
-                self.fork_node.setZ(max(0.0, current_z - lower_speed * dt))
-
-            # Fahre langsam mit konstanter Geschwindigkeit geradeaus in positiver X-Richtung
-            move_distance = 0.5 * dt  # 0.5 m/s Geschwindigkeit
-            current_pos = vehicle.getPos(self.render)
-            new_pos = Vec3(
-                current_pos.getX() + move_distance,  # Bewegung in positiver X-Richtung
-                current_pos.getY(),  # Y bleibt unverändert
-                current_pos.getZ()  # Z bleibt unverändert
-            )
-            vehicle.setPos(new_pos)
-
-            # Prüfe, ob das Fahrzeug den blauen Punkt erreicht oder überquert hat
-            blue_target = self.blue_dot.getPos(self.render)
-            if current_pos.getX() >= blue_target.getX():  # Vergleich entlang der X-Richtung
-                print("Das Fahrzeug hat den blauen Punkt erreicht.")
-                self.vehicle_state = "to_delivery"  # Wechsel zur nächsten Phase
-
-
-            pass
-
-        return task.cont
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: Test/KI Lab 2.py
===================================================================
diff --git a/Test/KI Lab 2.py b/Test/KI Lab 2.py
deleted file mode 100644
--- a/Test/KI Lab 2.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,228 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData,
-    GeomNode, GeomVertexWriter, GeomLines, Geom, Vec3, globalClock
-)
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.interval.IntervalGlobal import Sequence, Wait, LerpPosInterval, Func
-from direct.task import Task
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Fahrzeuggeschwindigkeit: Ursprünglich 1.5 m/s, um den Faktor 5 erhöht → 7.5 m/s
-        self.speed = 1.5 * 5
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie mit gleichem Abstand.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            # Annahmestation links (rot) bei x = -9
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            # Abgabestation rechts (grün) bei x = 9
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeug initialisieren
-        self.vehicle = self.loader.loadModel("models/box")
-        self.vehicle.setScale(1, 1, 0.5)
-        self.vehicle.setColor(LColor(0, 0, 1, 1))
-        self.vehicle.setPos(0, 0, 0)
-        self.vehicle.reparentTo(self.render)
-
-        self.cargo = None  # Das aktuell transportierte Paket
-        # Dictionary für alle Pickup-Pakete: Schlüssel = Pickup-Station, Wert = (Paket, Spawnzeit)
-        self.pickup_packages = {}
-
-        # Starte einen Task, der regelmäßig prüft, ob bei den Annahmestationen ein Paket fehlt.
-        self.taskMgr.doMethodLater(1, self.check_and_spawn_packages, "CheckSpawnPackages")
-
-        # Start des ersten Lieferzyklus
-        self.start_delivery_cycle()
-
-    def check_and_spawn_packages(self, task):
-        """
-        Für jede Annahmestation wird geprüft, ob bereits ein Paket vorhanden ist.
-        Falls nicht, wird an dieser Station (mit Spawnzeit = globalClock.getFrameTime())
-        ein Paket erzeugt.
-        """
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                self.spawn_package_at_station(station)
-        return Task.again
-
-    def spawn_package_at_station(self, station):
-        """
-        Erzeugt ein Paket (als Würfel) an der gegebenen Station.
-        Das Paket wird an die Position der Station (mit einem Z-Offset von +1)
-        gesetzt und zusammen mit der Spawnzeit in das Dictionary eingetragen.
-        """
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = globalClock.getFrameTime()
-        self.pickup_packages[station] = (package, spawn_time)
-
-    def start_delivery_cycle(self, start_pos=None):
-        """
-        Ablauf:
-          1. Das Fahrzeug startet vom aktuellen Punkt (start_pos) und sucht unter allen
-             Annahmestationen das Paket, welches am längsten wartet (älteste Spawnzeit).
-          2. Das Fahrzeug fährt zu dieser Annahmestation und nimmt das Paket auf.
-          3. Anschließend wird zufällig eine Abgabestation gewählt, zu der das Fahrzeug fährt.
-          4. Dort wird das Paket auf den Würfel der Abgabestation gesetzt; nach 1 Sekunde
-             wird es entfernt.
-          5. Der nächste Zyklus startet ab der aktuellen Position (der Abgabestation).
-        """
-        if start_pos is None:
-            start_pos = self.vehicle.getPos()
-
-        # Falls gerade keine Pakete existieren, kurz warten.
-        if not self.pickup_packages:
-            task = self.taskMgr.doMethodLater(1, lambda t: self.start_delivery_cycle(start_pos), "RetryCycle")
-            return
-
-        # Auswahl der Annahmestation mit dem ältesten Paket (kleinster Spawnzeitwert)
-        pickup_station = min(self.pickup_packages, key=lambda s: self.pickup_packages[s][1])
-        pickup_pos = pickup_station.getPos()
-        seg1_duration = (pickup_pos - start_pos).length() / self.speed
-
-        # Zufällige Auswahl einer Abgabestation
-        dropoff_station = random.choice(self.abgabe_stationen)
-        self.current_dropoff_station = dropoff_station  # Für drop_cargo()
-        dropoff_pos = dropoff_station.getPos()
-        seg2_duration = (dropoff_pos - pickup_pos).length() / self.speed
-
-        cycle = Sequence(
-            # Fahrt zur Annahmestation (Pickup-Station, bei der das älteste Paket liegt)
-            LerpPosInterval(self.vehicle, duration=seg1_duration, pos=pickup_pos),
-            # Nach der Ankunft: Paket vom Pickup-Punkt aufnehmen
-            Func(self.pickup_package, pickup_station),
-            # Fahrt zur zufällig ausgewählten Abgabestation
-            LerpPosInterval(self.vehicle, duration=seg2_duration, pos=dropoff_pos),
-            Func(self.drop_cargo),
-            Wait(1),
-            Func(self.remove_cargo),
-            # Starte nächsten Zyklus von der aktuellen Position aus (Abgabestation)
-            Func(self.start_delivery_cycle, self.vehicle.getPos())
-        )
-        cycle.start()
-
-    def pickup_package(self, station):
-        """
-        Nimmt das an der gegebenen Pickup-Station wartende Paket vom Boden und hängt es
-        als Kind des Fahrzeugs an. Gleichzeitig wird der Eintrag aus dem Dictionary entfernt.
-        """
-        if station in self.pickup_packages:
-            package, spawn_time = self.pickup_packages.pop(station)
-            package.wrtReparentTo(self.vehicle)
-            package.setPos(0, 0, 1)
-            self.cargo = package
-
-    def drop_cargo(self):
-        """
-        Setzt das Paket exakt auf den Würfel der (zufällig ausgewählten) Abgabestation
-        (Z-Offset +1).
-        """
-        self.cargo.wrtReparentTo(self.render)
-        targetPos = self.current_dropoff_station.getPos() + Vec3(0, 0, 1)
-        self.cargo.setPos(targetPos)
-
-    def remove_cargo(self):
-        """
-        Entfernt das aktuell transportierte Paket aus der Szene.
-        """
-        if self.cargo:
-            self.cargo.removeNode()
-            self.cargo = None
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-
-        # Horizontale Linien
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        # Vertikale Linien
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        """
-        Erzeugt ein Wireframe-Box-Modell als Station.
-        """
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        """
-        Erzeugt einen Würfel (als Paket), der etwas über dem Boden platziert wird.
-        """
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        """
-        Einfaches Beleuchtungssetup: Ambient- und Richtungslicht.
-        """
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-# Starte die Simulation
-app = LagerSimulation()
-app.run()
Index: Grundmodell/Gm25.py
===================================================================
diff --git a/Grundmodell/Gm25.py b/Grundmodell/Gm25.py
deleted file mode 100644
--- a/Grundmodell/Gm25.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,1798 +0,0 @@
-import random
-import math
-import tkinter as tk  # Für das extra Fenster der Auftragsübersicht
-from tkinter import ttk  # Für die tabellarische Darstellung (Treeview)
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-import matplotlib
-matplotlib.use("TkAgg")  # oder ein anderes geeignetes Backend
-import multiprocessing
-from multiprocessing import Queue, Process
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-import time
-import ctypes
-from PyQt5 import QtWidgets, QtCore
-import pyqtgraph as pg
-from direct.gui.DirectGui import DirectButton
-
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-from direct.task.TaskManagerGlobal import taskMgr
-from functools import partial
-
-class LagerSimulation(ShowBase):
-    def __init__(self, graph_queue=None):
-        super().__init__()
-        self.paused = False
-        # Pause-Knopf neben dem Slider platzieren – z.B. rechts davon.
-        self.pause_button = DirectButton(
-            text="Pause",
-            command=self.toggle_pause,
-            pos=(-0.5, 0, -0.85),  # Leicht links vom Slider
-            scale=0.07
-        )
-
-        # Speichere die Queue als Attribut
-        self.graph_process = None  # Hier wird der Graphing-Prozess gespeichert.
-        self.graph_queue = None  # Die Queue für den Datenaustausch.
-
-        self.tk_root = tk.Tk()
-        self.tk_root.withdraw()
-
-        self.taskMgr.add(self._tk_update, "tkUpdateTask")
-        self.taskMgr.add(self.update_delivery_timers, "UpdateDeliveryTimersTask")
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5  # Wird in update_vehicle genutzt
-        self.state_timer = 0.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Kennzahlen für Lieferzeiten
-        self.total_delivery_time = 0.0
-        self.total_delivery_count = 0
-        self.max_overall_delivery_time = 0.0
-
-        # Paketspawning an den Annahmestationen:
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-        # Fahrzeug-spezifische Zuordnung: Fahrzeug -> transportiertes Paket
-        self.cargos = {}
-
-        # NEU: Initialisiere die belegten Annahmestationen
-        self.occupied_pickups = set()  # Oder: [] für eine Liste
-
-        # Graph-Daten (Sim-Zeit, Pakete pro Minute, durchschnittliche Liegedauer)
-        self.graph_data = []
-        self.graph_opened = False
-
-        # Auftragsverwaltung: Speichere alle Aufträge (für die Anzeige) sowie in
-        # einer Queue (Liste) zur sequentiellen Abarbeitung.
-        self.orders = {}
-        self.orders_queue = []
-        self.next_order_id = 1
-
-        # Tkinter-Fenster für Auftragsübersicht
-        self.order_win = None
-        self.order_tree = None
-
-        # Umgebung initialisieren
-        self.draw_origin()
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.create_wall()
-        self.create_annahme_stations()
-        self.create_abgabe_stations()  # Hier wird auch self.abgabe_stations angelegt.
-        self.create_garagen_stations()
-
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # Fahrzeuge in den Garagen erstellen (genau 5 Fahrzeuge)
-        self.create_garage_vehicles()
-
-        # NEU: Testvariablen
-        self.first_vehicle_order_state = "idle"
-        self.attached_package = None
-        self.current_order = None  # wird durch Fahrzeuge individuell genutzt
-
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tastenzuordnungen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-        # Taste C öffnet das Fahrzeug-Kontrollfenster
-        self.accept("c", self.show_vehicle_control)
-
-        # Task-Manager
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClock")
-        # Task, der regelmäßig Graphdaten sendet
-        self.taskMgr.add(self.update_graph_data, "UpdateGraphDataTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        self.sim_clock += dt
-        return Task.cont
-
-    def toggle_pause(self):
-        if not self.paused:
-            # Speichern des aktuellen speed_factor, damit wir ihn beim Resume wiederherstellen können
-            self.previous_speed_factor = self.speed_factor
-            self.speed_factor = 0  # Simulation einfrieren: alle dt-basierte Updates ergeben 0
-            self.pause_button['text'] = "Weiter"
-            self.paused = True
-            print("Gesamte Simulation angehalten")
-        else:
-            # Wiederaufnahme der Simulation: speed_factor auf den vorherigen Wert zurücksetzen
-            self.speed_factor = self.previous_speed_factor if hasattr(self, 'previous_speed_factor') else 1.0
-            self.pause_button['text'] = "Pause"
-            self.paused = False
-            print("Simulation läuft wieder")
-
-    def open_graph(self):
-        # Starte den Graphprozess per Taste G (nur, wenn er noch nicht läuft)
-        if self.graph_process is None or not self.graph_process.is_alive():
-            from multiprocessing import Queue, Process
-            self.graph_queue = Queue()
-
-            # Sende alle bisher gesammelten Daten in die Queue:
-            for data in self.graph_data:
-                try:
-                    self.graph_queue.put(data, block=False)
-                except Exception:
-                    pass
-
-            from graph_pyqt import graph_process_pyqt
-            self.graph_process = Process(target=graph_process_pyqt, args=(self.graph_queue,))
-            self.graph_process.start()
-            print("Graphprozess gestartet.")
-        else:
-            print("Graphprozess läuft bereits.")
-
-    def update_graph_data(self, task):
-        if self.sim_clock > 0:
-            ppm = self.delivered_packages / (self.sim_clock / 60)
-        else:
-            ppm = 0.0
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        avg_delivery = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        new_data = (self.sim_clock, ppm, avg_dwell, avg_delivery)
-        # Speichere alle Daten ab Simulationsbeginn:
-        self.graph_data.append(new_data)
-
-        # Zusätzlich: Falls der Graphprozess aktiv ist, schicke den neuen Datensatz auch an die Queue
-        if self.graph_queue is not None:
-            try:
-                self.graph_queue.put(new_data, block=False)
-            except Exception:
-                pass
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-
-        # Bestimme die maximale Liegedauer aktueller Pakete an den Annahmestationen
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-
-        # Lieferzeit-Kennzahlen ermitteln: für Fahrzeuge, die aktuell ein Paket tragen
-        current_delivery_time = 0.0
-        for veh in self.garage_vehicles:
-            if veh.getPythonTag("package_attached"):
-                ds = veh.getPythonTag("delivery_start_time")
-                if ds:
-                    elapsed_delivery = self.sim_clock - ds
-                    current_delivery_time = max(current_delivery_time, elapsed_delivery)
-        avg_delivery_time = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        # Aktualisiere den Info-Label-Text
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s\n"
-            f"Lieferzeit (aktuell): {current_delivery_time:.1f}s\n"
-            f"Lieferzeit (maximal): {self.max_overall_delivery_time:.1f}s\n"
-            f"Durchschn. Lieferzeit: {avg_delivery_time:.1f}s"
-        )
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        # dt jetzt skaliert mit der Simulationsgeschwindigkeit
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    # ---------------------------
-    # METHODEN FÜR RASTER, LICHT, MAUER, URSPRUNG
-    # ---------------------------
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # STATIONSOBJEKTE UND ZUORDNUNG
-    # -----------------------------------
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        """
-        Erzeugt die Annahmestationen und erstellt für jede Station:
-          - Einen weißen Marker zur Orientierung
-          - Einen grünen Punkt (optional)
-          - Eine weiße Linie, an deren Endpunkt ein blauer Marker als Ziel in der "Translate‑Phase" dient
-
-        Zusätzlich wird ein Dictionary self.station_blue_dots aufgebaut, in dem jedem Annahmestations‑Node
-        der zugehörige blaue Marker zugeordnet wird. Außerdem wird für die erste Station die globale Variable
-        self.station_white_direction festgelegt.
-        """
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        self.station_blue_dots = {}
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basisstation (zum Beispiel als Rahmen)
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Erzeuge den weißen Marker als Orientierung
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Erzeuge den grünen Punkt (optional)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zeichne die weiße Linie: Sie beginnt bei center + Vec3(0, 0, -0.5) und verläuft 3 Meter in X‑Richtung.
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Erzeuge den blauen Marker, der als Ziel in der Translate‑Phase dient
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            # Speichere den blauen Marker im Dictionary, sodass er später erzeugt werden kann
-            self.station_blue_dots[station_dummy] = blue_dot
-
-            # Optionale Textanzeige der Stationsnummer
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) – falls benötigt:
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-            # Für die erste Station (oder den ersten relevanten Pickup) setzen wir globale Referenzen,
-            # die in vehicle_order_task benötigt werden.
-            if i == 1:
-                self.blue_dot = blue_dot
-                self.station_green_dot = green_dot
-                # Berechne den Mittelpunkt der weißen Linie als Referenz (optional)
-                self.white_line_center = (start_line + end_line) * 0.5
-                line_vec = end_line - start_line
-                if line_vec.length() != 0:
-                    self.station_white_direction = Vec2(line_vec.getX(), line_vec.getY()).normalized()
-                else:
-                    self.station_white_direction = Vec2(1, 0)  # Fallback-Wert
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        self.abgabe_stations = []  # Liste der Abgabestationen
-        self.abgabe_blue_dots = []  # Liste zum Speichern der blauen Marker für die Abgabe
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basiskonstruktion der Abgabestation
-            node = self.create_abgabe_station(pt)
-            self.abgabe_stations.append(node)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Marker am Zentrum (weiß)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Grüner Punkt: center + Vec3(0, 0, -0.5)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Weiße Linie: Startet bei center + Vec3(0, 0, -0.5)
-            # und verläuft 3 Meter in negativer X-Richtung
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt: wird an der Endposition der Linie erzeugt
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            # Speichere den blauen Marker für spätere Navigation der Abgabestation
-            self.abgabe_blue_dots.append(blue_dot)
-
-            # Anzeige der Stationsnummer (textuell)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) auf der Station
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 3)
-        v5 = pos + Vec3(1, 0, 3)
-        v6 = pos + Vec3(1, 2, 3)
-        v7 = pos + Vec3(0, 2, 3)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 3)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        self.garagen_stations = []
-        self.garagen_parking_points = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            self.garagen_stations.append(pt)
-            # ParkpunktGarage: Verschoben um 0.5 in negativer Y-Richtung:
-            center = pt + Vec3(0.5, 0.5, 1.5)
-            ParkpunktGarage = center + Vec3(0, 0, 0.7)
-            self.garagen_parking_points.append(ParkpunktGarage)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def create_garage_vehicles(self):
-        self.garage_vehicles = []
-        vehicle_id_counter = 1
-        for park in self.garagen_parking_points:
-            veh = self.create_vehicle(park_point=park)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            newPos.setZ(0)
-            veh.setPos(newPos)
-
-            # Fahrzeuge starten im Standby (idle)
-            veh.setPythonTag("current_order", None)
-            veh.setPythonTag("order_state", "idle")
-            veh.setPythonTag("package_attached", False)
-            veh.setPythonTag("vehicle_id", vehicle_id_counter)
-            # Speichere den Parkpunkt als Rückkehrziel
-            veh.setPythonTag("garage_target", park)
-            # Speichere auch das Anfangs-Heading, um es später beim Parken wiederherzustellen.
-            veh.setPythonTag("start_heading", veh.getH())
-            vehicle_id_counter += 1
-
-            self.garage_vehicles.append(veh)
-
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-            # Füge einen Textknoten hinzu, der die Fahrzeugnummer vorne auf dem Fahrzeug anzeigt.
-            # Wir suchen den Mast-Knoten.
-            mast = veh.find("**/mast")
-            if not mast.isEmpty():
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)  # Schwarz
-                tn.setAlign(TextNode.ACenter)
-                text_np = mast.attachNewNode(tn)
-                # Positioniere den Text relativ zum Mast: Wir nutzen den Vektor "intersection"
-                # und versetzen ihn in Z-Richtung um 0.2 Einheiten oberhalb des Zylinders.
-                text_np.setPos(intersection.x, intersection.y, intersection.z + 0.2)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-            else:
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)
-                tn.setAlign(TextNode.ACenter)
-                text_np = veh.attachNewNode(tn)
-                text_np.setPos(0, 1.2, 1.5)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-
-            self.taskMgr.add(partial(self.vehicle_order_task, veh),
-                             f"VehicleOrderTask_{veh.getPythonTag('vehicle_id')}")
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # FAHRZEUGERSTELLUNG (FFZ20-INTEGRATION)
-    # -----------------------------------
-    def create_vehicle(self, park_point=None):
-        # Erzeuge den übergeordneten Fahrzeug-Knoten
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # --------------------------
-        # Chassis erstellen (1 x 0.5 x 1.2, Farbe Rot)
-        # --------------------------
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # --------------------------
-        # Gabel (Fork) erstellen: Zwei Zähne
-        # --------------------------
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-
-        # Speichere den Gabel-Knoten als Python-Tag am Fahrzeug
-        vehicle_node.setPythonTag("fork_node", fork_node)
-
-        # --------------------------
-        # Erzeuge den grünen Referenzmarker (Gabel – grüner Punkt)
-        # --------------------------
-        ls_new = LineSegs()
-        ls_new.setThickness(2.0)
-        ls_new.setColor(1, 1, 1, 1)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_corner_global = fork_node.getPos() + left_corner_local
-        right_corner_global = fork_node.getPos() + right_corner_local
-        ls_new.moveTo(left_corner_global)
-        ls_new.drawTo(right_corner_global)
-        vehicle_node.attachNewNode(ls_new.create())
-        midpoint = (left_corner_global + right_corner_global) * 0.5
-        white_line_vec = right_corner_global - left_corner_global
-        white_line_dir = white_line_vec.normalized() if white_line_vec.length() != 0 else Vec3(0, 0, 0)
-        candidate = Vec3(-white_line_dir.getY(), white_line_dir.getX(), 0)
-        perp_direction = candidate.normalized() if candidate.length() != 0 else Vec3(0, 0, 0)
-        green_point_global = midpoint + perp_direction * 0.5
-
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        # Speichere den grünen Marker ebenfalls als Python-Tag
-        vehicle_node.setPythonTag("fork_green", green_marker_np)
-
-        # --------------------------
-        # Mast und weitere Fahrzeugteile
-        # --------------------------
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-        self.add_diagonals_to_mast(mast_node)
-        intersection = Vec3(0.5, 0.05, 1.0)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-        self.vehicle_cylinder = cylinder_node
-
-        # --------------------------
-        # Fahrzeugpositionierung am Parkpunkt
-        # --------------------------
-        if park_point is None:
-            vehicle_node.setPos(intersection.x, intersection.y, 0)
-        else:
-            vehicle_node.setPos(park_point - vehicle_node.getQuat().xform(intersection))
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        # Verwende die simulative Zeit, die bereits in update_sim_clock hochgezählt wird
-        t = self.sim_clock
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    # -----------------------------------
-    # FEHLENDE METHODEN: Paketspawning, Würfelerzeugung u.a.
-    # -----------------------------------
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Bestimme zufällig eine Abgabestation als Ziel
-        if hasattr(self, "abgabe_stations") and self.abgabe_stations:
-            target_index = random.randint(1, len(self.abgabe_stations))
-        else:
-            target_index = 1
-
-        # Erstelle den Auftrag zur Annahmestation
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def update_order_table(self):
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen die Stationsnummer (oder verwende "N/A").
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z.B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige den zugewiesenen Fahrzeugnamen an (oder "-" falls noch keiner zugeordnet wurde).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END,
-                                   values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = 5.0  # 5 Sekunden Verzögerung zwischen Spawns
-        for station in self.annahme_stations:
-            # Wenn aktuell kein Paket an der Station ist
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                # Prüfe, ob seit der letzten Entnahme mindestens 5 Sekunden vergangen sind
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2, self.ax3) = plt.subplots(3, 1, figsize=(8, 9))
-
-        # Erster Plot: Pakete pro Minute
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-
-        # Zweiter Plot: Durchschnittliche Liegedauer
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-
-        # Dritter Plot: Durchschnittliche Lieferzeit
-        self.line3, = self.ax3.plot([], [], marker="o", color="green", label="Durchschnittliche Lieferzeit (s)")
-        self.ax3.set_xlabel("Simulationszeit (s)")
-        self.ax3.set_ylabel("Lieferzeit (s)")
-        self.ax3.set_title("Durchschnittliche Lieferzeit")
-        self.ax3.legend()
-        self.ax3.grid(True)
-
-        plt.show(block=False)
-        # Starte im Tkinter-Hauptloop eine periodische Aktualisierung:
-        self.tk_root.after(500, self.tk_graph_update)  # alle 500ms
-
-    def tk_graph_update(self):
-        # GIL sichern: Gibt einen Statuswert zurück, der später wieder freigegeben wird.
-        gil_state = ctypes.pythonapi.PyGILState_Ensure()
-        try:
-            times = [data[0] for data in self.graph_data]
-            rates = [data[1] for data in self.graph_data]
-            dwell = [data[2] for data in self.graph_data]
-            delivery = [data[3] for data in self.graph_data]
-
-            self.line1.set_data(times, rates)
-            self.ax1.relim()
-            self.ax1.autoscale_view()
-
-            self.line2.set_data(times, dwell)
-            self.ax2.relim()
-            self.ax2.autoscale_view()
-
-            self.line3.set_data(times, delivery)
-            self.ax3.relim()
-            self.ax3.autoscale_view()
-
-            self.fig.canvas.draw_idle()
-            self.fig.canvas.flush_events()
-        finally:
-            ctypes.pythonapi.PyGILState_Release(gil_state)
-
-        # Nächsten Aufruf in 500ms einplanen
-        self.tk_root.after(500, self.tk_graph_update)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Hier werden nur die gewünschten Spalten "ID", "Annahmestation", "Ziel" und "Fahrzeug" definiert.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    def pickup_package(self, vehicle, station):
-        # Falls das Fahrzeug bereits ein Paket trägt, abbrechen.
-        if vehicle.getPythonTag("package_attached"):
-            return
-
-        # Führe den Pickup nur aus, wenn an der Station ein Paket vorhanden ist.
-        if station in self.pickup_packages:
-            # Hole das Paket, den Spawn-Zeitpunkt und den zugehörigen Timer-Knoten.
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            # Entferne den Timer-Knoten, sodass der angezeigte Zähler nicht weiter aktualisiert wird.
-            timer_np.removeNode()
-            # Berechne die Liegedauer (Differenz zwischen aktueller Simulationszeit und Spawn-Zeit).
-            dwell_time = self.sim_clock - spawn_time
-            # Aktualisiere globale Kennzahlen.
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Suche in den Aufträgen nach dem Auftrag, dessen Paket mit diesem Paket übereinstimmt,
-            # und speichere den errechneten Endwert (fixe Liegedauer) sowie den Status.
-            for order_id, order in self.orders.items():
-                if order.get("package") == package:
-                    order["dwell_time"] = dwell_time
-                    order["status"] = "Abgeholt"
-                    break
-
-            # Hole Referenzen zum Gabel-Knoten und zum grünen Marker des Fahrzeugs.
-            fork_node = vehicle.getPythonTag("fork_node")
-            fork_green = vehicle.getPythonTag("fork_green")
-            green_point_pos = fork_green.getPos(fork_node)
-
-            # Übergib das Paket an den Gabel-Knoten (sodass es optisch dem Fahrzeug zugeordnet wird)
-            # und positioniere es relativ zum grünen Marker.
-            package.wrtReparentTo(fork_node)
-            package.setPos(green_point_pos.getX() + 0.5,
-                           green_point_pos.getY() - 0.5,
-                           green_point_pos.getZ() + 1)
-            self.cargos[vehicle] = package
-
-            # Starte den Lieferzeit-Timer: Speichere den Zeitpunkt, an dem das Paket abgeholt wurde,
-            # und hänge einen neuen Timer-Knoten an das Paket.
-            vehicle.setPythonTag("delivery_start_time", self.sim_clock)
-            from panda3d.core import TextNode
-            delivery_timer_text = TextNode("delivery_timer")
-            delivery_timer_text.setText("0.0s")
-            delivery_timer_np = package.attachNewNode(delivery_timer_text)
-            delivery_timer_np.setScale(0.5)
-            delivery_timer_np.setPos(0, 0, 1.2)
-            package.setPythonTag("delivery_timer", delivery_timer_np)
-
-            # Aktualisiere den Zeitpunkt, zu dem an dieser Station zuletzt ein Paket entfernt wurde.
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-
-            # Berechne Lieferzeit:
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start is not None:
-                delivery_time = self.sim_clock - delivery_start
-                self.total_delivery_time += delivery_time
-                self.total_delivery_count += 1
-                self.max_overall_delivery_time = max(self.max_overall_delivery_time, delivery_time)
-                vehicle.clearPythonTag("delivery_start_time")
-
-            # Entferne den Lieferzeit-Timer vom Paket
-            delivery_timer_np = cargo.getPythonTag("delivery_timer")
-            if delivery_timer_np:
-                delivery_timer_np.removeNode()
-
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden das Paket entfernt
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def update_delivery_timers(self, task):
-        for vehicle, package in list(self.cargos.items()):
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start:
-                elapsed_delivery = self.sim_clock - delivery_start
-                delivery_timer_np = package.getPythonTag("delivery_timer")
-                if delivery_timer_np and not delivery_timer_np.isEmpty():
-                    delivery_timer_np.node().setText(f"{elapsed_delivery:.1f}s")
-        return Task.cont
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-
-    def select_next_order(self, vehicle):
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        for order in waiting_orders:
-            dwell_time = self.sim_clock - order.get("spawn_time", self.sim_clock)
-            order["dwell_time"] = dwell_time
-
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        vehicle_pos = vehicle.getPos(self.render)
-
-        def distance_to_station(order):
-            station = order.get("pickup_station")
-            if station:
-                station_pos = station.getPos(self.render)
-                return (station_pos - vehicle_pos).length()
-            return float('inf')
-
-        candidates.sort(key=distance_to_station)
-        chosen_order = candidates[0]
-        chosen_order["vehicle"] = f"Fahrzeug {vehicle.getPythonTag('vehicle_id')}"
-        return chosen_order
-
-    def vehicle_order_task(self, vehicle, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-
-        # Wenn das Fahrzeug im "idle"-Zustand steht, soll es nichts tun.
-        if vehicle.getPythonTag("order_state") == "idle":
-            return task.cont
-
-        state = vehicle.getPythonTag("order_state")
-        current_order = vehicle.getPythonTag("current_order")
-
-        # ------------------ Phase 1: Translate ------------------
-        if state == "translate":
-            if current_order is None:
-                next_order = self.select_next_order(vehicle)
-                if next_order is not None:
-                    vehicle.setPythonTag("current_order", next_order)
-                    next_order["status"] = "In Bearbeitung"
-                    print(
-                        f"Auftrag {next_order['id']} wird zugewiesen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}.")
-                else:
-                    print("Kein Auftrag verfügbar – Fallback zum globalen Ziel.")
-            current_order = vehicle.getPythonTag("current_order")
-            if current_order is not None:
-                pickup_station = current_order.get("pickup_station")
-                if pickup_station in self.station_blue_dots:
-                    blue_target = self.station_blue_dots[pickup_station].getPos(self.render)
-                else:
-                    blue_target = self.blue_dot.getPos(self.render)
-            else:
-                blue_target = self.blue_dot.getPos(self.render)
-            local_mast = Vec3(0.5, 0.05, 1.0)
-            mast_global = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(local_mast)
-            target_xy = Vec2(blue_target.getX(), blue_target.getY())
-            mast_xy = Vec2(mast_global.getX(), mast_global.getY())
-            error_vector = target_xy - mast_xy
-            threshold = 0.05
-            if error_vector.length() > threshold:
-                direction = error_vector.normalized()
-                move_distance = 1.5 * dt
-                current_pos = vehicle.getPos(self.render)
-                new_pos = Vec3(current_pos.getX() + direction.getX() * move_distance,
-                               current_pos.getY() + direction.getY() * move_distance, 0)
-                vehicle.setPos(new_pos)
-            else:
-                local_offset = vehicle.getQuat(self.render).xform(local_mast)
-                exact_pos = Vec3(blue_target.getX() - local_offset.getX(),
-                                 blue_target.getY() - local_offset.getY(), 0)
-                vehicle.setPos(exact_pos)
-                vehicle.setPythonTag("order_state", "rotate")
-
-        # ------------------ Phase 2: Rotate ------------------
-        elif state == "rotate":
-            desired_angle = math.degrees(math.atan2(self.station_white_direction.getY(),
-                                                    self.station_white_direction.getX()))
-            desired_angle = (desired_angle + 180) % 360
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_angle - current_heading + 180) % 360) - 180
-            kp_heading = 0.5
-            new_heading = current_heading + kp_heading * angle_diff
-            vehicle.setH(new_heading)
-            if abs(angle_diff) < 1.0:
-                vehicle.setPythonTag("order_state", "turn_right")
-
-        # ------------------ Phase 3: Turn Right ------------------
-        elif state == "turn_right":
-            if vehicle.getPythonTag("turn_right_init") is None:
-                vehicle.setPythonTag("turn_right_init", vehicle.getH() % 360)
-                vehicle.setPythonTag("turn_right_target", (vehicle.getPythonTag("turn_right_init") + 90) % 360)
-                print("Phase 3: Initialisiert für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "Start Heading =", vehicle.getPythonTag("turn_right_init"),
-                      "Target Heading =", vehicle.getPythonTag("turn_right_target"))
-            current_heading = vehicle.getH() % 360
-            turn_right_target = vehicle.getPythonTag("turn_right_target")
-            angle_diff = ((turn_right_target - current_heading + 180) % 360) - 180
-            kp_turn = 0.5
-            turn_rate = kp_turn * angle_diff
-            new_heading = current_heading + turn_rate * dt
-            vehicle.setH(new_heading)
-            print("Phase 3: Fahrzeug", vehicle.getPythonTag("vehicle_id"), "- Aktuelles Heading =", current_heading,
-                  "Winkelabweichung =", angle_diff, "Neues Heading =", new_heading)
-            if abs(angle_diff) < 1.0:
-                print("Phase 3: Drehung abgeschlossen für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      ". Übergang in 'approach'.")
-                vehicle.setPythonTag("order_state", "approach")
-                vehicle.clearPythonTag("turn_right_init")
-                vehicle.clearPythonTag("turn_right_target")
-
-        # ------------------ Phase 4: Approach ------------------
-        elif state == "approach":
-            if current_order is not None:
-                pickup_station = current_order.get("pickup_station")
-                target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-            else:
-                target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-            current = vehicle.getPos(self.render)
-            error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-            if error_vec.length() > 0.05:
-                direction = error_vec.normalized()
-                move_distance = 1.5 * dt
-                new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                               current.getY() + direction.getY() * move_distance, target.getZ())
-                vehicle.setPos(new_pos)
-            else:
-                vehicle.setPos(target)
-                vehicle.setPythonTag("order_state", "pickup")
-
-        # ------------------ Phase 5: Pickup ------------------
-        elif state == "pickup":
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            target_z = 1.0
-            raise_speed = 0.5
-            if current_z < target_z:
-                fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-            else:
-                if current_order is None:
-                    if self.orders_queue:
-                        vehicle.setPythonTag("current_order", self.orders_queue.pop(0))
-                    else:
-                        print("Keine verfügbaren Aufträge für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                              ". Überspringe Pickup-Phase.")
-                        vehicle.setPythonTag("order_state", "drive_out")
-                        return task.cont
-                # Nur wenn noch kein Paket am Fahrzeug befestigt ist:
-                if not vehicle.getPythonTag("package_attached"):
-                    pickup_station = vehicle.getPythonTag("current_order")["pickup_station"]
-                    self.pickup_package(vehicle, pickup_station)
-                    vehicle.setPythonTag("package_attached", True)
-                # Setze drive_out_target, falls noch nicht vorhanden
-                if vehicle.getPythonTag("drive_out_target") is None:
-                    vehicle.setPythonTag("drive_out_target",
-                                         vehicle.getPos(self.render) + vehicle.getQuat(self.render).getForward() * 5.0)
-                vehicle.setPythonTag("order_state", "drive_out")
-
-        # ------------------ Phase 6: Drive Out ------------------
-        elif state == "drive_out":
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            if current_z > 0.0:
-                lower_speed = 0.5
-                fork_node.setZ(max(0.0, current_z - lower_speed * dt))
-            current_pos = vehicle.getPos(self.render)
-            drive_out_target = vehicle.getPythonTag("drive_out_target")
-            if drive_out_target is None:
-                drive_out_target = current_pos + vehicle.getQuat(self.render).getForward() * 5.0
-                vehicle.setPythonTag("drive_out_target", drive_out_target)
-            diff = drive_out_target - current_pos
-            if diff.length() > 0.1:
-                move_distance = 0.5 * dt
-                step = diff.normalized() * move_distance
-                new_pos = current_pos + step
-                new_pos.setZ(0)  # Sicherstellen, dass das Fahrzeug auf dem Boden bleibt
-                vehicle.setPos(new_pos)
-            else:
-                vehicle.setPythonTag("order_state", "to_delivery")
-                vehicle.setPythonTag("drive_out_target", None)
-
-        # ------------------ Phase 7: To Delivery ------------------
-        elif state == "to_delivery":
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current_pos = vehicle.getPos(self.render)
-            diff = blue_target - current_pos
-            threshold = 0.5
-            move_distance = 1.5 * dt
-            if move_distance > diff.length():
-                vehicle.setPos(blue_target)
-            else:
-                vehicle.setPos(current_pos + diff.normalized() * move_distance)
-            if (blue_target - vehicle.getPos(self.render)).length() <= threshold:
-                print("Phase 7 abgeschlossen: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "hat den blauen Punkt der Abgabestation erreicht.")
-                vehicle.setPythonTag("order_state", "align_delivery")
-
-        # ------------------ Phase 8: Align Delivery ------------------
-        elif state == "align_delivery":
-            desired_heading = 90.0
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_heading - current_heading + 180) % 360) - 180
-            print("Phase 8: Align Delivery | Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                  "Current Heading: {:.2f}°, Desired: {:.2f}°, Diff: {:.2f}°".format(current_heading, desired_heading,
-                                                                                     angle_diff))
-            fixed_turn_speed = 90.0
-            turn_amount = fixed_turn_speed * dt
-            if abs(angle_diff) < 1.0:
-                vehicle.setH(desired_heading)
-                print("Phase 8 abgeschlossen: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "ausgerichtet (Heading = {:.2f}°).".format(desired_heading))
-                vehicle.setPythonTag("order_state", "delivery_center")
-            else:
-                if angle_diff > 0:
-                    new_heading = current_heading + turn_amount
-                else:
-                    new_heading = current_heading - turn_amount
-                new_heading %= 360
-                vehicle.setH(new_heading)
-                print("Phase 8: Rotating - Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "New Heading set to {:.2f}°".format(new_heading))
-
-        # ------------------ Phase 9: Delivery Approach ------------------
-        elif state == "delivery_center":
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current = vehicle.getPos(self.render)
-            target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-            print("Phase 9: Zielpunkt der Abgabestation für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                  "=", target_point)
-            error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-            tolerance = 0.05
-            move_distance = 1.5 * dt
-            if error_vec.length() > tolerance:
-                direction = error_vec.normalized()
-                new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                               current.getY() + direction.getY() * move_distance, current.getZ())
-                vehicle.setPos(new_pos)
-                print("Phase 9: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "bewegt sich von", current, "nach", new_pos)
-            else:
-                vehicle.setPos(target_point)
-                print("Phase 9: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "hat den Zielpunkt erreicht.")
-                vehicle.setPythonTag("order_state", "drop")
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_fork_z = fork_node.getZ()
-            if current_fork_z < 1.0:
-                new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-                fork_node.setZ(new_fork_z)
-                print("Phase 9: Gabel wird angehoben für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "(Z =", new_fork_z, ").")
-
-        # ------------------ Phase 10: Dropoff ------------------
-        elif state == "drop":
-            if vehicle.getPythonTag("package_attached"):
-                delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-                self.drop_cargo(vehicle)
-                print("Phase 10: Paket abgesetzt für Fahrzeug", vehicle.getPythonTag("vehicle_id"))
-                vehicle.setPythonTag("package_attached", False)
-            else:
-                fork_node = vehicle.getPythonTag("fork_node")
-                current_z = fork_node.getZ()
-                if current_z > 0.0:
-                    lower_speed = 0.5
-                    new_z = max(0.0, current_z - lower_speed * dt)
-                    fork_node.setZ(new_z)
-                    print("Phase 10: Gabel wird abgesenkt für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          ", aktueller Z-Wert =", new_z)
-                else:
-                    print("Phase 10: Dropoff vollständig abgeschlossen für Fahrzeug",
-                          vehicle.getPythonTag("vehicle_id"))
-                    # Prüfe, ob Standby angefordert wurde:
-                    if vehicle.getPythonTag("standby_pending"):
-                        vehicle.setPythonTag("order_state", "return_to_garage")
-                        print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} kehrt zur Garage zurück (Standby).")
-                    else:
-                        vehicle.setPythonTag("order_state", "translate")
-                    current_order["status"] = "Abgegeben"
-                    current_order["delivered_at"] = self.sim_clock
-                    vehicle.setPythonTag("current_order", None)
-
-        # ------------------ Neue Phase: Return to Garage (Standby) ------------------
-        elif state == "return_to_garage":
-            garage_target = vehicle.getPythonTag("garage_target")
-            if garage_target is None:
-                garage_target = self.garagen_parking_points[0]
-            current_pos = vehicle.getPos(self.render)
-            diff = garage_target - current_pos
-            if diff.length() > 0.1:
-                move_distance = 1.0 * dt
-                new_pos = current_pos + diff.normalized() * move_distance
-                new_pos.setZ(0)  # Sicherstellen, dass das Fahrzeug am Boden bleibt.
-                vehicle.setPos(new_pos)
-            else:
-                # Setze das Ausgangs-Heading wieder zurück
-                if vehicle.hasPythonTag("start_heading"):
-                    vehicle.setH(vehicle.getPythonTag("start_heading"))
-                vehicle.setPythonTag("order_state", "idle")
-                vehicle.setPythonTag("standby_pending", False)
-                print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} ist in der Garage (Standby).")
-
-        # ------------------ Phase 11: Exit Station and Start Next Order ------------------
-        elif state == "phase11":
-            if vehicle.getPythonTag("last_delivery_marker") is not None:
-                target_point = vehicle.getPythonTag("last_delivery_marker")
-            else:
-                delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    target_point = self.abgabe_blue_dots[0].getPos(self.render)
-                print("Phase 11: Zielpunkt (blauer Marker) für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "=", target_point)
-                current_pos = vehicle.getPos(self.render)
-                diff = target_point - current_pos
-                if diff.length() > 0.1:
-                    move_distance = 0.5 * dt
-                    step = diff.normalized() * move_distance
-                    vehicle.setPos(current_pos + step)
-                    print("Phase 11: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          "fährt aus der Station, neue Position =", current_pos + step)
-                else:
-                    vehicle.setPos(target_point)
-                    print("Phase 11: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          "hat den blauen Marker erreicht. Nächster Auftrag wird gestartet.")
-                    vehicle.setPythonTag("order_state", "next_order")
-
-        return task.cont
-
-    # Neue Methode: Kontrollfenster zur Fahrzeugsteuerung
-    def show_vehicle_control(self):
-        # Falls das Fenster bereits existiert, bringe es einfach in den Vordergrund,
-        # ohne die Radiobuttons neu zu initialisieren.
-        if hasattr(self, "control_win") and self.control_win.winfo_exists():
-            self.control_win.deiconify()
-            self.control_win.lift()
-            self.control_win.focus_force()
-            return
-
-        # Erstelle das Kontrollfenster als Toplevel des persistenten tk_root.
-        self.control_win = tk.Toplevel(self.tk_root)
-        self.control_win.title("Fahrzeugsteuerung")
-        # Beim Schließen soll das Fenster nicht zerstört, sondern nur versteckt werden
-        self.control_win.protocol("WM_DELETE_WINDOW", self.control_win.withdraw)
-        # Sorge dafür, dass das Fenster initial über allem liegt
-        self.control_win.attributes("-topmost", True)
-        self.control_win.after(100, lambda: self.control_win.attributes("-topmost", False))
-
-        # Erzeuge das Dictionary für die StringVar-Zuordnungen für die Fahrzeuge.
-        self.vehicle_state_vars = {}
-        row = 0
-        for veh in self.garage_vehicles:
-            frame = tk.Frame(self.control_win)
-            frame.grid(row=row, column=0, sticky="w", padx=5, pady=2)
-            vid = veh.getPythonTag("vehicle_id")
-            label = tk.Label(frame, text=f"Fahrzeug {vid}")
-            label.pack(side=tk.LEFT)
-            # Initialisiere die Radiobutton-Variable anhand des aktuellen Fahrzeugzustandes.
-            state = veh.getPythonTag("order_state")
-            if state is None:
-                state = "idle"
-            var = tk.StringVar(value=state)
-            self.vehicle_state_vars[veh] = var
-            rb_active = tk.Radiobutton(frame, text="Aufträge bearbeiten", variable=var, value="translate")
-            rb_active.pack(side=tk.LEFT)
-            rb_standby = tk.Radiobutton(frame, text="Standby", variable=var, value="idle")
-            rb_standby.pack(side=tk.LEFT)
-            row += 1
-        update_btn = tk.Button(self.control_win, text="Übernehmen", command=self.update_vehicle_control)
-        update_btn.grid(row=row, column=0, pady=5)
-
-    def update_vehicle_control(self):
-        for veh, var in self.vehicle_state_vars.items():
-            new_state = var.get()
-            if new_state == "idle" and veh.getPythonTag("current_order") is not None:
-                veh.setPythonTag("standby_pending", True)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Standby angefordert (Auftrag wird fortgesetzt).")
-            else:
-                veh.setPythonTag("standby_pending", False)
-                veh.setPythonTag("order_state", new_state)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Zustand auf {new_state} gesetzt.")
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-
-if __name__ == "__main__":
-    # Wichtig: setze auf Windows die Startmethode auf "spawn"
-    multiprocessing.set_start_method('spawn')
-
-    # Erzeuge eine Queue, auch wenn sie später eventuell neu erstellt wird, wenn "G" gedrückt wird.
-    graph_q = Queue()
-    app = LagerSimulation(graph_q)
-    app.run()
-
-    # Beim Schließen der Simulation den Graphprozess ggf. beenden
-    if app.graph_process is not None:
-        app.graph_process.terminate()
-        app.graph_process.join()
-
-
Index: Grundmodell/Gm6.py
===================================================================
diff --git a/Grundmodell/Gm6.py b/Grundmodell/Gm6.py
deleted file mode 100644
--- a/Grundmodell/Gm6.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,609 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Für das Paketspawning an den Annahmestationen
-        self.pickup_packages = {}  # station (NodePath) -> (Paket, Spawnzeit, Timer Node)
-        self.last_removed = {}  # station -> Zeitpunkt der letzten Entfernung
-
-        # Für Graph-Daten und Steuerung
-        self.graph_data = []  # Tupel: (Sim-Zeit, Pakete pro Minute, Durchschnittliche Liegedauer)
-        self.graph_opened = False
-
-        # Ursprung (Koordinatenachsen)
-        self.draw_origin()
-
-        # Kameraeinstellungen: Das ganze Feld soll gut sichtbar sein.
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # Licht und Bodenraster erzeugen
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-
-        # Erzeuge die Mauer (das umschließende Rechteck)
-        self.create_wall()
-
-        # Erzeuge Annahme-, Abgabe- und Garagenstationen
-        self.create_annahme_stations()
-        self.create_abgabe_stations()
-        self.create_garagen_stations()
-
-        # Setze auf ALLE Annahmestationen ein Paket
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # UI: Slider und Info-Anzeige zur Simulationssteuerung
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktion: Mit dem Mausrad hereinz- bzw. herauszoomen.
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        # Graph in extra Fenster per Taste "g" öffnen
-        self.accept("g", self.open_graph)
-
-        # Tasks: Aktualisierung der Simulationszeit, Info-Anzeige, Paketspawning, Paket-Timer und Graph-Daten
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-
-        # Bestimme aktuelle maximale Liegedauer aller wartenden Pakete
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        # X-Achse (rot)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        # Y-Achse (grün)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        # Z-Achse (blau)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # Original Funktion: Annahme-Station (ohne Z-Verschiebung)
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_annahme_station(pt)
-            # Dummy-Node als Referenz für das Paketspawning
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-            # Ursprünglicher Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Zusätzlicher grüner Punkt: 0.5 in positive Z-Richtung vom Mittelpunkt
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, 0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zusätzliche Linie: 3 Meter in positive X-Richtung vom grünen Punkt; Farbe weiß
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, 0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt am Ende der Linie
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            # Dekorative Kreuze
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-    # Original Funktion: Abgabestation (ohne Z-Verschiebung)
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_abgabe_station(pt)
-            # Ursprünglicher Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Zusätzlicher grüner Punkt: 0.5 in positive Z-Richtung vom Mittelpunkt
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, 0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zusätzliche Linie: 3 Meter in negative X-Richtung vom grünen Punkt; Farbe weiß
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, 0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt am Ende der Linie
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            # Dekorative Kreuze
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 2)
-        v5 = pos + Vec3(1, 0, 2)
-        v6 = pos + Vec3(1, 2, 2)
-        v7 = pos + Vec3(0, 2, 2)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        # Dekorative Kreuze auf geschlossenen Seiten (nicht auf dem Dach)
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 2)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            center = pt + Vec3(0.5, 1, 1)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    # Methoden für Paketspawning und Timer
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        cube = self.loader.loadModel("models/box")
-        cube.setScale(1, 1, 1)
-        cube.setPos(x, y, z + 1)
-        cube.setColor(farbe)
-        cube.reparentTo(self.render)
-        return cube
-
-    def check_and_spawn_packages(self, task):
-        # Wenn ein Paket abtransportiert wird, soll nach 10 Sekunden das nächste Paket spawnen.
-        # spawn_delay wird nun auf 10 Sekunden (in Simulationszeit) gesetzt.
-        spawn_delay = self.sim_time(10)
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-    def update_package_timers(self, task):
-        # Diese Methode aktualisiert nur den angezeigten Timer.
-        # Das Paket wird hier nicht automatisch entfernt.
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            elapsed = self.sim_clock - spawn_time
-            timer_np.node().setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor != 0 else t
-
-    # Methoden für graphische Darstellung der Kennzahlen
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.setTitle("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.setTitle("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: FFZ/FFZ12.py
===================================================================
diff --git a/FFZ/FFZ12.py b/FFZ/FFZ12.py
deleted file mode 100644
--- a/FFZ/FFZ12.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,428 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    LineSegs,
-    Vec3,
-    NodePath
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import math
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kameraeinstellungen (Fahrtrichtung: entlang Y-Achse)
-        self.cam.setPos(0, -30, 10)
-        self.cam.lookAt(0, 0, 0)
-
-        # Licht und Raster
-        self.setup_light()
-        self.create_grid(center_extent=10, cell_size=0.1)
-
-        # Fahrzeug erstellen und referenzieren
-        self.vehicle = self.create_vehicle()
-
-        # Slider für Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Slider zur Steuerung der Forkhöhe (0 bis 1 Meter)
-        self.fork_slider = DirectSlider(
-            range=(0.0, 1.0),
-            value=0.0,
-            pageSize=0.01,
-            command=self.update_fork_height,
-            pos=(-0.7, 0, -0.85),
-            scale=0.3
-        )
-        self.fork_label = DirectLabel(
-            text="Fork Höhe: 0.00m",
-            pos=(-0.7, 0, -0.75),
-            scale=0.07
-        )
-
-        # Laufzeitanzeige
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom via Mausrad
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben hinzufügen
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_cable, "UpdateCableTask")
-        # Das Fahrzeug fährt stationär.
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_fork_height(self, height=0, *args):
-        try:
-            height = float(height)
-        except ValueError:
-            height = 0.0
-        self.fork_node.setZ(height)
-        self.fork_label['text'] = f"Fork Höhe: {height:.2f}m"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def create_grid(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            x += cell_size
-
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        grid_np = self.render.attachNewNode(node)
-        grid_np.setColor(0.7, 0.7, 0.7, 1)
-        return grid_np
-
-    def setup_light(self):
-        ambient_light = AmbientLight("ambient_light")
-        ambient_light.setColor((0.5, 0.5, 0.5, 1))
-        ambient_np = self.render.attachNewNode(ambient_light)
-        self.render.setLight(ambient_np)
-
-        directional_light = DirectionalLight("directional_light")
-        directional_light.setColor((1, 1, 1, 1))
-        directional_np = self.render.attachNewNode(directional_light)
-        directional_np.setPos(10, -10, 10)
-        self.render.setLight(directional_np)
-
-    def create_vehicle(self):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Fahrmodul (Chassis): 1 x 0.5 x 1.2, rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        # Kanten des Fahrmoduls (Chassis) in Schwarz
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # Gabelmodul (Fork): Zwei Zähne (0.2 x 1.2 x 0.1)
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-        self.fork_node = fork_node
-
-        # Mast: Rahmen aus vier Balken
-        mast_node = vehicle_node.attachNewNode("mast")
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-
-        # Diagonalen auf der oberen Fläche des Mastes
-        self.add_diagonals_to_mast(mast_node)
-        # Schnittpunkt der Diagonalen (in Mast-Koordinaten)
-        intersection = Vec3(0.5, 0.05, 1.0)
-
-        # Gelber Zylinder: Durchmesser 0.1, Höhe 0.1, Farbe Gelb (1,1,0,1)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        # Lidar-Kreis: Mittelpunkt soll 1m in negativer Z-Richtung liegen; also z = -1.
-        lidar_center = Vec3(intersection.x, intersection.y, -1)
-        self.add_lidar_circle(mast_node, lidar_center, 2)
-
-        vehicle_node.setPos(-0.5, 0, 0)
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)  # Orange
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)  # Grün
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        # Top center
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        # Top circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        # Bottom center
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        # Bottom circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        # Top fan
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        # Bottom fan
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        # Side faces
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        # Unterseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        # Oberseite
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        # Vorderseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        # Rückseite
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        # Linke Seite
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        # Rechte Seite
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base+1, base+2)
-            tris.closePrimitive()
-            tris.addVertices(base, base+2, base+3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        # Unterkante
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        # Oberkante
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        # Vertikale Kanten
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        self.fork_label['text'] = f"Fork Höhe: {new_height:.2f}m"
-        return Task.cont
-
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: FFZ/FFZ2.py
===================================================================
diff --git a/FFZ/FFZ2.py b/FFZ/FFZ2.py
deleted file mode 100644
--- a/FFZ/FFZ2.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,267 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte für Simulationszeit und -geschwindigkeit
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kameraeinstellungen: Wir positionieren die Kamera so, dass das Fahrzeug gut sichtbar ist.
-        # Es wird angenommen, dass die Fahrtrichtung entlang der Y-Achse (positiv) verläuft.
-        self.cam.setPos(0, -30, 10)
-        self.cam.lookAt(0, 0, 0)
-
-        # Licht und Raster (Raster-Zellen: 0.1 x 0.1)
-        self.setup_light()
-        self.create_grid(center_extent=10, cell_size=0.1)
-
-        # Fahrzeug erstellen
-        self.create_vehicle()
-
-        # Slider zur Anpassung der Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Anzeige der Laufzeit
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktionalität: Mausrad heran-/herauszoomen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben zur Aktualisierung der Simulationszeit und Anzeige
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def create_grid(self, center_extent=40, cell_size=1):
-        """
-        Erstellt ein Raster in der XY-Ebene mit einer Zellengröße,
-        wobei Z=0 der Boden ist.
-        """
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        # Horizontale Linien
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            y += cell_size
-
-        # Vertikale Linien
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            x += cell_size
-
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        grid_np = self.render.attachNewNode(node)
-        grid_np.setColor(0.7, 0.7, 0.7, 1)
-        return grid_np
-
-    def setup_light(self):
-        ambient_light = AmbientLight("ambient_light")
-        ambient_light.setColor((0.5, 0.5, 0.5, 1))
-        ambient_np = self.render.attachNewNode(ambient_light)
-        self.render.setLight(ambient_np)
-
-        directional_light = DirectionalLight("directional_light")
-        directional_light.setColor((1, 1, 1, 1))
-        directional_np = self.render.attachNewNode(directional_light)
-        directional_np.setPos(10, -10, 10)
-        self.render.setLight(directional_np)
-
-    def create_vehicle(self):
-        """
-        Erzeugt ein fahrerloses Transportfahrzeug als 3D-Modell,
-        bestehend aus drei lückenlos verbundenen Modulen:
-
-          • Fahrmodul (Chassis): Größe 1 x 0.5 x 1.2,
-            platziert von (0,0,0) bis (1,0.5,1.2).
-
-          • Gabelmodul (Fork): Größe 1 x 1.2 x 0.2,
-            wird hinten am Fahrmodul angesetzt.
-            (Durch Verschiebung um -1.2 in Y liegt es von y = -1.2 bis 0.)
-
-          • Mast: Größe 1 x 0.1 x 1,
-            sitzt oben auf dem Fahrmodul (beginnt bei z = 1.2) und wird in Y zentriert.
-        """
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Fahrmodul (Chassis) – Farbe: Rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)  # Bereich: x: 0-1, y: 0-0.5, z: 0-1.2
-
-        # Gabelmodul (Fork) – Farbe: Grau, Höhe jetzt 0.2 statt 0.3
-        box_fork = self.create_box(1, 1.2, 0.2, (0.3, 0.3, 0.3, 1))
-        node_fork = vehicle_node.attachNewNode(box_fork)
-        node_fork.setTwoSided(True)
-        node_fork.setPos(0, -1.2, 0)  # Bereich: x: 0-1, y: -1.2 bis 0, z: 0-0.2
-
-        # Mast – Farbe: Dunkles Grau (0.2, 0.2, 0.2, 1)
-        box_mast = self.create_box(1, 0.1, 1, (0.2, 0.2, 0.2, 1))
-        node_mast = vehicle_node.attachNewNode(box_mast)
-        node_mast.setTwoSided(True)
-        node_mast.setPos(0, 0.2, 1.2)  # Bereich: x: 0-1, y: 0.2-0.3, z: 1.2-2.2
-
-        # Zentriere den gesamten Fahrzeugknoten in X
-        vehicle_node.setPos(-0.5, 0, 0)
-
-    def create_box(self, width, depth, height, color):
-        """
-        Erzeugt einen vollflächigen Quader (Box) mit den Dimensionen:
-          - Breite (X): width
-          - Tiefe (Y): depth
-          - Höhe (Z): height
-
-        Für jede Seite werden eigene Eckpunkte mit korrekten Normalen erzeugt,
-        sodass das Objekt wirklich solide wirkt.
-        """
-        format = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData('box', format, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, 'vertex')
-        normal = GeomVertexWriter(vdata, 'normal')
-        col = GeomVertexWriter(vdata, 'color')
-
-        # Unterseite (z = 0) mit Normal (0, 0, -1)
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-
-        # Oberseite (z = height) mit Normal (0, 0, 1)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-
-        # Vorderseite (y = 0) mit Normal (0, -1, 0)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-
-        # Rückseite (y = depth) mit Normal (0, 1, 0)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-
-        # Linke Seite (x = 0) mit Normal (-1, 0, 0)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-
-        # Rechte Seite (x = width) mit Normal (1, 0, 0)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        triangles = GeomTriangles(Geom.UHStatic)
-        # Jede Seite besteht aus 2 Dreiecken (insgesamt 12 Dreiecke)
-        for i in range(6):
-            base = i * 4
-            triangles.addVertices(base, base + 1, base + 2)
-            triangles.closePrimitive()
-            triangles.addVertices(base, base + 2, base + 3)
-            triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(triangles)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: Feld/Feld4.py
===================================================================
diff --git a/Feld/Feld4.py b/Feld/Feld4.py
deleted file mode 100644
--- a/Feld/Feld4.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,319 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec3,
-    LineSegs,
-    CardMaker,
-    TextNode
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import math
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte für Simulationszeit und -geschwindigkeit
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Ursprung (Koordinatenachsen) zeichnen
-        self.draw_origin()
-
-        # Kameraeinstellungen: So, dass das gesamte Feld gut sichtbar ist.
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # Erzeuge Licht und Bodenraster
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-
-        # Erzeuge die Mauer (flush, bündig ein Rechteck abschließend)
-        # Eckpunkte: (0,0,0), (0,60,0), (22,60,0) und (22,0,0)
-        self.create_wall()
-
-        # Erzeuge Annahmestationen an den vorgegebenen Positionen
-        self.create_annahme_stations()
-
-        # Slider zur Anpassung der Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Anzeige der Kennzahlen (z. B. Laufzeit)
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktion: Mit Mausrad hereinz- bzw. herauszoomen.
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben: Simulationszeit fortlaufend aktualisieren.
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-
-    def draw_origin(self):
-        """Zeichnet die drei farbigen Achsen im Ursprung (0,0,0)."""
-        ls = LineSegs()
-        ls.setThickness(2)
-        # X-Achse (rot)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        # Y-Achse (grün)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        # Z-Achse (blau)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        # Horizontale Linien
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        # Vertikale Linien
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        """
-        Erzeugt vier Wandsegmente, die ein Rechteck abschließen.
-        Die vier Eckpunkte sind:
-          p1 = (0, 0, 0)
-          p2 = (0, 60, 0)
-          p3 = (22, 60, 0)
-          p4 = (22, 0, 0)
-        Der innere Rand der Mauer liegt exakt auf diesen Punkten.
-        """
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        """
-        Fügt ein Wandsegment hinzu – sodass dessen innere Kante
-        exakt die Verbindung zwischen 'start' und 'end' bildet.
-        Die Eckpunkte werden in Clockwise-Reihenfolge angegeben.
-        """
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-
-        d = seg_vector.normalized()
-        # Für Clockwise angegebene Eckpunkte (innerer Bereich rechts) berechnen wir:
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        # Pivot-Korrektur: Zentriere das Modell anhand der TightBounds.
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def create_annahme_station(self, pos):
-        """
-        Erzeugt eine Annahmestation als 1×1×1-Würfel aus Linien (Gitter) in Grün.
-        Die Seite in positiver X-Richtung (x = 1) bleibt offen.
-        'pos' wird als untere linke Ecke des Würfels verwendet.
-        """
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        # Lokale Eckpunkte relativ zu pos:
-        v0 = pos + Vec3(0, 0, 0)   # unten, links, hinten
-        v1 = pos + Vec3(1, 0, 0)   # unten, rechts, hinten
-        v2 = pos + Vec3(1, 1, 0)   # unten, rechts, vorne
-        v3 = pos + Vec3(0, 1, 0)   # unten, links, vorne
-        v4 = pos + Vec3(0, 0, 1)   # oben, links, hinten
-        v5 = pos + Vec3(1, 0, 1)   # oben, rechts, hinten
-        v6 = pos + Vec3(1, 1, 1)   # oben, rechts, vorne
-        v7 = pos + Vec3(0, 1, 1)   # oben, links, vorne
-
-        # Untere Fläche (z=0)
-        ls.moveTo(v0)
-        ls.drawTo(v1)    # v0->v1 (wird gezeichnet, da nur ein Endpunkt x==1 hat)
-        # v1->v2: beide Punkte haben x==1 → diese Kante bleibt offen
-        ls.moveTo(v2)
-        ls.drawTo(v3)    # v2->v3
-        ls.moveTo(v3)
-        ls.drawTo(v0)    # v3->v0
-
-        # Obere Fläche (z=1)
-        ls.moveTo(v4)
-        ls.drawTo(v5)    # v4->v5 (wird gezeichnet, da v4.x=0, v5.x=1)
-        # v5->v6: beide Punkte haben x==1 → weglassen
-        ls.moveTo(v6)
-        ls.drawTo(v7)    # v6->v7
-        ls.moveTo(v7)
-        ls.drawTo(v4)    # v7->v4
-
-        # Vertikale Kanten (nur jene, bei denen nicht beide Enden x==1 sind)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        """
-        Platziert Annahmestationen an den vorgegebenen Positionen:
-          (1, 5, 0), (1, 10, 0), (1, 15, 0), (1, 20, 0), (1, 25, 0),
-          (1, 30, 0), (1, 35, 0), (1, 40, 0), (1, 45, 0) und (1, 50, 0).
-        Zusätzlich wird an jeder Station ein Mittelpunktmarker (kleine weiße Kugel) im Zentrum gesetzt.
-        Ferner wird die Stationsnummer als Text (in Schwarz) angezeigt.
-        Der Text wird so ausgerichtet, dass er flach auf dem Boden in der X‑Y Ebene liegt.
-        """
-        station_points = [
-            Vec3(1, 5, 0), Vec3(1, 10, 0), Vec3(1, 15, 0),
-            Vec3(1, 20, 0), Vec3(1, 25, 0), Vec3(1, 30, 0),
-            Vec3(1, 35, 0), Vec3(1, 40, 0), Vec3(1, 45, 0),
-            Vec3(1, 50, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            # Erzeuge die Annahmestation (Gitterwürfel)
-            self.create_annahme_station(pt)
-            # Füge einen Mittelpunktmarker hinzu (kleine weiße Kugel im Zentrum der Station)
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Erzeuge einen Textknoten für die Stationsnummer.
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))  # Schwarz für die Zahlen
-            tn_np = self.render.attachNewNode(tn)
-            # Platziere den Text so, dass er in X-Richtung neben der Station (außen) liegt
-            # Wir wählen hier x = pt.x + 1.1, y = pt.y + 0.5, z = 0.01
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            # Damit der Text flach auf dem Boden liegt, rotiere ihn so, dass er in der X-Y Ebene liegt:
-            tn_np.setHpr(0, -90, 0)  # -90° in Pitch bewirkt das Flachliegen
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: KI/KI36.py
===================================================================
diff --git a/KI/KI36.py b/KI/KI36.py
deleted file mode 100644
--- a/KI/KI36.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,599 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Matplotlib zum Plotten importieren
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs,
-    CardMaker
-)
-
-# Wir nutzen globalClock für dt.
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit & Zeitskalierungsfaktor
-        self.base_speed = 1.5
-        self.speed_factor = 1.0
-
-        # Simulationszeitticker & Statistik
-        self.sim_clock = 0.0
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        self.sim_start_real = globalClock.getFrameTime()
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Zeichne für jede Annahmestation den Align-Punkt (2 m in positive X-Richtung)
-        for station in self.annahme_stationen:
-            station_pos = station.getPos()
-            ls_pickup = LineSegs()
-            ls_pickup.setThickness(3.0)
-            ls_pickup.setColor(LColor(1, 1, 1, 1))
-            ls_pickup.moveTo(station_pos)
-            ls_pickup.drawTo(station_pos + Vec3(2, 0, 0))
-            self.render.attachNewNode(ls_pickup.create())
-
-        # Zeichne für jede Abgabestation den Align-Punkt (2 m in negative X-Richtung)
-        for station in self.abgabe_stationen:
-            station_pos = station.getPos()
-            ls_dropoff = LineSegs()
-            ls_dropoff.setThickness(3.0)
-            ls_dropoff.setColor(LColor(1, 1, 1, 1))
-            ls_dropoff.moveTo(station_pos)
-            ls_dropoff.drawTo(station_pos + Vec3(-2, 0, 0))
-            self.render.attachNewNode(ls_dropoff.create())
-
-        # --- Anfahrstationen (Startstationen) für die Fahrzeuge ---
-        # Diese Stationen sollen bei Y = 15 nebeneinander mit 4 Meter Abstand in X-Richtung liegen.
-        self.anfahrstationen = []
-        num_departure = 2  # Zu Beginn nur 2 Fahrzeuge
-        spacing_departure = 4.0
-        start_x = -spacing_departure * (num_departure - 1) / 2
-        for i in range(num_departure):
-            pos = Vec3(start_x + i * spacing_departure, 15, 0)
-            station = self.erzeuge_gitterbox(pos.getX(), pos.getY(), pos.getZ(), LColor(0.8, 0.8, 0, 1))
-            self.anfahrstationen.append(station)
-
-        # Fahrzeuge erstellen, jeweils eines pro Anfahrstation (insgesamt 2 Fahrzeuge)
-        self.vehicles = []
-        self.cargos = {}              # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}    # Fahrzeug -> zugewiesene Dropoff-Station
-        for i, start_station in enumerate(self.anfahrstationen):
-            vehicle = self.loader.loadModel("models/box")
-            vehicle.setScale(1, 1, 0.5)
-            if i % 2 == 0:
-                vehicle.setColor(LColor(0, 0, 1, 1))
-            else:
-                vehicle.setColor(LColor(0, 0, 0.8, 1))
-            vehicle.setPos(start_station.getPos())
-            vehicle.reparentTo(self.render)
-            self.vehicles.append(vehicle)
-            # Beim Start wird die Phase "pickup" gesetzt
-            vehicle.setPythonTag("phase", "pickup")
-            self.add_center_marker(vehicle)
-            self.add_offset_circle(vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Reste der Pick-up-/Drop-off-Logik
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Erfassung von Daten für Graphen (einmal pro Simulationssekunde)
-        self.graph_data = []
-        self.taskMgr.doMethodLater(1, self.record_graph_data, "RecordGraphDataTask")
-
-        # Graphen öffnen per Taste "G" (nach Schließen wieder möglich)
-        self.graph_opened = False
-        self.accept("g", self.open_graph)
-
-        # Zoom-Funktionalität: Mit Mausrad hereinz- bzw. herauszoomen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_lidar_status, "UpdateLidarStatusTask")
-
-        # Liefervorgang starten (Pickup-Phase) für jedes Fahrzeug
-        for vehicle in self.vehicles:
-            self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def zoom_in(self):
-        # Hereinzoomen: Field-of-View (FOV) verkleinern (nicht unter 10°)
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        # Herauszoomen: FOV vergrößern (nicht über 100°)
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def record_graph_data(self, task):
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0
-        self.graph_data.append((self.sim_clock, delivered_per_minute, avg_dwell_time))
-        return Task.again
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def add_offset_circle(self, vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5, num_segments=32):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        for i in range(num_segments + 1):
-            angle = 2 * math.pi * i / num_segments
-            x = circle_radius * math.cos(angle)
-            y = circle_radius * math.sin(angle)
-            if i == 0:
-                ls.moveTo(x, y, 0)
-            else:
-                ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        circle_np = vehicle.attachNewNode(circle_geom)
-        circle_np.setPos(offset)
-        vehicle.setPythonTag("lidar_circle", circle_np)
-
-    def draw_coordinate_axes(self, axis_length=5):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(1, 0, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        ls.setColor(0, 1, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        ls.setColor(0, 0, 1, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), (1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), (0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), (0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def update_lidar_status(self, task):
-        sensor_threshold = 3.0
-        for vehicle in self.vehicles:
-            pos = vehicle.getPos(self.render)
-            total_avoidance = Vec3(0, 0, 0)
-            # Standardmäßig volle Geschwindigkeit
-            multiplier = 1.0
-            phase = vehicle.getPythonTag("phase") if vehicle.hasPythonTag("phase") else "pickup"
-            for other in self.vehicles:
-                if other is vehicle:
-                    continue
-                pos_other = other.getPos(self.render)
-                diff = pos - pos_other
-                d = diff.length()
-                if d < sensor_threshold:
-                    other_phase = other.getPythonTag("phase") if other.hasPythonTag("phase") else "pickup"
-                    # Wenn ein Fahrzeug in der Pickup-Phase einem Fahrzeug in der Dropoff-Phase gegenübersteht:
-                    if phase == "pickup" and other_phase == "dropoff":
-                        candidate = 0.1
-                        avoidance_weight = 2.0
-                    # Wenn beide Fahrzeuge in der Dropoff-Phase sind, hat das Fahrzeug, das weiter von seiner Dropoff-Station entfernt ist, Vorrang
-                    elif phase == "dropoff" and other_phase == "dropoff":
-                        my_dropoff = self.current_dropoffs.get(vehicle)
-                        other_dropoff = self.current_dropoffs.get(other)
-                        if my_dropoff and other_dropoff:
-                            my_distance = (pos - my_dropoff.getPos()).length()
-                            other_distance = (pos_other - other_dropoff.getPos()).length()
-                            if my_distance > other_distance:
-                                candidate = 0.1
-                                avoidance_weight = 2.0
-                            else:
-                                candidate = 1.0
-                                avoidance_weight = 1.0
-                        else:
-                            candidate = 1.0
-                            avoidance_weight = 1.0
-                    else:
-                        candidate = 1.0
-                        avoidance_weight = 1.0
-                    multiplier = min(multiplier, candidate)
-                    if d > 0:
-                        total_avoidance += diff.normalized() * (sensor_threshold - d) * avoidance_weight
-            vehicle.setPythonTag("speed_multiplier", multiplier)
-            vehicle.setPythonTag("avoidance", total_avoidance)
-            lidar_circle = vehicle.getPythonTag("lidar_circle")
-            if lidar_circle:
-                if multiplier < 1.0 or total_avoidance.length() > 0.001:
-                    lidar_circle.setColor(LColor(1, 0, 0, 1))
-                else:
-                    lidar_circle.setColor(LColor(0, 1, 0, 1))
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-        current_wait_text = (
-            f"Liegedauer (aktuell): {current_max_wait_time:.1f}s"
-            if current_max_wait_time > 0 else "Kein Paket an Annahmestation"
-        )
-        maximal_wait_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted_time}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-            f"{current_wait_text}\n"
-            f"{maximal_wait_text}\n"
-            f"Liegedauer (Durchschnitt): {avg_dwell_time:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(
-            station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1)
-        )
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            to_target = target - current_pos
-            distance = to_target.length()
-            multiplier = vehicle.getPythonTag("speed_multiplier") if vehicle.hasPythonTag("speed_multiplier") else 1.0
-            effective_speed = self.base_speed * self.speed_factor * multiplier
-            step_distance = effective_speed * dt
-            if distance <= step_distance:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-            avoidance = vehicle.getPythonTag("avoidance") if vehicle.hasPythonTag("avoidance") else Vec3(0, 0, 0)
-            if avoidance.length() > 0.001:
-                combined = to_target.normalized() + avoidance.normalized() * 0.5
-                combined.normalize()
-                new_direction = combined
-            else:
-                new_direction = to_target.normalized()
-            vehicle.setPos(current_pos + new_direction * step_distance)
-            return Task.cont
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        # Beginn eines neuen Auftrags: Phase "pickup" und Speichern des job_start-Zeitpunkts
-        vehicle.setPythonTag("job_start", self.sim_clock)
-        vehicle.setPythonTag("phase", "pickup")
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        pickup_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        self.move_vehicle_to(vehicle, pickup_align,
-            lambda: self.move_vehicle_to(vehicle, pickup_station.getPos(),
-                lambda: self.after_pickup(vehicle, pickup_station)
-            )
-        )
-
-    def after_pickup(self, vehicle, pickup_station):
-        self.pickup_package(vehicle, pickup_station)
-        # Nach erfolgreichem Pickup Phase auf "dropoff" setzen
-        vehicle.setPythonTag("phase", "dropoff")
-        self.depart_from_pickup(vehicle, pickup_station,
-            lambda: self.start_dropoff_phase(vehicle)
-        )
-
-    def depart_from_pickup(self, vehicle, pickup_station, callback):
-        departure_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        departure_target = pickup_station.getPos() + Vec3(4, 0, 0)
-        self.move_vehicle_to(vehicle, departure_align,
-            lambda: self.move_vehicle_to(vehicle, departure_target, callback)
-        )
-
-    def start_dropoff_phase(self, vehicle):
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.start_dropoff_phase(vehicle)
-            return
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-        self.move_vehicle_to(vehicle, dropoff_align,
-            lambda: self.move_vehicle_to(vehicle, dropoff_station.getPos(),
-                lambda: self.after_dropoff(vehicle)
-            )
-        )
-
-    def after_dropoff(self, vehicle):
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        self.drop_cargo(vehicle)
-        self.remove_cargo(vehicle, remove_dropoff=True)
-        if dropoff_station is not None:
-            departure_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-            departure_target = dropoff_station.getPos() + Vec3(-4, 0, 0)
-            self.move_vehicle_to(vehicle, departure_align,
-                lambda: self.move_vehicle_to(vehicle, departure_target,
-                    lambda: self.start_delivery_cycle(vehicle, departure_target)
-                )
-            )
-        else:
-            self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle, remove_dropoff=True):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        if remove_dropoff:
-            dropoff_station = self.current_dropoffs.get(vehicle)
-            if dropoff_station in self.occupied_dropoffs:
-                self.occupied_dropoffs.remove(dropoff_station)
-            if vehicle in self.current_dropoffs:
-                del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices+1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices+1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z+1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
Index: Grundmodell/Gm14.py
===================================================================
diff --git a/Grundmodell/Gm14.py b/Grundmodell/Gm14.py
deleted file mode 100644
--- a/Grundmodell/Gm14.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,1287 +0,0 @@
-import random
-import math
-import tkinter as tk  # Für das extra Fenster der Auftragsübersicht
-from tkinter import ttk  # Für die tabellarische Darstellung (Treeview)
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5  # Wird in update_vehicle genutzt
-        self.state_timer = 0.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Paketspawning an den Annahmestationen:
-        # Mapping: station (Dummy-Node) -> (Paket, Spawnzeit, Timer Node)
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-        # Neues Attribut: Verknüpfung Fahrzeug -> transportiertes Paket
-        self.cargos = {}
-
-        # NEU: Initialisiere die belegten Annahmestationen
-        self.occupied_pickups = set()  # Oder: [] für eine Liste
-
-        # Graph-Daten (Sim-Zeit, Pakete pro Minute, durchschnittliche Liegedauer)
-        self.graph_data = []
-        self.graph_opened = False
-
-        # Auftragsverwaltung: Speichere alle Aufträge (für die Anzeige) sowie in
-        # einer Queue (Liste) zur sequentiellen Abarbeitung.
-        self.orders = {}         # Für die Anzeige
-        self.orders_queue = []   # Für die Fahrzeugabwicklung (FIFO)
-        self.next_order_id = 1
-
-        # Tkinter-Fenster für Auftragsübersicht
-        self.order_win = None
-        self.order_tree = None
-
-        # Umgebung initialisieren
-        self.draw_origin()
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.create_wall()
-        self.create_annahme_stations()
-        self.create_abgabe_stations()  # Hier wird auch self.abgabe_stations angelegt.
-        self.create_garagen_stations()
-
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # Fahrzeuge in den Garagen erstellen (genau 5 Fahrzeuge)
-        self.create_garage_vehicles()
-
-        # NEU: Auftragssystem für das Testfahrzeug initialisieren
-        # Zustände: "idle", "to_pickup", "wait_pickup", "to_delivery", "deliver"
-        self.first_vehicle_order_state = "idle"
-        self.attached_package = None
-        self.current_order = None  # Der aktuell abgearbeitete Auftrag
-        self.taskMgr.add(self.vehicle_order_task, "VehicleOrderTask")
-
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-        self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    # ---------------------------
-    # SIMULATION UND UI-METHODEN
-    # ---------------------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    # ---------------------------
-    # METHODEN FÜR RASTER, LICHT, MAUER, URSPRUNG
-    # ---------------------------
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # STATIONSOBJEKTE UND ZUORDNUNG
-    # -----------------------------------
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        # Beispielhafte Station-Punkte (siehe dein ursprünglicher Code)
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basisstation (zum Beispiel Rahmen)
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Erzeuge den Marker (großer weißer Punkt) als Orientierung
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Erzeuge den grünen Punkt an der Station (als optionaler Punkt)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zeichne die weiße Linie an der Station.
-            # Die Linie beginnt bei: center + Vec3(0,0,-0.5) und verläuft 3 Meter in X-Richtung.
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            white_line_node = self.render.attachNewNode(line_seg.create())
-
-            # Speichere den Node der weißen Linie global
-            self.white_line = white_line_node
-
-            # Berechne den Mittelpunkt der weißen Linie
-            self.white_line_center = (start_line + end_line) * 0.5
-
-            # Berechne die Richtung der weißen Linie (als 2D-Vektor, normalisiert)
-            line_vec = end_line - start_line
-            self.station_white_direction = Vec2(line_vec.getX(), line_vec.getY()).normalized()
-
-            # Erzeuge den blauen Punkt – dieser dient als Ziel in Phase 1.
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            # Speichere global relevante Punkte für die erste Station
-            if i == 1:
-                self.blue_dot = blue_dot
-                self.station_green_dot = green_dot
-
-            # (Optional) Textanzeige der Stationsnummer:
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) – falls benötigt:
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        self.abgabe_stations = []  # Liste der Abgabestationen
-        self.abgabe_blue_dots = []  # Liste zum Speichern der blauen Marker für die Abgabe
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basiskonstruktion der Abgabestation
-            node = self.create_abgabe_station(pt)
-            self.abgabe_stations.append(node)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Marker am Zentrum (weiß)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Grüner Punkt: center + Vec3(0, 0, -0.5)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Weiße Linie: Startet bei center + Vec3(0, 0, -0.5)
-            # und verläuft 3 Meter in negativer X-Richtung
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt: wird an der Endposition der Linie erzeugt
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            # Speichere den blauen Marker für spätere Navigation der Abgabestation
-            self.abgabe_blue_dots.append(blue_dot)
-
-            # Anzeige der Stationsnummer (textuell)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) auf der Station
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 3)
-        v5 = pos + Vec3(1, 0, 3)
-        v6 = pos + Vec3(1, 2, 3)
-        v7 = pos + Vec3(0, 2, 3)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 3)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        self.garagen_stations = []
-        self.garagen_parking_points = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            self.garagen_stations.append(pt)
-            # ParkpunktGarage: Verschoben um 0.5 in negativer Y-Richtung:
-            center = pt + Vec3(0.5, 0.5, 1.5)
-            ParkpunktGarage = center + Vec3(0, 0, 0.7)
-            self.garagen_parking_points.append(ParkpunktGarage)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def create_garage_vehicles(self):
-        """
-        Erzeugt nur das erste Fahrzeug in der Simulation.
-
-        Ursprünglich wurde für jeden Garagen-Parkpunkt ein Fahrzeug erstellt.
-        Mit dieser Anpassung wird nur das Fahrzeug am ersten Parkpunkt erzeugt,
-        alle weiteren Fahrzeuge werden nicht erzeugt.
-        """
-        self.garage_vehicles = []
-        if self.garagen_parking_points:
-            park = self.garagen_parking_points[0]  # Nur der erste Parkpunkt wird verwendet.
-            veh = self.create_vehicle(park_point=None)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            # Statt newPos.setZ(0.1) setzen wir den Z-Wert als Offset zum berechneten Wert:
-            newPos.setZ(newPos.getZ() + 0.1)
-            veh.setPos(newPos)
-            self.garage_vehicles.append(veh)
-
-            # Erzeuge Fahrzeugmarker
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # FAHRZEUGERSTELLUNG (FFZ20-INTEGRATION)
-    # -----------------------------------
-    def create_vehicle(self, park_point=None):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Chassis: 1 x 0.5 x 1.2, Farbe Rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # Fork (Gabel): Zwei Zähne
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-        self.fork_node = fork_node
-
-        # Berechne den Mittelpunkt der Gabel (mittels der linken und rechten Eckpunkte)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_corner_global = fork_node.getPos() + left_corner_local
-        right_corner_global = fork_node.getPos() + right_corner_local
-
-        ls_new = LineSegs()
-        ls_new.setThickness(2.0)
-        ls_new.setColor(1, 1, 1, 1)
-        ls_new.moveTo(left_corner_global)
-        ls_new.drawTo(right_corner_global)
-        vehicle_node.attachNewNode(ls_new.create())
-
-        midpoint = (left_corner_global + right_corner_global) * 0.5
-        white_line_vec = right_corner_global - left_corner_global
-        if white_line_vec.length() != 0:
-            white_line_dir = white_line_vec.normalized()
-        else:
-            white_line_dir = Vec3(0, 0, 0)
-        candidate = Vec3(-white_line_dir.getY(), white_line_dir.getX(), 0)
-        vehicle_pos = vehicle_node.getPos()
-        if candidate.dot(vehicle_pos - midpoint) < 0:
-            candidate = -candidate
-        if candidate.length() != 0:
-            perp_direction = candidate.normalized()
-        else:
-            perp_direction = Vec3(0, 0, 0)
-        line_length = 1.0
-        line_end = midpoint + perp_direction * line_length
-        ls_mid = LineSegs()
-        ls_mid.setThickness(2.0)
-        ls_mid.setColor(1, 1, 1, 1)
-        ls_mid.moveTo(midpoint)
-        ls_mid.drawTo(line_end)
-        vehicle_node.attachNewNode(ls_mid.create())
-
-        # Fahrzeug: Gabel – grüner Punkt (als Referenz)
-        green_point_global = midpoint + perp_direction * 0.5
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        self.fork_green = green_marker_np  # Global abgespeichert
-
-        # Mast: Erzeuge den Mast und hänge den Zylinder als Referenz an
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-
-        self.add_diagonals_to_mast(mast_node)
-        intersection = Vec3(0.5, 0.05, 1.0)
-
-        # Fahrzeug: Zylinder – Erzeuge den Zylinder und speichere ihn global
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-        self.vehicle_cylinder = cylinder_node  # Global abgespeichert
-
-        # Optional: Zusätzliche Fahrzeugbestandteile (wie Lidar) können hier ergänzt werden.
-
-        if park_point is None:
-            vehicle_node.setPos(intersection.x, intersection.y, 0)
-        else:
-            vehicle_node.setPos(park_point - intersection)
-
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    # -----------------------------------
-    # FEHLENDE METHODEN: Paketspawning, Würfelerzeugung u.a.
-    # -----------------------------------
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        if hasattr(self, "abgabe_stations") and self.abgabe_stations:
-            target_index = random.randint(1, len(self.abgabe_stations))
-        else:
-            target_index = 1
-
-        # Der Auftrag wird hier erstellt – und zwar genau dann, wenn ein Paket gespawnt wird.
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def update_order_table(self):
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen (z.B. "annahme_station_3") nur die Nummer.
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z.B. "Abgabestation 5") nur die Nummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Bestimme die Fahrzeugzuordnung.
-            # Wird "1" angezeigt, wenn der Auftrag aktuell (und noch nicht erledigt) dem Fahrzeug zugeordnet ist.
-            # Andernfalls wird ein "-" angezeigt.
-            if self.current_order is not None and order["id"] == self.current_order["id"] and order.get(
-                    "status") != "Erledigt":
-                vehicle_display = "1"
-            else:
-                vehicle_display = "-"
-
-            self.order_tree.insert("", tk.END, values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def check_and_spawn_packages(self, task):
-        # Maximale Anzahl an Aufträgen beschränken auf die Anzahl der Pakete in der Simulation
-        max_orders = len(self.pickup_packages)
-        if len(self.orders) >= max_orders:
-            return Task.cont
-
-        spawn_delay = 5.0  # 5 Sekunden Verzögerung zwischen Spawns
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0.0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Wir legen hier die Spalten in der gewünschten Reihenfolge an: Auftrags ID, Annahmestation, Ziel, Fahrzeug.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Setze das Paket relativ zum Gabelmodul mit einem Offset in X- und Y-Richtung
-            green_point_pos = self.fork_green.getPos(self.fork_node)
-            package.wrtReparentTo(self.fork_node)
-            package.setPos(
-                green_point_pos.getX() + 0.5,  # Versatz um +0.5 in X-Richtung
-                green_point_pos.getY() + -0.5,  # Versatz um +0.5 in Y-Richtung
-                green_point_pos.getZ() + 1  # Z-Offset, um das Paket oberhalb der Gabel zu platzieren
-            )
-
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def vehicle_order_task(self, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-
-        # Zustandsinitialisierung
-        if not hasattr(self, "vehicle_state"):
-            self.vehicle_state = "translate"
-        if not hasattr(self, "package_attached"):
-            self.package_attached = False
-
-        if not self.garage_vehicles:
-            return task.cont
-
-        vehicle = self.garage_vehicles[0]
-
-        # PHASE 1: Translate – Fahre zur blauen Markierung der Annahmestation
-        if self.vehicle_state == "translate":
-            blue_target = self.blue_dot.getPos(self.render)
-            local_mast = Vec3(0.5, 0.05, 1.0)
-            # Berechne die Position des Mastes im Weltkoordinatensystem
-            mast_global = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(local_mast)
-            target_xy = Vec2(blue_target.getX(), blue_target.getY())
-            mast_xy = Vec2(mast_global.getX(), mast_global.getY())
-            error_vector = target_xy - mast_xy
-            threshold = 0.05  # 5 cm Toleranz
-            if error_vector.length() > threshold:
-                direction = error_vector.normalized()
-                move_distance = 1.5 * dt
-                current_pos = vehicle.getPos(self.render)
-                new_pos = Vec3(
-                    current_pos.getX() + direction.getX() * move_distance,
-                    current_pos.getY() + direction.getY() * move_distance,
-                    0
-                )
-                vehicle.setPos(new_pos)
-            else:
-                # Exaktes Ausrichten im XY-Bereich
-                local_offset = vehicle.getQuat(self.render).xform(local_mast)
-                exact_pos = Vec3(
-                    blue_target.getX() - local_offset.getX(),
-                    blue_target.getY() - local_offset.getY(),
-                    0
-                )
-                vehicle.setPos(exact_pos)
-                self.vehicle_state = "rotate"
-
-        # PHASE 2: Rotate – Drehe das Fahrzeug in Richtung der Einfahrtrichtung
-        elif self.vehicle_state == "rotate":
-            desired_angle = math.degrees(math.atan2(self.station_white_direction.getY(),
-                                                    self.station_white_direction.getX()))
-            desired_angle = (desired_angle + 180) % 360  # Anpassung mit 180°-Offset
-            current_heading = vehicle.getH()
-            angle_diff = (desired_angle - current_heading + 180) % 360 - 180
-            kp_heading = 0.5
-            new_heading = current_heading + kp_heading * angle_diff
-            vehicle.setH(new_heading)
-            if abs(angle_diff) < 1.0:
-                self.vehicle_state = "turn_right"
-
-        # PHASE 3: Turn Right – Drehe das Fahrzeug um 90° nach rechts
-        elif self.vehicle_state == "turn_right":
-            if not hasattr(self, "turn_right_init"):
-                self.turn_right_init = vehicle.getH()
-                self.turn_right_target = (self.turn_right_init + 90) % 360
-            current_heading = vehicle.getH()
-            angle_diff = (self.turn_right_target - current_heading + 180) % 360 - 180
-            kp_turn = 0.5
-            new_heading = current_heading + kp_turn * angle_diff
-            vehicle.setH(new_heading)
-            if abs(angle_diff) < 1.0:
-                self.vehicle_state = "approach"
-                del self.turn_right_init, self.turn_right_target
-
-        # PHASE 4: Approach – Fahre versetzt in die Annahmestation hinein
-        elif self.vehicle_state == "approach":
-            target = self.station_green_dot.getPos(self.render) + Vec3(0.5, 0.5, 0)
-            current = vehicle.getPos(self.render)
-            error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-            if error_vec.length() > 0.05:
-                direction = error_vec.normalized()
-                move_distance = 1.5 * dt
-                new_pos = Vec3(
-                    current.getX() + direction.getX() * move_distance,
-                    current.getY() + direction.getY() * move_distance,
-                    target.getZ()
-                )
-                vehicle.setPos(new_pos)
-            else:
-                self.vehicle_state = "pickup"
-
-        # PHASE 5: Pickup – Paket aufnehmen und Gabel hochfahren
-        elif self.vehicle_state == "pickup":
-            current_z = self.fork_node.getZ()
-            target_z = 1.0  # Zielhöhe der Gabel
-            raise_speed = 0.5
-            if current_z < target_z:
-                self.fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-            else:
-                if self.current_order is None:
-                    if self.orders_queue:
-                        self.current_order = self.orders_queue.pop(0)
-                    else:
-                        print("Keine verfügbaren Aufträge. Überspringe Pickup-Phase.")
-                        self.vehicle_state = "drive_out"
-                        return task.cont
-                pickup_station = self.current_order["pickup_station"]
-                self.pickup_package(vehicle, pickup_station)
-                self.package_attached = True
-                # Initialisiere den Akkumulator für die Drive Out-Phase
-                self.drive_distance_travelled = 0.0
-                self.vehicle_state = "drive_out"
-
-        # PHASE 6: Drive Out – Fahre langsam aus dem Pickup-Bereich heraus
-        elif self.vehicle_state == "drive_out":
-            # Senke die Gabel, falls noch nicht ganz unten
-            current_z = self.fork_node.getZ()
-            if current_z > 0.0:
-                lower_speed = 0.5
-                self.fork_node.setZ(max(0.0, current_z - lower_speed * dt))
-            # Fahre mit konstanter, langsamer Geschwindigkeit in Fahrtrichtung
-            forward = vehicle.getQuat(self.render).getForward()
-            move_distance = 0.5 * dt
-            current_pos = vehicle.getPos(self.render)
-            new_pos = current_pos + forward * move_distance
-            vehicle.setPos(new_pos)
-            # Strecke akkumulieren
-            self.drive_distance_travelled += move_distance
-            if self.drive_distance_travelled >= 5.0:
-                self.vehicle_state = "to_delivery"
-
-        # PHASE 7: To Delivery – Fahre zum blauen Punkt der Abgabestation
-        elif self.vehicle_state == "to_delivery":
-            delivery_target_str = self.current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            # Hier wird der Unterschied zwischen Fahrzeugposition und Ziel ermittelt
-            current_pos = vehicle.getPos(self.render)
-            diff = blue_target - current_pos
-            distance = diff.length()
-            threshold = 0.05
-            if distance > threshold:
-                step = min(1.5 * dt, distance)
-                move_vec = diff.normalized() * step
-                vehicle.setPos(current_pos + move_vec)
-            else:
-                print("Auftrag abgeschlossen: Fahrzeug hat die Abgabestation erreicht.")
-                self.vehicle_state = "idle"
-                self.current_order["status"] = "Erledigt"
-                self.current_order["delivered_at"] = self.sim_clock
-                self.current_order = None
-                self.package_attached = False
-                self.drop_cargo(vehicle)
-
-        return task.cont
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: Grundmodell/Gm27.py
===================================================================
diff --git a/Grundmodell/Gm27.py b/Grundmodell/Gm27.py
deleted file mode 100644
--- a/Grundmodell/Gm27.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,2050 +0,0 @@
-import random
-import math
-import tkinter as tk  # Für das extra Fenster der Auftragsübersicht
-from tkinter import ttk  # Für die tabellarische Darstellung (Treeview)
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-import matplotlib
-matplotlib.use("TkAgg")  # oder ein anderes geeignetes Backend
-import multiprocessing
-from multiprocessing import Queue, Process
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-import time
-import ctypes
-from PyQt5 import QtWidgets, QtCore
-import pyqtgraph as pg
-from direct.gui.DirectGui import DirectButton
-
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-from direct.task.TaskManagerGlobal import taskMgr
-from functools import partial
-
-class LagerSimulation(ShowBase):
-    def __init__(self, graph_queue=None):
-        super().__init__()
-        self.paused = False
-        # Pause-Knopf neben dem Slider platzieren – z.B. rechts davon.
-        self.pause_button = DirectButton(
-            text="Pause",
-            command=self.toggle_pause,
-            pos=(-0.5, 0, -0.85),  # Leicht links vom Slider
-            scale=0.07
-        )
-
-        # Speichere die Queue als Attribut
-        self.graph_process = None  # Hier wird der Graphing-Prozess gespeichert.
-        self.graph_queue = None  # Die Queue für den Datenaustausch.
-
-        self.tk_root = tk.Tk()
-        self.tk_root.withdraw()
-
-        self.taskMgr.add(self._tk_update, "tkUpdateTask")
-        self.taskMgr.add(self.update_delivery_timers, "UpdateDeliveryTimersTask")
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5  # Wird in update_vehicle genutzt
-        self.state_timer = 0.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Kennzahlen für Lieferzeiten
-        self.total_delivery_time = 0.0
-        self.total_delivery_count = 0
-        self.max_overall_delivery_time = 0.0
-
-        # Paketspawning an den Annahmestationen:
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-        # Fahrzeug-spezifische Zuordnung: Fahrzeug -> transportiertes Paket
-        self.cargos = {}
-
-        # NEU: Initialisiere die belegten Annahmestationen
-        self.occupied_pickups = set()  # Oder: [] für eine Liste
-
-        # Graph-Daten (Sim-Zeit, Pakete pro Minute, durchschnittliche Liegedauer)
-        self.graph_data = []
-        self.graph_opened = False
-
-        # Auftragsverwaltung: Speichere alle Aufträge (für die Anzeige) sowie in
-        # einer Queue (Liste) zur sequentiellen Abarbeitung.
-        self.orders = {}
-        self.orders_queue = []
-        self.next_order_id = 1
-
-        # Tkinter-Fenster für Auftragsübersicht
-        self.order_win = None
-        self.order_tree = None
-
-        # Umgebung initialisieren
-        self.draw_origin()
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.create_wall()
-        self.create_annahme_stations()
-        self.create_abgabe_stations()  # Hier wird auch self.abgabe_stations angelegt.
-        self.create_garagen_stations()
-
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # Fahrzeuge in den Garagen erstellen (genau 5 Fahrzeuge)
-        self.create_garage_vehicles()
-
-        # NEU: Testvariablen
-        self.first_vehicle_order_state = "idle"
-        self.attached_package = None
-        self.current_order = None  # wird durch Fahrzeuge individuell genutzt
-
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tastenzuordnungen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-        # Taste C öffnet das Fahrzeug-Kontrollfenster
-        self.accept("c", self.show_vehicle_control)
-
-        # Task-Manager
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClock")
-        # Task, der regelmäßig Graphdaten sendet
-        self.taskMgr.add(self.update_graph_data, "UpdateGraphDataTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        self.sim_clock += dt
-        return Task.cont
-
-    def toggle_pause(self):
-        if not self.paused:
-            # Speichern des aktuellen speed_factor, damit wir ihn beim Resume wiederherstellen können
-            self.previous_speed_factor = self.speed_factor
-            self.speed_factor = 0  # Simulation einfrieren: alle dt-basierte Updates ergeben 0
-            self.pause_button['text'] = "Weiter"
-            self.paused = True
-            print("Gesamte Simulation angehalten")
-        else:
-            # Wiederaufnahme der Simulation: speed_factor auf den vorherigen Wert zurücksetzen
-            self.speed_factor = self.previous_speed_factor if hasattr(self, 'previous_speed_factor') else 1.0
-            self.pause_button['text'] = "Pause"
-            self.paused = False
-            print("Simulation läuft wieder")
-
-    def open_graph(self):
-        # Starte den Graphprozess per Taste G (nur, wenn er noch nicht läuft)
-        if self.graph_process is None or not self.graph_process.is_alive():
-            from multiprocessing import Queue, Process
-            self.graph_queue = Queue()
-
-            # Sende alle bisher gesammelten Daten in die Queue:
-            for data in self.graph_data:
-                try:
-                    self.graph_queue.put(data, block=False)
-                except Exception:
-                    pass
-
-            from graph_pyqt import graph_process_pyqt
-            self.graph_process = Process(target=graph_process_pyqt, args=(self.graph_queue,))
-            self.graph_process.start()
-            print("Graphprozess gestartet.")
-        else:
-            print("Graphprozess läuft bereits.")
-
-    def update_graph_data(self, task):
-        if self.sim_clock > 0:
-            ppm = self.delivered_packages / (self.sim_clock / 60)
-        else:
-            ppm = 0.0
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        avg_delivery = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        new_data = (self.sim_clock, ppm, avg_dwell, avg_delivery)
-        # Speichere alle Daten ab Simulationsbeginn:
-        self.graph_data.append(new_data)
-
-        # Zusätzlich: Falls der Graphprozess aktiv ist, schicke den neuen Datensatz auch an die Queue
-        if self.graph_queue is not None:
-            try:
-                self.graph_queue.put(new_data, block=False)
-            except Exception:
-                pass
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-
-        # Bestimme die maximale Liegedauer aktueller Pakete an den Annahmestationen
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-
-        # Lieferzeit-Kennzahlen ermitteln: für Fahrzeuge, die aktuell ein Paket tragen
-        current_delivery_time = 0.0
-        for veh in self.garage_vehicles:
-            if veh.getPythonTag("package_attached"):
-                ds = veh.getPythonTag("delivery_start_time")
-                if ds:
-                    elapsed_delivery = self.sim_clock - ds
-                    current_delivery_time = max(current_delivery_time, elapsed_delivery)
-        avg_delivery_time = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        # Aktualisiere den Info-Label-Text
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s\n"
-            f"Lieferzeit (aktuell): {current_delivery_time:.1f}s\n"
-            f"Lieferzeit (maximal): {self.max_overall_delivery_time:.1f}s\n"
-            f"Durchschn. Lieferzeit: {avg_delivery_time:.1f}s"
-        )
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        # dt jetzt skaliert mit der Simulationsgeschwindigkeit
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    # ---------------------------
-    # METHODEN FÜR RASTER, LICHT, MAUER, URSPRUNG
-    # ---------------------------
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # STATIONSOBJEKTE UND ZUORDNUNG
-    # -----------------------------------
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        """
-        Erzeugt die Annahmestationen und erstellt für jede Station:
-          - Einen weißen Marker zur Orientierung
-          - Einen grünen Punkt (optional)
-          - Eine weiße Linie, an deren Endpunkt ein blauer Marker als Ziel in der "Translate‑Phase" dient
-
-        Zusätzlich wird ein Dictionary self.station_blue_dots aufgebaut, in dem jedem Annahmestations‑Node
-        der zugehörige blaue Marker zugeordnet wird. Außerdem wird für die erste Station die globale Variable
-        self.station_white_direction festgelegt.
-        """
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        self.station_blue_dots = {}
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basisstation (zum Beispiel als Rahmen)
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Erzeuge den weißen Marker als Orientierung
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Erzeuge den grünen Punkt (optional)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zeichne die weiße Linie: Sie beginnt bei center + Vec3(0, 0, -0.5) und verläuft 3 Meter in X‑Richtung.
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Erzeuge den blauen Marker, der als Ziel in der Translate‑Phase dient
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            # Speichere den blauen Marker im Dictionary, sodass er später erzeugt werden kann
-            self.station_blue_dots[station_dummy] = blue_dot
-
-            # Optionale Textanzeige der Stationsnummer
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) – falls benötigt:
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-            # Für die erste Station (oder den ersten relevanten Pickup) setzen wir globale Referenzen,
-            # die in vehicle_order_task benötigt werden.
-            if i == 1:
-                self.blue_dot = blue_dot
-                self.station_green_dot = green_dot
-                # Berechne den Mittelpunkt der weißen Linie als Referenz (optional)
-                self.white_line_center = (start_line + end_line) * 0.5
-                line_vec = end_line - start_line
-                if line_vec.length() != 0:
-                    self.station_white_direction = Vec2(line_vec.getX(), line_vec.getY()).normalized()
-                else:
-                    self.station_white_direction = Vec2(1, 0)  # Fallback-Wert
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        self.abgabe_stations = []  # Liste der Abgabestationen
-        self.abgabe_blue_dots = []  # Liste zum Speichern der blauen Marker für die Abgabe
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basiskonstruktion der Abgabestation
-            node = self.create_abgabe_station(pt)
-            self.abgabe_stations.append(node)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Marker am Zentrum (weiß)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Grüner Punkt: center + Vec3(0, 0, -0.5)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Weiße Linie: Startet bei center + Vec3(0, 0, -0.5)
-            # und verläuft 3 Meter in negativer X-Richtung
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt: wird an der Endposition der Linie erzeugt
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            # Speichere den blauen Marker für spätere Navigation der Abgabestation
-            self.abgabe_blue_dots.append(blue_dot)
-
-            # Anzeige der Stationsnummer (textuell)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) auf der Station
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 3)
-        v5 = pos + Vec3(1, 0, 3)
-        v6 = pos + Vec3(1, 2, 3)
-        v7 = pos + Vec3(0, 2, 3)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 3)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        self.garagen_stations = []
-        self.garagen_parking_points = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            self.garagen_stations.append(pt)
-            # ParkpunktGarage: Verschoben um 0.5 in negativer Y-Richtung:
-            center = pt + Vec3(0.5, 0.5, 1.5)
-            ParkpunktGarage = center + Vec3(0, 0, 0.7)
-            self.garagen_parking_points.append(ParkpunktGarage)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def create_garage_vehicles(self):
-        self.garage_vehicles = []
-        vehicle_id_counter = 1
-        for park in self.garagen_parking_points:
-            veh = self.create_vehicle(park_point=park)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            newPos.setZ(0)
-            veh.setPos(newPos)
-
-            # Fahrzeuge starten im Standby (idle)
-            veh.setPythonTag("current_order", None)
-            veh.setPythonTag("order_state", "idle")
-            veh.setPythonTag("package_attached", False)
-            veh.setPythonTag("vehicle_id", vehicle_id_counter)
-            # Speichere den Parkpunkt als Rückkehrziel
-            veh.setPythonTag("garage_target", park)
-            # Speichere auch das Anfangs-Heading, um es später beim Parken wiederherzustellen.
-            veh.setPythonTag("start_heading", veh.getH())
-            vehicle_id_counter += 1
-
-            self.garage_vehicles.append(veh)
-
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-            # Füge einen Textknoten hinzu, der die Fahrzeugnummer vorne auf dem Fahrzeug anzeigt.
-            # Wir suchen den Mast-Knoten.
-            mast = veh.find("**/mast")
-            if not mast.isEmpty():
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)  # Schwarz
-                tn.setAlign(TextNode.ACenter)
-                text_np = mast.attachNewNode(tn)
-                # Positioniere den Text relativ zum Mast: Wir nutzen den Vektor "intersection"
-                # und versetzen ihn in Z-Richtung um 0.2 Einheiten oberhalb des Zylinders.
-                text_np.setPos(intersection.x, intersection.y, intersection.z + 0.2)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-            else:
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)
-                tn.setAlign(TextNode.ACenter)
-                text_np = veh.attachNewNode(tn)
-                text_np.setPos(0, 1.2, 1.5)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-
-            self.taskMgr.add(partial(self.vehicle_order_task, veh),
-                             f"VehicleOrderTask_{veh.getPythonTag('vehicle_id')}")
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # FAHRZEUGERSTELLUNG (FFZ20-INTEGRATION)
-    # -----------------------------------
-    def create_vehicle(self, park_point=None):
-        # Erzeuge den übergeordneten Fahrzeug-Knoten
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # --------------------------
-        # Chassis erstellen (1 x 0.5 x 1.2, Farbe Rot)
-        # --------------------------
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # --------------------------
-        # Gabel (Fork) erstellen: Zwei Zähne
-        # --------------------------
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-
-        # Speichere den Gabel-Knoten als Python-Tag am Fahrzeug
-        vehicle_node.setPythonTag("fork_node", fork_node)
-
-        # --------------------------
-        # Erzeuge den grünen Referenzmarker (für die Gabel)
-        # --------------------------
-        ls_new = LineSegs()
-        ls_new.setThickness(2.0)
-        ls_new.setColor(1, 1, 1, 1)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_corner_global = fork_node.getPos() + left_corner_local
-        right_corner_global = fork_node.getPos() + right_corner_local
-        ls_new.moveTo(left_corner_global)
-        ls_new.drawTo(right_corner_global)
-        vehicle_node.attachNewNode(ls_new.create())
-        midpoint = (left_corner_global + right_corner_global) * 0.5
-        white_line_vec = right_corner_global - left_corner_global
-        white_line_dir = white_line_vec.normalized() if white_line_vec.length() != 0 else Vec3(0, 0, 0)
-        candidate = Vec3(-white_line_dir.getY(), white_line_dir.getX(), 0)
-        perp_direction = candidate.normalized() if candidate.length() != 0 else Vec3(0, 0, 0)
-        green_point_global = midpoint + perp_direction * 0.5
-
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        vehicle_node.setPythonTag("fork_green", green_marker_np)
-
-        # --------------------------
-        # Mast und weitere Fahrzeugteile
-        # --------------------------
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-        self.add_diagonals_to_mast(mast_node)
-
-        # Setze einen Schnittpunkt (Intersection) – dieser wird als Referenz genutzt.
-        intersection = Vec3(0.5, 0.05, 1.0)
-
-        # Jetzt – der wichtige Teil:
-        # Lidar-Kreis: Mittelpunkt soll 1 m in negativer Z-Richtung liegen (also Z = -1),
-        # Farbe Grün, Radius 2.
-        # Hier wird der Kreis am Mast (parent_node = mast_node) angehängt.
-        lidar_center = Vec3(intersection.x, intersection.y, -1)
-        self.add_lidar_circle(mast_node, lidar_center, 2)
-
-        # --------------------------
-        # Lenkachse erzeugen:
-        # Anstatt den Zylinder direkt bei (0.5, 0.05, 1.0) anzubringen,
-        # erstellen wir einen Pivot-Knoten (steering_axis) mit Z=0.
-        # --------------------------
-        steering_axis = mast_node.attachNewNode("steering_axis")
-        steering_axis.setPos(0.5, 0.05, -1.2)  # Global: 1.2 + (-1.2) = 0
-        steering_axis.setH(90)
-        vehicle_node.setPythonTag("steering_axis", steering_axis)
-
-        # Erzeuge den Zylinder, der die Lenkachse (auch als visuelles Element) darstellt
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(steering_axis)
-        cylinder_node.setPos(0, 0, 0)
-        self.vehicle_cylinder = steering_axis
-
-        # Hier fügen wir den Pfeil an der Lenkachse hinzu – er soll immer in die vorwärtsgerichtete (lokale X-) Richtung zeigen.
-        self.add_steering_arrow(steering_axis, color=(0, 1, 0, 1))
-        # --------------------------
-        # Fahrzeugpositionierung am Parkpunkt
-        # --------------------------
-        if park_point is None:
-            vehicle_node.setPos(0, 0, 0)
-        else:
-            intersection = Vec3(0.5, 0.05, 1.0)
-            vehicle_node.setPos(park_point - vehicle_node.getQuat().xform(intersection))
-        return vehicle_node
-
-    def add_steering_arrow(self, steering_axis, color=(0, 1, 0, 1)):
-        """
-        Erzeugt einen Pfeil, der die Vorwärtsrichtung (lokale X-Achse) des Lenkpivots anzeigt.
-        Der Pfeil wird als Kind des übergebenen steering_axis-Node angehängt und passt sich
-        automatisch dessen Rotation an.
-        """
-        arrow_ls = LineSegs()
-        arrow_ls.setThickness(2.0)
-        arrow_ls.setColor(*color)
-
-        # Zeichne eine Linie von (0,0,0) bis (2,0,0) – das ist die Basis des Pfeils
-        arrow_ls.moveTo(0, 0, 0)
-        arrow_ls.drawTo(2, 0, 0)
-
-        # Zeichne den Pfeilkopf: zwei kurze schräge Linien am Ende der Pfeillinie
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, 0.3, 0)
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, -0.3, 0)
-
-        arrow_np = steering_axis.attachNewNode(arrow_ls.create())
-        arrow_np.setPos(0, 0, 0)  # Falls nötig, hier noch zusätzlichen Offset anpassen
-        return arrow_np
-
-    def rotate_around_pivot(self, vehicle, pivot, delta_angle):
-        """
-        Dreht das Fahrzeug (vehicle) um den gegebenen Pivotpunkt (pivot) um delta_angle (in Grad).
-        Dabei wird die Position des Fahrzeugs neu berechnet, sodass es um den Pivot rotiert.
-        """
-        # Aktuelle globale Fahrzeugposition
-        pos = vehicle.getPos(self.render)
-        # Globaler Pivotpunkt
-        pivot_pos = pivot.getPos(self.render)
-        # Berechne den Vektor vom Pivot zum Fahrzeug
-        rel = pos - pivot_pos
-        # Wandle den Drehwinkel in Bogenmaß um
-        rad = math.radians(delta_angle)
-        cos_val = math.cos(rad)
-        sin_val = math.sin(rad)
-        # Drehe den relativen Vektor
-        new_x = rel.getX() * cos_val - rel.getY() * sin_val
-        new_y = rel.getX() * sin_val + rel.getY() * cos_val
-        new_rel = Vec3(new_x, new_y, rel.getZ())
-        # Neue globale Fahrzeugposition
-        new_pos = pivot_pos + new_rel
-        vehicle.setPos(new_pos)
-        # Aktualisiere auch das Heading des Fahrzeugs (aufaddieren des Drehwinkels)
-        vehicle.setH(vehicle.getH() + delta_angle)
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)  # Grün
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        return parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        # Verwende die simulative Zeit, die bereits in update_sim_clock hochgezählt wird
-        t = self.sim_clock
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    # -----------------------------------
-    # FEHLENDE METHODEN: Paketspawning, Würfelerzeugung u.a.
-    # -----------------------------------
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Bestimme zufällig eine Abgabestation als Ziel
-        if hasattr(self, "abgabe_stations") and self.abgabe_stations:
-            target_index = random.randint(1, len(self.abgabe_stations))
-        else:
-            target_index = 1
-
-        # Erstelle den Auftrag zur Annahmestation
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def update_order_table(self):
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen die Stationsnummer (oder verwende "N/A").
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z.B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige den zugewiesenen Fahrzeugnamen an (oder "-" falls noch keiner zugeordnet wurde).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END,
-                                   values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = 5.0  # 5 Sekunden Verzögerung zwischen Spawns
-        for station in self.annahme_stations:
-            # Wenn aktuell kein Paket an der Station ist
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                # Prüfe, ob seit der letzten Entnahme mindestens 5 Sekunden vergangen sind
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2, self.ax3) = plt.subplots(3, 1, figsize=(8, 9))
-
-        # Erster Plot: Pakete pro Minute
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-
-        # Zweiter Plot: Durchschnittliche Liegedauer
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-
-        # Dritter Plot: Durchschnittliche Lieferzeit
-        self.line3, = self.ax3.plot([], [], marker="o", color="green", label="Durchschnittliche Lieferzeit (s)")
-        self.ax3.set_xlabel("Simulationszeit (s)")
-        self.ax3.set_ylabel("Lieferzeit (s)")
-        self.ax3.set_title("Durchschnittliche Lieferzeit")
-        self.ax3.legend()
-        self.ax3.grid(True)
-
-        plt.show(block=False)
-        # Starte im Tkinter-Hauptloop eine periodische Aktualisierung:
-        self.tk_root.after(500, self.tk_graph_update)  # alle 500ms
-
-    def tk_graph_update(self):
-        # GIL sichern: Gibt einen Statuswert zurück, der später wieder freigegeben wird.
-        gil_state = ctypes.pythonapi.PyGILState_Ensure()
-        try:
-            times = [data[0] for data in self.graph_data]
-            rates = [data[1] for data in self.graph_data]
-            dwell = [data[2] for data in self.graph_data]
-            delivery = [data[3] for data in self.graph_data]
-
-            self.line1.set_data(times, rates)
-            self.ax1.relim()
-            self.ax1.autoscale_view()
-
-            self.line2.set_data(times, dwell)
-            self.ax2.relim()
-            self.ax2.autoscale_view()
-
-            self.line3.set_data(times, delivery)
-            self.ax3.relim()
-            self.ax3.autoscale_view()
-
-            self.fig.canvas.draw_idle()
-            self.fig.canvas.flush_events()
-        finally:
-            ctypes.pythonapi.PyGILState_Release(gil_state)
-
-        # Nächsten Aufruf in 500ms einplanen
-        self.tk_root.after(500, self.tk_graph_update)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Hier werden nur die gewünschten Spalten "ID", "Annahmestation", "Ziel" und "Fahrzeug" definiert.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    def pickup_package(self, vehicle, station):
-        # Falls das Fahrzeug bereits ein Paket trägt, abbrechen.
-        if vehicle.getPythonTag("package_attached"):
-            return
-
-        # Führe den Pickup nur aus, wenn an der Station ein Paket vorhanden ist.
-        if station in self.pickup_packages:
-            # Hole das Paket, den Spawn-Zeitpunkt und den zugehörigen Timer-Knoten.
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            # Entferne den Timer-Knoten, sodass der angezeigte Zähler nicht weiter aktualisiert wird.
-            timer_np.removeNode()
-            # Berechne die Liegedauer (Differenz zwischen aktueller Simulationszeit und Spawn-Zeit).
-            dwell_time = self.sim_clock - spawn_time
-            # Aktualisiere globale Kennzahlen.
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Suche in den Aufträgen nach dem Auftrag, dessen Paket mit diesem Paket übereinstimmt,
-            # und speichere den errechneten Endwert (fixe Liegedauer) sowie den Status.
-            for order_id, order in self.orders.items():
-                if order.get("package") == package:
-                    order["dwell_time"] = dwell_time
-                    order["status"] = "Abgeholt"
-                    break
-
-            # Hole Referenzen zum Gabel-Knoten und zum grünen Marker des Fahrzeugs.
-            fork_node = vehicle.getPythonTag("fork_node")
-            fork_green = vehicle.getPythonTag("fork_green")
-            green_point_pos = fork_green.getPos(fork_node)
-
-            # Übergib das Paket an den Gabel-Knoten (sodass es optisch dem Fahrzeug zugeordnet wird)
-            # und positioniere es relativ zum grünen Marker.
-            package.wrtReparentTo(fork_node)
-            package.setPos(green_point_pos.getX() + 0.5,
-                           green_point_pos.getY() - 0.5,
-                           green_point_pos.getZ() + 1)
-            self.cargos[vehicle] = package
-
-            # Starte den Lieferzeit-Timer: Speichere den Zeitpunkt, an dem das Paket abgeholt wurde,
-            # und hänge einen neuen Timer-Knoten an das Paket.
-            vehicle.setPythonTag("delivery_start_time", self.sim_clock)
-            from panda3d.core import TextNode
-            delivery_timer_text = TextNode("delivery_timer")
-            delivery_timer_text.setText("0.0s")
-            delivery_timer_np = package.attachNewNode(delivery_timer_text)
-            delivery_timer_np.setScale(0.5)
-            delivery_timer_np.setPos(0, 0, 1.2)
-            package.setPythonTag("delivery_timer", delivery_timer_np)
-
-            # Aktualisiere den Zeitpunkt, zu dem an dieser Station zuletzt ein Paket entfernt wurde.
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-
-            # Berechne Lieferzeit:
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start is not None:
-                delivery_time = self.sim_clock - delivery_start
-                self.total_delivery_time += delivery_time
-                self.total_delivery_count += 1
-                self.max_overall_delivery_time = max(self.max_overall_delivery_time, delivery_time)
-                vehicle.clearPythonTag("delivery_start_time")
-
-            # Entferne den Lieferzeit-Timer vom Paket
-            delivery_timer_np = cargo.getPythonTag("delivery_timer")
-            if delivery_timer_np:
-                delivery_timer_np.removeNode()
-
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden das Paket entfernt
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def update_delivery_timers(self, task):
-        for vehicle, package in list(self.cargos.items()):
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start:
-                elapsed_delivery = self.sim_clock - delivery_start
-                delivery_timer_np = package.getPythonTag("delivery_timer")
-                if delivery_timer_np and not delivery_timer_np.isEmpty():
-                    delivery_timer_np.node().setText(f"{elapsed_delivery:.1f}s")
-        return Task.cont
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-
-    def select_next_order(self, vehicle):
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        for order in waiting_orders:
-            dwell_time = self.sim_clock - order.get("spawn_time", self.sim_clock)
-            order["dwell_time"] = dwell_time
-
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        vehicle_pos = vehicle.getPos(self.render)
-
-        def distance_to_station(order):
-            station = order.get("pickup_station")
-            if station:
-                station_pos = station.getPos(self.render)
-                return (station_pos - vehicle_pos).length()
-            return float('inf')
-
-        candidates.sort(key=distance_to_station)
-        chosen_order = candidates[0]
-        chosen_order["vehicle"] = f"Fahrzeug {vehicle.getPythonTag('vehicle_id')}"
-        return chosen_order
-
-    # Diese Methode simuliert einen einfachen Lidar-Scan, indem sie alle anderen Fahrzeuge betrachtet.
-    # Liegt ein Fahrzeug näher als sensor_range, wird ein repulsiver Vektor zurückgegeben.
-    def compute_avoidance_vector(self, vehicle, sensor_range=5.0):
-        """
-        Berechnet den repulsiven Vektor zur Kollisionsvermeidung,
-        allerdings **nur** für Fahrzeuge, die eine höhere Priorität haben als das aktuelle Fahrzeug.
-
-        Parameters:
-          vehicle: Das aktuelle Fahrzeug (NodePath), für das der Vektor berechnet wird.
-          sensor_range: Maximaler Abstand, in dem Fahrzeuge als Hindernisse gelten.
-
-        Returns:
-          Ein Vec2, der den zusätzlichen Ausweichvektor enthält (kann auch 0 sein).
-        """
-        avoidance = Vec2(0, 0)
-        current_pos = vehicle.getPos(self.render)
-        # Hole den eigenen Prioritätswert; Standard ist 1 (niedrigste Priorität)
-        my_priority = vehicle.getPythonTag("priority") if vehicle.hasPythonTag("priority") else 1
-
-        for other in self.garage_vehicles:
-            if other == vehicle:
-                continue
-            # Hole den Prioritätswert des anderen Fahrzeugs
-            other_priority = other.getPythonTag("priority") if other.hasPythonTag("priority") else 1
-            # Nur wenn das andere Fahrzeug eine höhere Priorität hat, sollte unser Fahrzeug ausweichen.
-            if other_priority > my_priority:
-                other_pos = other.getPos(self.render)
-                diff = Vec2(current_pos.getX() - other_pos.getX(),
-                            current_pos.getY() - other_pos.getY())
-                dist = diff.length()
-                if dist < sensor_range and dist > 0.001:
-                    weight = (sensor_range - dist) / sensor_range
-                    # Addiere den repulsiven Vektor – hier ohne zusätzliche Symmetrie, also faktor = 1.0
-                    avoidance += diff.normalized() * weight
-            else:
-                # Bei gleicher oder niedriger Priorität: kein Abstoßungseffekt
-                continue
-
-        return avoidance
-
-    def apply_priority_logic(self, vehicle):
-        """
-        Bestimmt anhand der Vorfahrtslogik, ob das Fahrzeug normal fahren darf (Rückgabe 1.0)
-        oder ob es gebremst bzw. gestoppt werden soll (Rückgabe 0.0).
-
-        Regeln:
-          - Fahrzeuge mit einem Paket (package_attached == True) haben grundsätzlich Vorrang.
-          - Haben zwei Fahrzeuge beide ein Paket, so hat das Fahrzeug mit dem kürzeren Weg
-            zur zugehörigen Station (entsprechend current_order["pickup_station"] oder "ziel")
-            Vorrang. Das Fahrzeug mit der längeren Strecke wird gebremst.
-          - Ist ein Fahrzeug bereits in der Station (z. B. order_state in ["pickup", "drop"]),
-            so muss jedes andere Fahrzeug, das näher als 3 Meter an der zugehörigen Station ist,
-            warten (Rückgabe 0.0).
-          - Fahrzeuge ohne Paket fahren immer mit 0 (also warten), sofern ein anderes Fahrzeug
-            in den Vorrang fällt.
-
-        Rückgabewert:
-          Ein Multiplikator (float) für die gewünschte Geschwindigkeit: 1.0 = volles Tempo, 0.0 = Stopp.
-        """
-        my_pos = vehicle.getPos(self.render)
-        my_package = vehicle.getPythonTag("package_attached")
-        my_state = vehicle.getPythonTag("order_state")
-        my_order = vehicle.getPythonTag("current_order")
-
-        # Zuerst: Falls ein Fahrzeug bereits in der Station ist, muss jedes Fahrzeug, das näher als 3 m an den
-        # entsprechenden Stations-Koordinaten ist, bremsen.
-        # Wir gehen hier vorerst von Pickup-Stations aus – für Dropoff kann diese Logik analog ergänzt werden.
-        if my_order is not None and "pickup_station" in my_order:
-            station = my_order["pickup_station"]
-            station_pos = station.getPos(self.render)
-            if (my_pos - station_pos).length() < 3.0 and my_state not in ["pickup", "drop"]:
-                # Das Fahrzeug ist zu nah an einer Station, an der schon ein Fahrzeug aktiv ist – bremsen.
-                return 0.0
-
-        # Fahrzeug hat Paket?
-        if my_package:
-            # Wenn ich ein Paket habe, prüfe, ob ein anderes Fahrzeug, das auch ein Paket hat, einen kürzeren Weg hat
-            # zur (Pickup-)Station.
-            if my_order is not None and "pickup_station" in my_order:
-                my_station = my_order["pickup_station"]
-                station_pos = my_station.getPos(self.render)
-                my_dist = (my_pos - station_pos).length()
-                for other in self.garage_vehicles:
-                    if other == vehicle:
-                        continue
-                    # Nur Fahrzeuge, die auch ein Paket tragen, vergleichen wir.
-                    if other.getPythonTag("package_attached"):
-                        other_order = other.getPythonTag("current_order")
-                        if other_order is not None and "pickup_station" in other_order:
-                            other_station = other_order["pickup_station"]
-                            other_pos = other.getPos(self.render)
-                            other_dist = (other_pos - other_station.getPos(self.render)).length()
-                            # Hat ein anderes Fahrzeug einen kürzeren Weg, dann darf ich nicht fahren:
-                            if other_dist < my_dist:
-                                return 0.0
-                # Wenn kein anderes Fahrzeug einen kürzeren Weg hat (oder keines das Paket hat),
-                # fahre normal:
-                return 1.0
-            else:
-                # Falls ich ein Paket habe, aber der Auftrag ist unvollständig, einfach volle Geschwindigkeit
-                return 1.0
-        else:
-            # Fahrzeuge ohne Paket müssen im Zweifelsfall warten, wenn sich ein Fahrzeug mit Paket in der Nähe befindet.
-            for other in self.garage_vehicles:
-                if other == vehicle:
-                    continue
-                if other.getPythonTag("package_attached"):
-                    return 0.0
-            # Wenn keiner ein Paket hat, fahren beide normal:
-            return 1.0
-
-    # ---------------------------------------------------------------------------
-    # Fahrzeugsteuerung: Ursprüngliche Zustandsmaschine, erweitert um Kollisionsvermeidung
-    # in den Phasen translate, to_delivery, phase11 und return_to_garage.
-    def vehicle_order_task(self, vehicle, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        state = vehicle.getPythonTag("order_state")
-        current_order = vehicle.getPythonTag("current_order")
-
-        # ------------------ Phase 1: Translate (Fahrt zum Pickup) ------------------
-        if state == "translate":
-            # Falls noch kein Auftrag vorhanden, einen zuweisen
-            if current_order is None:
-                next_order = self.select_next_order(vehicle)
-                if next_order is not None:
-                    vehicle.setPythonTag("current_order", next_order)
-                    next_order["status"] = "In Bearbeitung"
-                    print(
-                        f"Auftrag {next_order['id']} wird zugewiesen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}.")
-                else:
-                    print("Kein Auftrag verfügbar – Fallback zum globalen Ziel.")
-                current_order = vehicle.getPythonTag("current_order")
-
-            # Ziel: Pickup-Station (über den blauen Marker)
-            if current_order is not None:
-                pickup_station = current_order.get("pickup_station")
-                if pickup_station in self.station_blue_dots:
-                    target = self.station_blue_dots[pickup_station].getPos(self.render)
-                else:
-                    target = self.blue_dot.getPos(self.render)
-            else:
-                # Fallback
-                target = self.blue_dot.getPos(self.render)
-
-            current_pos = vehicle.getPos(self.render)
-
-            # Hole den globalen Heading-Wert des Lenkpivots (steering_axis)
-            pivot = vehicle.getPythonTag("steering_axis")
-            global_hpr = pivot.getNetTransform().getHpr()  # Liefert Vec3(H, P, R)
-            global_heading = global_hpr.getX()  # Heading in Grad
-            current_heading_rad = math.radians(global_heading)
-
-            # Berechne gewünschten Heading anhand der Differenz zum Ziel
-            desired_heading_rad = math.atan2(target.getY() - current_pos.getY(),
-                                             target.getX() - current_pos.getX())
-            heading_error = desired_heading_rad - current_heading_rad
-            while heading_error > math.pi:
-                heading_error -= 2 * math.pi
-            while heading_error < -math.pi:
-                heading_error += 2 * math.pi
-
-            gain = 1.0
-            max_delta = gain * dt
-            delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-            delta_heading_deg = math.degrees(delta_heading_rad)
-
-            # Drehe das Fahrzeug um den Pivot
-            self.rotate_around_pivot(vehicle, pivot, delta_heading_deg)
-
-            # Aktualisiere die Fahrzeugposition basierend auf der neuen globalen Heading-Ausrichtung
-            global_hpr = pivot.getNetTransform().getHpr()  # nach Rotation
-            new_global_heading = global_hpr.getX()  # in Grad
-            new_heading_rad = math.radians(new_global_heading)
-            speed = 1.5  # Geschwindigkeit anpassen
-            new_x = current_pos.getX() + speed * math.cos(new_heading_rad) * dt
-            new_y = current_pos.getY() + speed * math.sin(new_heading_rad) * dt
-
-            # --- Kollisionsvermeidung in Phase translate ---
-            avoidance = self.compute_avoidance_vector(vehicle, sensor_range=5.0)
-            avoidance_weight = 0.3  # Gewichtung des Verletzungsvektors; anpassen nach Bedarf.
-            new_x += avoidance.getX() * avoidance_weight
-            new_y += avoidance.getY() * avoidance_weight
-            new_pos = Vec3(new_x, new_y, 0)
-            vehicle.setPos(new_pos)
-
-            # Wenn das Fahrzeug nahe genug am Ziel ist, Zustand wechseln
-            distance_to_target = math.sqrt((target.getX() - new_pos.getX()) ** 2 +
-                                           (target.getY() - new_pos.getY()) ** 2)
-            if distance_to_target < 0.1:
-                vehicle.setPos(target)
-                vehicle.setPythonTag("order_state", "rotate")
-
-
-        # ------------------ Phase 2: Rotate ------------------
-        elif state == "rotate":
-            desired_angle = math.degrees(math.atan2(self.station_white_direction.getY(),
-                                                    self.station_white_direction.getX()))
-            desired_angle = (desired_angle + 180) % 360
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_angle - current_heading + 180) % 360) - 180
-            kp_heading = 0.5
-            new_heading = current_heading + kp_heading * angle_diff
-            vehicle.setH(new_heading)
-            if abs(angle_diff) < 1.0:
-                vehicle.setPythonTag("order_state", "turn_right")
-
-        # ------------------ Phase 3: Turn Right ------------------
-        elif state == "turn_right":
-            if vehicle.getPythonTag("turn_right_init") is None:
-                vehicle.setPythonTag("turn_right_init", vehicle.getH() % 360)
-                vehicle.setPythonTag("turn_right_target", (vehicle.getPythonTag("turn_right_init") + 90) % 360)
-                print("Phase 3: Initialisiert für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "Start Heading =", vehicle.getPythonTag("turn_right_init"),
-                      "Target Heading =", vehicle.getPythonTag("turn_right_target"))
-            current_heading = vehicle.getH() % 360
-            turn_right_target = vehicle.getPythonTag("turn_right_target")
-            angle_diff = ((turn_right_target - current_heading + 180) % 360) - 180
-            kp_turn = 0.5
-            turn_rate = kp_turn * angle_diff
-            new_heading = current_heading + turn_rate * dt
-            vehicle.setH(new_heading)
-            print("Phase 3: Fahrzeug", vehicle.getPythonTag("vehicle_id"), "- Aktuelles Heading =", current_heading,
-                  "Winkelabweichung =", angle_diff, "Neues Heading =", new_heading)
-            if abs(angle_diff) < 1.0:
-                print("Phase 3: Drehung abgeschlossen für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      ". Übergang in 'approach'.")
-                vehicle.setPythonTag("order_state", "approach")
-                vehicle.clearPythonTag("turn_right_init")
-                vehicle.clearPythonTag("turn_right_target")
-
-        # ------------------ Phase 4: Approach ------------------
-        elif state == "approach":
-            if current_order is not None:
-                pickup_station = current_order.get("pickup_station")
-                target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-            else:
-                target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-            current = vehicle.getPos(self.render)
-            error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-            if error_vec.length() > 0.05:
-                direction = error_vec.normalized()
-                move_distance = 1.5 * dt
-                new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                               current.getY() + direction.getY() * move_distance, target.getZ())
-                vehicle.setPos(new_pos)
-            else:
-                vehicle.setPos(target)
-                vehicle.setPythonTag("order_state", "pickup")
-
-        # ------------------ Phase 5: Pickup ------------------
-        elif state == "pickup":
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            target_z = 1.0
-            raise_speed = 0.5
-            if current_z < target_z:
-                fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-            else:
-                if current_order is None:
-                    if self.orders_queue:
-                        vehicle.setPythonTag("current_order", self.orders_queue.pop(0))
-                    else:
-                        print("Keine verfügbaren Aufträge für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                              ". Überspringe Pickup-Phase.")
-                        vehicle.setPythonTag("order_state", "drive_out")
-                        return task.cont
-                if not vehicle.getPythonTag("package_attached"):
-                    pickup_station = vehicle.getPythonTag("current_order")["pickup_station"]
-                    self.pickup_package(vehicle, pickup_station)
-                    vehicle.setPythonTag("package_attached", True)
-                if vehicle.getPythonTag("drive_out_target") is None:
-                    vehicle.setPythonTag("drive_out_target",
-                                         vehicle.getPos(self.render) + vehicle.getQuat(self.render).getForward() * 5.0)
-                vehicle.setPythonTag("order_state", "drive_out")
-
-        # ------------------ Phase 6: Drive Out ------------------
-        elif state == "drive_out":
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            if current_z > 0.0:
-                lower_speed = 0.5
-                fork_node.setZ(max(0.0, current_z - lower_speed * dt))
-            current_pos = vehicle.getPos(self.render)
-            drive_out_target = vehicle.getPythonTag("drive_out_target")
-            if drive_out_target is None:
-                drive_out_target = current_pos + vehicle.getQuat(self.render).getForward() * 5.0
-                vehicle.setPythonTag("drive_out_target", drive_out_target)
-            diff = drive_out_target - current_pos
-            if diff.length() > 0.1:
-                move_distance = 0.5 * dt
-                step = diff.normalized() * move_distance
-                new_pos = current_pos + step
-                new_pos.setZ(0)  # Fahrzeug bleibt am Boden
-                vehicle.setPos(new_pos)
-            else:
-                vehicle.setPythonTag("order_state", "to_delivery")
-                vehicle.setPythonTag("drive_out_target", None)
-
-        # ------------------ Phase 7: To Delivery (Fahrt zur Abgabestation) ------------------
-        elif state == "to_delivery":
-            if current_order is None:
-                return Task.cont
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                target = self.abgabe_blue_dots[0].getPos(self.render)
-
-            current_pos = vehicle.getPos(self.render)
-            pivot = vehicle.getPythonTag("steering_axis")
-            global_hpr = pivot.getNetTransform().getHpr()
-            global_heading = global_hpr.getX()  # in Grad
-            current_heading_rad = math.radians(global_heading)
-            desired_heading_rad = math.atan2(target.getY() - current_pos.getY(),
-                                             target.getX() - current_pos.getX())
-            heading_error = desired_heading_rad - current_heading_rad
-            while heading_error > math.pi:
-                heading_error -= 2 * math.pi
-            while heading_error < -math.pi:
-                heading_error += 2 * math.pi
-            gain = 1.0
-            max_delta = gain * dt
-            delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-            delta_heading_deg = math.degrees(delta_heading_rad)
-            self.rotate_around_pivot(vehicle, pivot, delta_heading_deg)
-            global_hpr = pivot.getNetTransform().getHpr()
-            new_global_heading = global_hpr.getX()
-            new_heading_rad = math.radians(new_global_heading)
-            speed = 1.5
-            new_x = current_pos.getX() + speed * math.cos(new_heading_rad) * dt
-            new_y = current_pos.getY() + speed * math.sin(new_heading_rad) * dt
-
-            # --- Kollisionsvermeidung in Phase "to_delivery" ---
-            avoidance = self.compute_avoidance_vector(vehicle, sensor_range=5.0)
-            avoidance_weight = 0.3
-            new_x += avoidance.getX() * avoidance_weight
-            new_y += avoidance.getY() * avoidance_weight
-
-            new_pos = Vec3(new_x, new_y, 0)
-            vehicle.setPos(new_pos)
-
-            distance_to_target = math.sqrt((target.getX() - new_pos.getX()) ** 2 +
-                                           (target.getY() - new_pos.getY()) ** 2)
-            if distance_to_target < 0.5:
-                print(
-                    f"Phase 7 abgeschlossen: Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den blauen Punkt erreicht.")
-                vehicle.setPythonTag("order_state", "align_delivery")
-
-        # ------------------ Phase 8: Align Delivery ------------------
-        elif state == "align_delivery":
-            desired_heading = 90.0
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_heading - current_heading + 180) % 360) - 180
-            print("Phase 8: Align Delivery | Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                  "Current Heading: {:.2f}°, Desired: {:.2f}°, Diff: {:.2f}°".format(current_heading, desired_heading,
-                                                                                     angle_diff))
-            fixed_turn_speed = 90.0
-            turn_amount = fixed_turn_speed * dt
-            if abs(angle_diff) < 1.0:
-                vehicle.setH(desired_heading)
-                print("Phase 8 abgeschlossen: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "ausgerichtet (Heading = {:.2f}°).".format(desired_heading))
-                vehicle.setPythonTag("order_state", "delivery_center")
-            else:
-                if angle_diff > 0:
-                    new_heading = current_heading + turn_amount
-                else:
-                    new_heading = current_heading - turn_amount
-                new_heading %= 360
-                vehicle.setH(new_heading)
-                print("Phase 8: Rotating - Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "New Heading set to {:.2f}°".format(new_heading))
-
-        # ------------------ Phase 9: Delivery Approach ------------------
-        elif state == "delivery_center":
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current = vehicle.getPos(self.render)
-            target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-            print("Phase 9: Zielpunkt der Abgabestation für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                  "=", target_point)
-            error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-            tolerance = 0.05
-            move_distance = 1.5 * dt
-            if error_vec.length() > tolerance:
-                direction = error_vec.normalized()
-                new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                               current.getY() + direction.getY() * move_distance, current.getZ())
-                vehicle.setPos(new_pos)
-                print("Phase 9: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "bewegt sich von", current, "nach", new_pos)
-            else:
-                vehicle.setPos(target_point)
-                print("Phase 9: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "hat den Zielpunkt erreicht.")
-                vehicle.setPythonTag("order_state", "drop")
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_fork_z = fork_node.getZ()
-            if current_fork_z < 1.0:
-                new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-                fork_node.setZ(new_fork_z)
-                print("Phase 9: Gabel wird angehoben für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "(Z =", new_fork_z, ").")
-
-        # ------------------ Phase 10: Dropoff ------------------
-        elif state == "drop":
-            if vehicle.getPythonTag("package_attached"):
-                delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-                self.drop_cargo(vehicle)
-                print("Phase 10: Paket abgesetzt für Fahrzeug", vehicle.getPythonTag("vehicle_id"))
-                vehicle.setPythonTag("package_attached", False)
-            else:
-                fork_node = vehicle.getPythonTag("fork_node")
-                current_z = fork_node.getZ()
-                if current_z > 0.0:
-                    lower_speed = 0.5
-                    new_z = max(0.0, current_z - lower_speed * dt)
-                    fork_node.setZ(new_z)
-                    print("Phase 10: Gabel wird abgesenkt für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          ", aktueller Z-Wert =", new_z)
-                else:
-                    print("Phase 10: Dropoff vollständig abgeschlossen für Fahrzeug",
-                          vehicle.getPythonTag("vehicle_id"))
-                    if vehicle.getPythonTag("standby_pending"):
-                        vehicle.setPythonTag("order_state", "return_to_garage")
-                        print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} kehrt zur Garage zurück (Standby).")
-                    else:
-                        vehicle.setPythonTag("order_state", "translate")
-                    current_order["status"] = "Abgegeben"
-                    current_order["delivered_at"] = self.sim_clock
-                    vehicle.setPythonTag("current_order", None)
-
-        # ------------------ Phase 11: Exit Station and Start Next Order ------------------
-        elif state == "phase11":
-            if vehicle.getPythonTag("last_delivery_marker") is not None:
-                target_point = vehicle.getPythonTag("last_delivery_marker")
-            else:
-                delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    target_point = self.abgabe_blue_dots[0].getPos(self.render)
-                print("Phase 11: Zielpunkt (blauer Marker) für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "=", target_point)
-                current_pos = vehicle.getPos(self.render)
-                diff = target_point - current_pos
-                if diff.length() > 0.1:
-                    move_distance = 0.5 * dt
-                    step = diff.normalized() * move_distance
-                    new_pos = current_pos + step
-                    # --- Kollisionsvermeidung in Phase 11 ---
-                    avoidance = self.compute_avoidance_vector(vehicle, sensor_range=5.0)
-                    avoidance_weight = 0.3
-                    new_pos.setX(new_pos.getX() + avoidance.getX() * avoidance_weight)
-                    new_pos.setY(new_pos.getY() + avoidance.getY() * avoidance_weight)
-                    vehicle.setPos(new_pos)
-                    print("Phase 11: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          "fährt aus der Station, neue Position =", new_pos)
-                else:
-                    vehicle.setPos(target_point)
-                    print("Phase 11: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          "hat den blauen Marker erreicht. Nächster Auftrag wird gestartet.")
-                    vehicle.setPythonTag("order_state", "next_order")
-
-        # ------------------ Return to Garage (Standby) ------------------
-        elif state == "return_to_garage":
-            garage_target = vehicle.getPythonTag("garage_target")
-            if garage_target is None:
-                garage_target = self.garagen_parking_points[0]
-            current_pos = vehicle.getPos(self.render)
-            diff = garage_target - current_pos
-            if diff.length() > 0.1:
-                move_distance = 1.0 * dt
-                new_pos = current_pos + diff.normalized() * move_distance
-                new_pos.setZ(0)  # Fahrzeug auf Boden bleiben
-                # --- Kollisionsvermeidung in Return to Garage ---
-                avoidance = self.compute_avoidance_vector(vehicle, sensor_range=5.0)
-                avoidance_weight = 0.3
-                new_pos.setX(new_pos.getX() + avoidance.getX() * avoidance_weight)
-                new_pos.setY(new_pos.getY() + avoidance.getY() * avoidance_weight)
-                vehicle.setPos(new_pos)
-            else:
-                if vehicle.hasPythonTag("start_heading"):
-                    vehicle.setH(vehicle.getPythonTag("start_heading"))
-                vehicle.setPythonTag("order_state", "idle")
-                vehicle.setPythonTag("standby_pending", False)
-                print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} ist in der Garage (Standby).")
-
-        return task.cont
-
-    # Neue Methode: Kontrollfenster zur Fahrzeugsteuerung
-    def show_vehicle_control(self):
-        # Falls das Fenster bereits existiert, bringe es einfach in den Vordergrund,
-        # ohne die Radiobuttons neu zu initialisieren.
-        if hasattr(self, "control_win") and self.control_win.winfo_exists():
-            self.control_win.deiconify()
-            self.control_win.lift()
-            self.control_win.focus_force()
-            return
-
-        # Erstelle das Kontrollfenster als Toplevel des persistenten tk_root.
-        self.control_win = tk.Toplevel(self.tk_root)
-        self.control_win.title("Fahrzeugsteuerung")
-        # Beim Schließen soll das Fenster nicht zerstört, sondern nur versteckt werden
-        self.control_win.protocol("WM_DELETE_WINDOW", self.control_win.withdraw)
-        # Sorge dafür, dass das Fenster initial über allem liegt
-        self.control_win.attributes("-topmost", True)
-        self.control_win.after(100, lambda: self.control_win.attributes("-topmost", False))
-
-        # Erzeuge das Dictionary für die StringVar-Zuordnungen für die Fahrzeuge.
-        self.vehicle_state_vars = {}
-        row = 0
-        for veh in self.garage_vehicles:
-            frame = tk.Frame(self.control_win)
-            frame.grid(row=row, column=0, sticky="w", padx=5, pady=2)
-            vid = veh.getPythonTag("vehicle_id")
-            label = tk.Label(frame, text=f"Fahrzeug {vid}")
-            label.pack(side=tk.LEFT)
-            # Initialisiere die Radiobutton-Variable anhand des aktuellen Fahrzeugzustandes.
-            state = veh.getPythonTag("order_state")
-            if state is None:
-                state = "idle"
-            var = tk.StringVar(value=state)
-            self.vehicle_state_vars[veh] = var
-            rb_active = tk.Radiobutton(frame, text="Aufträge bearbeiten", variable=var, value="translate")
-            rb_active.pack(side=tk.LEFT)
-            rb_standby = tk.Radiobutton(frame, text="Standby", variable=var, value="idle")
-            rb_standby.pack(side=tk.LEFT)
-            row += 1
-        update_btn = tk.Button(self.control_win, text="Übernehmen", command=self.update_vehicle_control)
-        update_btn.grid(row=row, column=0, pady=5)
-
-    def update_vehicle_control(self):
-        for veh, var in self.vehicle_state_vars.items():
-            new_state = var.get()
-            if new_state == "idle" and veh.getPythonTag("current_order") is not None:
-                veh.setPythonTag("standby_pending", True)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Standby angefordert (Auftrag wird fortgesetzt).")
-            else:
-                veh.setPythonTag("standby_pending", False)
-                veh.setPythonTag("order_state", new_state)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Zustand auf {new_state} gesetzt.")
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-
-if __name__ == "__main__":
-    # Wichtig: setze auf Windows die Startmethode auf "spawn"
-    multiprocessing.set_start_method('spawn')
-
-    # Erzeuge eine Queue, auch wenn sie später eventuell neu erstellt wird, wenn "G" gedrückt wird.
-    graph_q = Queue()
-    app = LagerSimulation(graph_q)
-    app.run()
-
-    # Beim Schließen der Simulation den Graphprozess ggf. beenden
-    if app.graph_process is not None:
-        app.graph_process.terminate()
-        app.graph_process.join()
-
-
Index: KI/KI37.py
===================================================================
diff --git a/KI/KI37.py b/KI/KI37.py
deleted file mode 100644
--- a/KI/KI37.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,664 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Matplotlib zum Plotten importieren
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs,
-    CardMaker
-)
-
-# Wir nutzen globalClock für dt.
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit & Zeitskalierungsfaktor
-        self.base_speed = 1.5  # Maximale Geschwindigkeit in m/s
-        self.speed_factor = 1.0
-
-        # Neue Parameter: Beschleunigung und Bremsverzögerung (Simulationseinheiten)
-        self.acceleration = 2.5  # m/s²
-        self.braking_deceleration = -2.5  # m/s² (negativ)
-
-        # Simulationszeitticker & Statistik
-        self.sim_clock = 0.0
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        self.sim_start_real = globalClock.getFrameTime()
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Zeichne für jede Annahmestation den Align-Punkt (2 m in positive X-Richtung)
-        for station in self.annahme_stationen:
-            station_pos = station.getPos()
-            ls_pickup = LineSegs()
-            ls_pickup.setThickness(3.0)
-            ls_pickup.setColor(LColor(1, 1, 1, 1))
-            ls_pickup.moveTo(station_pos)
-            ls_pickup.drawTo(station_pos + Vec3(2, 0, 0))
-            self.render.attachNewNode(ls_pickup.create())
-
-        # Zeichne für jede Abgabestation den Align-Punkt (2 m in negative X-Richtung)
-        for station in self.abgabe_stationen:
-            station_pos = station.getPos()
-            ls_dropoff = LineSegs()
-            ls_dropoff.setThickness(3.0)
-            ls_dropoff.setColor(LColor(1, 1, 1, 1))
-            ls_dropoff.moveTo(station_pos)
-            ls_dropoff.drawTo(station_pos + Vec3(-2, 0, 0))
-            self.render.attachNewNode(ls_dropoff.create())
-
-        # --- Anfahrstationen (Startstationen) für die Fahrzeuge ---
-        # Diese Stationen sollen bei Y = 15 nebeneinander mit 4 Meter Abstand in X-Richtung liegen.
-        self.anfahrstationen = []
-        num_departure = 2  # Zu Beginn nur 2 Fahrzeuge
-        spacing_departure = 4.0
-        start_x = -spacing_departure * (num_departure - 1) / 2
-        for i in range(num_departure):
-            pos = Vec3(start_x + i * spacing_departure, 15, 0)
-            station = self.erzeuge_gitterbox(pos.getX(), pos.getY(), pos.getZ(), LColor(0.8, 0.8, 0, 1))
-            self.anfahrstationen.append(station)
-
-        # Fahrzeuge erstellen, jeweils eines pro Anfahrstation (insgesamt 2 Fahrzeuge)
-        self.vehicles = []
-        self.cargos = {}  # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}  # Fahrzeug -> zugewiesene Dropoff-Station
-        for i, start_station in enumerate(self.anfahrstationen):
-            vehicle = self.loader.loadModel("models/box")
-            vehicle.setScale(1, 1, 0.5)
-            if i % 2 == 0:
-                vehicle.setColor(LColor(0, 0, 1, 1))
-            else:
-                vehicle.setColor(LColor(0, 0, 0.8, 1))
-            vehicle.setPos(start_station.getPos())
-            vehicle.reparentTo(self.render)
-            # Initialisiere die aktuelle Geschwindigkeit
-            vehicle.setPythonTag("current_speed", 0.0)
-            # Beim Start wird die Phase "pickup" gesetzt
-            vehicle.setPythonTag("phase", "pickup")
-            self.add_center_marker(vehicle)
-            self.add_offset_circle(vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-            self.vehicles.append(vehicle)
-
-        # Reste der Pick-up-/Drop-off-Logik
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Erfassung von Daten für Graphen (einmal pro Simulationssekunde)
-        self.graph_data = []
-        self.taskMgr.doMethodLater(1, self.record_graph_data, "RecordGraphDataTask")
-
-        # Graphen öffnen per Taste "G" (nach Schließen wieder möglich)
-        self.graph_opened = False
-        self.accept("g", self.open_graph)
-
-        # Zoom-Funktionalität: Mit Mausrad hereinz- bzw. herauszoomen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_lidar_status, "UpdateLidarStatusTask")
-
-        # Liefervorgang starten (Pickup-Phase) für jedes Fahrzeug mit gestaggertem Start
-        for i, vehicle in enumerate(self.vehicles):
-            self.taskMgr.doMethodLater(i * 0.5,
-                                       lambda task, v=vehicle: self.start_delivery_cycle(v, v.getPos()),
-                                       f"StartDeliveryCycleTask_{i}"
-                                       )
-
-    def zoom_in(self):
-        # Hereinzoomen: Field-of-View (FOV) verkleinern (nicht unter 10°)
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        # Herauszoomen: FOV vergrößern (nicht über 100°)
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def record_graph_data(self, task):
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0
-        self.graph_data.append((self.sim_clock, delivered_per_minute, avg_dwell_time))
-        return Task.again
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def add_offset_circle(self, vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5, num_segments=32):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        for i in range(num_segments + 1):
-            angle = 2 * math.pi * i / num_segments
-            x = circle_radius * math.cos(angle)
-            y = circle_radius * math.sin(angle)
-            if i == 0:
-                ls.moveTo(x, y, 0)
-            else:
-                ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        circle_np = vehicle.attachNewNode(circle_geom)
-        circle_np.setPos(offset)
-        vehicle.setPythonTag("lidar_circle", circle_np)
-
-    def draw_coordinate_axes(self, axis_length=5):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(1, 0, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        ls.setColor(0, 1, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        ls.setColor(0, 0, 1, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), (1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), (0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), (0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def update_lidar_status(self, task):
-        sensor_threshold = 3.0
-        for vehicle in self.vehicles:
-            pos = vehicle.getPos(self.render)
-            total_avoidance = Vec3(0, 0, 0)
-            # Standardmäßig volle Geschwindigkeit
-            multiplier = 1.0
-            phase = vehicle.getPythonTag("phase") if vehicle.hasPythonTag("phase") else "pickup"
-            # Dynamische Hindernisse: Andere Fahrzeuge
-            for other in self.vehicles:
-                if other is vehicle:
-                    continue
-                pos_other = other.getPos(self.render)
-                diff = pos - pos_other
-                d = diff.length()
-                if d < sensor_threshold:
-                    other_phase = other.getPythonTag("phase") if other.hasPythonTag("phase") else "pickup"
-                    # Priorität: Falls ein Fahrzeug in Pickup einem in Dropoff gegenübersteht
-                    if phase == "pickup" and other_phase == "dropoff":
-                        candidate = 0.1
-                        avoidance_weight = 2.0
-                    # Falls beide Fahrzeuge in Dropoff sind, entscheidet der Abstand zur Dropoff-Station
-                    elif phase == "dropoff" and other_phase == "dropoff":
-                        my_dropoff = self.current_dropoffs.get(vehicle)
-                        other_dropoff = self.current_dropoffs.get(other)
-                        if my_dropoff and other_dropoff:
-                            my_distance = (pos - my_dropoff.getPos()).length()
-                            other_distance = (pos_other - other_dropoff.getPos()).length()
-                            if my_distance > other_distance:
-                                candidate = 0.1
-                                avoidance_weight = 2.0
-                            else:
-                                candidate = 1.0
-                                avoidance_weight = 1.0
-                        else:
-                            candidate = 1.0
-                            avoidance_weight = 1.0
-                    else:
-                        candidate = 1.0
-                        avoidance_weight = 1.0
-                    multiplier = min(multiplier, candidate)
-                    if d > 0:
-                        total_avoidance += diff.normalized() * (sensor_threshold - d) * avoidance_weight
-
-            # Statische Hindernisse (Annahme-, Abgabe- und Anfahrstationen)
-            static_obstacles = self.annahme_stationen + self.abgabe_stationen + self.anfahrstationen
-            for obst in static_obstacles:
-                pos_obst = obst.getPos(self.render)
-                diff = pos - pos_obst
-                d = diff.length()
-                if d < sensor_threshold:
-                    candidate = 0.1
-                    avoidance_weight = 2.0
-                    multiplier = min(multiplier, candidate)
-                    if d > 0:
-                        total_avoidance += diff.normalized() * (sensor_threshold - d) * avoidance_weight
-
-            vehicle.setPythonTag("speed_multiplier", multiplier)
-            vehicle.setPythonTag("avoidance", total_avoidance)
-            lidar_circle = vehicle.getPythonTag("lidar_circle")
-            if lidar_circle:
-                if multiplier < 1.0 or total_avoidance.length() > 0.001:
-                    lidar_circle.setColor(LColor(1, 0, 0, 1))
-                else:
-                    lidar_circle.setColor(LColor(0, 1, 0, 1))
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-        current_wait_text = (
-            f"Liegedauer (aktuell): {current_max_wait_time:.1f}s"
-            if current_max_wait_time > 0 else "Kein Paket an Annahmestation"
-        )
-        maximal_wait_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted_time}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-            f"{current_wait_text}\n"
-            f"{maximal_wait_text}\n"
-            f"Liegedauer (Durchschnitt): {avg_dwell_time:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(
-            station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1)
-        )
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        def move_task(task):
-            dt = globalClock.getDt()
-            # Nutze sim_dt als simulierte Zeit (dt * Speed Factor)
-            sim_dt = dt * self.speed_factor
-            current_pos = vehicle.getPos()
-            to_target = target - current_pos
-            distance = to_target.length()
-
-            # Geschwindigkeitsbegrenzung anhand des aktuellen avoidance multipliers
-            multiplier = vehicle.getPythonTag("speed_multiplier") if vehicle.hasPythonTag("speed_multiplier") else 1.0
-            effective_max_speed = self.base_speed * multiplier  # in m/s im Simulationszeitmaßstab
-
-            current_speed = vehicle.getPythonTag("current_speed") if vehicle.hasPythonTag("current_speed") else 0.0
-
-            # Berechne den notwendigen Bremsweg: v² / (2 * |a|)
-            braking_distance = (current_speed * current_speed) / (
-                        2 * abs(self.braking_deceleration)) if current_speed > 0 else 0
-
-            if distance <= braking_distance:
-                # Bremsvorgang
-                new_speed = current_speed + self.braking_deceleration * sim_dt
-                new_speed = max(new_speed, 0.0)
-            else:
-                # Beschleunigen bis zur maximalen effektiven Geschwindigkeit
-                new_speed = current_speed + self.acceleration * sim_dt
-                new_speed = min(new_speed, effective_max_speed)
-
-            step_distance = new_speed * sim_dt
-
-            if distance <= step_distance:
-                vehicle.setPos(target)
-                vehicle.setPythonTag("current_speed", 0.0)
-                on_complete()
-                return Task.done
-
-            avoidance = vehicle.getPythonTag("avoidance") if vehicle.hasPythonTag("avoidance") else Vec3(0, 0, 0)
-            if avoidance.length() > 0.001:
-                combined = to_target.normalized() + avoidance.normalized() * 0.5
-                if combined.length() > 0.001:
-                    combined.normalize()
-                else:
-                    combined = to_target.normalized()
-                new_direction = combined
-            else:
-                new_direction = to_target.normalized()
-
-            new_pos = current_pos + new_direction * step_distance
-            vehicle.setPos(new_pos)
-            vehicle.setPythonTag("current_speed", new_speed)
-            return Task.cont
-
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        # Beginn eines neuen Auftrags: Phase "pickup" und Speichern des job_start-Zeitpunkts
-        vehicle.setPythonTag("job_start", self.sim_clock)
-        vehicle.setPythonTag("phase", "pickup")
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        # Verfügbare Pickup-Stationen, die momentan nicht belegt sind
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-
-        # Kombiniertes Ranking: Wartezeit minus ein Anteil an der Entfernung
-        distance_weight = 0.5  # Anpassbar
-        pickup_station = max(available_pickups, key=lambda s: (current_time - self.pickup_packages[s][1]) -
-                                                              distance_weight * (
-                                                                          s.getPos() - vehicle.getPos()).length())
-        self.occupied_pickups.add(pickup_station)
-        pickup_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        self.move_vehicle_to(vehicle, pickup_align,
-                             lambda: self.move_vehicle_to(vehicle, pickup_station.getPos(),
-                                                          lambda: self.after_pickup(vehicle, pickup_station)
-                                                          )
-                             )
-
-    def after_pickup(self, vehicle, pickup_station):
-        self.pickup_package(vehicle, pickup_station)
-        # Nach erfolgreichem Pickup Phase auf "dropoff" setzen
-        vehicle.setPythonTag("phase", "dropoff")
-        self.depart_from_pickup(vehicle, pickup_station,
-                                lambda: self.start_dropoff_phase(vehicle)
-                                )
-
-    def depart_from_pickup(self, vehicle, pickup_station, callback):
-        departure_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        departure_target = pickup_station.getPos() + Vec3(4, 0, 0)
-        self.move_vehicle_to(vehicle, departure_align,
-                             lambda: self.move_vehicle_to(vehicle, departure_target, callback)
-                             )
-
-    def start_dropoff_phase(self, vehicle):
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.start_dropoff_phase(vehicle)
-            return
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-        self.move_vehicle_to(vehicle, dropoff_align,
-                             lambda: self.move_vehicle_to(vehicle, dropoff_station.getPos(),
-                                                          lambda: self.after_dropoff(vehicle)
-                                                          )
-                             )
-
-    def after_dropoff(self, vehicle):
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        self.drop_cargo(vehicle)
-        self.remove_cargo(vehicle, remove_dropoff=True)
-        if dropoff_station is not None:
-            departure_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-            departure_target = dropoff_station.getPos() + Vec3(-4, 0, 0)
-            self.move_vehicle_to(vehicle, departure_align,
-                                 lambda: self.move_vehicle_to(vehicle, departure_target,
-                                                              lambda: self.start_delivery_cycle(vehicle,
-                                                                                                departure_target)
-                                                              )
-                                 )
-        else:
-            self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle, remove_dropoff=True):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        if remove_dropoff:
-            dropoff_station = self.current_dropoffs.get(vehicle)
-            if dropoff_station in self.occupied_dropoffs:
-                self.occupied_dropoffs.remove(dropoff_station)
-            if vehicle in self.current_dropoffs:
-                del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
-
-#Hier ist in die Fahrlogik die sequenzielle abarbeitung inkludiert. Nicht nur der Zeitfaktor, auc hder Weg spielt eine Rolle
\ No newline at end of file
Index: Grundmodell/Gm15.py
===================================================================
diff --git a/Grundmodell/Gm15.py b/Grundmodell/Gm15.py
deleted file mode 100644
--- a/Grundmodell/Gm15.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,1305 +0,0 @@
-import random
-import math
-import tkinter as tk  # Für das extra Fenster der Auftragsübersicht
-from tkinter import ttk  # Für die tabellarische Darstellung (Treeview)
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5  # Wird in update_vehicle genutzt
-        self.state_timer = 0.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Paketspawning an den Annahmestationen:
-        # Mapping: station (Dummy-Node) -> (Paket, Spawnzeit, Timer Node)
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-        # Neues Attribut: Verknüpfung Fahrzeug -> transportiertes Paket
-        self.cargos = {}
-
-        # NEU: Initialisiere die belegten Annahmestationen
-        self.occupied_pickups = set()  # Oder: [] für eine Liste
-
-        # Graph-Daten (Sim-Zeit, Pakete pro Minute, durchschnittliche Liegedauer)
-        self.graph_data = []
-        self.graph_opened = False
-
-        # Auftragsverwaltung: Speichere alle Aufträge (für die Anzeige) sowie in
-        # einer Queue (Liste) zur sequentiellen Abarbeitung.
-        self.orders = {}         # Für die Anzeige
-        self.orders_queue = []   # Für die Fahrzeugabwicklung (FIFO)
-        self.next_order_id = 1
-
-        # Tkinter-Fenster für Auftragsübersicht
-        self.order_win = None
-        self.order_tree = None
-
-        # Umgebung initialisieren
-        self.draw_origin()
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.create_wall()
-        self.create_annahme_stations()
-        self.create_abgabe_stations()  # Hier wird auch self.abgabe_stations angelegt.
-        self.create_garagen_stations()
-
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # Fahrzeuge in den Garagen erstellen (genau 5 Fahrzeuge)
-        self.create_garage_vehicles()
-
-        # NEU: Auftragssystem für das Testfahrzeug initialisieren
-        # Zustände: "idle", "to_pickup", "wait_pickup", "to_delivery", "deliver"
-        self.first_vehicle_order_state = "idle"
-        self.attached_package = None
-        self.current_order = None  # Der aktuell abgearbeitete Auftrag
-        self.taskMgr.add(self.vehicle_order_task, "VehicleOrderTask")
-
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-        self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    # ---------------------------
-    # SIMULATION UND UI-METHODEN
-    # ---------------------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    # ---------------------------
-    # METHODEN FÜR RASTER, LICHT, MAUER, URSPRUNG
-    # ---------------------------
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # STATIONSOBJEKTE UND ZUORDNUNG
-    # -----------------------------------
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        # Beispielhafte Station-Punkte (siehe dein ursprünglicher Code)
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basisstation (zum Beispiel Rahmen)
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Erzeuge den Marker (großer weißer Punkt) als Orientierung
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Erzeuge den grünen Punkt an der Station (als optionaler Punkt)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zeichne die weiße Linie an der Station.
-            # Die Linie beginnt bei: center + Vec3(0,0,-0.5) und verläuft 3 Meter in X-Richtung.
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            white_line_node = self.render.attachNewNode(line_seg.create())
-
-            # Speichere den Node der weißen Linie global
-            self.white_line = white_line_node
-
-            # Berechne den Mittelpunkt der weißen Linie
-            self.white_line_center = (start_line + end_line) * 0.5
-
-            # Berechne die Richtung der weißen Linie (als 2D-Vektor, normalisiert)
-            line_vec = end_line - start_line
-            self.station_white_direction = Vec2(line_vec.getX(), line_vec.getY()).normalized()
-
-            # Erzeuge den blauen Punkt – dieser dient als Ziel in Phase 1.
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            # Speichere global relevante Punkte für die erste Station
-            if i == 1:
-                self.blue_dot = blue_dot
-                self.station_green_dot = green_dot
-
-            # (Optional) Textanzeige der Stationsnummer:
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) – falls benötigt:
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        self.abgabe_stations = []  # Liste der Abgabestationen
-        self.abgabe_blue_dots = []  # Liste zum Speichern der blauen Marker für die Abgabe
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basiskonstruktion der Abgabestation
-            node = self.create_abgabe_station(pt)
-            self.abgabe_stations.append(node)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Marker am Zentrum (weiß)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Grüner Punkt: center + Vec3(0, 0, -0.5)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Weiße Linie: Startet bei center + Vec3(0, 0, -0.5)
-            # und verläuft 3 Meter in negativer X-Richtung
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt: wird an der Endposition der Linie erzeugt
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            # Speichere den blauen Marker für spätere Navigation der Abgabestation
-            self.abgabe_blue_dots.append(blue_dot)
-
-            # Anzeige der Stationsnummer (textuell)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) auf der Station
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 3)
-        v5 = pos + Vec3(1, 0, 3)
-        v6 = pos + Vec3(1, 2, 3)
-        v7 = pos + Vec3(0, 2, 3)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 3)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        self.garagen_stations = []
-        self.garagen_parking_points = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            self.garagen_stations.append(pt)
-            # ParkpunktGarage: Verschoben um 0.5 in negativer Y-Richtung:
-            center = pt + Vec3(0.5, 0.5, 1.5)
-            ParkpunktGarage = center + Vec3(0, 0, 0.7)
-            self.garagen_parking_points.append(ParkpunktGarage)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def create_garage_vehicles(self):
-        """
-        Erzeugt nur das erste Fahrzeug in der Simulation.
-
-        Ursprünglich wurde für jeden Garagen-Parkpunkt ein Fahrzeug erstellt.
-        Mit dieser Anpassung wird nur das Fahrzeug am ersten Parkpunkt erzeugt,
-        alle weiteren Fahrzeuge werden nicht erzeugt.
-        """
-        self.garage_vehicles = []
-        if self.garagen_parking_points:
-            park = self.garagen_parking_points[0]  # Nur der erste Parkpunkt wird verwendet.
-            veh = self.create_vehicle(park_point=None)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            # Statt newPos.setZ(0.1) setzen wir den Z-Wert als Offset zum berechneten Wert:
-            newPos.setZ(newPos.getZ() + 0.1)
-            veh.setPos(newPos)
-            self.garage_vehicles.append(veh)
-
-            # Erzeuge Fahrzeugmarker
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # FAHRZEUGERSTELLUNG (FFZ20-INTEGRATION)
-    # -----------------------------------
-    def create_vehicle(self, park_point=None):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Chassis: 1 x 0.5 x 1.2, Farbe Rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # Fork (Gabel): Zwei Zähne
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-        self.fork_node = fork_node
-
-        # Berechne den Mittelpunkt der Gabel (mittels der linken und rechten Eckpunkte)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_corner_global = fork_node.getPos() + left_corner_local
-        right_corner_global = fork_node.getPos() + right_corner_local
-
-        ls_new = LineSegs()
-        ls_new.setThickness(2.0)
-        ls_new.setColor(1, 1, 1, 1)
-        ls_new.moveTo(left_corner_global)
-        ls_new.drawTo(right_corner_global)
-        vehicle_node.attachNewNode(ls_new.create())
-
-        midpoint = (left_corner_global + right_corner_global) * 0.5
-        white_line_vec = right_corner_global - left_corner_global
-        if white_line_vec.length() != 0:
-            white_line_dir = white_line_vec.normalized()
-        else:
-            white_line_dir = Vec3(0, 0, 0)
-        candidate = Vec3(-white_line_dir.getY(), white_line_dir.getX(), 0)
-        vehicle_pos = vehicle_node.getPos()
-        if candidate.dot(vehicle_pos - midpoint) < 0:
-            candidate = -candidate
-        if candidate.length() != 0:
-            perp_direction = candidate.normalized()
-        else:
-            perp_direction = Vec3(0, 0, 0)
-        line_length = 1.0
-        line_end = midpoint + perp_direction * line_length
-        ls_mid = LineSegs()
-        ls_mid.setThickness(2.0)
-        ls_mid.setColor(1, 1, 1, 1)
-        ls_mid.moveTo(midpoint)
-        ls_mid.drawTo(line_end)
-        vehicle_node.attachNewNode(ls_mid.create())
-
-        # Fahrzeug: Gabel – grüner Punkt (als Referenz)
-        green_point_global = midpoint + perp_direction * 0.5
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        self.fork_green = green_marker_np  # Global abgespeichert
-
-        # Mast: Erzeuge den Mast und hänge den Zylinder als Referenz an
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-
-        self.add_diagonals_to_mast(mast_node)
-        intersection = Vec3(0.5, 0.05, 1.0)
-
-        # Fahrzeug: Zylinder – Erzeuge den Zylinder und speichere ihn global
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-        self.vehicle_cylinder = cylinder_node  # Global abgespeichert
-
-        # Optional: Zusätzliche Fahrzeugbestandteile (wie Lidar) können hier ergänzt werden.
-
-        if park_point is None:
-            vehicle_node.setPos(intersection.x, intersection.y, 0)
-        else:
-            vehicle_node.setPos(park_point - intersection)
-
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    # -----------------------------------
-    # FEHLENDE METHODEN: Paketspawning, Würfelerzeugung u.a.
-    # -----------------------------------
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        if hasattr(self, "abgabe_stations") and self.abgabe_stations:
-            target_index = random.randint(1, len(self.abgabe_stations))
-        else:
-            target_index = 1
-
-        # Der Auftrag wird hier erstellt – und zwar genau dann, wenn ein Paket gespawnt wird.
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def update_order_table(self):
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen (z.B. "annahme_station_3") nur die Nummer.
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z.B. "Abgabestation 5") nur die Nummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Bestimme die Fahrzeugzuordnung.
-            # Wird "1" angezeigt, wenn der Auftrag aktuell (und noch nicht erledigt) dem Fahrzeug zugeordnet ist.
-            # Andernfalls wird ein "-" angezeigt.
-            if self.current_order is not None and order["id"] == self.current_order["id"] and order.get(
-                    "status") != "Erledigt":
-                vehicle_display = "1"
-            else:
-                vehicle_display = "-"
-
-            self.order_tree.insert("", tk.END, values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def check_and_spawn_packages(self, task):
-        # Maximale Anzahl an Aufträgen beschränken auf die Anzahl der Pakete in der Simulation
-        max_orders = len(self.pickup_packages)
-        if len(self.orders) >= max_orders:
-            return Task.cont
-
-        spawn_delay = 5.0  # 5 Sekunden Verzögerung zwischen Spawns
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0.0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Wir legen hier die Spalten in der gewünschten Reihenfolge an: Auftrags ID, Annahmestation, Ziel, Fahrzeug.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Setze das Paket relativ zum Gabelmodul mit einem Offset in X- und Y-Richtung
-            green_point_pos = self.fork_green.getPos(self.fork_node)
-            package.wrtReparentTo(self.fork_node)
-            package.setPos(
-                green_point_pos.getX() + 0.5,  # Versatz um +0.5 in X-Richtung
-                green_point_pos.getY() + -0.5,  # Versatz um +0.5 in Y-Richtung
-                green_point_pos.getZ() + 1  # Z-Offset, um das Paket oberhalb der Gabel zu platzieren
-            )
-
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def vehicle_order_task(self, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-
-        # Zustandsinitialisierung (keine Änderungen an Phasen 1–5)
-        if not hasattr(self, "vehicle_state"):
-            self.vehicle_state = "translate"
-        if not hasattr(self, "package_attached"):
-            self.package_attached = False
-
-        if not self.garage_vehicles:
-            return task.cont
-
-        vehicle = self.garage_vehicles[0]
-
-        # -------------------------------------------
-        # PHASE 1: Translate – Fahrt zur blauen Markierung
-        if self.vehicle_state == "translate":
-            blue_target = self.blue_dot.getPos(self.render)
-            local_mast = Vec3(0.5, 0.05, 1.0)
-            mast_global = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(local_mast)
-            target_xy = Vec2(blue_target.getX(), blue_target.getY())
-            mast_xy = Vec2(mast_global.getX(), mast_global.getY())
-            error_vector = target_xy - mast_xy
-            threshold = 0.05  # 5 cm Toleranz
-            if error_vector.length() > threshold:
-                direction = error_vector.normalized()
-                move_distance = 1.5 * dt
-                current_pos = vehicle.getPos(self.render)
-                new_pos = Vec3(
-                    current_pos.getX() + direction.getX() * move_distance,
-                    current_pos.getY() + direction.getY() * move_distance,
-                    0
-                )
-                vehicle.setPos(new_pos)
-            else:
-                local_offset = vehicle.getQuat(self.render).xform(local_mast)
-                exact_pos = Vec3(
-                    blue_target.getX() - local_offset.getX(),
-                    blue_target.getY() - local_offset.getY(),
-                    0
-                )
-                vehicle.setPos(exact_pos)
-                self.vehicle_state = "rotate"
-
-        # -------------------------------------------
-        # PHASE 2: Rotate – Fahrzeug dreht sich in Fahrtrichtung
-        elif self.vehicle_state == "rotate":
-            desired_angle = math.degrees(math.atan2(self.station_white_direction.getY(),
-                                                    self.station_white_direction.getX()))
-            desired_angle = (desired_angle + 180) % 360  # 180°-Offset
-            current_heading = vehicle.getH()
-            angle_diff = (desired_angle - current_heading + 180) % 360 - 180
-            kp_heading = 0.5
-            new_heading = current_heading + kp_heading * angle_diff
-            vehicle.setH(new_heading)
-            if abs(angle_diff) < 1.0:
-                self.vehicle_state = "turn_right"
-
-        # -------------------------------------------
-        # PHASE 3: Turn Right – Drehe das Fahrzeug um 90° nach rechts
-        elif self.vehicle_state == "turn_right":
-            if not hasattr(self, "turn_right_init"):
-                self.turn_right_init = vehicle.getH()
-                self.turn_right_target = (self.turn_right_init + 90) % 360
-            current_heading = vehicle.getH()
-            angle_diff = (self.turn_right_target - current_heading + 180) % 360 - 180
-            kp_turn = 0.5
-            new_heading = current_heading + kp_turn * angle_diff
-            vehicle.setH(new_heading)
-            if abs(angle_diff) < 1.0:
-                self.vehicle_state = "approach"
-                del self.turn_right_init, self.turn_right_target
-
-        # -------------------------------------------
-        # PHASE 4: Approach – Fahrt versetzt in die Annahmestation hinein
-        elif self.vehicle_state == "approach":
-            target = self.station_green_dot.getPos(self.render) + Vec3(0.5, 0.5, 0)
-            current = vehicle.getPos(self.render)
-            error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-            if error_vec.length() > 0.05:
-                direction = error_vec.normalized()
-                move_distance = 1.5 * dt
-                new_pos = Vec3(
-                    current.getX() + direction.getX() * move_distance,
-                    current.getY() + direction.getY() * move_distance,
-                    target.getZ()
-                )
-                vehicle.setPos(new_pos)
-            else:
-                self.vehicle_state = "pickup"
-
-        # -------------------------------------------
-        # PHASE 5: Pickup – Paket aufnehmen, Gabel hochfahren
-        elif self.vehicle_state == "pickup":
-            current_z = self.fork_node.getZ()
-            target_z = 1.0  # gewünschte Höhe der Gabel beim Aufnehmen
-            raise_speed = 0.5
-            if current_z < target_z:
-                self.fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-            else:
-                if self.current_order is None:
-                    if self.orders_queue:
-                        self.current_order = self.orders_queue.pop(0)
-                    else:
-                        print("Keine verfügbaren Aufträge. Überspringe Pickup-Phase.")
-                        self.vehicle_state = "drive_out"
-                        return task.cont
-                pickup_station = self.current_order["pickup_station"]
-                self.pickup_package(vehicle, pickup_station)
-                self.package_attached = True
-                # Hier wird der Ausgangspunkt und das Ziel für das Drive Out gesetzt
-                self.drive_out_start = vehicle.getPos(self.render)
-                self.drive_out_target = self.drive_out_start + vehicle.getQuat(self.render).getForward() * 5.0
-                self.vehicle_state = "drive_out"
-
-        # -------------------------------------------
-        # PHASE 6: Drive Out – Fahrzeug fährt aus der Station heraus
-        # (Dies wurde angepasst, ohne die vorherigen Phasen zu verändern)
-        elif self.vehicle_state == "drive_out":
-            # Gabel absenken, falls nötig
-            current_z = self.fork_node.getZ()
-            if current_z > 0.0:
-                lower_speed = 0.5
-                self.fork_node.setZ(max(0.0, current_z - lower_speed * dt))
-            current_pos = vehicle.getPos(self.render)
-            diff = self.drive_out_target - current_pos
-            # Fahre in Richtung des originally festgelegten Drive-Out-Ziels (5 m vorwärts)
-            if diff.length() > 0.1:
-                move_distance = 0.5 * dt
-                step = diff.normalized() * move_distance
-                vehicle.setPos(current_pos + step)
-            else:
-                self.vehicle_state = "to_delivery"
-
-        # -------------------------------------------
-        # PHASE 7: To Delivery – Fahre zum blauen Punkt der Abgabestation
-        elif self.vehicle_state == "to_delivery":
-            delivery_target_str = self.current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current_pos = vehicle.getPos(self.render)
-            diff = blue_target - current_pos
-            distance = diff.length()
-            threshold = 0.5  # großzügiger Toleranzwert
-            move_distance = 1.5 * dt
-            if move_distance > distance:
-                vehicle.setPos(blue_target)
-            else:
-                vehicle.setPos(current_pos + diff.normalized() * move_distance)
-            if (blue_target - vehicle.getPos(self.render)).length() <= threshold:
-                print("Auftrag abgeschlossen: Fahrzeug hat die Abgabestation erreicht. Starte Drop-Sequence.")
-                self.vehicle_state = "drop"
-
-        # -------------------------------------------
-        # PHASE 8: Drop – Gabel senken und Paket an Abgabestation absetzen
-        elif self.vehicle_state == "drop":
-            current_z = self.fork_node.getZ()
-            if current_z > 0.0:
-                lower_speed = 0.5
-                self.fork_node.setZ(max(0.0, current_z - lower_speed * dt))
-            else:
-                self.drop_cargo(vehicle)
-                print("Paket wurde an der Abgabestation abgesetzt.")
-                # Zustandsvariablen für den nächsten Auftrag zurücksetzen
-                self.vehicle_state = "translate"
-                self.package_attached = False
-                self.current_order["status"] = "Erledigt"
-                self.current_order["delivered_at"] = self.sim_clock
-                self.current_order = None
-
-        return task.cont
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: TestFFZ/TestFFZ9.py
===================================================================
diff --git a/TestFFZ/TestFFZ9.py b/TestFFZ/TestFFZ9.py
deleted file mode 100644
--- a/TestFFZ/TestFFZ9.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,595 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs,
-    CardMaker
-)
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-# Globaler Clock (wird für die Zeitberechnung genutzt)
-globalClock = ClockObject.getGlobalClock()
-
-
-def rotate_vector(vec, angle_degrees):
-    """
-    Rotiert einen Vektor (nur X- und Y-Komponenten) um den angegebenen Winkel in Grad.
-    """
-    angle_rad = math.radians(angle_degrees)
-    cos_a = math.cos(angle_rad)
-    sin_a = math.sin(angle_rad)
-    x = vec.getX() * cos_a - vec.getY() * sin_a
-    y = vec.getX() * sin_a + vec.getY() * cos_a
-    return Vec3(x, y, vec.getZ())
-
-
-# =============================================================================
-# Klasse: SimulationSurface
-# =============================================================================
-class SimulationSurface(ShowBase):
-    def __init__(self):
-        super().__init__()
-        # Basisparameter und Statistik
-        self.base_speed = 1.5  # m/s, Maximalgeschwindigkeit
-        self.speed_factor = 1.0
-        self.sim_clock = 0.0
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-        self.sim_start_real = globalClock.getFrameTime()
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        # Aufbau der Szene, Stationen, UI, Tasks und Graph
-        self.setup_environment()
-        self.setup_stations()
-        self.setup_UI()
-        self.setup_tasks()
-        self.setup_graph()
-
-        # Füge einen globalen Kreis als Marker in den Weltkoordinaten (0.5, 0.5, 2) hinzu
-        # (Dieser dient als zusätzliches Referenzelement.)
-        self.circle_marker = self.create_circle(Vec3(0.5, 0.5, 2), radius=0.5, segments=64, color=LColor(0, 1, 0, 1))
-
-        # Mausevents (Zoom)
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-    def create_circle(self, pos, radius=0.5, segments=64, color=LColor(0, 1, 0, 1)):
-        """Erzeugt einen gleichmäßig skalierten Kreis als LineSegs-Objekt an der angegebenen Position."""
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(color)
-        angle_step = 2 * math.pi / segments
-        ls.moveTo(radius * math.cos(0), radius * math.sin(0), 0)
-        for i in range(1, segments + 1):
-            angle = angle_step * i
-            x = radius * math.cos(angle)
-            y = radius * math.sin(angle)
-            ls.drawTo(x, y, 0)
-        ls.drawTo(radius * math.cos(0), radius * math.sin(0), 0)
-        node = ls.create()
-        circle_np = self.render.attachNewNode(node)
-        circle_np.setPos(pos)
-        return circle_np
-
-    def setup_environment(self):
-        self.erzeuge_licht()
-        self.boden = self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-    def setup_stations(self):
-        self.pickup_station = self.erzeuge_gitterbox(-9, 0, 0, LColor(1, 0, 0, 1))
-        self.drop_station = self.erzeuge_gitterbox(9, 4, 0, LColor(0, 1, 0, 1))
-        # Align-Punkte an der Pickup-Station
-        ls1 = LineSegs()
-        ls1.setThickness(3.0)
-        ls1.setColor(LColor(1, 1, 1, 1))
-        p1 = self.pickup_station.getPos(self.render)
-        ls1.moveTo(p1)
-        ls1.drawTo(p1 + Vec3(2, 0, 0))
-        self.render.attachNewNode(ls1.create())
-        ls1_parallel = LineSegs()
-        ls1_parallel.setThickness(3.0)
-        ls1_parallel.setColor(LColor(1, 1, 1, 1))
-        ls1_parallel.moveTo(p1 + Vec3(0, 1, 0))
-        ls1_parallel.drawTo(p1 + Vec3(2, 0, 0) + Vec3(0, 1, 0))
-        self.render.attachNewNode(ls1_parallel.create())
-
-        # Align-Punkte an der Drop-Station
-        ls2 = LineSegs()
-        ls2.setThickness(3.0)
-        ls2.setColor(LColor(1, 1, 1, 1))
-        p2 = self.drop_station.getPos(self.render)
-        ls2.moveTo(p2)
-        ls2.drawTo(p2 + Vec3(-2, 0, 0))
-        self.render.attachNewNode(ls2.create())
-        ls2_parallel = LineSegs()
-        ls2_parallel.setThickness(3.0)
-        ls2_parallel.setColor(LColor(1, 1, 1, 1))
-        ls2_parallel.moveTo(p2 + Vec3(0, 1, 0))
-        ls2_parallel.drawTo(p2 + Vec3(-2, 0, 0) + Vec3(0, 1, 0))
-        self.render.attachNewNode(ls2_parallel.create())
-
-        # Neuer Mittelpunkt an den Stationen, wie bei den Stationen üblich: (0.5, 0.5, 2.0)
-        pickup_center_marker = self.loader.loadModel("models/misc/sphere")
-        pickup_center_marker.setScale(0.2)
-        pickup_center_marker.setColor(LColor(1, 1, 0, 1))
-        pickup_center_marker.reparentTo(self.pickup_station)
-        pickup_center_marker.setPos(0.5, 0.5, 2.0)
-
-        drop_center_marker = self.loader.loadModel("models/misc/sphere")
-        drop_center_marker.setScale(0.2)
-        drop_center_marker.setColor(LColor(1, 1, 0, 1))
-        drop_center_marker.reparentTo(self.drop_station)
-        drop_center_marker.setPos(0.5, 0.5, 2.0)
-
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-    def setup_UI(self):
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-    def setup_tasks(self):
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-
-    def setup_graph(self):
-        self.graph_opened = False
-        self.accept("g", self.open_graph)
-        self.graph_data = []
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider["value"]
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label["text"] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in [self.pickup_station, self.drop_station]:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        # Neuer Mittelpunkt beim Paket: (0.5, 0.5, 1)
-        package_center_marker = self.loader.loadModel("models/misc/sphere")
-        package_center_marker.setScale(0.2)
-        package_center_marker.setColor(LColor(0, 1, 0, 1))
-        package_center_marker.reparentTo(package)
-        package_center_marker.setPos(0.5, 0.5, 1)
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            current_max = max(current_max, elapsed)
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        current_text = f"Liegedauer (aktuell): {current_max:.1f}s" if current_max > 0 else "Kein Paket"
-        maximal_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-        avg_val = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        delivered = self.delivered_packages
-        ppm = delivered / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label["text"] = (
-            f"Laufzeit: {formatted}\nAbgegebene Pakete: {delivered}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n{current_text}\n{maximal_text}\n"
-            f"Durchschn. Liegedauer: {avg_val:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n = 0
-        mi = -center_extent - 0.5
-        ma = center_extent + 0.5
-        y = mi
-        while y <= ma:
-            writer.addData3(mi, y, 0)
-            writer.addData3(ma, y, 0)
-            lines.addVertices(n, n + 1)
-            n += 2
-            y += cell_size
-        x = mi
-        while x <= ma:
-            writer.addData3(x, mi, 0)
-            writer.addData3(x, ma, 0)
-            lines.addVertices(n, n + 1)
-            n += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        box = self.loader.loadModel("models/box")
-        box.setScale(1, 1, 1)
-        box.setPos(x, y, z)
-        box.setColor(farbe)
-        box.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        box.reparentTo(self.render)
-        return box
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        cube = self.loader.loadModel("models/box")
-        cube.setScale(1, 1, 1)
-        cube.setPos(x, y, z + 1)
-        cube.setColor(farbe)
-        cube.reparentTo(self.render)
-        return cube
-
-    def draw_coordinate_axes(self, axis_length=5):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), LColor(1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), LColor(0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), LColor(0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        curr = lens.getFov()[0]
-        new = max(10, curr - 5)
-        lens.setFov(new)
-        print(f"Zoom In: FOV von {curr} auf {new}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        curr = lens.getFov()[0]
-        new = min(100, curr + 5)
-        lens.setFov(new)
-        print(f"Zoom Out: FOV von {curr} auf {new}")
-
-
-# =============================================================================
-# Klasse: VehicleController (Fahrzeug-Logik inkl. Lenkung, Pakettransport, etc.)
-# =============================================================================
-class VehicleController:
-    def __init__(self, surface: SimulationSurface):
-        self.surface = surface
-        self.vehicles = []  # Liste aller Fahrzeuge
-        self.cargos = {}  # Paketzuordnung zu Fahrzeugen
-        self.current_dropoffs = {}
-        self.create_vehicles()
-
-    def create_vehicles(self):
-        start_position = self.surface.pickup_station.getPos()
-        vehicle = self.surface.loader.loadModel("models/box")
-        # Fahrzeug wird in X-Richtung verlängert (Skalierung: (2, 1, 0.5))
-        vehicle.setScale(2, 1, 0.5)
-        vehicle.setColor(LColor(0, 0, 1, 1))
-        vehicle.setPos(start_position)
-        vehicle.reparentTo(self.surface.render)
-        vehicle.setPythonTag("role", "pickup_to_dropoff")
-        vehicle.setPythonTag("phase", "pickup")
-        vehicle.setPythonTag("speed", 0.0)
-        # Füge den Center Marker hinzu – dieser wird als kleiner Sphere-Punkt hinzugefügt, wie an den Stationen.
-        self.add_center_marker(vehicle)
-        self.add_additional_marker(vehicle)
-        self.add_steering_axle(vehicle)
-        self.attach_lidar_sensor(vehicle, offset=Vec3(0.5, 0.5, 0), radius=2.5)
-        self.vehicles.append(vehicle)
-
-    def add_center_marker(self, vehicle, radius=0.2):
-        # Anstelle eines Kreises als Liniengrafik verwenden wir hier eine kleine Sphere als Punkt.
-        marker = self.surface.loader.loadModel("models/misc/sphere")
-        marker.setScale(radius)  # Klein skalieren, sodass es wie ein Punkt erscheint.
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        # Setze den Mittelpunkt des Fahrzeugs auf (0.5, 0.5, 2.0)
-        marker.setPos(0.5, 0.5, 2.0)
-        vehicle.setPythonTag("center_marker", marker)
-
-    def add_additional_marker(self, vehicle, scale=0.2):
-        marker = self.surface.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(0, 1, 1, 1))  # Cyan als Zusatzmarker
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 1, 0.01)
-        vehicle.setPythonTag("additional_marker", marker)
-
-    def add_steering_axle(self, vehicle, scale=0.1):
-        axle = self.surface.loader.loadModel("models/box")
-        axle.setScale(0.1, 0.5, 0.1)
-        axle.setColor(LColor(1, 0, 0, 1))  # Rot
-        axle.setPos(0, -0.5, 0)
-        axle.setName("steering_axle")
-        axle.reparentTo(vehicle)
-
-    def attach_lidar_sensor(self, vehicle, offset=Vec3(0.5, 0.5, 0), radius=2.5):
-        sensor_np = vehicle.attachNewNode("lidar_sensor")
-        sensor_np.setPos(offset)
-        vscale = vehicle.getScale()
-        sensor_np.setScale(1.0 / vscale.getX(), 1.0 / vscale.getY(), 1.0)
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 1, 0, 1))
-        segments = 64
-        ls.moveTo(radius * math.cos(0), radius * math.sin(0), 0)
-        for i in range(1, segments + 1):
-            angle = (2 * math.pi * i) / segments
-            x = radius * math.cos(angle)
-            y = radius * math.sin(angle)
-            ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        sensor_np.attachNewNode(circle_geom)
-
-    def get_source_target(self, vehicle):
-        role = vehicle.getPythonTag("role")
-        if role == "pickup_to_dropoff":
-            return self.surface.pickup_station, self.surface.drop_station
-        else:
-            return self.surface.drop_station, self.surface.pickup_station
-
-    def compute_avoidance_vector(self, vehicle):
-        avoidance = Vec3(0, 0, 0)
-        sensor_center = vehicle.getPos(self.surface.render) + Vec3(0.5, 0.5, 0)
-        detection_radius = 2.5
-        for other in self.vehicles:
-            if other is vehicle:
-                continue
-            other_center = other.getPos(self.surface.render)
-            diff = sensor_center - other_center
-            distance = diff.length()
-            if distance < detection_radius and distance > 0:
-                avoidance += diff.normalized() * (detection_radius - distance)
-        return avoidance
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        max_speed = 1.5
-        accel = 2.5
-        decel = 2.5
-        max_turn_rate = 90  # Grad pro Sekunde
-
-        def move_task(task):
-            dt = globalClock.getDt() * self.surface.speed_factor
-            pos = vehicle.getPos()
-            to_target = target - pos
-            distance = to_target.length()
-            if distance < 0.05:
-                vehicle.setPos(target)
-                on_complete()
-                vehicle.setPythonTag("speed", 0.0)
-                return Task.done
-
-            base_vec = to_target.normalized()
-            avoidance = self.compute_avoidance_vector(vehicle)
-            avoidance_weight = 1.0
-            if avoidance.length() > 0:
-                composite = (base_vec + avoidance.normalized() * avoidance_weight)
-                composite.normalize()
-            else:
-                composite = base_vec
-
-            desired_heading = math.degrees(math.atan2(composite.getY(), composite.getX()))
-            steering_axle = vehicle.find("**/steering_axle")
-            steering_offset = steering_axle.getH() if not steering_axle.isEmpty() else 0
-            effective_desired_heading = desired_heading + steering_offset
-            current_heading = vehicle.getH()
-            heading_error = (effective_desired_heading - current_heading + 180) % 360 - 180
-            turn_amount = max_turn_rate * dt
-            if abs(heading_error) < turn_amount:
-                new_heading = effective_desired_heading
-            else:
-                new_heading = current_heading + turn_amount * (1 if heading_error > 0 else -1)
-            vehicle.setH(new_heading)
-
-            forward = Vec3(math.cos(math.radians(new_heading)),
-                           math.sin(math.radians(new_heading)),
-                           0)
-            current_speed = vehicle.getPythonTag("speed")
-            if distance <= (current_speed ** 2) / (2 * decel):
-                new_speed = max(current_speed - decel * dt, 0)
-            else:
-                new_speed = min(current_speed + accel * dt, max_speed)
-            movement = forward * new_speed * dt
-            vehicle.setPos(pos + movement)
-            vehicle.setPythonTag("speed", new_speed)
-            return Task.cont
-
-        self.surface.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        vehicle.setPythonTag("job_start", self.surface.sim_clock)
-        vehicle.setPythonTag("phase", "pickup")
-        source, target = self.get_source_target(vehicle)
-        if source not in self.surface.pickup_packages:
-            self.surface.spawn_package_at_station(source)
-        self.move_vehicle_to(vehicle, source.getPos(), lambda: self.after_pickup(vehicle, source, target))
-
-    def after_pickup(self, vehicle, source, target):
-        self.pickup_package(vehicle, source)
-        vehicle.setPythonTag("phase", "deliver")
-        vehicle.setPythonTag("departure_station", source)
-        dwell_delay = 1.0
-        vehicle.setPythonTag("departure_ready_time", self.surface.sim_clock + dwell_delay)
-        self.move_vehicle_to(vehicle, target.getPos(), lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        self.drop_cargo(vehicle)
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, source):
-        if source in self.surface.pickup_packages:
-            package, spawn_time, timer_np = self.surface.pickup_packages.pop(source)
-            timer_np.removeNode()
-            dwell = self.surface.sim_clock - spawn_time
-            self.surface.total_dwell_time += dwell
-            self.surface.picked_up_count += 1
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.surface.last_removed[source] = self.surface.sim_clock
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.surface.render)
-            _, target = self.get_source_target(vehicle)
-            targetPos = target.getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.surface.delivered_packages += 1
-
-    def remove_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-
-
-# =============================================================================
-# Hauptprogramm
-# =============================================================================
-if __name__ == "__main__":
-    surface = SimulationSurface()
-    vehicle_controller = VehicleController(surface)
-    for vehicle in vehicle_controller.vehicles:
-        vehicle_controller.start_delivery_cycle(vehicle, vehicle.getPos())
-    surface.run()
Index: KI/KI11.py
===================================================================
diff --git a/KI/KI11.py b/KI/KI11.py
deleted file mode 100644
--- a/KI/KI11.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,344 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode
-)
-# Globaler Clock über ClockObject
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.interval.IntervalGlobal import Sequence, Wait, LerpPosInterval, Func
-from direct.task import Task
-# Importiere DirectGUI für Slider und Label
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit
-        self.base_speed = 1.5
-        # Geschwindigkeitsfaktor (wird über den Slider angepasst)
-        self.speed_factor = 1.0
-        # Effektive Fahrzeuggeschwindigkeit
-        self.speed = self.base_speed * self.speed_factor
-
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie (gleicher Abstand)
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            # Annahmestation links (rot) bei x = -9
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            # Abgabestation rechts (grün) bei x = 9
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeuge initialisieren – zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}             # Dictionary: Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}   # Dictionary: Fahrzeug -> aktuell gewählte Abgabestation
-
-        # Fahrzeug 1
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-
-        # Fahrzeug 2 – leicht versetzt, damit sich die Modelle nicht überlappen.
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)  # y-Offset von 2 Einheiten
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-
-        # Globaler Pool für alle Pickup-Pakete:
-        # Schlüssel = Annahmestation, Wert = (Paket, Spawnzeit, Timer-TextNode)
-        self.pickup_packages = {}
-        # Für jede Station wird der Zeitpunkt des letzten Entfernens initialisiert.
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = globalClock.getFrameTime()
-
-        # Reservierungssets:
-        self.occupied_dropoffs = set()  # Für Drop-Offs (reservierte Abgabestationen)
-        self.occupied_pickups = set()    # Für Pickup-Stationen
-
-        # Slider zur Anpassung des Geschwindigkeitsfaktors
-        self.speed_slider = DirectSlider(
-            range=(0.1, 3.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        # Label zur Anzeige des aktuellen Geschwindigkeitsfaktors
-        self.speed_label = DirectLabel(
-            text=f"Sim Speed: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Starte einen Task, der regelmäßig prüft, ob an einer Annahmestation ein Paket fehlen soll.
-        # Spawnzeit beträgt hier 1 Sekunde.
-        self.taskMgr.doMethodLater(1, self.check_and_spawn_packages, "CheckSpawnPackages")
-        # Task zum Aktualisieren der Timer-Anzeige über den Paketen.
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-
-        # Starte für Fahrzeug 1 den Auftrag sofort...
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-        # ... und für Fahrzeug 2 8 Sekunden später.
-        self.taskMgr.doMethodLater(8, lambda t, veh=self.vehicles[1]:
-                                     self.start_delivery_cycle(veh, veh.getPos()),
-                                     "StartVehicle2")
-
-    def update_simulation_speed(self, speed_factor=None):
-        """
-        Aktualisiert den Geschwindigkeitsfaktor und berechnet die neue Fahrzeuggeschwindigkeit.
-        Falls kein Parameter übergeben wird, wird der aktuelle Wert des Sliders genutzt.
-        """
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        self.speed_factor = speed_factor
-        self.speed = self.base_speed * self.speed_factor
-        self.speed_label['text'] = f"Sim Speed: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        """
-        Überprüft alle Annahmestationen:
-          Falls an einer Station noch kein Paket vorhanden ist und seit dem letzten
-          Entfernen mindestens 1 Sekunde vergangen sind, wird ein Paket erzeugt.
-        """
-        spawn_delay = 1  # 1 Sekunde Wartezeit pro Station
-        current_time = globalClock.getFrameTime()
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if current_time - self.last_removed.get(station, current_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.again
-
-    def spawn_package_at_station(self, station):
-        """
-        Erzeugt ein Paket (als Würfel) an der gegebenen Annahmestation.
-        Das Paket wird mit einem Z-Offset von +1 positioniert. Zusätzlich wird über dem Paket
-        ein TextNode angehängt, der später die Wartezeit anzeigt.
-        """
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = globalClock.getFrameTime()
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        """
-        Aktualisiert in jedem Frame den Text (Wartezeit) aller wartenden Pakete.
-        """
-        current_time = globalClock.getFrameTime()
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = current_time - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        """
-        Liefert für ein einzelnes Fahrzeug folgenden Ablauf:
-          1. Aus dem globalen Pool der Pickup‑Pakete wählt das Fahrzeug das Paket mit der
-             höchsten Wartezeit (also das älteste Paket, gemessen an der Spawnzeit) – sofern
-             die Pickup‑Station nicht reserviert ist.
-          2. Das Fahrzeug reserviert die Pickup‑Station und fährt dorthin, um das Paket aufzunehmen.
-          3. Anschließend wählt es als Abgabestation zufällig eine aus, die noch nicht reserviert ist,
-             reserviert diese und fährt dorthin.
-          4. Nach 1 Sekunde Wartezeit wird das Paket abgesetzt und beide Reservierungen werden aufgehoben.
-          5. Der nächste Zyklus startet von der aktuellen Position des Fahrzeugs.
-        """
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-
-        if not self.pickup_packages:
-            self.taskMgr.doMethodLater(1,
-                lambda t: self.start_delivery_cycle(vehicle, vehicle.getPos()),
-                "RetryCycle_" + str(id(vehicle)))
-            return
-
-        current_time = globalClock.getFrameTime()
-        # Filtern: nur Pakete, deren Pickup‑Station nicht reserviert ist.
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            self.taskMgr.doMethodLater(1,
-                lambda t: self.start_delivery_cycle(vehicle, vehicle.getPos()),
-                "RetryCycle_" + str(id(vehicle)))
-            return
-
-        # Wähle das Paket mit der höchsten Wartezeit.
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        # Reserviere die Pickup‑Station.
-        self.occupied_pickups.add(pickup_station)
-        pickup_pos = pickup_station.getPos()
-        seg1_duration = (pickup_pos - start_pos).length() / self.speed
-
-        # Wähle als Abgabestation nur aus denen, die nicht reserviert sind.
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.occupied_pickups.remove(pickup_station)
-            self.taskMgr.doMethodLater(1,
-                lambda t: self.start_delivery_cycle(vehicle, vehicle.getPos()),
-                "RetryCycle_" + str(id(vehicle)))
-            return
-
-        dropoff_station = random.choice(available_dropoffs)
-        # Reserviere die Abgabestation.
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_pos = dropoff_station.getPos()
-        seg2_duration = (dropoff_pos - pickup_pos).length() / self.speed
-
-        cycle = Sequence(
-            LerpPosInterval(vehicle, duration=seg1_duration, pos=pickup_pos),
-            Func(self.pickup_package, vehicle, pickup_station),
-            LerpPosInterval(vehicle, duration=seg2_duration, pos=dropoff_pos),
-            Func(self.drop_cargo, vehicle),
-            Wait(1),
-            Func(self.remove_cargo, vehicle),
-            Func(self.start_delivery_cycle, vehicle, vehicle.getPos())
-        )
-        cycle.start()
-
-    def pickup_package(self, vehicle, station):
-        """
-        Das Fahrzeug übernimmt an der angegebenen Annahmestation das wartende Paket.
-        Dabei wird der Timer-Text entfernt, der Eintrag aus dem globalen Pool gelöscht,
-        und der Zeitpunkt der Entfernung (last_removed) aktualisiert.
-        Anschließend wird die Reservierung der Pickup‑Station aufgehoben.
-        """
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = globalClock.getFrameTime()
-            # Pickup-Reservierung aufheben.
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        """
-        Das vom Fahrzeug transportierte Paket wird exakt auf den Würfel der reservierten
-        Abgabestation (mit einem Z‑Offset von +1) abgesetzt.
-        """
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-
-    def remove_cargo(self, vehicle):
-        """
-        Entfernt das aktuell transportierte Paket des Fahrzeugs aus der Szene und gibt die
-        reservierte Abgabestation wieder frei.
-        """
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        if dropoff_station in self.occupied_dropoffs:
-            self.occupied_dropoffs.remove(dropoff_station)
-            del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        """
-        Erzeugt ein Wireframe-Box-Modell als Station.
-        """
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        """
-        Erzeugt einen Würfel (als Paket), der etwas über dem Boden platziert wird.
-        """
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        """
-        Einfaches Beleuchtungssetup: Ambient- und Richtungslicht.
-        """
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-# Starte die Simulation
-app = LagerSimulation()
-app.run()
Index: KI/KI3.py
===================================================================
diff --git a/KI/KI3.py b/KI/KI3.py
deleted file mode 100644
--- a/KI/KI3.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,235 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData,
-    GeomNode, GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject
-)
-# Hole den globalen Clock aus ClockObject
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.interval.IntervalGlobal import Sequence, Wait, LerpPosInterval, Func
-from direct.task import Task
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Fahrzeuggeschwindigkeit: Ursprünglich 1.5 m/s, um den Faktor 5 erhöht → 7.5 m/s
-        self.speed = 1.5 * 5
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie mit gleichem Abstand.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            # Annahmestation links (rot) bei x = -9
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            # Abgabestation rechts (grün) bei x = 9
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeug initialisieren
-        self.vehicle = self.loader.loadModel("models/box")
-        self.vehicle.setScale(1, 1, 0.5)
-        self.vehicle.setColor(LColor(0, 0, 1, 1))
-        self.vehicle.setPos(0, 0, 0)
-        self.vehicle.reparentTo(self.render)
-
-        self.cargo = None  # Das aktuell transportierte Paket
-        # Dictionary für alle Pickup-Pakete: Schlüssel = Pickup-Station, Wert = (Paket, Spawnzeit)
-        self.pickup_packages = {}
-
-        # Starte einen Task, der regelmäßig prüft, ob bei den Annahmestationen ein Paket fehlt.
-        self.taskMgr.doMethodLater(1, self.check_and_spawn_packages, "CheckSpawnPackages")
-
-        # Start des ersten Lieferzyklus
-        self.start_delivery_cycle()
-
-    def check_and_spawn_packages(self, task):
-        """
-        Für jede Annahmestation wird geprüft, ob bereits ein Paket vorhanden ist.
-        Falls nicht, wird an dieser Station (mit Spawnzeit = globalClock.getFrameTime())
-        ein Paket erzeugt.
-        """
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                self.spawn_package_at_station(station)
-        return Task.again
-
-    def spawn_package_at_station(self, station):
-        """
-        Erzeugt ein Paket (als Würfel) an der gegebenen Station.
-        Das Paket wird an die Position der Station (mit einem Z-Offset von +1)
-        gesetzt und zusammen mit der Spawnzeit in das Dictionary eingetragen.
-        """
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = globalClock.getFrameTime()
-        self.pickup_packages[station] = (package, spawn_time)
-
-    def start_delivery_cycle(self, start_pos=None):
-        """
-        Ablauf:
-          1. Das Fahrzeug startet vom aktuellen Punkt (start_pos) und sucht unter allen
-             Annahmestationen das Paket, welches am längsten wartet (älteste Spawnzeit).
-          2. Das Fahrzeug fährt zu dieser Annahmestation und nimmt das Paket auf.
-          3. Anschließend wird zufällig eine Abgabestation gewählt, zu der das Fahrzeug fährt.
-          4. Dort wird das Paket auf den Würfel der Abgabestation gesetzt; nach 1 Sekunde
-             wird es entfernt.
-          5. Der nächste Zyklus startet ab der aktuellen Position (der Abgabestation).
-        """
-        if start_pos is None:
-            start_pos = self.vehicle.getPos()
-
-        # Falls gerade keine Pakete existieren, kurz warten.
-        if not self.pickup_packages:
-            self.taskMgr.doMethodLater(1, lambda t: self.start_delivery_cycle(start_pos), "RetryCycle")
-            return
-
-        # Auswahl der Annahmestation mit dem ältesten Paket (kleinster Spawnzeitwert)
-        pickup_station = min(self.pickup_packages, key=lambda s: self.pickup_packages[s][1])
-        pickup_pos = pickup_station.getPos()
-        seg1_duration = (pickup_pos - start_pos).length() / self.speed
-
-        # Zufällige Auswahl einer Abgabestation
-        dropoff_station = random.choice(self.abgabe_stationen)
-        self.current_dropoff_station = dropoff_station  # Für drop_cargo()
-        dropoff_pos = dropoff_station.getPos()
-        seg2_duration = (dropoff_pos - pickup_pos).length() / self.speed
-
-        cycle = Sequence(
-            # Fahrt zur Annahmestation (Pickup-Station, bei der das älteste Paket liegt)
-            LerpPosInterval(self.vehicle, duration=seg1_duration, pos=pickup_pos),
-            # Nach der Ankunft: Paket vom Pickup-Punkt aufnehmen
-            Func(self.pickup_package, pickup_station),
-            # Fahrt zur zufällig ausgewählten Abgabestation
-            LerpPosInterval(self.vehicle, duration=seg2_duration, pos=dropoff_pos),
-            Func(self.drop_cargo),
-            Wait(1),
-            Func(self.remove_cargo),
-            # Starte nächsten Zyklus von der aktuellen Position aus (Abgabestation)
-            Func(self.start_delivery_cycle, self.vehicle.getPos())
-        )
-        cycle.start()
-
-    def pickup_package(self, station):
-        """
-        Nimmt das an der gegebenen Pickup-Station wartende Paket vom Boden und hängt es
-        als Kind des Fahrzeugs an. Gleichzeitig wird der Eintrag aus dem Dictionary entfernt.
-        """
-        if station in self.pickup_packages:
-            package, spawn_time = self.pickup_packages.pop(station)
-            package.wrtReparentTo(self.vehicle)
-            package.setPos(0, 0, 1)
-            self.cargo = package
-
-    def drop_cargo(self):
-        """
-        Setzt das Paket exakt auf den Würfel der (zufällig ausgewählten) Abgabestation
-        (Z-Offset +1).
-        """
-        self.cargo.wrtReparentTo(self.render)
-        targetPos = self.current_dropoff_station.getPos() + Vec3(0, 0, 1)
-        self.cargo.setPos(targetPos)
-
-    def remove_cargo(self):
-        """
-        Entfernt das aktuell transportierte Paket aus der Szene.
-        """
-        if self.cargo:
-            self.cargo.removeNode()
-            self.cargo = None
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-
-        # Horizontale Linien
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        # Vertikale Linien
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        """
-        Erzeugt ein Wireframe-Box-Modell als Station.
-        """
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        """
-        Erzeugt einen Würfel (als Paket), der etwas über dem Boden platziert wird.
-        """
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        """
-        Einfaches Beleuchtungssetup: Ambient- und Richtungslicht.
-        """
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-# Starte die Simulation
-app = LagerSimulation()
-app.run()
-
-# Starte die Simulation
-app = LagerSimulation()
-app.run()
Index: Grundmodell Erweitert Split/GES5.py
===================================================================
diff --git a/Grundmodell Erweitert Split/GES5.py b/Grundmodell Erweitert Split/GES5.py
deleted file mode 100644
--- a/Grundmodell Erweitert Split/GES5.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,2111 +0,0 @@
-# Standardbibliothek
-import random
-import math
-import time
-import ctypes
-import multiprocessing
-from multiprocessing import Queue, Process
-from functools import partial
-import tkinter as tk
-from tkinter import ttk
-
-# Drittanbieter
-import matplotlib
-import matplotlib.pyplot as plt
-from PyQt5 import QtWidgets, QtCore
-import pyqtgraph as pg
-
-# Panda3D und Direct (Engine-spezifische Importe)
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.task.TaskManagerGlobal import taskMgr
-from direct.gui.DirectGui import DirectButton, DirectSlider, DirectLabel
-
-from direct.showbase.ShowBase import ShowBase
-from environment_visualization import EnvironmentVisualizer
-
-class LagerSimulation(ShowBase):
-    def __init__(self, graph_queue=None):
-        # Basisinitialisierung (ShowBase, etc.)
-        super().__init__()
-
-        # ------------------------------------------------------------------------
-        # 1. Umgebung aufbauen: Verwende den extrahierten EnvironmentVisualizer
-        # ------------------------------------------------------------------------
-        self.env_viz = EnvironmentVisualizer(self.render, self.loader)
-
-        # Rufe die Methoden des Visualizers auf, um die Umgebung zu erstellen.
-        self.env_viz.draw_origin()
-        self.env_viz.erzeuge_licht()
-        self.env_viz.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.env_viz.create_wall()
-        self.env_viz.create_annahme_stations()
-        self.env_viz.create_abgabe_stations()
-        self.env_viz.create_garagen_stations()
-
-        # Um in anderen Methoden (z. B. für Paket- oder Auftrags-Handling) auf die Stationen
-        # und deren Marker zugreifen zu können, übergeben wir die entsprechenden Listen.
-        self.annahme_stations = self.env_viz.annahme_stations
-        self.station_blue_dots = self.env_viz.station_blue_dots
-        self.abgabe_stations = self.env_viz.abgabe_stations
-        self.abgabe_blue_dots = self.env_viz.abgabe_blue_dots
-        self.garagen_stations = self.env_viz.garagen_stations
-        self.garagen_parking_points = self.env_viz.garagen_parking_points
-
-        # Setze den Pickup-Offset (dieser Vektor wird bei der Steuerung genutzt)
-        self.pickup_offset = Vec3(0.5, -0.5, 0)
-
-        # Falls du weitere Referenzen (wie self.blue_dot, self.station_green_dot) brauchst, ebenfalls setzen.
-        if hasattr(self.env_viz, 'blue_dot'):
-            self.blue_dot = self.env_viz.blue_dot
-        if hasattr(self.env_viz, 'station_green_dot'):
-            self.station_green_dot = self.env_viz.station_green_dot
-
-        # ------------------------------------------------------------------------
-        # 2. Restliche Initialisierung (Simulationsvariablen, UI, Tasks, etc.)
-        # (Der restliche Code bleibt weitgehend unverändert.)
-        # ------------------------------------------------------------------------
-
-        self.paused = False
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5
-
-        # Weitere Attribute, z. B. für KPIs, Paket- und Auftragsverwaltung usw.
-        self.delivered_packages = 0
-        self.pickup_packages = {}
-        self.last_removed = {}
-        self.orders = {}
-        self.orders_queue = []
-        self.next_order_id = 1
-        # (Weitere Initialisierungen kommen hier…)
-        self.cargos = {}
-        # Falls du auch weitere Attribute benötigst, wie beispielsweise eine Liste der belegten Pickup-Stations:
-        self.occupied_pickups = set()
-
-        self.max_overall_wait_time = 0.0  # Maximale Wartezeit der Pakete
-        self.total_dwell_time = 0.0  # Summe aller Liegedauern abgeholter Pakete
-        self.picked_up_count = 0  # Anzahl abgeholter Pakete
-        self.total_delivery_time = 0.0  # Summe aller Lieferzeiten
-        self.total_delivery_count = 0  # Anzahl der Lieferungen
-        self.max_overall_delivery_time = 0.0
-
-        self.graph_queue = None
-        self.graph_data = []
-        self.graph_process = None
-
-        # Beispiel: Initialisierung des Tkinter-Fensters
-        self.tk_root = tk.Tk()
-        self.tk_root.withdraw()
-
-        # Weiterer Code: Kamera, Lichter (falls weiterhin benötigt – ansonsten übernehmen wir vollständig den Visualizer)
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # UI-bezogene Attribute initialisieren:
-        self.order_win = None
-        self.order_tree = None
-        self.graph_queue = None
-        self.graph_data = []
-
-        # TensorFlow-Modell und RL-Agent initialisieren (wie gehabt)
-        try:
-            import tensorflow as tf
-            self.tf_model = tf.keras.models.load_model("mein_model.keras")
-            print("TensorFlow Modell erfolgreich geladen.")
-        except Exception as e:
-            print(f"Fehler beim Laden des TensorFlow Modells: {e}")
-            self.tf_model = None
-
-        state_bins = ((10, 10), (10, 10))
-        action_space = [0, 1, 2]
-        self.rl_agent = RLAgent(state_bins, action_space, learning_rate=0.1, discount_factor=0.9, epsilon=0.2)
-        self.training_data = []  # Trainingsdatenliste
-
-        # Spawn-Einstellungen (Standardwerte)
-        self.package_spawn_delay = 5.0
-        self.package_spawn_distribution = "uniform"
-        # Hier speichern wir die Variablen für die Stationen als Dictionary (Index -> BooleanVar)
-        self.spawn_station_vars = {}
-        # Falls du beispielsweise 10 Annahmestationen hast:
-        for i in range(10):
-            self.spawn_station_vars[i] = tk.BooleanVar(value=False)
-
-        # Fahrzeuge in den Garagen instanziieren:
-        self.create_garage_vehicles()
-        # --- UI-Elemente für Simulationssteuerung ---
-        # Slider für Simulationsgeschwindigkeit
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        self.paused = False
-        # Pause-Knopf neben dem Slider platzieren – z.B. rechts davon.
-        self.pause_button = DirectButton(
-            text="Pause",
-            command=self.toggle_pause,
-            pos=(-0.5, 0, -0.85),  # Leicht links vom Slider
-            scale=0.07
-        )
-
-        # --- Tastenzuordnungen ---
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-        # Taste "c" öffnet das Fahrzeug-Kontrollfenster
-        self.accept("c", self.show_vehicle_control)
-
-        # --- Tasks (TaskMgr) hinzufügen ---
-        self.taskMgr.add(self._tk_update, "tkUpdateTask")
-        self.taskMgr.add(self.update_delivery_timers, "UpdateDeliveryTimersTask")
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClock")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_graph_data, "UpdateGraphDataTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-    # ---------------1. Initialisierung & Simulationssteuerung---------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        self.sim_clock += dt
-        return Task.cont
-
-    def toggle_pause(self):
-        if not self.paused:
-            # Speichern des aktuellen speed_factor, damit wir ihn beim Resume wiederherstellen können
-            self.previous_speed_factor = self.speed_factor
-            self.speed_factor = 0  # Simulation einfrieren: alle dt-basierte Updates ergeben 0
-            self.pause_button['text'] = "Weiter"
-            self.paused = True
-            print("Gesamte Simulation angehalten")
-        else:
-            # Wiederaufnahme der Simulation: speed_factor auf den vorherigen Wert zurücksetzen
-            self.speed_factor = self.previous_speed_factor if hasattr(self, 'previous_speed_factor') else 1.0
-            self.pause_button['text'] = "Pause"
-            self.paused = False
-            print("Simulation läuft wieder")
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        # dt jetzt skaliert mit der Simulationsgeschwindigkeit
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-    # ---------------2. Graphik & UI (GUI-/Tk-/Matplotlib-Funktionen)---------------
-    def open_graph(self):
-        # Starte den Graphprozess per Taste G (nur, wenn er noch nicht läuft)
-        if self.graph_process is None or not self.graph_process.is_alive():
-            from multiprocessing import Queue, Process
-            self.graph_queue = Queue()
-
-            # Sende alle bisher gesammelten Daten in die Queue:
-            for data in self.graph_data:
-                try:
-                    self.graph_queue.put(data, block=False)
-                except Exception:
-                    pass
-
-            from graph_pyqt import graph_process_pyqt
-            self.graph_process = Process(target=graph_process_pyqt, args=(self.graph_queue,))
-            self.graph_process.start()
-            print("Graphprozess gestartet.")
-        else:
-            print("Graphprozess läuft bereits.")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2, self.ax3) = plt.subplots(3, 1, figsize=(8, 9))
-
-        # Erster Plot: Pakete pro Minute
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-
-        # Zweiter Plot: Durchschnittliche Liegedauer
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-
-        # Dritter Plot: Durchschnittliche Lieferzeit
-        self.line3, = self.ax3.plot([], [], marker="o", color="green", label="Durchschnittliche Lieferzeit (s)")
-        self.ax3.set_xlabel("Simulationszeit (s)")
-        self.ax3.set_ylabel("Lieferzeit (s)")
-        self.ax3.set_title("Durchschnittliche Lieferzeit")
-        self.ax3.legend()
-        self.ax3.grid(True)
-
-        plt.show(block=False)
-        # Starte im Tkinter-Hauptloop eine periodische Aktualisierung:
-        self.tk_root.after(500, self.tk_graph_update)  # alle 500ms
-
-    def tk_graph_update(self):
-        # GIL sichern: Gibt einen Statuswert zurück, der später wieder freigegeben wird.
-        gil_state = ctypes.pythonapi.PyGILState_Ensure()
-        try:
-            times = [data[0] for data in self.graph_data]
-            rates = [data[1] for data in self.graph_data]
-            dwell = [data[2] for data in self.graph_data]
-            delivery = [data[3] for data in self.graph_data]
-
-            self.line1.set_data(times, rates)
-            self.ax1.relim()
-            self.ax1.autoscale_view()
-
-            self.line2.set_data(times, dwell)
-            self.ax2.relim()
-            self.ax2.autoscale_view()
-
-            self.line3.set_data(times, delivery)
-            self.ax3.relim()
-            self.ax3.autoscale_view()
-
-            self.fig.canvas.draw_idle()
-            self.fig.canvas.flush_events()
-        finally:
-            ctypes.pythonapi.PyGILState_Release(gil_state)
-
-        # Nächsten Aufruf in 500ms einplanen
-        self.tk_root.after(500, self.tk_graph_update)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-
-        # Bestimme die maximale Liegedauer aktueller Pakete an den Annahmestationen
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-
-        # Lieferzeit-Kennzahlen ermitteln: für Fahrzeuge, die aktuell ein Paket tragen
-        current_delivery_time = 0.0
-        for veh in self.garage_vehicles:
-            if veh.getPythonTag("package_attached"):
-                ds = veh.getPythonTag("delivery_start_time")
-                if ds:
-                    elapsed_delivery = self.sim_clock - ds
-                    current_delivery_time = max(current_delivery_time, elapsed_delivery)
-        avg_delivery_time = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        # Aktualisiere den Info-Label-Text
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s\n"
-            f"Lieferzeit (aktuell): {current_delivery_time:.1f}s\n"
-            f"Lieferzeit (maximal): {self.max_overall_delivery_time:.1f}s\n"
-            f"Durchschn. Lieferzeit: {avg_delivery_time:.1f}s"
-        )
-        return Task.cont
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def update_graph_data(self, task):
-        if self.sim_clock > 0:
-            ppm = self.delivered_packages / (self.sim_clock / 60)
-        else:
-            ppm = 0.0
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        avg_delivery = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        new_data = (self.sim_clock, ppm, avg_dwell, avg_delivery)
-        # Speichere alle Daten ab Simulationsbeginn:
-        self.graph_data.append(new_data)
-
-        # Zusätzlich: Falls der Graphprozess aktiv ist, schicke den neuen Datensatz auch an die Queue
-        if self.graph_queue is not None:
-            try:
-                self.graph_queue.put(new_data, block=False)
-            except Exception:
-                pass
-        return Task.cont
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Hier werden nur die gewünschten Spalten "ID", "Annahmestation", "Ziel" und "Fahrzeug" definiert.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    #-------Fahrzeugsteuerung(Bedienfenster)-------
-    def update_vehicle_control(self):
-        for veh, var in self.vehicle_state_vars.items():
-            new_state = var.get()
-            if new_state == "idle" and veh.getPythonTag("current_order") is not None:
-                veh.setPythonTag("standby_pending", True)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Standby angefordert (Auftrag wird fortgesetzt).")
-            else:
-                veh.setPythonTag("standby_pending", False)
-                veh.setPythonTag("order_state", new_state)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Zustand auf {new_state} gesetzt.")
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-    def update_cable(self, task):
-        # Verwende die simulative Zeit, die bereits in update_sim_clock hochgezählt wird
-        t = self.sim_clock
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    def create_garage_vehicles(self):
-        self.garage_vehicles = []
-        vehicle_id_counter = 1
-        for park in self.garagen_parking_points:
-            veh = self.create_vehicle(park_point=park)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            newPos.setZ(0)
-            veh.setPos(newPos)
-
-            # Fahrzeuge starten im Standby (idle)
-            veh.setPythonTag("current_order", None)
-            veh.setPythonTag("order_state", "idle")
-            veh.setPythonTag("package_attached", False)
-            veh.setPythonTag("vehicle_id", vehicle_id_counter)
-            # Speichere den Parkpunkt als Rückkehrziel
-            veh.setPythonTag("garage_target", park)
-            # Speichere auch das Anfangs-Heading, um es später beim Parken wiederherzustellen.
-            veh.setPythonTag("start_heading", veh.getH())
-            vehicle_id_counter += 1
-
-            self.garage_vehicles.append(veh)
-
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-            # Füge einen Textknoten hinzu, der die Fahrzeugnummer vorne auf dem Fahrzeug anzeigt.
-            # Wir suchen den Mast-Knoten.
-            mast = veh.find("**/mast")
-            if not mast.isEmpty():
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)  # Schwarz
-                tn.setAlign(TextNode.ACenter)
-                text_np = mast.attachNewNode(tn)
-                # Positioniere den Text relativ zum Mast: Wir nutzen den Vektor "intersection"
-                # und versetzen ihn in Z-Richtung um 0.2 Einheiten oberhalb des Zylinders.
-                text_np.setPos(intersection.x, intersection.y, intersection.z + 0.2)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-            else:
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)
-                tn.setAlign(TextNode.ACenter)
-                text_np = veh.attachNewNode(tn)
-                text_np.setPos(0, 1.2, 1.5)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-
-            self.taskMgr.add(partial(self.vehicle_order_task, veh),
-                             f"VehicleOrderTask_{veh.getPythonTag('vehicle_id')}")
-
-    # --------------- Erstellung des Fahrzeugs---------------
-    def create_vehicle(self, park_point=None):
-        # Erzeuge den übergeordneten Fahrzeug-Knoten
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # --------------------------
-        # Chassis erstellen (1 x 0.5 x 1.2, Farbe Rot)
-        # --------------------------
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # --------------------------
-        # Gabel (Fork) erstellen: Zwei Zähne
-        # --------------------------
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        vehicle_node.setPythonTag("fork_node", fork_node)
-
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-
-        # --------------------------
-        # Statt weißer Kante von der Gabel: bereits eingezeichnete grüne Mittellinie verwenden.
-        # In diesem Beispiel nehmen wir an, dass du schon eine „mittlere“ Linie gezeichnet hast.
-        # Zeichne die grüne Mittellinie, z. B. von einem Punkt an der Gabel (als Ausgangspunkt)
-        # bis zu einem Referenzpunkt – hier nutzen wir einen zuvor festgelegten Offset.
-        #
-        # Wir definieren:
-        #   - Den Ausgangspunkt als den grün markierten Punkt, der den mittleren Punkt der Gabel repräsentieren soll.
-        #   - Den Zielpunkt als den Referenzpunkt, der als Idealwert in create_vehicle bestimmt wurde.
-        # In unserem Beispiel berechnen wir den Zielpunkt einmalig aus den lokalen Offsets an der weißen Kante.
-        # (Diese Werte kannst du bei Bedarf anpassen.)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_global = fork_node.getPos(self.render) + left_corner_local
-        right_global = fork_node.getPos(self.render) + right_corner_local
-        # Berechne den idealen (statischen) Mittelpunkt als Referenz – dieser wird nur einmal gesetzt.
-        midpoint_white = (left_global + right_global) * 0.5
-        # Nun lege den grünen Marker so, dass er exakt in der Mitte der Gabel liegt.
-        # Hier entspricht der grüne Punkt der Mittellinie der Gabel.
-        green_point_global = midpoint_white  # Hier wird angenommen, dass der ideale Mittelpunkt gleich dem Referenzpunkt ist.
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        vehicle_node.setPythonTag("fork_green", green_marker_np)
-
-        # Zeichne die grüne Mittellinie.
-        # Als Beispiel: Zeichne eine Linie vom grünen Marker in Richtung +Y (relativ zum Fahrzeug),
-        # weil du den idealen Zustand so festgelegt hast, dass genau diese Linie mit der Station übereinstimmen soll.
-        ls_mid = LineSegs()
-        ls_mid.setThickness(2.0)
-        ls_mid.setColor(0, 1, 0, 1)  # grün
-        # Starte die Linie am grünen Marker.
-        ls_mid.moveTo(green_point_global)
-        # Zeichne beispielsweise eine Linie 1 Einheit lang in +Y-Richtung:
-        ls_mid.drawTo(green_point_global + Vec3(0, 1, 0))
-        fork_center_line = vehicle_node.attachNewNode(ls_mid.create())
-        # Speichere den NodePath der grünen Mittellinie
-        vehicle_node.setPythonTag("fork_center_line", fork_center_line)
-        print("[DEBUG] create_vehicle: Grüne Mittellinie (fork_center_line) gesetzt.")
-
-        # --------------------------
-        # Restliche Fahrzeugteile (Mast, Lenkachse, etc.)
-        # --------------------------
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-        self.add_diagonals_to_mast(mast_node)
-
-        intersection = Vec3(0.5, 0.05, 1.0)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        # --------------------------
-        # Lenkachse erzeugen (Pivot-Node)
-        # --------------------------
-        steering_axis = mast_node.attachNewNode("steering_axis")
-        steering_axis.setPos(0.5, 0.25, -1.2)
-        steering_axis.setH(90)
-        vehicle_node.setPythonTag("steering_axis", steering_axis)
-
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(steering_axis)
-        cylinder_node.setPos(0, 0, 0)
-        self.vehicle_cylinder = steering_axis
-        self.add_steering_arrow(steering_axis, color=(0, 1, 0, 1))
-
-        # --------------------------
-        # Positioniere das Fahrzeug am Parkpunkt
-        # --------------------------
-        if park_point is None:
-            vehicle_node.setPos(0, 0, 0)
-        else:
-            intersection = Vec3(0, 0, 1.0)
-            vehicle_node.setPos(park_point - vehicle_node.getQuat().xform(intersection))
-
-        # ********** Ursprung (Koordinatensystem) am Fahrzeug einzeichnen **********
-        ls_x = LineSegs()
-        ls_x.setThickness(2)
-        ls_x.setColor(LColor(1, 0, 0, 1))
-        ls_x.moveTo(0, 0, 0)
-        ls_x.drawTo(1, 0, 0)
-        vehicle_node.attachNewNode(ls_x.create())
-
-        ls_y = LineSegs()
-        ls_y.setThickness(2)
-        ls_y.setColor(LColor(0, 1, 0, 1))
-        ls_y.moveTo(0, 0, 0)
-        ls_y.drawTo(0, 1, 0)
-        vehicle_node.attachNewNode(ls_y.create())
-
-        ls_z = LineSegs()
-        ls_z.setThickness(2)
-        ls_z.setColor(LColor(0, 0, 1, 1))
-        ls_z.moveTo(0, 0, 0)
-        ls_z.drawTo(0, 0, 1)
-        vehicle_node.attachNewNode(ls_z.create())
-
-        from panda3d.core import TextNode
-        tn_x = TextNode("label_x")
-        tn_x.setText("X")
-        tn_x.setTextColor(1, 0, 0, 1)
-        label_x = vehicle_node.attachNewNode(tn_x)
-        label_x.setScale(0.3)
-        label_x.setPos(2.0, 0, 0)
-
-        tn_y = TextNode("label_y")
-        tn_y.setText("Y")
-        tn_y.setTextColor(0, 1, 0, 1)
-        label_y = vehicle_node.attachNewNode(tn_y)
-        label_y.setScale(0.3)
-        label_y.setPos(0, 2.0, 0)
-
-        tn_z = TextNode("label_z")
-        tn_z.setText("Z")
-        tn_z.setTextColor(0, 0, 1, 1)
-        label_z = vehicle_node.attachNewNode(tn_z)
-        label_z.setScale(0.3)
-        label_z.setPos(0, 0, 2.0)
-
-        return vehicle_node
-
-    def add_steering_arrow(self, steering_axis, color=(0, 1, 0, 1)):
-        """
-        Erzeugt einen Pfeil, der die Vorwärtsrichtung (lokale X-Achse) des Lenkpivots anzeigt.
-        Der Pfeil wird als Kind des übergebenen steering_axis-Node angehängt und passt sich
-        automatisch dessen Rotation an.
-        """
-        arrow_ls = LineSegs()
-        arrow_ls.setThickness(2.0)
-        arrow_ls.setColor(*color)
-
-        # Zeichne eine Linie von (0,0,0) bis (2,0,0) – das ist die Basis des Pfeils
-        arrow_ls.moveTo(0, 0, 0)
-        arrow_ls.drawTo(2, 0, 0)
-
-        # Zeichne den Pfeilkopf: zwei kurze schräge Linien am Ende der Pfeillinie
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, 0.3, 0)
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, -0.3, 0)
-
-        arrow_np = steering_axis.attachNewNode(arrow_ls.create())
-        arrow_np.setPos(0, 0, 0)  # Falls nötig, hier noch zusätzlichen Offset anpassen
-        return arrow_np
-
-    def rotate_around_pivot(self, vehicle, pivot, delta_angle):
-        """
-        Dreht das Fahrzeug (vehicle) um den gegebenen Pivotpunkt (pivot) um delta_angle (in Grad).
-        Dabei wird die Position des Fahrzeugs neu berechnet, sodass es um den Pivot rotiert.
-        """
-        # Aktuelle globale Fahrzeugposition
-        pos = vehicle.getPos(self.render)
-        # Globaler Pivotpunkt
-        pivot_pos = pivot.getPos(self.render)
-        # Berechne den Vektor vom Pivot zum Fahrzeug
-        rel = pos - pivot_pos
-        # Wandle den Drehwinkel in Bogenmaß um
-        rad = math.radians(delta_angle)
-        cos_val = math.cos(rad)
-        sin_val = math.sin(rad)
-        # Drehe den relativen Vektor
-        new_x = rel.getX() * cos_val - rel.getY() * sin_val
-        new_y = rel.getX() * sin_val + rel.getY() * cos_val
-        new_rel = Vec3(new_x, new_y, rel.getZ())
-        # Neue globale Fahrzeugposition
-        new_pos = pivot_pos + new_rel
-        vehicle.setPos(new_pos)
-        # Aktualisiere auch das Heading des Fahrzeugs (aufaddieren des Drehwinkels)
-        vehicle.setH(vehicle.getH() + delta_angle)
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    # ---------------6. Paket- & Auftragsverwaltung---------------
-        # Beispiel einer Methode, die weiterhin auf die extrahierten Umgebungselemente zugreift:
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Je nach gewählter Verteilung kannst du hier Anpassungen vornehmen.
-        # Für den Moment wählen wir einfach zufällig aus allen Abgabestationen,
-        # falls keine spezielle Logik für die Verteilung implementiert ist.
-        target_index = random.randint(1, len(self.abgabe_stations))
-
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def check_and_spawn_packages(self, task):
-        # Verwende den neuen Delay-Wert aus den Einstellungen
-        spawn_delay = self.package_spawn_delay
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-        # Beispiel für eine vorhandene Methode, die auf die Umgebungselemente zugreift:
-    def update_order_table(self):
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen die Stationsnummer (oder verwende "N/A").
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z.B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige den zugewiesenen Fahrzeugnamen an (oder "-" falls noch keiner zugeordnet wurde).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END,
-                                   values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if hasattr(self, 'order_win') and self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    # ---------------7. Cargo-Handling (Pickup, Drop & Timer)---------------
-    def pickup_package(self, vehicle, station):
-        # Falls das Fahrzeug bereits ein Paket trägt, abbrechen.
-        if vehicle.getPythonTag("package_attached"):
-            return
-
-        # Führe den Pickup nur aus, wenn an der Station ein Paket vorhanden ist.
-        if station in self.pickup_packages:
-            # Hole das Paket, den Spawn-Zeitpunkt und den zugehörigen Timer-Knoten.
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            # Entferne den Timer-Knoten, sodass der angezeigte Zähler nicht weiter aktualisiert wird.
-            timer_np.removeNode()
-            # Berechne die Liegedauer (Differenz zwischen aktueller Simulationszeit und Spawn-Zeit).
-            dwell_time = self.sim_clock - spawn_time
-            # Aktualisiere globale Kennzahlen.
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Suche in den Aufträgen nach dem Auftrag, dessen Paket mit diesem Paket übereinstimmt,
-            # und speichere den errechneten Endwert (fixe Liegedauer) sowie den Status.
-            for order_id, order in self.orders.items():
-                if order.get("package") == package:
-                    order["dwell_time"] = dwell_time
-                    order["status"] = "Abgeholt"
-                    break
-
-            # Hole Referenzen zum Gabel-Knoten und zum grünen Marker des Fahrzeugs.
-            fork_node = vehicle.getPythonTag("fork_node")
-            fork_green = vehicle.getPythonTag("fork_green")
-            green_point_pos = fork_green.getPos(fork_node)
-
-            # Übergib das Paket an den Gabel-Knoten (sodass es optisch dem Fahrzeug zugeordnet wird)
-            # und positioniere es relativ zum grünen Marker.
-            package.wrtReparentTo(fork_node)
-            package.setPos(green_point_pos.getX() + 0.5,
-                           green_point_pos.getY() - 0.5,
-                           green_point_pos.getZ() + 1)
-            self.cargos[vehicle] = package
-
-            # Starte den Lieferzeit-Timer: Speichere den Zeitpunkt, an dem das Paket abgeholt wurde,
-            # und hänge einen neuen Timer-Knoten an das Paket.
-            vehicle.setPythonTag("delivery_start_time", self.sim_clock)
-            from panda3d.core import TextNode
-            delivery_timer_text = TextNode("delivery_timer")
-            delivery_timer_text.setText("0.0s")
-            delivery_timer_np = package.attachNewNode(delivery_timer_text)
-            delivery_timer_np.setScale(0.5)
-            delivery_timer_np.setPos(0, 0, 1.2)
-            package.setPythonTag("delivery_timer", delivery_timer_np)
-
-            # Aktualisiere den Zeitpunkt, zu dem an dieser Station zuletzt ein Paket entfernt wurde.
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-
-            # Berechne Lieferzeit:
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start is not None:
-                delivery_time = self.sim_clock - delivery_start
-                self.total_delivery_time += delivery_time
-                self.total_delivery_count += 1
-                self.max_overall_delivery_time = max(self.max_overall_delivery_time, delivery_time)
-                vehicle.clearPythonTag("delivery_start_time")
-
-            # Entferne den Lieferzeit-Timer vom Paket
-            delivery_timer_np = cargo.getPythonTag("delivery_timer")
-            if delivery_timer_np:
-                delivery_timer_np.removeNode()
-
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden das Paket entfernt
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def update_delivery_timers(self, task):
-        for vehicle, package in list(self.cargos.items()):
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start:
-                elapsed_delivery = self.sim_clock - delivery_start
-                delivery_timer_np = package.getPythonTag("delivery_timer")
-                if delivery_timer_np and not delivery_timer_np.isEmpty():
-                    delivery_timer_np.node().setText(f"{elapsed_delivery:.1f}s")
-        return Task.cont
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-
-    # ---------------8. Auftrags-/Fahrzeuglogik---------------
-    def select_next_order(self, vehicle):
-        # Sammle alle Aufträge, die noch "Wartend" sind
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        # Aktualisiere die Dwell-Zeit für jeden Auftrag
-        for order in waiting_orders:
-            order["dwell_time"] = self.sim_clock - order.get("spawn_time", self.sim_clock)
-
-        # Wähle den Auftrag mit der maximalen Dwell-Zeit (evtl. mit etwas Toleranz)
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        # Finde aus den Kandidaten den Auftrag, dessen Pickup-Station (order["pickup_station"])
-        # am nächsten zur aktuellen Fahrzeugposition liegt.
-        vehicle_pos = vehicle.getPos(self.render)
-        candidates.sort(key=lambda order: (order["pickup_station"].getPos(self.render) - vehicle_pos).length())
-        return candidates[0]
-
-    def show_vehicle_control(self):
-        # Falls das Fenster bereits existiert, wiederverwenden
-        if hasattr(self, "control_win") and self.control_win.winfo_exists():
-            self.control_win.deiconify()
-            self.control_win.lift()
-            self.control_win.focus_force()
-            return
-
-        self.control_win = tk.Toplevel(self.tk_root)
-        self.control_win.title("Kontrollfenster")
-        self.control_win.protocol("WM_DELETE_WINDOW", self.control_win.withdraw)
-        self.control_win.attributes("-topmost", True)
-        self.control_win.after(100, lambda: self.control_win.attributes("-topmost", False))
-
-        # ---------------- Fahrzeugsteuerung ----------------
-        # Zunächst einen Button einfügen, der ALLE Fahrzeuge auf "Aufträge bearbeiten" setzt.
-        all_vehicles_btn = tk.Button(
-            self.control_win,
-            text="Alle Fahrzeuge auf 'Aufträge bearbeiten' setzen",
-            command=lambda: [self.vehicle_state_vars[veh].set("translate") for veh in self.garage_vehicles]
-        )
-        all_vehicles_btn.grid(row=0, column=0, sticky="w", padx=5, pady=5)
-
-        # Nun die einzelnen Fahrzeugzeilen – starte ab Zeile 1
-        self.vehicle_state_vars = {}
-        row = 1
-        for veh in self.garage_vehicles:
-            frame = tk.Frame(self.control_win)
-            frame.grid(row=row, column=0, sticky="w", padx=5, pady=2)
-            vid = veh.getPythonTag("vehicle_id")
-            label = tk.Label(frame, text=f"Fahrzeug {vid}")
-            label.pack(side=tk.LEFT)
-            state = veh.getPythonTag("order_state") or "idle"
-            var = tk.StringVar(value=state)
-            self.vehicle_state_vars[veh] = var
-            rb_active = tk.Radiobutton(frame, text="Aufträge bearbeiten", variable=var, value="translate")
-            rb_active.pack(side=tk.LEFT)
-            rb_standby = tk.Radiobutton(frame, text="Standby", variable=var, value="idle")
-            rb_standby.pack(side=tk.LEFT)
-            row += 1
-
-        update_btn = tk.Button(self.control_win, text="Übernehmen", command=self.update_vehicle_control)
-        update_btn.grid(row=row, column=0, pady=5)
-        row += 1
-
-        # ---------------- Spawn-Einstellungen ----------------
-        spawn_frame = tk.LabelFrame(self.control_win, text="Spawn Einstellungen", padx=5, pady=5)
-        spawn_frame.grid(row=row, column=0, sticky="w", padx=5, pady=5)
-
-        # Eingabe der Spawnverzögerung
-        tk.Label(spawn_frame, text="Spawnverzögerung (Sekunden):").grid(row=0, column=0, sticky="w")
-        self.spawn_delay_var = tk.DoubleVar(value=self.package_spawn_delay)
-        delay_entry = tk.Entry(spawn_frame, textvariable=self.spawn_delay_var, width=6)
-        delay_entry.grid(row=0, column=1, sticky="w")
-
-        # Direkt in diesem Spawn-Feld: Button, der alle Annahmestationen auswählt
-        btn_select_all_stations = tk.Button(
-            spawn_frame,
-            text="Alle Annahmestationen auswählen",
-            command=lambda: [self.spawn_station_vars[i].set(True) for i in self.spawn_station_vars]
-        )
-        btn_select_all_stations.grid(row=0, column=2, padx=5)
-
-        # Auswahl der Annahmestationen (Checkbuttons)
-        tk.Label(spawn_frame, text="Annahmestationen:").grid(row=1, column=0, sticky="w", pady=(5, 0))
-        stations_frame = tk.Frame(spawn_frame)
-        stations_frame.grid(row=2, column=0, columnspan=3, sticky="w")
-        for i in range(min(10, len(self.annahme_stations))):
-            cb = tk.Checkbutton(stations_frame, text=f"Annahmestation {i + 1}",
-                                variable=self.spawn_station_vars[i])
-            cb.pack(anchor="w")
-
-        def apply_spawn_from_control():
-            self.package_spawn_delay = self.spawn_delay_var.get()
-            selected = []
-            for i, var in self.spawn_station_vars.items():
-                if var.get():
-                    selected.append(self.annahme_stations[i])
-            self.package_spawn_stations = selected
-            print(
-                f"Spawn Einstellungen übernommen: Delay={self.package_spawn_delay}s, "
-                f"Stations: {[i + 1 for i, var in self.spawn_station_vars.items() if var.get()]}"
-            )
-            # Spawne nur an Stationen, an denen noch kein Paket existiert:
-            for station in self.package_spawn_stations:
-                if station not in self.pickup_packages:
-                    self.spawn_package_at_station(station)
-            # Option: spawn_win schließen oder offen lassen
-            # self.control_win.withdraw()
-
-        apply_btn = tk.Button(
-            spawn_frame,
-            text="Einstellungen übernehmen und spawnen",
-            command=apply_spawn_from_control
-        )
-        apply_btn.grid(row=3, column=0, columnspan=3, pady=5)
-
-    def show_spawn_control(self):
-        spawn_win = tk.Toplevel(self.tk_root)
-        spawn_win.title("Paketspawn Einstellungen")
-
-        # Eingabefeld für Spawnverzögerung
-        tk.Label(spawn_win, text="Spawnverzögerung (Sekunden):").pack(pady=2)
-        delay_entry = tk.Entry(spawn_win)
-        delay_entry.insert(0, str(self.package_spawn_delay))
-        delay_entry.pack(pady=2)
-
-        # (Dropdown für Spawn-Verteilung wurde entfernt)
-
-        # Checkbuttons für die Auswahl der Annahmestationen
-        tk.Label(spawn_win, text="Annahmestationen auswählen (1-10):").pack(pady=2)
-        stations_frame = tk.Frame(spawn_win)
-        stations_frame.pack(pady=2)
-
-        station_vars = {}
-        for idx, station in enumerate(self.annahme_stations):
-            var = tk.BooleanVar(value=False)
-            station_label = f"Annahmestation {idx + 1}"
-            cb = tk.Checkbutton(stations_frame, text=station_label, variable=var)
-            cb.pack(anchor="w")
-            station_vars[idx] = var
-
-        def apply_spawn_settings():
-            try:
-                new_delay = float(delay_entry.get())
-            except ValueError:
-                new_delay = self.package_spawn_delay
-            new_stations = []
-            for idx, var in station_vars.items():
-                if var.get():
-                    new_stations.append(self.annahme_stations[idx])
-
-            self.package_spawn_delay = new_delay
-            self.package_spawn_stations = new_stations
-
-            print(f"Spawn-Einstellungen aktualisiert: Delay={new_delay}s, "
-                  f"Stationen: {[f'Annahmestation {idx + 1}' for idx, var in station_vars.items() if var.get()]}")
-            # Spawne nur dort Pakete, wo noch kein Paket vorhanden ist:
-            for station in self.package_spawn_stations:
-                if station not in self.pickup_packages:
-                    self.spawn_package_at_station(station)
-
-            spawn_win.destroy()
-
-        tk.Button(spawn_win, text="Einstellungen speichern", command=apply_spawn_settings).pack(pady=5)
-
-    def vehicle_order_task(self, vehicle, task):
-        # Berechne dt (berücksichtigt die Simulationsgeschwindigkeit)
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-
-        # (Optional) Überprüfe, ob ein Zustand gesetzt ist. Bleibt das Fahrzeug in "idle", wird nichts gemacht.
-        state = vehicle.getPythonTag("order_state")
-        if state is None:
-            vehicle.setPythonTag("order_state", "idle")
-            return Task.cont
-        if state == "idle":
-            return Task.cont
-
-        # --- Modellinferenz & Trainingsdatenerfassung ---
-        frame_count = vehicle.getPythonTag("frame_count")
-        if frame_count is None:
-            frame_count = 0
-        frame_count += 1
-        vehicle.setPythonTag("frame_count", frame_count)
-
-        sensor_data = self.collect_sensor_data(vehicle)
-        import numpy as np
-        if self.tf_model is not None and (frame_count % 10 == 0):
-            input_data = sensor_data.reshape(1, sensor_data.shape[0], sensor_data.shape[1], 1)
-            prediction = self.tf_model.predict(input_data)
-            model_delta_angle = prediction[0][0]
-            print(f"[TF] Modell-Korrektur: {model_delta_angle:.2f}°")
-        else:
-            model_delta_angle = 0.0
-            if self.tf_model is not None:
-                print(f"[TF] Modell-Korrektur übersprungen (Frame Count: {frame_count})")
-            else:
-                print("[TF] Kein Modell vorhanden, Modell-Korrektur wird übersprungen.")
-
-        ideal_correction = self.compute_ideal_steering_correction(vehicle)
-        print(f"[IDEAL] Ideal berechneter Korrekturwinkel: {ideal_correction:.2f}°")
-        if state == "translate":
-            self.log_training_sample(sensor_data, ideal_correction)
-        # --- Ende Modellinferenz & Logging ---
-
-        # Zustandsbasierte Handler-Aufrufe:
-        if state == "translate":
-            self.handle_translate_phase(vehicle, dt)
-        elif state == "rotate":
-            self.handle_rotate_phase(vehicle, dt)
-        elif state == "approach":
-            self.handle_approach_phase(vehicle, dt)
-        elif state == "pickup":
-            self.handle_pickup_phase(vehicle, dt)
-        elif state == "drive_out":
-            self.handle_drive_out_phase(vehicle, dt)
-        elif state == "to_delivery":
-            self.handle_to_delivery_phase(vehicle, dt)
-        elif state == "align_delivery":
-            self.handle_align_delivery_phase(vehicle, dt)
-        elif state == "delivery_center":
-            self.handle_delivery_center_phase(vehicle, dt)
-        elif state == "drop":
-            self.handle_drop_phase(vehicle, dt)
-        elif state == "delivery_exit":
-            self.handle_drive_out_phase_delivery(vehicle, dt)
-        elif state == "return_to_garage":
-            self.handle_return_to_garage_phase(vehicle, dt)
-        else:
-            print(
-                f"Unbekannter Zustand '{state}' für Fahrzeug {vehicle.getPythonTag('vehicle_id')}. Setze auf 'translate'.")
-            vehicle.setPythonTag("order_state", "translate")
-
-        return Task.cont
-
-    # -------------------- Handler für einzelne Phasen --------------------
-
-    def handle_translate_phase(self, vehicle, dt):
-        import math
-        from panda3d.core import Vec3
-        # --- Zusätzlicher Safety-Zweig in der Translate-Phase ---
-        current_order = vehicle.getPythonTag("current_order")
-        station_occupied = False
-        if current_order is not None and "pickup_station" in current_order:
-            pickup_station = current_order["pickup_station"]
-            if self.is_station_occupied(pickup_station, exclude_vehicle=vehicle):
-                station_occupied = True
-                print(
-                    f"[WARTEN] Annahmestation {pickup_station.getName()} blockiert. Fahrzeug {vehicle.getPythonTag('vehicle_id')} wartet.")
-        # Setze die Basisgeschwindigkeit auf 1.5, sofern die Station nicht blockiert ist, sonst 0
-        base_speed = 1.5 if not station_occupied else 0.0
-
-        # Passe die Geschwindigkeit unter Kollisionsvermeidung an
-        adjusted_speed = self.collision_avoidance_adjustment(vehicle, base_speed)
-
-        # Falls noch kein Auftrag vorhanden, weise einen neuen zu
-        if current_order is None:
-            next_order = self.select_next_order(vehicle)
-            if next_order is not None:
-                next_order["status"] = "In Bearbeitung"
-                next_order["vehicle"] = f"Fahrzeug {vehicle.getPythonTag('vehicle_id')}"
-                vehicle.setPythonTag("current_order", next_order)
-                print(f"Auftrag {next_order['id']} wird zugewiesen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}.")
-            current_order = vehicle.getPythonTag("current_order")
-
-        # Bestimme das Ziel – Verwende den blauen Marker der Pickup-Station
-        if current_order is not None:
-            pickup_station = current_order.get("pickup_station")
-            if pickup_station in self.station_blue_dots:
-                target = self.station_blue_dots[pickup_station].getPos(self.render)
-            else:
-                target = self.blue_dot.getPos(self.render)
-        else:
-            target = self.blue_dot.getPos(self.render)
-
-        current_pos = vehicle.getPos(self.render)
-        pivot = vehicle.getPythonTag("steering_axis")
-        # Berechne den Referenzpunkt über denpickup_offset
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-
-        # Berechne den gewünschten Heading-Winkel (in Radiant)
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-        heading_error = desired_heading_rad - current_heading_rad
-        while heading_error > math.pi:
-            heading_error -= 2 * math.pi
-        while heading_error < -math.pi:
-            heading_error += 2 * math.pi
-
-        gain = 1.0
-        max_delta = gain * dt
-        delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-        self.rotate_around_pivot(vehicle, pivot, math.degrees(delta_heading_rad))
-
-        global_hpr = pivot.getNetTransform().getHpr()
-        new_heading_rad = math.radians(global_hpr.getX())
-        new_x = current_pos.getX() + adjusted_speed * math.cos(new_heading_rad) * dt
-        new_y = current_pos.getY() + adjusted_speed * math.sin(new_heading_rad) * dt
-        new_pos = Vec3(new_x, new_y, 0)
-        vehicle.setPos(new_pos)
-
-        # Wenn der vom Offset zum Ziel gemessene Abstand klein genug ist, wechsle in die nächste Phase
-        new_offset_pos = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        if (target - new_offset_pos).length() < 0.1:
-            vehicle.setPythonTag("order_state", "rotate")
-
-        return Task.cont
-
-    def handle_approach_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None:
-            pickup_station = current_order.get("pickup_station")
-            target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-        else:
-            target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-        current = vehicle.getPos(self.render)
-        error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-        if error_vec.length() > 0.05:
-            direction = error_vec.normalized()
-            move_distance = 1.5 * dt
-            new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                           current.getY() + direction.getY() * move_distance, target.getZ())
-            vehicle.setPos(new_pos)
-        else:
-            vehicle.setPos(target)
-            vehicle.setPythonTag("order_state", "pickup")
-
-    def handle_pickup_phase(self, vehicle, dt):
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        target_z = 1.0
-        raise_speed = 0.5
-        if current_z < target_z:
-            fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-        else:
-            if vehicle.getPythonTag("current_order") is None:
-                if self.orders_queue:
-                    vehicle.setPythonTag("current_order", self.orders_queue.pop(0))
-                else:
-                    print(
-                        f"Keine verfügbaren Aufträge für Fahrzeug {vehicle.getPythonTag('vehicle_id')}. Überspringe Pickup-Phase.")
-                    vehicle.setPythonTag("order_state", "drive_out")
-                    return
-            if not vehicle.getPythonTag("package_attached"):
-                pickup_station = vehicle.getPythonTag("current_order")["pickup_station"]
-                self.pickup_package(vehicle, pickup_station)
-                vehicle.setPythonTag("package_attached", True)
-            if vehicle.getPythonTag("drive_out_target") is None:
-                vehicle.setPythonTag("drive_out_target",
-                                     vehicle.getPos(self.render) + vehicle.getQuat(self.render).getForward() * 5.0)
-            vehicle.setPythonTag("order_state", "drive_out")
-
-    def handle_drive_out_phase(self, vehicle, dt):
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        if current_z > 0:
-            lower_speed = 0.5
-            fork_node.setZ(max(0, current_z - lower_speed * dt))
-        current_pos = vehicle.getPos(self.render)
-        drive_out_target = vehicle.getPythonTag("drive_out_target")
-        if drive_out_target is None:
-            drive_out_target = current_pos + vehicle.getQuat(self.render).getForward() * 5.0
-            vehicle.setPythonTag("drive_out_target", drive_out_target)
-        diff = drive_out_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            vehicle.setPythonTag("order_state", "to_delivery")
-            vehicle.setPythonTag("drive_out_target", None)
-
-    def handle_to_delivery_phase(self, vehicle, dt):
-        import math
-        from panda3d.core import Vec3
-
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is None:
-            return Task.cont
-
-        # Bestimme das Ziel: Nutze den blauen Marker der Abgabestation (aus dem Auftrag, z. B. "Abgabestation 3")
-        try:
-            target_index = int(current_order.get("ziel", "Abgabestation 1").split()[-1])
-        except Exception:
-            target_index = 1
-        if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-            target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-        else:
-            target = self.abgabe_blue_dots[0].getPos(self.render)
-
-        current_pos = vehicle.getPos(self.render)
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-
-        # Prüfe, ob an der Abgabestation bereits ein Fahrzeug in Phase "delivery_exit" aktiv ist.
-        if self.is_delivery_station_occupied(target, exclude_vehicle=vehicle):
-            print(f"[WARTEN] Abgabestation blockiert. Fahrzeug {vehicle.getPythonTag('vehicle_id')} wartet.")
-            return Task.cont
-
-        # Berechne den gewünschten Basiswinkel vom Offset-Punkt zum Ziel.
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-
-        pivot = vehicle.getPythonTag("steering_axis")
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-        heading_error = desired_heading_rad - current_heading_rad
-        while heading_error > math.pi:
-            heading_error -= 2 * math.pi
-        while heading_error < -math.pi:
-            heading_error += 2 * math.pi
-
-        gain = 1.0
-        max_delta = gain * dt
-        delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-        self.rotate_around_pivot(vehicle, pivot, math.degrees(delta_heading_rad))
-
-        global_hpr = pivot.getNetTransform().getHpr()
-        new_heading_rad = math.radians(global_hpr.getX())
-        # Geschwindigkeit wird angepasst (hier basierend auf Kollisionsvermeidung und 1,5 Einheiten Basis)
-        adjusted_speed = self.collision_avoidance_adjustment(vehicle, base_speed=1.5)
-        new_x = current_pos.getX() + adjusted_speed * math.cos(new_heading_rad) * dt
-        new_y = current_pos.getY() + adjusted_speed * math.sin(new_heading_rad) * dt
-        new_pos = Vec3(new_x, new_y, current_pos.getZ())
-        vehicle.setPos(new_pos)
-
-        new_offset_pos = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        if (target - new_offset_pos).length() < 0.1:
-            vehicle.setPythonTag("order_state", "align_delivery")
-
-        return Task.cont
-
-    def handle_align_delivery_phase(self, vehicle, dt):
-        import math
-
-        # 1. Ermittle den Basiszielwinkel aus der weißen Linie der Abgabestation.
-        # Wir gehen davon aus, dass self.abgabe_white_line existiert und den globalen Heading liefert.
-        try:
-            base_target_heading = self.abgabe_white_line.getH(self.render) % 360
-        except Exception as e:
-            base_target_heading = 90.0
-            print(
-                f"[Align Delivery] Warning: self.abgabe_white_line nicht gefunden, verwende Default {base_target_heading}°.")
-
-        # 2. Füge den zusätzlichen Versatz von 90° hinzu.
-        # Das bedeutet: Der gewünschte End-Heading ist 90° mehr als der von der weißen Linie gemessene Winkel.
-        desired_heading = (base_target_heading + 90) % 360
-
-        # 3. Ermittle den aktuellen globalen Heading über den Pivot-Knoten (z. B. steering_axis).
-        pivot = vehicle.getPythonTag("steering_axis")
-        pivot_hpr = pivot.getNetTransform().getHpr()
-        current_heading = pivot_hpr.getX() % 360
-
-        # 4. Berechne den minimalen Winkelunterschied (normiert auf [-180, 180]).
-        error = desired_heading - current_heading
-        while error > 180:
-            error -= 360
-        while error < -180:
-            error += 360
-
-        print(f"[Align Delivery] Vehicle {vehicle.getPythonTag('vehicle_id')}: "
-              f"Current Pivot Heading: {current_heading:.2f}°, "
-              f"Desired Heading: {desired_heading:.2f}° (Basis: {base_target_heading:.2f}°+90°), "
-              f"Error: {error:.2f}°")
-
-        # 5. Falls der Fehler sehr klein ist (< 1°), gilt die Ausrichtung als abgeschlossen.
-        if abs(error) < 1.0:
-            # Optional: kleine abschließende Korrektur
-            self.rotate_around_pivot(vehicle, pivot, error)
-            vehicle.setPythonTag("order_state", "delivery_center")
-            print(f"[Align Delivery] Alignment complete for vehicle {vehicle.getPythonTag('vehicle_id')}.")
-            return Task.cont
-
-        # 6. Berechne den Drehschritt (proportional, begrenzt durch einen festen maximalen Drehwinkel pro Frame).
-        turn_speed = 90.0  # maximale Drehgeschwindigkeit in Grad pro Sekunde
-        max_turn = turn_speed * dt
-        turn_angle = max(-max_turn, min(max_turn, error))
-
-        # 7. Drehe das Fahrzeug über den Pivot-Knoten.
-        self.rotate_around_pivot(vehicle, pivot, turn_angle)
-
-        return Task.cont
-
-    def handle_delivery_center_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is None:
-            return
-        delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-        try:
-            target_index = int(delivery_target_str.split()[-1])
-        except ValueError:
-            target_index = 1
-        if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-            blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-        else:
-            blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-        current = vehicle.getPos(self.render)
-        target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-        print(f"Phase 9: Zielpunkt der Abgabestation für Fahrzeug {vehicle.getPythonTag('vehicle_id')}: {target_point}")
-        error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-        tolerance = 0.05
-        move_distance = 1.5 * dt
-        if error_vec.length() > tolerance:
-            direction = error_vec.normalized()
-            new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                           current.getY() + direction.getY() * move_distance, current.getZ())
-            vehicle.setPos(new_pos)
-            print(f"Phase 9: Fahrzeug {vehicle.getPythonTag('vehicle_id')} bewegt sich von {current} nach {new_pos}")
-        else:
-            vehicle.setPos(target_point)
-            print(f"Phase 9: Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den Zielpunkt erreicht.")
-            vehicle.setPythonTag("order_state", "drop")
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_fork_z = fork_node.getZ()
-        if current_fork_z < 1.0:
-            new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-            fork_node.setZ(new_fork_z)
-            print(
-                f"Phase 9: Gabel wird angehoben für Fahrzeug {vehicle.getPythonTag('vehicle_id')} (Z = {new_fork_z}).")
-
-    def handle_drop_phase(self, vehicle, dt):
-        # Falls das Fahrzeug ein Paket trägt, wird dieses abgesetzt.
-        if vehicle.getPythonTag("package_attached"):
-            self.drop_cargo(vehicle)
-            print(f"Phase 10: Paket abgesetzt für Fahrzeug {vehicle.getPythonTag('vehicle_id')}")
-            vehicle.setPythonTag("package_attached", False)
-        else:
-            # Falls die Gabel noch abgesenkt werden muss:
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            if current_z > 0:
-                lower_speed = 0.5
-                fork_node.setZ(max(0, current_z - lower_speed * dt))
-            print(f"Phase 10: Dropoff abgeschlossen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}")
-
-        # Setze den Zustand nun auf "delivery_exit", damit das Fahrzeug aus dem Lieferbereich herausfährt.
-        vehicle.setPythonTag("order_state", "delivery_exit")
-        # Optional: den Auftrag als "Abgegeben" markieren und löschen.
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None:
-            current_order["status"] = "Abgegeben"
-            current_order["delivered_at"] = self.sim_clock
-        vehicle.clearPythonTag("current_order")
-
-        return Task.cont
-
-    def handle_drive_out_phase_delivery(self, vehicle, dt):
-        from panda3d.core import Vec3
-        # Senke die Gabel (Fork), falls sie noch angehoben ist.
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        if current_z > 0:
-            lower_speed = 0.5
-            fork_node.setZ(max(0, current_z - lower_speed * dt))
-
-        # Hole die aktuelle Position des Fahrzeugs (global).
-        current_pos = vehicle.getPos(self.render)
-
-        # Prüfe, ob bereits ein Drive‑Out‑Ziel (für den Lieferbereich) gesetzt wurde.
-        drive_out_target = vehicle.getPythonTag("drive_out_target")
-        if drive_out_target is None:
-            # Falls nicht, setzen wir als Ziel 5 Einheiten in Fahrtrichtung.
-            drive_out_target = current_pos + vehicle.getQuat(self.render).getForward() * 5.0
-            vehicle.setPythonTag("drive_out_target", drive_out_target)
-
-        # Berechne den Unterschied zwischen aktueller Position und Ziel.
-        diff = drive_out_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            new_pos.setZ(0)  # Stelle sicher, dass das Fahrzeug am Boden bleibt.
-            vehicle.setPos(new_pos)
-        else:
-            # Sobald das Fahrzeug das Drive‑Out‑Ziel erreicht hat, wird der Zustand auf "translate" gesetzt
-            # Damit bearbeitet es dann weitere Aufträge.
-            vehicle.setPythonTag("order_state", "translate")
-            vehicle.setPythonTag("drive_out_target", None)
-            print(
-                f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den Lieferbereich verlassen und wechselt in 'translate'.")
-
-        return Task.cont
-
-    def handle_phase11(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if vehicle.getPythonTag("last_delivery_marker") is not None:
-            target_point = vehicle.getPythonTag("last_delivery_marker")
-        else:
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                target_point = self.abgabe_blue_dots[0].getPos(self.render)
-        print(f"Phase 11: Zielpunkt (blauer Marker) für Fahrzeug {vehicle.getPythonTag('vehicle_id')}: {target_point}")
-        current_pos = vehicle.getPos(self.render)
-        diff = target_point - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            vehicle.setPos(new_pos)
-            print(
-                f"Phase 11: Fahrzeug {vehicle.getPythonTag('vehicle_id')} fährt aus der Station, neue Position: {new_pos}")
-        else:
-            vehicle.setPos(target_point)
-            print(
-                f"Phase 11: Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den blauen Marker erreicht. Nächster Auftrag wird gestartet.")
-            vehicle.setPythonTag("order_state", "next_order")
-
-    def handle_return_to_garage_phase(self, vehicle, dt):
-        garage_target = vehicle.getPythonTag("garage_target")
-        if garage_target is None:
-            garage_target = self.garagen_parking_points[0]
-        current_pos = vehicle.getPos(self.render)
-        diff = garage_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 1.0 * dt
-            new_pos = current_pos + diff.normalized() * move_distance
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            if vehicle.hasPythonTag("start_heading"):
-                vehicle.setH(vehicle.getPythonTag("start_heading"))
-            vehicle.setPythonTag("order_state", "idle")
-            vehicle.setPythonTag("standby_pending", False)
-            print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} ist in der Garage (Standby).")
-
-    def collect_sensor_data(self, vehicle, sensor_range=5, grid_resolution=0.5):
-        """
-        Erzeugt ein einfaches 2D-Occupancy-Grid, das den Bereich um das Fahrzeug simuliert.
-
-        Parameter:
-          sensor_range: Radius (in Welt-Einheiten) um das Fahrzeug.
-          grid_resolution: Größe der einzelnen Zellen im Grid.
-
-        Rückgabe:
-          Ein NumPy-Array (2D) mit 0 (frei) als Platzhalter.
-        """
-        import numpy as np
-        grid_size = int((sensor_range * 2) / grid_resolution)
-        sensor_grid = np.zeros((grid_size, grid_size))
-        # --- Hier kannst du später echte Kollisionsabfragen oder Ray-Casting integrieren ---
-        return sensor_grid
-
-    def compute_ideal_steering_correction(self, vehicle):
-        """
-        Berechnet einen idealen Korrekturwinkel (in Grad) für die Navigation in der 'translate'-Phase.
-        Es wird ein vereinfachtes Modell genutzt, das den Unterschied zwischen dem gewünschten und dem aktuellen
-        Heading (über die Fahrzeug-Steuerachse) ermittelt.
-        """
-        import math
-
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None and "pickup_station" in current_order:
-            pickup_station = current_order["pickup_station"]
-            if pickup_station in self.station_blue_dots:
-                target = self.station_blue_dots[pickup_station].getPos(self.render)
-            else:
-                target = self.blue_dot.getPos(self.render)
-        else:
-            target = self.blue_dot.getPos(self.render)
-
-        current_pos = vehicle.getPos(self.render)
-        # Bestimme einen Offset-Punkt, basierend auf der bereits existierenden pickup_offset
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        # Berechne den gewünschten Heading-Winkel (in Radiant): Richtung von offset_pos zu target
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-
-        # Hole den aktuellen Heading-Wert vom Steuerachsen-Node (pivot)
-        pivot = vehicle.getPythonTag("steering_axis")
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-
-        ideal_correction_rad = desired_heading_rad - current_heading_rad
-        # Winkelbereich anpassen [-pi, pi]
-        while ideal_correction_rad > math.pi:
-            ideal_correction_rad -= 2 * math.pi
-        while ideal_correction_rad < -math.pi:
-            ideal_correction_rad += 2 * math.pi
-
-        return math.degrees(ideal_correction_rad)
-
-    def compute_avoidance_angle(self, current_vehicle, safe_distance=3.0):
-        """
-        Berechnet einen zusätzlichen Ausweichwinkel (in Grad) basierend auf den
-        Positionen anderer Fahrzeuge. Fahrzeuge, die sehr nah sind, sollen einen
-        höheren Einfluss haben. Der Rückgabewert wird mit einem Gewichtungsfaktor
-        multipliziert, sodass der Ausweichimpuls moderat bleibt.
-        """
-        import math
-        from panda3d.core import Vec2
-
-        current_pos = current_vehicle.getPos(self.render)
-        avoidance_vector = Vec2(0, 0)
-
-        # Schleife über alle Fahrzeuge (außer dem eigenen)
-        for other in self.garage_vehicles:
-            if other == current_vehicle:
-                continue
-            other_pos = other.getPos(self.render)
-            diff = Vec2(current_pos.getX() - other_pos.getX(),
-                        current_pos.getY() - other_pos.getY())
-            dist = diff.length()
-            if dist > 0 and dist < safe_distance:
-                # Je näher das Fahrzeug, desto größer der Einfluss (gewichtete Summe)
-                weight = (safe_distance - dist) / safe_distance
-                avoidance_vector += diff.normalized() * weight
-
-        # Falls kein Fahrzeug in der Nähe ist, wird kein Ausweichwinkel angewendet.
-        if avoidance_vector.length() == 0:
-            return 0.0
-
-        # Berechne den Winkel, den der resultierende Ausweichvektor vorgibt.
-        avoidance_angle = math.degrees(math.atan2(avoidance_vector.getY(), avoidance_vector.getX()))
-        # Mit einem Faktor abschwächen, um den Einfluss zu mildern.
-        weight_factor = 0.5  # Passe diesen Faktor bei Bedarf an (0 = kein Ausweichen, 1 = voll)
-        return avoidance_angle * weight_factor
-
-    def log_training_sample(self, sensor_data, ideal_angle):
-        """
-        Speichert ein Trainingssample bestehend aus den gesammelten Sensorwerten und dem idealen Korrekturwinkel.
-        """
-        self.training_data.append((sensor_data.copy(), ideal_angle))
-        # Optional: Gib eine Debug-Ausgabe aus, um das Logging zu überwachen.
-        print(
-            f"[LOG] Trainingssample gespeichert: Ideal Correction = {ideal_angle:.2f}°, Sensor Shape = {sensor_data.shape}")
-
-    def apply_safety_rules(self, vehicle, sensor_data, model_delta_angle, ideal_correction):
-        """
-        Kombiniert den vom Modell (model_delta_angle) und den ideal berechneten Korrekturwert (ideal_correction)
-        nur dann mit einem festen Sicherheitswert, wenn die Sensordaten einen kritischen Occupancy-Level anzeigen.
-
-        Falls der Occupancy-Level niedrig ist, wird ausschließlich der ideal vorhandene Korrekturwert verwendet.
-        """
-        import numpy as np
-        # Beispiel: Untersuche die mittlere Zeile des sensor_data-Grids als Indikator für frontale Hindernisse
-        middle_row = sensor_data[sensor_data.shape[0] // 2]
-        occupancy_level = np.sum(middle_row)
-
-        # Definiere einen kritischen Schwellenwert (diesen Wert ggf. anpassen)
-        threshold = 1.0
-
-        if occupancy_level > threshold:
-            print(
-                f"[RULE] Kritischer Occupancy-Level = {occupancy_level:.2f} erkannt. Sicherheitskorrektur wird angewendet.")
-            # Hier legen wir fest, dass in kritischen Situationen der Sicherheitswert stärker gewichtet wird.
-            safety_correction = 15.0  # z. B. 15° als feste Korrektur (Wert anpassen)
-            # Gewichteter Ansatz: Sicherheitskorrektur dominiert, während ein kleiner Anteil des idealen Wertes einfließt.
-            final_angle = 0.7 * safety_correction + 0.3 * ideal_correction
-        else:
-            # Wenn kein kritischer Wert vorliegt, einfach den ideal berechneten Korrekturwert verwenden.
-            final_angle = ideal_correction
-
-        return final_angle
-
-    def collision_avoidance_adjustment(self, current_vehicle, base_speed, safe_distance=3.0):
-        current_pos = current_vehicle.getPos(self.render)
-        adjusted_speed = base_speed
-        # Berechne einen Basisfaktor (z.B. basierend auf Abstand zu anderen Fahrzeugen):
-        for veh in self.garage_vehicles:
-            if veh == current_vehicle:
-                continue
-            other_pos = veh.getPos(self.render)
-            distance = (current_pos - other_pos).length()
-            if distance < safe_distance:
-                factor = (distance / safe_distance) ** 2
-                candidate_speed = base_speed * factor
-                if candidate_speed < adjusted_speed:
-                    adjusted_speed = candidate_speed
-
-        # Hier integrieren wir den RL-Ausdruck:
-        # Nehme als Zustandsvektor bspw. [min_distance_to_others, current_speed]
-        min_distance = min(
-            [(current_pos - v.getPos(self.render)).length() for v in self.garage_vehicles if v != current_vehicle])
-        current_speed = self.current_speed  # oder eine entsprechende Eigenschaft des Fahrzeugs
-        state = [min_distance, current_speed]
-
-        # Angenommen, du hast für jedes Fahrzeug einen eigenen RL-Agenten (oder einen globalen)
-        action = self.rl_agent.select_action(state)
-        # Definiere, wie Aktion in einen zusätzlichen Bremsfaktor übersetzt wird:
-        # Beispiel: Aktion 0: kein zusätzlicher Bremsfaktor, 1: 20% Reduktion, 2: 50% Reduktion
-        action_to_factor = {0: 1.0, 1: 0.8, 2: 0.5}
-        braking_factor = action_to_factor.get(action, 1.0)
-        adjusted_speed *= braking_factor
-
-        return adjusted_speed
-
-    def is_station_occupied(self, station, exclude_vehicle=None, occupancy_threshold=1.0):
-        """
-        Prüft, ob sich bereits ein Fahrzeug an der gegebenen Station (z. B. Pickup‑Station)
-        befindet. Dabei wird als Zielpunkt zumeist der blaue Marker genutzt, der der Station
-        zugeordnet ist. Das Fahrzeug exclude_vehicle (z. B. das aktuell agierende Fahrzeug)
-        wird dabei nicht berücksichtigt.
-        """
-        # Falls ein blauer Marker vorhanden ist, nutze dessen Position als Zielort:
-        if hasattr(self, 'station_blue_dots') and station in self.station_blue_dots:
-            station_pos = self.station_blue_dots[station].getPos(self.render)
-        else:
-            station_pos = station.getPos(self.render)
-        for veh in self.garage_vehicles:
-            if veh == exclude_vehicle:
-                continue
-            if (veh.getPos(self.render) - station_pos).length() < occupancy_threshold:
-                return True
-        return False
-
-    def is_delivery_station_occupied(self, target_pos, exclude_vehicle=None, occupancy_threshold=1.0):
-        """
-        Prüft, ob sich ein Fahrzeug in der Nähe der Abgabestation (target_pos) befindet,
-        welches in einer Lieferphase (z. B. drop, delivery_center oder align_delivery) ist oder noch ein Paket
-        transportiert (package_attached = True). Das Fahrzeug exclude_vehicle (z. B. das aktuell anfahrende Fahrzeug)
-        wird dabei nicht berücksichtigt.
-        """
-        for veh in self.garage_vehicles:
-            if veh == exclude_vehicle:
-                continue
-            # Hole den aktuellen Zustand und ob ein Paket noch angebracht ist.
-            state = veh.getPythonTag("order_state")
-            package_attached = veh.getPythonTag("package_attached")
-            if state in ["drop", "delivery_center", "align_delivery"] or package_attached:
-                if (veh.getPos(self.render) - target_pos).length() < occupancy_threshold:
-                    return True
-        return False
-
-    def check_collisions(self):
-        collision_threshold = 1.0  # z. B. wenn Fahrzeuge näher als 1 Einheit sind
-        collisions = []
-        for i in range(len(self.garage_vehicles)):
-            veh1 = self.garage_vehicles[i]
-            pos1 = veh1.getPos(self.render)
-            for j in range(i + 1, len(self.garage_vehicles)):
-                veh2 = self.garage_vehicles[j]
-                pos2 = veh2.getPos(self.render)
-                if (pos1 - pos2).length() < collision_threshold:
-                    collisions.append((veh1, veh2))
-        return collisions
-
-    def update_rl_on_collisions(self):
-        collisions = self.check_collisions()
-        for veh1, veh2 in collisions:
-            # Für jedes beteiligte Fahrzeug:
-            for veh in (veh1, veh2):
-                # Erstelle einen Zustandsvektor – analog zum, der in collision_avoidance_adjustment verwendet wird.
-                current_pos = veh.getPos(self.render)
-                min_distance = min([(current_pos - v.getPos(self.render)).length()
-                                    for v in self.garage_vehicles if v != veh])
-                current_speed = self.current_speed  # oder fahrzeugspezifisch
-                state = [min_distance, current_speed]
-                # Nehme an, die letzte von deinem Agenten gewählte Aktion ist gespeichert (das könntest du in einem PythonTag ablegen)
-                last_action = veh.getPythonTag("last_braking_action")
-
-                # Definiere den negativen Reward
-                reward = -10
-                # Erfasse den nächsten Zustand (nach Entfernen des Kollisionsereignisses oder nach einer kurzen Verzögerung)
-                next_state = state  # In einem echten Setup wäre hier der nächste gemessene Zustand
-                self.rl_agent.update(state, last_action, reward, next_state)
-                print(f"RL-Update für Fahrzeug {veh.getPythonTag('vehicle_id')}: Kollisionsreward {reward} vergeben.")
-
-import random
-import numpy as np
-
-class RLAgent:
-    def __init__(self, state_bins, action_space, learning_rate=0.1, discount_factor=0.9, epsilon=0.2):
-        """
-        state_bins: Tuple oder Liste, um kontinuierliche Zustände zu diskretisieren (z.B. (max_distance, num_bins))
-        action_space: Liste diskreter Aktionen (z.B. [0, 1, 2] --> 0: keine Bremsung, 1: leicht, 2: stark)
-        """
-        self.state_bins = state_bins
-        self.action_space = action_space
-        self.lr = learning_rate
-        self.gamma = discount_factor
-        self.epsilon = epsilon
-        # Initialisiere Q-Tabelle als Dictionary: key: (discretisierter_state), value: Liste von Q-Werten pro Aktion
-        self.q_table = {}
-
-    def discretize_state(self, state):
-        """
-        Nimmt einen Zustandsvektor (z.B. [distance, speed]) und gibt einen diskreten Zustand zurück.
-        Hier ein Beispiel: Falls state[0] = Abstand und state[1] = Geschwindigkeit.
-        """
-        # Beispiel: Wir nehmen an, dass state_bins = ((max_distance, num_bins), (max_speed, num_bins))
-        discrete_state = []
-        for i, (max_val, bins) in enumerate(self.state_bins):
-            # Begrenze state[i] um max_val:
-            val = min(state[i], max_val)
-            bin_size = max_val / bins
-            discrete_state.append(int(val // bin_size))
-        return tuple(discrete_state)
-
-    def select_action(self, state):
-        discrete_state = self.discretize_state(state)
-        if discrete_state not in self.q_table:
-            self.q_table[discrete_state] = [0.0 for _ in self.action_space]
-        # Epsilon-greedy Auswahl:
-        if random.random() < self.epsilon:
-            return random.choice(self.action_space)
-        else:
-            q_values = self.q_table[discrete_state]
-            return self.action_space[np.argmax(q_values)]
-
-    def update(self, state, action, reward, next_state):
-        s = self.discretize_state(state)
-        s_next = self.discretize_state(next_state)
-        if s not in self.q_table:
-            self.q_table[s] = [0.0 for _ in self.action_space]
-        if s_next not in self.q_table:
-            self.q_table[s_next] = [0.0 for _ in self.action_space]
-        a_index = self.action_space.index(action)
-        # Q-Learning Update-Regel:
-        best_next = max(self.q_table[s_next])
-        self.q_table[s][a_index] += self.lr * (reward + self.gamma * best_next - self.q_table[s][a_index])
-
-    def is_station_occupied(self, station, exclude_vehicle=None, occupancy_threshold=1.0):
-        # Bestimme den Zielpunkt der Station – falls über station_blue_dots verfügbar.
-        if hasattr(self, 'station_blue_dots') and station in self.station_blue_dots:
-            station_pos = self.station_blue_dots[station].getPos(self.render)
-        else:
-            station_pos = station.getPos(self.render)
-        for veh in self.garage_vehicles:
-            if veh == exclude_vehicle:
-                continue
-            # Falls das Fahrzeug an derselben Pickup-Station arbeitet…
-            current_order = veh.getPythonTag("current_order")
-            if current_order is not None and current_order.get("pickup_station") == station:
-                # …und sich im kritischen Zustand "drive_out" befindet, blockiere die Station.
-                if veh.getPythonTag("order_state") == "drive_out":
-                    return True
-            # Alternativ: Auch wenn ein Fahrzeug aufgrund seiner physischen Position zu nahe ist.
-            if (veh.getPos(self.render) - station_pos).length() < occupancy_threshold:
-                return True
-        return False
-
-
-if __name__ == "__main__":
-    # Wichtig: setze auf Windows die Startmethode auf "spawn"
-    multiprocessing.set_start_method('spawn')
-
-    # Erzeuge eine Queue, auch wenn sie später eventuell neu erstellt wird, wenn "G" gedrückt wird.
-    graph_q = Queue()
-    app = LagerSimulation(graph_q)
-    app.run()
-
-    # Beim Schließen der Simulation den Graphprozess ggf. beenden
-    if app.graph_process is not None:
-        app.graph_process.terminate()
-        app.graph_process.join()
\ No newline at end of file
Index: KI/KI6.py
===================================================================
diff --git a/KI/KI6.py b/KI/KI6.py
deleted file mode 100644
--- a/KI/KI6.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,291 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData,
-    GeomNode, GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode
-)
-# Globaler Clock über ClockObject
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.interval.IntervalGlobal import Sequence, Wait, LerpPosInterval, Func
-from direct.task import Task
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Fahrzeuggeschwindigkeit: 1.5 m/s * 5 = 7.5 m/s
-        self.speed = 1.5 * 5
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie (gleicher Abstand).
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            # Annahmestation links (rot) bei x = -9
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            # Abgabestation rechts (grün) bei x = 9
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeuge initialisieren – wir erzeugen zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}             # Dictionary: Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}   # Dictionary: Fahrzeug -> aktuelle Abgabestation (für drop_cargo)
-
-        # Fahrzeug 1
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-
-        # Fahrzeug 2 – leicht versetzt, damit die Modelle nicht exakt übereinander liegen.
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)  # y-Offset von 2 Einheiten
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-
-        # Dictionary für alle Pickup-Pakete:
-        # Schlüssel = Annahmestation, Wert = (Paket, Spawnzeit, Timer-TextNode)
-        self.pickup_packages = {}
-        # Dictionary für die letzte Entfernung (bzw. Initialisierung) pro Station
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = globalClock.getFrameTime()
-
-        # Starte einen Task, der regelmäßig prüft, ob an einer Annahmestation ein Paket fehlen soll.
-        self.taskMgr.doMethodLater(1, self.check_and_spawn_packages, "CheckSpawnPackages")
-        # Task zum Aktualisieren der angezeigten Timer (Wartezeit) auf den Paketen.
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-
-        # Starte für jedes Fahrzeug einen eigenen Lieferzyklus.
-        for v in self.vehicles:
-            self.start_delivery_cycle(v, v.getPos())
-
-    def check_and_spawn_packages(self, task):
-        """
-        Für jede Annahmestation wird geprüft, ob bereits ein Paket vorhanden ist.
-        Falls nicht, und wenn seit dem letzten Entfernen mindestens 5 Sekunden vergangen sind,
-        wird an dieser Station ein neues Paket erzeugt.
-        """
-        spawn_delay = 5  # 5 Sekunden Wartezeit pro Station
-        current_time = globalClock.getFrameTime()
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if current_time - self.last_removed.get(station, current_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.again
-
-    def spawn_package_at_station(self, station):
-        """
-        Erzeugt ein Paket (als Würfel) an der gegebenen Annahmestation.
-        Das Paket wird mit einem Z-Offset von +1 positioniert. Zusätzlich wird über dem Paket
-        ein TextNode angehängt, der später die Wartezeit anzeigt.
-        """
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = globalClock.getFrameTime()
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        """
-        Aktualisiert den Text (Wartezeit) aller wartenden Pakete.
-        """
-        current_time = globalClock.getFrameTime()
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = current_time - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        """
-        Ablauf für ein einzelnes Fahrzeug:
-          - Das Fahrzeug startet vom aktuellen Punkt (start_pos) und sucht sich aus
-            dem globalen Pickup-Pool **das Paket mit der höchsten Wartezeit**.
-          - Bevor das Fahrzeug diesen Auftrag übernimmt, prüfen beide Fahrzeuge, welches
-            Fahrzeug sich näher an der betreffenden Pickup-Station (mit dem längsten Timer)
-            befindet. Nur das Fahrzeug, das näher ist, übernimmt den Auftrag.
-          - Nachdem das Fahrzeug zur Pickup-Station gefahren ist, wird das Paket eingesammelt,
-            anschließend wird zufällig eine Abgabestation gewählt, zu der das Fahrzeug fährt.
-          - Dort wird das Paket auf den Würfel der Abgabestation gesetzt; nach 1 Sekunde
-            wird es entfernt.
-          - Der nächste Zyklus startet von der aktuellen Position (der Abgabestation) erneut.
-        """
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-
-        # Falls gerade keine Pakete existieren, kurze Wartephase und dann erneut versuchen.
-        if not self.pickup_packages:
-            self.taskMgr.doMethodLater(1,
-                                       lambda t: self.start_delivery_cycle(vehicle, vehicle.getPos()),
-                                       "RetryCycle_" + str(id(vehicle)))
-            return
-
-        current_time = globalClock.getFrameTime()
-        # Auswahl des Pickups mit höchster Wartezeit, also des Pakets mit niedrigster Spawnzeit.
-        target_station = min(self.pickup_packages, key=lambda s: self.pickup_packages[s][1])
-        # Berechne für jedes Fahrzeug die Distanz zur Zielstation.
-        distances = {v: (v.getPos() - target_station.getPos()).length() for v in self.vehicles}
-        closest_vehicle = min(distances, key=distances.get)
-        # Nur das Fahrzeug, das näher an der Station ist, übernimmt den Auftrag.
-        if vehicle != closest_vehicle:
-            self.taskMgr.doMethodLater(1,
-                                       lambda t: self.start_delivery_cycle(vehicle, vehicle.getPos()),
-                                       "RetryCycle_" + str(id(vehicle)))
-            return
-
-        pickup_station = target_station
-        pickup_pos = pickup_station.getPos()
-        seg1_duration = (pickup_pos - start_pos).length() / self.speed
-
-        # Zufällige Auswahl einer Abgabestation.
-        dropoff_station = random.choice(self.abgabe_stationen)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_pos = dropoff_station.getPos()
-        seg2_duration = (dropoff_pos - pickup_pos).length() / self.speed
-
-        cycle = Sequence(
-            LerpPosInterval(vehicle, duration=seg1_duration, pos=pickup_pos),
-            Func(self.pickup_package, vehicle, pickup_station),
-            LerpPosInterval(vehicle, duration=seg2_duration, pos=dropoff_pos),
-            Func(self.drop_cargo, vehicle),
-            Wait(1),
-            Func(self.remove_cargo, vehicle),
-            Func(self.start_delivery_cycle, vehicle, vehicle.getPos())
-        )
-        cycle.start()
-
-    def pickup_package(self, vehicle, station):
-        """
-        Das Fahrzeug nimmt an der gegebenen Annahmestation das wartende Paket auf.
-        Dabei wird der zugehörige Timer-Text entfernt, der Eintrag aus dem globalen Pool gelöscht
-        und der Zeitpunkt in last_removed aktualisiert.
-        """
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            # Aktualisiere den Zeitpunkt an der Station, an dem zuletzt ein Paket entfernt wurde.
-            self.last_removed[station] = globalClock.getFrameTime()
-
-    def drop_cargo(self, vehicle):
-        """
-        Setzt das vom Fahrzeug transportierte Paket exakt auf den Würfel der
-        (zufällig ausgewählten) Abgabestation (mit einem Z-Offset von +1).
-        """
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-
-    def remove_cargo(self, vehicle):
-        """
-        Entfernt das aktuell transportierte Paket des Fahrzeugs aus der Szene.
-        """
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-
-        # Horizontale Linien
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        # Vertikale Linien
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        """
-        Erzeugt ein Wireframe-Box-Modell als Station.
-        """
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        """
-        Erzeugt einen Würfel (als Paket), der etwas über dem Boden platziert wird.
-        """
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        """
-        Einfaches Beleuchtungssetup: Ambient- und Richtungslicht.
-        """
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-# Starte die Simulation
-app = LagerSimulation()
-app.run()
Index: Grundmodell/Gm28.py
===================================================================
diff --git a/Grundmodell/Gm28.py b/Grundmodell/Gm28.py
deleted file mode 100644
--- a/Grundmodell/Gm28.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,2039 +0,0 @@
-import random
-import math
-import tkinter as tk  # Für das extra Fenster der Auftragsübersicht
-from tkinter import ttk  # Für die tabellarische Darstellung (Treeview)
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-import matplotlib
-matplotlib.use("TkAgg")  # oder ein anderes geeignetes Backend
-import multiprocessing
-from multiprocessing import Queue, Process
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-import time
-import ctypes
-from PyQt5 import QtWidgets, QtCore
-import pyqtgraph as pg
-from direct.gui.DirectGui import DirectButton
-
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-from direct.task.TaskManagerGlobal import taskMgr
-from functools import partial
-
-class LagerSimulation(ShowBase):
-    def __init__(self, graph_queue=None):
-        super().__init__()
-        self.paused = False
-        # Pause-Knopf neben dem Slider platzieren – z.B. rechts davon.
-        self.pause_button = DirectButton(
-            text="Pause",
-            command=self.toggle_pause,
-            pos=(-0.5, 0, -0.85),  # Leicht links vom Slider
-            scale=0.07
-        )
-
-        # Speichere die Queue als Attribut
-        self.graph_process = None  # Hier wird der Graphing-Prozess gespeichert.
-        self.graph_queue = None  # Die Queue für den Datenaustausch.
-
-        self.tk_root = tk.Tk()
-        self.tk_root.withdraw()
-
-        self.taskMgr.add(self._tk_update, "tkUpdateTask")
-        self.taskMgr.add(self.update_delivery_timers, "UpdateDeliveryTimersTask")
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5  # Wird in update_vehicle genutzt
-        self.state_timer = 0.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Kennzahlen für Lieferzeiten
-        self.total_delivery_time = 0.0
-        self.total_delivery_count = 0
-        self.max_overall_delivery_time = 0.0
-
-        # Paketspawning an den Annahmestationen:
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-        # Fahrzeug-spezifische Zuordnung: Fahrzeug -> transportiertes Paket
-        self.cargos = {}
-
-        # NEU: Initialisiere die belegten Annahmestationen
-        self.occupied_pickups = set()  # Oder: [] für eine Liste
-
-        # Graph-Daten (Sim-Zeit, Pakete pro Minute, durchschnittliche Liegedauer)
-        self.graph_data = []
-        self.graph_opened = False
-
-        # Auftragsverwaltung: Speichere alle Aufträge (für die Anzeige) sowie in
-        # einer Queue (Liste) zur sequentiellen Abarbeitung.
-        self.orders = {}
-        self.orders_queue = []
-        self.next_order_id = 1
-
-        # Tkinter-Fenster für Auftragsübersicht
-        self.order_win = None
-        self.order_tree = None
-
-        # Umgebung initialisieren
-        self.draw_origin()
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.create_wall()
-        self.create_annahme_stations()
-        self.create_abgabe_stations()  # Hier wird auch self.abgabe_stations angelegt.
-        self.create_garagen_stations()
-
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # Fahrzeuge in den Garagen erstellen (genau 5 Fahrzeuge)
-        self.create_garage_vehicles()
-
-        # NEU: Testvariablen
-        self.first_vehicle_order_state = "idle"
-        self.attached_package = None
-        self.current_order = None  # wird durch Fahrzeuge individuell genutzt
-
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tastenzuordnungen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-        # Taste C öffnet das Fahrzeug-Kontrollfenster
-        self.accept("c", self.show_vehicle_control)
-
-        # Task-Manager
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClock")
-        # Task, der regelmäßig Graphdaten sendet
-        self.taskMgr.add(self.update_graph_data, "UpdateGraphDataTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        self.sim_clock += dt
-        return Task.cont
-
-    def toggle_pause(self):
-        if not self.paused:
-            # Speichern des aktuellen speed_factor, damit wir ihn beim Resume wiederherstellen können
-            self.previous_speed_factor = self.speed_factor
-            self.speed_factor = 0  # Simulation einfrieren: alle dt-basierte Updates ergeben 0
-            self.pause_button['text'] = "Weiter"
-            self.paused = True
-            print("Gesamte Simulation angehalten")
-        else:
-            # Wiederaufnahme der Simulation: speed_factor auf den vorherigen Wert zurücksetzen
-            self.speed_factor = self.previous_speed_factor if hasattr(self, 'previous_speed_factor') else 1.0
-            self.pause_button['text'] = "Pause"
-            self.paused = False
-            print("Simulation läuft wieder")
-
-    def open_graph(self):
-        # Starte den Graphprozess per Taste G (nur, wenn er noch nicht läuft)
-        if self.graph_process is None or not self.graph_process.is_alive():
-            from multiprocessing import Queue, Process
-            self.graph_queue = Queue()
-
-            # Sende alle bisher gesammelten Daten in die Queue:
-            for data in self.graph_data:
-                try:
-                    self.graph_queue.put(data, block=False)
-                except Exception:
-                    pass
-
-            from graph_pyqt import graph_process_pyqt
-            self.graph_process = Process(target=graph_process_pyqt, args=(self.graph_queue,))
-            self.graph_process.start()
-            print("Graphprozess gestartet.")
-        else:
-            print("Graphprozess läuft bereits.")
-
-    def update_graph_data(self, task):
-        if self.sim_clock > 0:
-            ppm = self.delivered_packages / (self.sim_clock / 60)
-        else:
-            ppm = 0.0
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        avg_delivery = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        new_data = (self.sim_clock, ppm, avg_dwell, avg_delivery)
-        # Speichere alle Daten ab Simulationsbeginn:
-        self.graph_data.append(new_data)
-
-        # Zusätzlich: Falls der Graphprozess aktiv ist, schicke den neuen Datensatz auch an die Queue
-        if self.graph_queue is not None:
-            try:
-                self.graph_queue.put(new_data, block=False)
-            except Exception:
-                pass
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-
-        # Bestimme die maximale Liegedauer aktueller Pakete an den Annahmestationen
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-
-        # Lieferzeit-Kennzahlen ermitteln: für Fahrzeuge, die aktuell ein Paket tragen
-        current_delivery_time = 0.0
-        for veh in self.garage_vehicles:
-            if veh.getPythonTag("package_attached"):
-                ds = veh.getPythonTag("delivery_start_time")
-                if ds:
-                    elapsed_delivery = self.sim_clock - ds
-                    current_delivery_time = max(current_delivery_time, elapsed_delivery)
-        avg_delivery_time = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        # Aktualisiere den Info-Label-Text
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s\n"
-            f"Lieferzeit (aktuell): {current_delivery_time:.1f}s\n"
-            f"Lieferzeit (maximal): {self.max_overall_delivery_time:.1f}s\n"
-            f"Durchschn. Lieferzeit: {avg_delivery_time:.1f}s"
-        )
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        # dt jetzt skaliert mit der Simulationsgeschwindigkeit
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    # ---------------------------
-    # METHODEN FÜR RASTER, LICHT, MAUER, URSPRUNG
-    # ---------------------------
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # STATIONSOBJEKTE UND ZUORDNUNG
-    # -----------------------------------
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        """
-        Erzeugt die Annahmestationen und erstellt für jede Station:
-          - Einen weißen Marker zur Orientierung
-          - Einen grünen Punkt (optional)
-          - Eine weiße Linie, an deren Endpunkt ein blauer Marker als Ziel in der "Translate‑Phase" dient
-
-        Zusätzlich wird ein Dictionary self.station_blue_dots aufgebaut, in dem jedem Annahmestations‑Node
-        der zugehörige blaue Marker zugeordnet wird. Außerdem wird für die erste Station die globale Variable
-        self.station_white_direction festgelegt.
-        """
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        self.station_blue_dots = {}
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basisstation (zum Beispiel als Rahmen)
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Erzeuge den weißen Marker als Orientierung
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Erzeuge den grünen Punkt (optional)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zeichne die weiße Linie: Sie beginnt bei center + Vec3(0, 0, -0.5) und verläuft 3 Meter in X‑Richtung.
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Erzeuge den blauen Marker, der als Ziel in der Translate‑Phase dient
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            # Speichere den blauen Marker im Dictionary, sodass er später erzeugt werden kann
-            self.station_blue_dots[station_dummy] = blue_dot
-
-            # Optionale Textanzeige der Stationsnummer
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) – falls benötigt:
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-            # Für die erste Station (oder den ersten relevanten Pickup) setzen wir globale Referenzen,
-            # die in vehicle_order_task benötigt werden.
-            if i == 1:
-                self.blue_dot = blue_dot
-                self.station_green_dot = green_dot
-                # Berechne den Mittelpunkt der weißen Linie als Referenz (optional)
-                self.white_line_center = (start_line + end_line) * 0.5
-                line_vec = end_line - start_line
-                if line_vec.length() != 0:
-                    self.station_white_direction = Vec2(line_vec.getX(), line_vec.getY()).normalized()
-                else:
-                    self.station_white_direction = Vec2(1, 0)  # Fallback-Wert
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        self.abgabe_stations = []  # Liste der Abgabestationen
-        self.abgabe_blue_dots = []  # Liste zum Speichern der blauen Marker für die Abgabe
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basiskonstruktion der Abgabestation
-            node = self.create_abgabe_station(pt)
-            self.abgabe_stations.append(node)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Marker am Zentrum (weiß)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Grüner Punkt: center + Vec3(0, 0, -0.5)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Weiße Linie: Startet bei center + Vec3(0, 0, -0.5)
-            # und verläuft 3 Meter in negativer X-Richtung
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt: wird an der Endposition der Linie erzeugt
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            # Speichere den blauen Marker für spätere Navigation der Abgabestation
-            self.abgabe_blue_dots.append(blue_dot)
-
-            # Anzeige der Stationsnummer (textuell)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) auf der Station
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 3)
-        v5 = pos + Vec3(1, 0, 3)
-        v6 = pos + Vec3(1, 2, 3)
-        v7 = pos + Vec3(0, 2, 3)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 3)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        self.garagen_stations = []
-        self.garagen_parking_points = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            self.garagen_stations.append(pt)
-            # ParkpunktGarage: Verschoben um 0.5 in negativer Y-Richtung:
-            center = pt + Vec3(0.5, 0.5, 1.5)
-            ParkpunktGarage = center + Vec3(0, 0, 0.7)
-            self.garagen_parking_points.append(ParkpunktGarage)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def create_garage_vehicles(self):
-        self.garage_vehicles = []
-        vehicle_id_counter = 1
-        for park in self.garagen_parking_points:
-            veh = self.create_vehicle(park_point=park)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            newPos.setZ(0)
-            veh.setPos(newPos)
-
-            # Fahrzeuge starten im Standby (idle)
-            veh.setPythonTag("current_order", None)
-            veh.setPythonTag("order_state", "idle")
-            veh.setPythonTag("package_attached", False)
-            veh.setPythonTag("vehicle_id", vehicle_id_counter)
-            # Speichere den Parkpunkt als Rückkehrziel
-            veh.setPythonTag("garage_target", park)
-            # Speichere auch das Anfangs-Heading, um es später beim Parken wiederherzustellen.
-            veh.setPythonTag("start_heading", veh.getH())
-            vehicle_id_counter += 1
-
-            self.garage_vehicles.append(veh)
-
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-            # Füge einen Textknoten hinzu, der die Fahrzeugnummer vorne auf dem Fahrzeug anzeigt.
-            # Wir suchen den Mast-Knoten.
-            mast = veh.find("**/mast")
-            if not mast.isEmpty():
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)  # Schwarz
-                tn.setAlign(TextNode.ACenter)
-                text_np = mast.attachNewNode(tn)
-                # Positioniere den Text relativ zum Mast: Wir nutzen den Vektor "intersection"
-                # und versetzen ihn in Z-Richtung um 0.2 Einheiten oberhalb des Zylinders.
-                text_np.setPos(intersection.x, intersection.y, intersection.z + 0.2)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-            else:
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)
-                tn.setAlign(TextNode.ACenter)
-                text_np = veh.attachNewNode(tn)
-                text_np.setPos(0, 1.2, 1.5)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-
-            self.taskMgr.add(partial(self.vehicle_order_task, veh),
-                             f"VehicleOrderTask_{veh.getPythonTag('vehicle_id')}")
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # FAHRZEUGERSTELLUNG (FFZ20-INTEGRATION)
-    # -----------------------------------
-    def create_vehicle(self, park_point=None):
-        # Erzeuge den übergeordneten Fahrzeug-Knoten
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # --------------------------
-        # Chassis erstellen (1 x 0.5 x 1.2, Farbe Rot)
-        # --------------------------
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # --------------------------
-        # Gabel (Fork) erstellen: Zwei Zähne
-        # --------------------------
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-
-        # Speichere den Gabel-Knoten als Python-Tag am Fahrzeug
-        vehicle_node.setPythonTag("fork_node", fork_node)
-
-        # --------------------------
-        # Erzeuge den grünen Referenzmarker (für die Gabel)
-        # --------------------------
-        ls_new = LineSegs()
-        ls_new.setThickness(2.0)
-        ls_new.setColor(1, 1, 1, 1)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_corner_global = fork_node.getPos() + left_corner_local
-        right_corner_global = fork_node.getPos() + right_corner_local
-        ls_new.moveTo(left_corner_global)
-        ls_new.drawTo(right_corner_global)
-        vehicle_node.attachNewNode(ls_new.create())
-        midpoint = (left_corner_global + right_corner_global) * 0.5
-        white_line_vec = right_corner_global - left_corner_global
-        white_line_dir = white_line_vec.normalized() if white_line_vec.length() != 0 else Vec3(0, 0, 0)
-        candidate = Vec3(-white_line_dir.getY(), white_line_dir.getX(), 0)
-        perp_direction = candidate.normalized() if candidate.length() != 0 else Vec3(0, 0, 0)
-        green_point_global = midpoint + perp_direction * 0.5
-
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        vehicle_node.setPythonTag("fork_green", green_marker_np)
-
-        # --------------------------
-        # Mast und weitere Fahrzeugteile
-        # --------------------------
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-        self.add_diagonals_to_mast(mast_node)
-
-        # Setze einen Schnittpunkt (Intersection) – dieser wird als Referenz genutzt.
-        intersection = Vec3(0.5, 0.05, 1.0)
-
-        # Jetzt – der wichtige Teil:
-        # Lidar-Kreis: Mittelpunkt soll 1 m in negativer Z-Richtung liegen (also Z = -1),
-        # Farbe Grün, Radius 2.
-        # Hier wird der Kreis am Mast (parent_node = mast_node) angehängt.
-        lidar_center = Vec3(intersection.x, intersection.y, -1)
-        self.add_lidar_circle(mast_node, lidar_center, 2)
-
-        # --------------------------
-        # Lenkachse erzeugen:
-        # Anstatt den Zylinder direkt bei (0.5, 0.05, 1.0) anzubringen,
-        # erstellen wir einen Pivot-Knoten (steering_axis) mit Z=0.
-        # --------------------------
-        steering_axis = mast_node.attachNewNode("steering_axis")
-        steering_axis.setPos(0.5, 0.05, -1.2)  # Global: 1.2 + (-1.2) = 0
-        steering_axis.setH(90)
-        vehicle_node.setPythonTag("steering_axis", steering_axis)
-
-        # Erzeuge den Zylinder, der die Lenkachse (auch als visuelles Element) darstellt
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(steering_axis)
-        cylinder_node.setPos(0, 0, 0)
-        self.vehicle_cylinder = steering_axis
-
-        # Hier fügen wir den Pfeil an der Lenkachse hinzu – er soll immer in die vorwärtsgerichtete (lokale X-) Richtung zeigen.
-        self.add_steering_arrow(steering_axis, color=(0, 1, 0, 1))
-        # --------------------------
-        # Fahrzeugpositionierung am Parkpunkt
-        # --------------------------
-        if park_point is None:
-            vehicle_node.setPos(0, 0, 0)
-        else:
-            intersection = Vec3(0.5, 0.05, 1.0)
-            vehicle_node.setPos(park_point - vehicle_node.getQuat().xform(intersection))
-        return vehicle_node
-
-    def add_steering_arrow(self, steering_axis, color=(0, 1, 0, 1)):
-        """
-        Erzeugt einen Pfeil, der die Vorwärtsrichtung (lokale X-Achse) des Lenkpivots anzeigt.
-        Der Pfeil wird als Kind des übergebenen steering_axis-Node angehängt und passt sich
-        automatisch dessen Rotation an.
-        """
-        arrow_ls = LineSegs()
-        arrow_ls.setThickness(2.0)
-        arrow_ls.setColor(*color)
-
-        # Zeichne eine Linie von (0,0,0) bis (2,0,0) – das ist die Basis des Pfeils
-        arrow_ls.moveTo(0, 0, 0)
-        arrow_ls.drawTo(2, 0, 0)
-
-        # Zeichne den Pfeilkopf: zwei kurze schräge Linien am Ende der Pfeillinie
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, 0.3, 0)
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, -0.3, 0)
-
-        arrow_np = steering_axis.attachNewNode(arrow_ls.create())
-        arrow_np.setPos(0, 0, 0)  # Falls nötig, hier noch zusätzlichen Offset anpassen
-        return arrow_np
-
-    def rotate_around_pivot(self, vehicle, pivot, delta_angle):
-        """
-        Dreht das Fahrzeug (vehicle) um den gegebenen Pivotpunkt (pivot) um delta_angle (in Grad).
-        Dabei wird die Position des Fahrzeugs neu berechnet, sodass es um den Pivot rotiert.
-        """
-        # Aktuelle globale Fahrzeugposition
-        pos = vehicle.getPos(self.render)
-        # Globaler Pivotpunkt
-        pivot_pos = pivot.getPos(self.render)
-        # Berechne den Vektor vom Pivot zum Fahrzeug
-        rel = pos - pivot_pos
-        # Wandle den Drehwinkel in Bogenmaß um
-        rad = math.radians(delta_angle)
-        cos_val = math.cos(rad)
-        sin_val = math.sin(rad)
-        # Drehe den relativen Vektor
-        new_x = rel.getX() * cos_val - rel.getY() * sin_val
-        new_y = rel.getX() * sin_val + rel.getY() * cos_val
-        new_rel = Vec3(new_x, new_y, rel.getZ())
-        # Neue globale Fahrzeugposition
-        new_pos = pivot_pos + new_rel
-        vehicle.setPos(new_pos)
-        # Aktualisiere auch das Heading des Fahrzeugs (aufaddieren des Drehwinkels)
-        vehicle.setH(vehicle.getH() + delta_angle)
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)  # Grün
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        return parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        # Verwende die simulative Zeit, die bereits in update_sim_clock hochgezählt wird
-        t = self.sim_clock
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    # -----------------------------------
-    # FEHLENDE METHODEN: Paketspawning, Würfelerzeugung u.a.
-    # -----------------------------------
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Bestimme zufällig eine Abgabestation als Ziel
-        if hasattr(self, "abgabe_stations") and self.abgabe_stations:
-            target_index = random.randint(1, len(self.abgabe_stations))
-        else:
-            target_index = 1
-
-        # Erstelle den Auftrag zur Annahmestation
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def update_order_table(self):
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen die Stationsnummer (oder verwende "N/A").
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z.B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige den zugewiesenen Fahrzeugnamen an (oder "-" falls noch keiner zugeordnet wurde).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END,
-                                   values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = 5.0  # 5 Sekunden Verzögerung zwischen Spawns
-        for station in self.annahme_stations:
-            # Wenn aktuell kein Paket an der Station ist
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                # Prüfe, ob seit der letzten Entnahme mindestens 5 Sekunden vergangen sind
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2, self.ax3) = plt.subplots(3, 1, figsize=(8, 9))
-
-        # Erster Plot: Pakete pro Minute
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-
-        # Zweiter Plot: Durchschnittliche Liegedauer
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-
-        # Dritter Plot: Durchschnittliche Lieferzeit
-        self.line3, = self.ax3.plot([], [], marker="o", color="green", label="Durchschnittliche Lieferzeit (s)")
-        self.ax3.set_xlabel("Simulationszeit (s)")
-        self.ax3.set_ylabel("Lieferzeit (s)")
-        self.ax3.set_title("Durchschnittliche Lieferzeit")
-        self.ax3.legend()
-        self.ax3.grid(True)
-
-        plt.show(block=False)
-        # Starte im Tkinter-Hauptloop eine periodische Aktualisierung:
-        self.tk_root.after(500, self.tk_graph_update)  # alle 500ms
-
-    def tk_graph_update(self):
-        # GIL sichern: Gibt einen Statuswert zurück, der später wieder freigegeben wird.
-        gil_state = ctypes.pythonapi.PyGILState_Ensure()
-        try:
-            times = [data[0] for data in self.graph_data]
-            rates = [data[1] for data in self.graph_data]
-            dwell = [data[2] for data in self.graph_data]
-            delivery = [data[3] for data in self.graph_data]
-
-            self.line1.set_data(times, rates)
-            self.ax1.relim()
-            self.ax1.autoscale_view()
-
-            self.line2.set_data(times, dwell)
-            self.ax2.relim()
-            self.ax2.autoscale_view()
-
-            self.line3.set_data(times, delivery)
-            self.ax3.relim()
-            self.ax3.autoscale_view()
-
-            self.fig.canvas.draw_idle()
-            self.fig.canvas.flush_events()
-        finally:
-            ctypes.pythonapi.PyGILState_Release(gil_state)
-
-        # Nächsten Aufruf in 500ms einplanen
-        self.tk_root.after(500, self.tk_graph_update)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Hier werden nur die gewünschten Spalten "ID", "Annahmestation", "Ziel" und "Fahrzeug" definiert.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    def pickup_package(self, vehicle, station):
-        # Falls das Fahrzeug bereits ein Paket trägt, abbrechen.
-        if vehicle.getPythonTag("package_attached"):
-            return
-
-        # Führe den Pickup nur aus, wenn an der Station ein Paket vorhanden ist.
-        if station in self.pickup_packages:
-            # Hole das Paket, den Spawn-Zeitpunkt und den zugehörigen Timer-Knoten.
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            # Entferne den Timer-Knoten, sodass der angezeigte Zähler nicht weiter aktualisiert wird.
-            timer_np.removeNode()
-            # Berechne die Liegedauer (Differenz zwischen aktueller Simulationszeit und Spawn-Zeit).
-            dwell_time = self.sim_clock - spawn_time
-            # Aktualisiere globale Kennzahlen.
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Suche in den Aufträgen nach dem Auftrag, dessen Paket mit diesem Paket übereinstimmt,
-            # und speichere den errechneten Endwert (fixe Liegedauer) sowie den Status.
-            for order_id, order in self.orders.items():
-                if order.get("package") == package:
-                    order["dwell_time"] = dwell_time
-                    order["status"] = "Abgeholt"
-                    break
-
-            # Hole Referenzen zum Gabel-Knoten und zum grünen Marker des Fahrzeugs.
-            fork_node = vehicle.getPythonTag("fork_node")
-            fork_green = vehicle.getPythonTag("fork_green")
-            green_point_pos = fork_green.getPos(fork_node)
-
-            # Übergib das Paket an den Gabel-Knoten (sodass es optisch dem Fahrzeug zugeordnet wird)
-            # und positioniere es relativ zum grünen Marker.
-            package.wrtReparentTo(fork_node)
-            package.setPos(green_point_pos.getX() + 0.5,
-                           green_point_pos.getY() - 0.5,
-                           green_point_pos.getZ() + 1)
-            self.cargos[vehicle] = package
-
-            # Starte den Lieferzeit-Timer: Speichere den Zeitpunkt, an dem das Paket abgeholt wurde,
-            # und hänge einen neuen Timer-Knoten an das Paket.
-            vehicle.setPythonTag("delivery_start_time", self.sim_clock)
-            from panda3d.core import TextNode
-            delivery_timer_text = TextNode("delivery_timer")
-            delivery_timer_text.setText("0.0s")
-            delivery_timer_np = package.attachNewNode(delivery_timer_text)
-            delivery_timer_np.setScale(0.5)
-            delivery_timer_np.setPos(0, 0, 1.2)
-            package.setPythonTag("delivery_timer", delivery_timer_np)
-
-            # Aktualisiere den Zeitpunkt, zu dem an dieser Station zuletzt ein Paket entfernt wurde.
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-
-            # Berechne Lieferzeit:
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start is not None:
-                delivery_time = self.sim_clock - delivery_start
-                self.total_delivery_time += delivery_time
-                self.total_delivery_count += 1
-                self.max_overall_delivery_time = max(self.max_overall_delivery_time, delivery_time)
-                vehicle.clearPythonTag("delivery_start_time")
-
-            # Entferne den Lieferzeit-Timer vom Paket
-            delivery_timer_np = cargo.getPythonTag("delivery_timer")
-            if delivery_timer_np:
-                delivery_timer_np.removeNode()
-
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden das Paket entfernt
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def update_delivery_timers(self, task):
-        for vehicle, package in list(self.cargos.items()):
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start:
-                elapsed_delivery = self.sim_clock - delivery_start
-                delivery_timer_np = package.getPythonTag("delivery_timer")
-                if delivery_timer_np and not delivery_timer_np.isEmpty():
-                    delivery_timer_np.node().setText(f"{elapsed_delivery:.1f}s")
-        return Task.cont
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-
-    def select_next_order(self, vehicle):
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        for order in waiting_orders:
-            dwell_time = self.sim_clock - order.get("spawn_time", self.sim_clock)
-            order["dwell_time"] = dwell_time
-
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        vehicle_pos = vehicle.getPos(self.render)
-
-        def distance_to_station(order):
-            station = order.get("pickup_station")
-            if station:
-                station_pos = station.getPos(self.render)
-                return (station_pos - vehicle_pos).length()
-            return float('inf')
-
-        candidates.sort(key=distance_to_station)
-        chosen_order = candidates[0]
-        chosen_order["vehicle"] = f"Fahrzeug {vehicle.getPythonTag('vehicle_id')}"
-        return chosen_order
-
-    # Diese Methode simuliert einen einfachen Lidar-Scan, indem sie alle anderen Fahrzeuge betrachtet.
-    # Liegt ein Fahrzeug näher als sensor_range, wird ein repulsiver Vektor zurückgegeben.
-    def compute_avoidance_vector(self, vehicle, sensor_range=5.0):
-        """
-        Berechnet den repulsiven Vektor zur Kollisionsvermeidung,
-        allerdings **nur** für Fahrzeuge, die eine höhere Priorität haben als das aktuelle Fahrzeug.
-
-        Parameters:
-          vehicle: Das aktuelle Fahrzeug (NodePath), für das der Vektor berechnet wird.
-          sensor_range: Maximaler Abstand, in dem Fahrzeuge als Hindernisse gelten.
-
-        Returns:
-          Ein Vec2, der den zusätzlichen Ausweichvektor enthält (kann auch 0 sein).
-        """
-        avoidance = Vec2(0, 0)
-        current_pos = vehicle.getPos(self.render)
-        # Hole den eigenen Prioritätswert; Standard ist 1 (niedrigste Priorität)
-        my_priority = vehicle.getPythonTag("priority") if vehicle.hasPythonTag("priority") else 1
-
-        for other in self.garage_vehicles:
-            if other == vehicle:
-                continue
-            # Hole den Prioritätswert des anderen Fahrzeugs
-            other_priority = other.getPythonTag("priority") if other.hasPythonTag("priority") else 1
-            # Nur wenn das andere Fahrzeug eine höhere Priorität hat, sollte unser Fahrzeug ausweichen.
-            if other_priority > my_priority:
-                other_pos = other.getPos(self.render)
-                diff = Vec2(current_pos.getX() - other_pos.getX(),
-                            current_pos.getY() - other_pos.getY())
-                dist = diff.length()
-                if dist < sensor_range and dist > 0.001:
-                    weight = (sensor_range - dist) / sensor_range
-                    # Addiere den repulsiven Vektor – hier ohne zusätzliche Symmetrie, also faktor = 1.0
-                    avoidance += diff.normalized() * weight
-            else:
-                # Bei gleicher oder niedriger Priorität: kein Abstoßungseffekt
-                continue
-
-        return avoidance
-
-    def compute_priority_multiplier(self, vehicle, sensor_range=5.0):
-        """
-        Liefert 1.0, wenn das Fahrzeug Vorrang hat und normal fahren darf,
-        oder 0.0, wenn ein anderes Fahrzeug mit höherem Rang in Nähe ist.
-
-        Die Phasenpriorität ist wie folgt definiert:
-           "to_delivery"       → 4 (höchste)
-           "translate"         → 3
-           "phase11"           → 2
-           "return_to_garage"  → 1 (niedrigste)
-
-        Liegt ein anderes Fahrzeug im sensor_range, so überprüfe, ob
-        dessen Rang höher ist oder – bei Gleichem Rang – ob dessen Abstand zum Ziel
-        geringer ist als der eigene. Falls ja, wird 0.0 zurückgegeben.
-        """
-        phase_priority = {
-            "to_delivery": 4,
-            "translate": 3,
-            "phase11": 2,
-            "return_to_garage": 1
-        }
-        my_state = vehicle.getPythonTag("order_state")
-        my_rank = phase_priority.get(my_state, 0)
-        my_pos = vehicle.getPos(self.render)
-
-        # Hilfsfunktion: Bestimme das jeweilige Ziel des Fahrzeugs
-        def get_target(v):
-            order = v.getPythonTag("current_order")
-            state = v.getPythonTag("order_state")
-            if order is None:
-                return None
-            if state == "to_delivery" or state == "phase11":
-                # Ziel aus Abgabestation
-                target_str = order.get("ziel", "Abgabestation 1")
-                try:
-                    idx = int(target_str.split()[-1])
-                except ValueError:
-                    idx = 1
-                if 0 <= idx - 1 < len(self.abgabe_blue_dots):
-                    return self.abgabe_blue_dots[idx - 1].getPos(self.render)
-                else:
-                    return self.abgabe_blue_dots[0].getPos(self.render)
-            elif state == "translate":
-                pickup = order.get("pickup_station")
-                if pickup in self.station_blue_dots:
-                    return self.station_blue_dots[pickup].getPos(self.render)
-                else:
-                    return self.blue_dot.getPos(self.render)
-            elif state == "return_to_garage":
-                return v.getPythonTag("garage_target")
-            return None
-
-        my_target = get_target(vehicle)
-        my_distance = (my_pos - my_target).length() if my_target is not None else float('inf')
-
-        # Prüfe alle andere Fahrzeuge im Lidar-Bereich:
-        for other in self.garage_vehicles:
-            if other == vehicle:
-                continue
-            other_pos = other.getPos(self.render)
-            if (my_pos - other_pos).length() > sensor_range:
-                continue
-            other_state = other.getPythonTag("order_state")
-            other_rank = phase_priority.get(other_state, 0)
-            # Falls ein anderes Fahrzeug in einer höheren Phase ist, muss ich anhalten.
-            if other_rank > my_rank:
-                return 0.0
-            # Falls beide in derselben Phase sind, vergleiche die Distanzen zum jeweiligen Ziel.
-            if other_rank == my_rank:
-                other_target = get_target(other)
-                other_distance = (
-                            other.getPos(self.render) - other_target).length() if other_target is not None else float(
-                    'inf')
-                if other_distance < my_distance:
-                    return 0.0
-        return 1.0
-
-    # ---------------------------------------------------------------------------
-    # Fahrzeugsteuerung: Ursprüngliche Zustandsmaschine, erweitert um Kollisionsvermeidung
-    # in den Phasen translate, to_delivery, phase11 und return_to_garage.
-    def vehicle_order_task(self, vehicle, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        state = vehicle.getPythonTag("order_state")
-        current_order = vehicle.getPythonTag("current_order")
-
-        # Annahme: dt, state, current_order, current_pos, pivot (im Fall von Drehungen) etc. sind bereits berechnet.
-        # Außerdem gehen wir davon aus, dass new_heading_rad bereits aus der Drehlogik berechnet wurde.
-
-        if state == "translate":
-            # Falls noch kein Auftrag vorhanden, versuche einen zuzuweisen.
-            if current_order is None:
-                next_order = self.select_next_order(vehicle)
-                if next_order is not None:
-                    vehicle.setPythonTag("current_order", next_order)
-                    next_order["status"] = "In Bearbeitung"
-                    print(f"Auftrag {next_order['id']} wird Fahrzeug {vehicle.getPythonTag('vehicle_id')} zugewiesen.")
-                else:
-                    print("Kein Auftrag verfügbar – Fallback zum globalen Ziel.")
-                current_order = vehicle.getPythonTag("current_order")
-
-            # Ziel: Pickup-Station über den blauen Marker.
-            if current_order is not None:
-                pickup_station = current_order.get("pickup_station")
-                if pickup_station in self.station_blue_dots:
-                    target = self.station_blue_dots[pickup_station].getPos(self.render)
-                else:
-                    target = self.blue_dot.getPos(self.render)
-            else:
-                target = self.blue_dot.getPos(self.render)
-
-            current_pos = vehicle.getPos(self.render)
-            pivot = vehicle.getPythonTag("steering_axis")
-            global_hpr = pivot.getNetTransform().getHpr()
-            global_heading = global_hpr.getX()
-            current_heading_rad = math.radians(global_heading)
-
-            desired_heading_rad = math.atan2(target.getY() - current_pos.getY(), target.getX() - current_pos.getX())
-            heading_error = desired_heading_rad - current_heading_rad
-            while heading_error > math.pi:
-                heading_error -= 2 * math.pi
-            while heading_error < -math.pi:
-                heading_error += 2 * math.pi
-
-            gain = 1.0
-            max_delta = gain * dt
-            delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-            delta_heading_deg = math.degrees(delta_heading_rad)
-
-            self.rotate_around_pivot(vehicle, pivot, delta_heading_deg)
-
-            global_hpr = pivot.getNetTransform().getHpr()
-            new_global_heading = global_hpr.getX()
-            new_heading_rad = math.radians(new_global_heading)
-            base_speed = 1.5
-            multiplier = self.compute_priority_multiplier(vehicle, sensor_range=5.0)
-            effective_speed = base_speed * multiplier
-
-            new_x = current_pos.getX() + effective_speed * math.cos(new_heading_rad) * dt
-            new_y = current_pos.getY() + effective_speed * math.sin(new_heading_rad) * dt
-            new_pos = Vec3(new_x, new_y, 0)
-            vehicle.setPos(new_pos)
-
-            distance_to_target = math.sqrt(
-                (target.getX() - new_pos.getX()) ** 2 + (target.getY() - new_pos.getY()) ** 2)
-            if distance_to_target < 0.1:
-                vehicle.setPos(target)
-                vehicle.setPythonTag("order_state", "rotate")
-
-
-        # ------------------ Phase 2: Rotate ------------------
-        elif state == "rotate":
-            desired_angle = math.degrees(math.atan2(self.station_white_direction.getY(),
-                                                    self.station_white_direction.getX()))
-            desired_angle = (desired_angle + 180) % 360
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_angle - current_heading + 180) % 360) - 180
-            kp_heading = 0.5
-            new_heading = current_heading + kp_heading * angle_diff
-            vehicle.setH(new_heading)
-            if abs(angle_diff) < 1.0:
-                vehicle.setPythonTag("order_state", "turn_right")
-
-        # ------------------ Phase 3: Turn Right ------------------
-        elif state == "turn_right":
-            if vehicle.getPythonTag("turn_right_init") is None:
-                vehicle.setPythonTag("turn_right_init", vehicle.getH() % 360)
-                vehicle.setPythonTag("turn_right_target", (vehicle.getPythonTag("turn_right_init") + 90) % 360)
-                print("Phase 3: Initialisiert für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "Start Heading =", vehicle.getPythonTag("turn_right_init"),
-                      "Target Heading =", vehicle.getPythonTag("turn_right_target"))
-            current_heading = vehicle.getH() % 360
-            turn_right_target = vehicle.getPythonTag("turn_right_target")
-            angle_diff = ((turn_right_target - current_heading + 180) % 360) - 180
-            kp_turn = 0.5
-            turn_rate = kp_turn * angle_diff
-            new_heading = current_heading + turn_rate * dt
-            vehicle.setH(new_heading)
-            print("Phase 3: Fahrzeug", vehicle.getPythonTag("vehicle_id"), "- Aktuelles Heading =", current_heading,
-                  "Winkelabweichung =", angle_diff, "Neues Heading =", new_heading)
-            if abs(angle_diff) < 1.0:
-                print("Phase 3: Drehung abgeschlossen für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      ". Übergang in 'approach'.")
-                vehicle.setPythonTag("order_state", "approach")
-                vehicle.clearPythonTag("turn_right_init")
-                vehicle.clearPythonTag("turn_right_target")
-
-        # ------------------ Phase 4: Approach ------------------
-        elif state == "approach":
-            if current_order is not None:
-                pickup_station = current_order.get("pickup_station")
-                target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-            else:
-                target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-            current = vehicle.getPos(self.render)
-            error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-            if error_vec.length() > 0.05:
-                direction = error_vec.normalized()
-                move_distance = 1.5 * dt
-                new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                               current.getY() + direction.getY() * move_distance, target.getZ())
-                vehicle.setPos(new_pos)
-            else:
-                vehicle.setPos(target)
-                vehicle.setPythonTag("order_state", "pickup")
-
-        # ------------------ Phase 5: Pickup ------------------
-        elif state == "pickup":
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            target_z = 1.0
-            raise_speed = 0.5
-            if current_z < target_z:
-                fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-            else:
-                if current_order is None:
-                    if self.orders_queue:
-                        vehicle.setPythonTag("current_order", self.orders_queue.pop(0))
-                    else:
-                        print("Keine verfügbaren Aufträge für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                              ". Überspringe Pickup-Phase.")
-                        vehicle.setPythonTag("order_state", "drive_out")
-                        return task.cont
-                if not vehicle.getPythonTag("package_attached"):
-                    pickup_station = vehicle.getPythonTag("current_order")["pickup_station"]
-                    self.pickup_package(vehicle, pickup_station)
-                    vehicle.setPythonTag("package_attached", True)
-                if vehicle.getPythonTag("drive_out_target") is None:
-                    vehicle.setPythonTag("drive_out_target",
-                                         vehicle.getPos(self.render) + vehicle.getQuat(self.render).getForward() * 5.0)
-                vehicle.setPythonTag("order_state", "drive_out")
-
-        # ------------------ Phase 6: Drive Out ------------------
-        elif state == "drive_out":
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            if current_z > 0.0:
-                lower_speed = 0.5
-                fork_node.setZ(max(0.0, current_z - lower_speed * dt))
-            current_pos = vehicle.getPos(self.render)
-            drive_out_target = vehicle.getPythonTag("drive_out_target")
-            if drive_out_target is None:
-                drive_out_target = current_pos + vehicle.getQuat(self.render).getForward() * 5.0
-                vehicle.setPythonTag("drive_out_target", drive_out_target)
-            diff = drive_out_target - current_pos
-            if diff.length() > 0.1:
-                move_distance = 0.5 * dt
-                step = diff.normalized() * move_distance
-                new_pos = current_pos + step
-                new_pos.setZ(0)  # Fahrzeug bleibt am Boden
-                vehicle.setPos(new_pos)
-            else:
-                vehicle.setPythonTag("order_state", "to_delivery")
-                vehicle.setPythonTag("drive_out_target", None)
-
-        # --- Phase 7: To Delivery (Fahrt zur Abgabestation) ---
-        elif state == "to_delivery":
-            if current_order is None:
-                return Task.cont
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                target = self.abgabe_blue_dots[0].getPos(self.render)
-
-            current_pos = vehicle.getPos(self.render)
-            pivot = vehicle.getPythonTag("steering_axis")
-            global_hpr = pivot.getNetTransform().getHpr()
-            global_heading = global_hpr.getX()
-            current_heading_rad = math.radians(global_heading)
-
-            desired_heading_rad = math.atan2(target.getY() - current_pos.getY(), target.getX() - current_pos.getX())
-            heading_error = desired_heading_rad - current_heading_rad
-            while heading_error > math.pi:
-                heading_error -= 2 * math.pi
-            while heading_error < -math.pi:
-                heading_error += 2 * math.pi
-            gain = 1.0
-            max_delta = gain * dt
-            delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-            delta_heading_deg = math.degrees(delta_heading_rad)
-            self.rotate_around_pivot(vehicle, pivot, delta_heading_deg)
-
-            global_hpr = pivot.getNetTransform().getHpr()
-            new_global_heading = global_hpr.getX()
-            new_heading_rad = math.radians(new_global_heading)
-            base_speed = 1.5
-            multiplier = self.compute_priority_multiplier(vehicle, sensor_range=5.0)
-            effective_speed = base_speed * multiplier
-
-            new_x = current_pos.getX() + effective_speed * math.cos(new_heading_rad) * dt
-            new_y = current_pos.getY() + effective_speed * math.sin(new_heading_rad) * dt
-            new_pos = Vec3(new_x, new_y, 0)
-            vehicle.setPos(new_pos)
-
-            distance_to_target = math.sqrt(
-                (target.getX() - new_pos.getX()) ** 2 + (target.getY() - new_pos.getY()) ** 2)
-            if distance_to_target < 0.5:
-                print(
-                    f"Phase 7 abgeschlossen: Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den blauen Punkt erreicht.")
-                vehicle.setPythonTag("order_state", "align_delivery")
-
-
-        # ------------------ Phase 8: Align Delivery ------------------
-        elif state == "align_delivery":
-            desired_heading = 90.0
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_heading - current_heading + 180) % 360) - 180
-            print("Phase 8: Align Delivery | Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                  "Current Heading: {:.2f}°, Desired: {:.2f}°, Diff: {:.2f}°".format(current_heading, desired_heading,
-                                                                                     angle_diff))
-            fixed_turn_speed = 90.0
-            turn_amount = fixed_turn_speed * dt
-            if abs(angle_diff) < 1.0:
-                vehicle.setH(desired_heading)
-                print("Phase 8 abgeschlossen: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "ausgerichtet (Heading = {:.2f}°).".format(desired_heading))
-                vehicle.setPythonTag("order_state", "delivery_center")
-            else:
-                if angle_diff > 0:
-                    new_heading = current_heading + turn_amount
-                else:
-                    new_heading = current_heading - turn_amount
-                new_heading %= 360
-                vehicle.setH(new_heading)
-                print("Phase 8: Rotating - Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "New Heading set to {:.2f}°".format(new_heading))
-
-        # ------------------ Phase 9: Delivery Approach ------------------
-        elif state == "delivery_center":
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current = vehicle.getPos(self.render)
-            target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-            print("Phase 9: Zielpunkt der Abgabestation für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                  "=", target_point)
-            error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-            tolerance = 0.05
-            move_distance = 1.5 * dt
-            if error_vec.length() > tolerance:
-                direction = error_vec.normalized()
-                new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                               current.getY() + direction.getY() * move_distance, current.getZ())
-                vehicle.setPos(new_pos)
-                print("Phase 9: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "bewegt sich von", current, "nach", new_pos)
-            else:
-                vehicle.setPos(target_point)
-                print("Phase 9: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "hat den Zielpunkt erreicht.")
-                vehicle.setPythonTag("order_state", "drop")
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_fork_z = fork_node.getZ()
-            if current_fork_z < 1.0:
-                new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-                fork_node.setZ(new_fork_z)
-                print("Phase 9: Gabel wird angehoben für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "(Z =", new_fork_z, ").")
-
-        # ------------------ Phase 10: Dropoff ------------------
-        elif state == "drop":
-            if vehicle.getPythonTag("package_attached"):
-                delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-                self.drop_cargo(vehicle)
-                print("Phase 10: Paket abgesetzt für Fahrzeug", vehicle.getPythonTag("vehicle_id"))
-                vehicle.setPythonTag("package_attached", False)
-            else:
-                fork_node = vehicle.getPythonTag("fork_node")
-                current_z = fork_node.getZ()
-                if current_z > 0.0:
-                    lower_speed = 0.5
-                    new_z = max(0.0, current_z - lower_speed * dt)
-                    fork_node.setZ(new_z)
-                    print("Phase 10: Gabel wird abgesenkt für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                          ", aktueller Z-Wert =", new_z)
-                else:
-                    print("Phase 10: Dropoff vollständig abgeschlossen für Fahrzeug",
-                          vehicle.getPythonTag("vehicle_id"))
-                    if vehicle.getPythonTag("standby_pending"):
-                        vehicle.setPythonTag("order_state", "return_to_garage")
-                        print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} kehrt zur Garage zurück (Standby).")
-                    else:
-                        vehicle.setPythonTag("order_state", "translate")
-                    current_order["status"] = "Abgegeben"
-                    current_order["delivered_at"] = self.sim_clock
-                    vehicle.setPythonTag("current_order", None)
-
-        # --- Phase 11: Exit Station and Start Next Order ---
-        elif state == "phase11":
-            if vehicle.getPythonTag("last_delivery_marker") is not None:
-                target_point = vehicle.getPythonTag("last_delivery_marker")
-            else:
-                delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    target_point = self.abgabe_blue_dots[0].getPos(self.render)
-                print("Phase 11: Zielpunkt (blauer Marker) für Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "=", target_point)
-
-            current_pos = vehicle.getPos(self.render)
-            diff = target_point - current_pos
-            if diff.length() > 0.1:
-                base_speed = 0.5
-                multiplier = self.compute_priority_multiplier(vehicle, sensor_range=5.0)
-                effective_speed = base_speed * multiplier
-                step = diff.normalized() * effective_speed * dt
-                new_pos = current_pos + step
-                # Optional: Bei Bedarf kann hier auch Kollisionsvermeidung addiert werden.
-                vehicle.setPos(new_pos)
-                print("Phase 11: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "fährt aus der Station, neue Position =", new_pos)
-            else:
-                vehicle.setPos(target_point)
-                print("Phase 11: Fahrzeug", vehicle.getPythonTag("vehicle_id"),
-                      "hat den blauen Marker erreicht. Nächster Auftrag wird gestartet.")
-                vehicle.setPythonTag("order_state", "next_order")
-
-
-        # --- Return to Garage (Standby) ---
-        elif state == "return_to_garage":
-            garage_target = vehicle.getPythonTag("garage_target")
-            if garage_target is None:
-                garage_target = self.garagen_parking_points[0]
-            current_pos = vehicle.getPos(self.render)
-            diff = garage_target - current_pos
-            if diff.length() > 0.1:
-                base_speed = 1.0
-                multiplier = self.compute_priority_multiplier(vehicle, sensor_range=5.0)
-                effective_speed = base_speed * multiplier
-                new_pos = current_pos + diff.normalized() * effective_speed * dt
-                new_pos.setZ(0)
-                vehicle.setPos(new_pos)
-            else:
-                if vehicle.hasPythonTag("start_heading"):
-                    vehicle.setH(vehicle.getPythonTag("start_heading"))
-                vehicle.setPythonTag("order_state", "idle")
-                vehicle.setPythonTag("standby_pending", False)
-                print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} ist in der Garage (Standby).")
-
-    # Neue Methode: Kontrollfenster zur Fahrzeugsteuerung
-    def show_vehicle_control(self):
-        # Falls das Fenster bereits existiert, bringe es einfach in den Vordergrund,
-        # ohne die Radiobuttons neu zu initialisieren.
-        if hasattr(self, "control_win") and self.control_win.winfo_exists():
-            self.control_win.deiconify()
-            self.control_win.lift()
-            self.control_win.focus_force()
-            return
-
-        # Erstelle das Kontrollfenster als Toplevel des persistenten tk_root.
-        self.control_win = tk.Toplevel(self.tk_root)
-        self.control_win.title("Fahrzeugsteuerung")
-        # Beim Schließen soll das Fenster nicht zerstört, sondern nur versteckt werden
-        self.control_win.protocol("WM_DELETE_WINDOW", self.control_win.withdraw)
-        # Sorge dafür, dass das Fenster initial über allem liegt
-        self.control_win.attributes("-topmost", True)
-        self.control_win.after(100, lambda: self.control_win.attributes("-topmost", False))
-
-        # Erzeuge das Dictionary für die StringVar-Zuordnungen für die Fahrzeuge.
-        self.vehicle_state_vars = {}
-        row = 0
-        for veh in self.garage_vehicles:
-            frame = tk.Frame(self.control_win)
-            frame.grid(row=row, column=0, sticky="w", padx=5, pady=2)
-            vid = veh.getPythonTag("vehicle_id")
-            label = tk.Label(frame, text=f"Fahrzeug {vid}")
-            label.pack(side=tk.LEFT)
-            # Initialisiere die Radiobutton-Variable anhand des aktuellen Fahrzeugzustandes.
-            state = veh.getPythonTag("order_state")
-            if state is None:
-                state = "idle"
-            var = tk.StringVar(value=state)
-            self.vehicle_state_vars[veh] = var
-            rb_active = tk.Radiobutton(frame, text="Aufträge bearbeiten", variable=var, value="translate")
-            rb_active.pack(side=tk.LEFT)
-            rb_standby = tk.Radiobutton(frame, text="Standby", variable=var, value="idle")
-            rb_standby.pack(side=tk.LEFT)
-            row += 1
-        update_btn = tk.Button(self.control_win, text="Übernehmen", command=self.update_vehicle_control)
-        update_btn.grid(row=row, column=0, pady=5)
-
-    def update_vehicle_control(self):
-        for veh, var in self.vehicle_state_vars.items():
-            new_state = var.get()
-            if new_state == "idle" and veh.getPythonTag("current_order") is not None:
-                veh.setPythonTag("standby_pending", True)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Standby angefordert (Auftrag wird fortgesetzt).")
-            else:
-                veh.setPythonTag("standby_pending", False)
-                veh.setPythonTag("order_state", new_state)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Zustand auf {new_state} gesetzt.")
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-
-if __name__ == "__main__":
-    # Wichtig: setze auf Windows die Startmethode auf "spawn"
-    multiprocessing.set_start_method('spawn')
-
-    # Erzeuge eine Queue, auch wenn sie später eventuell neu erstellt wird, wenn "G" gedrückt wird.
-    graph_q = Queue()
-    app = LagerSimulation(graph_q)
-    app.run()
-
-    # Beim Schließen der Simulation den Graphprozess ggf. beenden
-    if app.graph_process is not None:
-        app.graph_process.terminate()
-        app.graph_process.join()
-
-
Index: Grundmodell/Gm5.py
===================================================================
diff --git a/Grundmodell/Gm5.py b/Grundmodell/Gm5.py
deleted file mode 100644
--- a/Grundmodell/Gm5.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,606 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Für das Paketspawning an den Annahmestationen
-        self.pickup_packages = {}  # station (NodePath) -> (Paket, Spawnzeit, Timer Node)
-        self.last_removed = {}  # station -> Zeitpunkt der letzten Entfernung
-
-        # Für Graph-Daten und Steuerung
-        self.graph_data = []  # Tupel: (Sim-Zeit, Pakete pro Minute, Durchschnittliche Liegedauer)
-        self.graph_opened = False
-
-        # Ursprung (Koordinatenachsen)
-        self.draw_origin()
-
-        # Kameraeinstellungen: Das ganze Feld soll gut sichtbar sein.
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # Licht und Bodenraster erzeugen
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-
-        # Erzeuge die Mauer (das umschließende Rechteck)
-        self.create_wall()
-
-        # Erzeuge Annahme-, Abgabe- und Garagenstationen
-        self.create_annahme_stations()
-        self.create_abgabe_stations()
-        self.create_garagen_stations()
-
-        # Setze ein Paket auf Annahmestation 1
-        self.spawn_package_at_station(self.annahme_stations[0])
-
-        # UI: Slider und Info-Anzeige zur Simulationssteuerung
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktion: Mit dem Mausrad hereinz- bzw. herauszoomen.
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        # Graph in extra Fenster per Taste "g" öffnen
-        self.accept("g", self.open_graph)
-
-        # Tasks: Aktualisierung der Simulationszeit, Info-Anzeige, Paketspawning, Paket-Timer und Graph-Daten
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-
-        # Bestimme aktuelle maximale Liegedauer aller wartenden Pakete
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        # X-Achse (rot)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        # Y-Achse (grün)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        # Z-Achse (blau)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # Original Funktion: Annahme-Station (ohne Z-Verschiebung)
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_annahme_station(pt)
-            # Dummy-Node als Referenz für das Paketspawning
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-            # Ursprünglicher Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Zusätzlicher grüner Punkt: 0.5 in positive Z-Richtung vom Mittelpunkt
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, 0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zusätzliche Linie: 3 Meter in positive X-Richtung vom grünen Punkt; Farbe weiß
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, 0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt am Ende der Linie
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            # Dekorative Kreuze hinzufügen
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-    # Original Funktion: Abgabestation (ohne Z-Verschiebung)
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_abgabe_station(pt)
-            # Ursprünglicher Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Zusätzlicher grüner Punkt: 0.5 in positive Z-Richtung vom Mittelpunkt
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, 0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zusätzliche Linie: 3 Meter in negative X-Richtung vom grünen Punkt; Farbe weiß
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, 0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt am Ende der Linie
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-            # Dekorative Kreuze hinzufügen
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 2)
-        v5 = pos + Vec3(1, 0, 2)
-        v6 = pos + Vec3(1, 2, 2)
-        v7 = pos + Vec3(0, 2, 2)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        # Dekorative Kreuze auf geschlossenen Seiten (nicht auf dem Dach)
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 2)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            center = pt + Vec3(0.5, 1, 1)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    # Methoden für Paketspawning und Timer
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        cube = self.loader.loadModel("models/box")
-        cube.setScale(1, 1, 1)
-        cube.setPos(x, y, z + 1)
-        cube.setColor(farbe)
-        cube.reparentTo(self.render)
-        return cube
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)  # 1 Sekunde Simulationszeit
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-    def update_package_timers(self, task):
-        # Diese Methode aktualisiert nur den angezeigten Timer
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            elapsed = self.sim_clock - spawn_time
-            timer_np.node().setText(f"{elapsed:.1f}s")
-            # Hinweis: Die automatische Entfernung des Pakets nach 5 Sekunden wurde entfernt.
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor != 0 else t
-
-    # Methoden für graphische Darstellung der Kennzahlen
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.setTitle("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.setTitle("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: TestFFZ/TestFFZ1.py
===================================================================
diff --git a/TestFFZ/TestFFZ1.py b/TestFFZ/TestFFZ1.py
deleted file mode 100644
--- a/TestFFZ/TestFFZ1.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,468 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs,
-    CardMaker
-)
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-# Globaler Clock
-globalClock = ClockObject.getGlobalClock()
-
-
-# =============================================================================
-# Klasse für die statische Oberfläche (Boden, Licht, Stationen, GUI usw.)
-# =============================================================================
-class SimulationSurface(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisparameter und Statistik
-        self.base_speed = 1.5
-        self.speed_factor = 1.0
-        self.sim_clock = 0.0
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-        self.sim_start_real = globalClock.getFrameTime()
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        # Umgebung und statische Elemente aufbauen
-        self.setup_environment()
-        self.setup_stations()
-        self.setup_UI()
-        self.setup_tasks()
-        self.setup_graph()
-
-        # Mausevents für Zoom
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-    def setup_environment(self):
-        self.erzeuge_licht()
-        self.boden = self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-    def setup_stations(self):
-        # Erzeuge eine Annahmestation (Pickup) bei X = -9 und eine Abgabestation (Drop) bei X = 9
-        self.pickup_station = self.erzeuge_gitterbox(-9, 0, 0, LColor(1, 0, 0, 1))
-        self.drop_station = self.erzeuge_gitterbox(9, 0, 0, LColor(0, 1, 0, 1))
-        # Zeichne Align-Punkte für bessere Orientierung
-        ls1 = LineSegs()
-        ls1.setThickness(3.0)
-        ls1.setColor(LColor(1, 1, 1, 1))
-        p1 = self.pickup_station.getPos()
-        ls1.moveTo(p1)
-        ls1.drawTo(p1 + Vec3(2, 0, 0))
-        self.render.attachNewNode(ls1.create())
-
-        ls2 = LineSegs()
-        ls2.setThickness(3.0)
-        ls2.setColor(LColor(1, 1, 1, 1))
-        p2 = self.drop_station.getPos()
-        ls2.moveTo(p2)
-        ls2.drawTo(p2 + Vec3(-2, 0, 0))
-        self.render.attachNewNode(ls2.create())
-
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-    def setup_UI(self):
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-    def setup_tasks(self):
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-
-    def setup_graph(self):
-        self.graph_opened = False
-        self.accept("g", self.open_graph)
-        self.graph_data = []  # Für die spätere Graph-Aktualisierung
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in [self.pickup_station, self.drop_station]:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            current_max = max(current_max, elapsed)
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        current_text = f"Liegedauer (aktuell): {current_max:.1f}s" if current_max > 0 else "Kein Paket"
-        maximal_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-        avg_val = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        delivered = self.delivered_packages
-        ppm = delivered / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\nAbgegebene Pakete: {delivered}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n{current_text}\n{maximal_text}\n"
-            f"Durchschn. Liegedauer: {avg_val:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.setTitle("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n = 0
-        mi = -center_extent - 0.5
-        ma = center_extent + 0.5
-        y = mi
-        while y <= ma:
-            writer.addData3(mi, y, 0)
-            writer.addData3(ma, y, 0)
-            lines.addVertices(n, n + 1)
-            n += 2
-            y += cell_size
-        x = mi
-        while x <= ma:
-            writer.addData3(x, mi, 0)
-            writer.addData3(x, ma, 0)
-            lines.addVertices(n, n + 1)
-            n += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        box = self.loader.loadModel("models/box")
-        box.setScale(1, 1, 1)
-        box.setPos(x, y, z)
-        box.setColor(farbe)
-        box.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        box.reparentTo(self.render)
-        return box
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        cube = self.loader.loadModel("models/box")
-        cube.setScale(1, 1, 1)
-        cube.setPos(x, y, z + 1)
-        cube.setColor(farbe)
-        cube.reparentTo(self.render)
-        return cube
-
-    def draw_coordinate_axes(self, axis_length=5):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), LColor(1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), LColor(0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), LColor(0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        curr = lens.getFov()[0]
-        new = max(10, curr - 5)
-        lens.setFov(new)
-        print(f"Zoom In: FOV von {curr} auf {new}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        curr = lens.getFov()[0]
-        new = min(100, curr + 5)
-        lens.setFov(new)
-        print(f"Zoom Out: FOV von {curr} auf {new}")
-
-
-# =============================================================================
-# Fahrzeuglogik mit integriertem Lidarsensor
-# =============================================================================
-class VehicleController:
-    def __init__(self, surface: SimulationSurface):
-        self.surface = surface
-        self.vehicles = []         # Liste der Fahrzeuge
-        self.cargos = {}           # Fahrzeug -> aktuelles Paket
-        self.current_dropoffs = {} # Fahrzeug -> ausgewählte Dropoff-Station
-        self.create_vehicles()
-
-    def create_vehicles(self):
-        roles = ["pickup_to_dropoff", "dropoff_to_pickup"]
-        start_positions = [self.surface.pickup_station.getPos(),
-                           self.surface.drop_station.getPos()]
-        for i in range(2):
-            vehicle = self.surface.loader.loadModel("models/box")
-            vehicle.setScale(1, 1, 0.5)
-            if i % 2 == 0:
-                vehicle.setColor(LColor(0, 0, 1, 1))
-            else:
-                vehicle.setColor(LColor(0, 0, 0.8, 1))
-            vehicle.setPos(start_positions[i])
-            vehicle.reparentTo(self.surface.render)
-            vehicle.setPythonTag("role", roles[i])
-            vehicle.setPythonTag("phase", "pickup")
-            self.add_center_marker(vehicle)
-            # Hinzufügen des Lidarsensors mit Offset (0.5, 0.5, 0)
-            self.attach_lidar_sensor(vehicle, offset=Vec3(0.5, 0.5, 0), radius=2.5)
-            self.vehicles.append(vehicle)
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        marker = self.surface.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def attach_lidar_sensor(self, vehicle, offset=Vec3(0.5, 0.5, 0), radius=2.5):
-        """
-        Fügt dem Fahrzeug einen visuellen Lidarsensor hinzu.
-        Der Sensor erscheint als Kreis in der XY-Ebene, dessen Mittelpunkt relativ
-        zum Fahrzeug bei `offset` liegt.
-        """
-        sensor_np = vehicle.attachNewNode("lidar_sensor")
-        sensor_np.setPos(offset)
-
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 1, 0, 1))  # Gelb zur Hervorhebung
-        segments = 64
-
-        ls.moveTo(radius * math.cos(0), radius * math.sin(0), 0)
-        for i in range(1, segments + 1):
-            angle = (2 * math.pi * i) / segments
-            x = radius * math.cos(angle)
-            y = radius * math.sin(angle)
-            ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        sensor_np.attachNewNode(circle_geom)
-
-    def get_source_target(self, vehicle):
-        role = vehicle.getPythonTag("role")
-        if role == "pickup_to_dropoff":
-            return self.surface.pickup_station, self.surface.drop_station
-        else:
-            return self.surface.drop_station, self.surface.pickup_station
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        def move_task(task):
-            dt = globalClock.getDt()
-            pos = vehicle.getPos()
-            to_target = target - pos
-            distance = to_target.length()
-            effective = self.surface.base_speed * self.surface.speed_factor
-            step = effective * dt
-            if distance <= step:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-            else:
-                vehicle.setPos(pos + to_target.normalized() * step)
-                return Task.cont
-
-        self.surface.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        vehicle.setPythonTag("job_start", self.surface.sim_clock)
-        vehicle.setPythonTag("phase", "pickup")
-        source, target = self.get_source_target(vehicle)
-        if source not in self.surface.pickup_packages:
-            self.surface.spawn_package_at_station(source)
-        self.move_vehicle_to(vehicle, source.getPos(),
-                             lambda: self.after_pickup(vehicle, source, target))
-
-    def after_pickup(self, vehicle, source, target):
-        self.pickup_package(vehicle, source)
-        vehicle.setPythonTag("phase", "deliver")
-        self.move_vehicle_to(vehicle, target.getPos(),
-                             lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        self.drop_cargo(vehicle)
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, source):
-        if source in self.surface.pickup_packages:
-            package, spawn_time, timer_np = self.surface.pickup_packages.pop(source)
-            timer_np.removeNode()
-            dwell = self.surface.sim_clock - spawn_time
-            self.surface.total_dwell_time += dwell
-            self.surface.picked_up_count += 1
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.surface.last_removed[source] = self.surface.sim_clock
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.surface.render)
-            _, target = self.get_source_target(vehicle)
-            targetPos = target.getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.surface.delivered_packages += 1
-
-    def remove_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-
-
-# =============================================================================
-# Hauptprogramm: Erzeuge Oberfläche und starte die Fahrzeuglogik
-# =============================================================================
-if __name__ == "__main__":
-    surface = SimulationSurface()
-    vehicle_controller = VehicleController(surface)
-    for vehicle in vehicle_controller.vehicles:
-        vehicle_controller.start_delivery_cycle(vehicle, vehicle.getPos())
-    surface.run()
Index: FFZ/FFZ11.py
===================================================================
diff --git a/FFZ/FFZ11.py b/FFZ/FFZ11.py
deleted file mode 100644
--- a/FFZ/FFZ11.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,393 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    LineSegs,
-    Vec3,
-    NodePath
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import math
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -30, 10)
-        self.cam.lookAt(0, 0, 0)
-
-        # Licht und Raster
-        self.setup_light()
-        self.create_grid(center_extent=10, cell_size=0.1)
-
-        # Fahrzeug erstellen und referenzieren
-        self.vehicle = self.create_vehicle()
-
-        # Slider für Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3)
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07)
-
-        # Slider zur Einstellung der Forkhöhe
-        self.fork_slider = DirectSlider(
-            range=(0.0, 1.0),
-            value=0.0,
-            pageSize=0.01,
-            command=self.update_fork_height,
-            pos=(-0.7, 0, -0.85),
-            scale=0.3)
-        self.fork_label = DirectLabel(
-            text="Fork Höhe: 0.00m",
-            pos=(-0.7, 0, -0.75),
-            scale=0.07)
-
-        # Laufzeitanzeige
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0))
-
-        # Zoom via Mausrad
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_cable, "UpdateCableTask")
-        # Das Fahrzeug bleibt stationär.
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_fork_height(self, height=0, *args):
-        try:
-            height = float(height)
-        except ValueError:
-            height = 0.0
-        self.fork_node.setZ(height)
-        self.fork_label['text'] = f"Fork Höhe: {height:.2f}m"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def create_grid(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            x += cell_size
-
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        grid_np = self.render.attachNewNode(node)
-        grid_np.setColor(0.7, 0.7, 0.7, 1)
-        return grid_np
-
-    def setup_light(self):
-        ambient_light = AmbientLight("ambient_light")
-        ambient_light.setColor((0.5, 0.5, 0.5, 1))
-        ambient_np = self.render.attachNewNode(ambient_light)
-        self.render.setLight(ambient_np)
-
-        directional_light = DirectionalLight("directional_light")
-        directional_light.setColor((1, 1, 1, 1))
-        directional_np = self.render.attachNewNode(directional_light)
-        directional_np.setPos(10, -10, 10)
-        self.render.setLight(directional_np)
-
-    def create_vehicle(self):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Fahrmodul (Chassis): 1 x 0.5 x 1.2, rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-
-        # Gabelmodul (Fork): zwei Zähne
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-        self.fork_node = fork_node
-
-        # Mast: Rahmen aus vier Balken (Top, Bottom, Left, Right)
-        mast_node = vehicle_node.attachNewNode("mast")
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-
-        # Diagonalen auf der oberen Fläche des Mastes
-        self.add_diagonals_to_mast(mast_node)
-        # Schnittpunkt der Diagonalen (in Mast-Koordinaten)
-        intersection = Vec3(0.5, 0.05, 1.0)
-
-        # Gelber Zylinder: Durchmesser 0.1, Höhe 0.1, Farbe Gelb (1,1,0,1)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        # Lidar-Kreis: Mittelpunkt auf z = -1 (1 in negativer Z-Richtung)
-        lidar_center = Vec3(intersection.x, intersection.y, -1)
-        self.add_lidar_circle(mast_node, lidar_center, 2)
-
-        vehicle_node.setPos(-0.5, 0, 0)
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)  # Orange
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)  # Grün
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        # Top center
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        # Top circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        # Bottom center
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        # Bottom circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        # Top fan
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        # Bottom fan
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        # Side faces
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        # Unterseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        # Oberseite
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        # Vorderseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        # Rückseite
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        # Linke Seite
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        # Rechte Seite
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def update_cable(self, task):
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        self.fork_label['text'] = f"Fork Höhe: {new_height:.2f}m"
-        return Task.cont
-
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: KI/KI23.py
===================================================================
diff --git a/KI/KI23.py b/KI/KI23.py
deleted file mode 100644
--- a/KI/KI23.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,475 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs
-)
-
-# Wir nutzen globalClock für dt.
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit
-        self.base_speed = 1.5
-        # Zeitskalierungsfaktor
-        self.speed_factor = 1.0
-        # Simulationszeitticker in simulierten Sekunden
-        self.sim_clock = 0.0
-        # Zähler der abgegebenen Pakete
-        self.delivered_packages = 0
-        # Speichert über die gesamte Simulation die maximal erreichte Liegedauer eines Paketes
-        self.max_overall_wait_time = 0.0
-
-        # Zeitpunkt des Simulationsstarts (reale Zeit)
-        self.sim_start_real = globalClock.getFrameTime()
-
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erstelle 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeuge initialisieren – zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}           # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {} # Fahrzeug -> aktuell reservierte Abgabestation
-
-        # Fahrzeug 1: startet sofort.
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-        # Markiere den Fahrzeugmittelpunkt (weißer Punkt) und füge den Lidar-Kreis als zusätzliche Visualisierung hinzu.
-        self.add_center_marker(vehicle1)
-        self.add_offset_circle(vehicle1, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Fahrzeug 2: startet 8 simulierte Sekunden später.
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)  # y-Offset von 2 Einheiten.
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-        self.add_center_marker(vehicle2)
-        self.add_offset_circle(vehicle2, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Globaler Pool für Pickup-Pakete und Zeitstempel (in simulierten Sekunden).
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider zur Anpassung des Zeitskalierungsfaktors.
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Info-Anzeige.
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tasks.
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_vehicle2_start, "CheckVehicle2StartTask")
-        # Task zur Aktualisierung der Lidar-Farbe und Kollisionsausweichlogik.
-        self.taskMgr.add(self.update_lidar_status, "UpdateLidarStatusTask")
-
-        # Starte Liefervorgänge.
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-        # Fahrzeug 2 startet, sobald 8 simulierte Sekunden erreicht sind (via Task).
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        """
-        Fügt dem Fahrzeug einen weißen Punkt als Markierung des Fahrzeugmittelpunkts hinzu.
-        """
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))  # Weiß.
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def add_offset_circle(self, vehicle, offset=Vec3(0.5, 0.5, 0.01),
-                          circle_radius=1.5, num_segments=32):
-        """
-        Zeichnet einen Kreis als Visualisierung der Lidar-Grenze des Fahrzeugs.
-        Der Kreis wird relativ zum Fahrzeug angehängt (als Kindknoten) und über
-        den angegebenen Offset positioniert. Der Kreis ist standardmäßig grün.
-        """
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))  # Standard: grün.
-        for i in range(num_segments + 1):
-            angle = 2 * math.pi * i / num_segments
-            x = circle_radius * math.cos(angle)
-            y = circle_radius * math.sin(angle)
-            if i == 0:
-                ls.moveTo(x, y, 0)
-            else:
-                ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        circle_np = vehicle.attachNewNode(circle_geom)
-        circle_np.setPos(offset)
-        # Speichern des Kreis-Knotens per PythonTag, damit wir ihn später modifizieren können.
-        vehicle.setPythonTag("lidar_circle", circle_np)
-
-    def update_lidar_status(self, task):
-        """
-        Aktualisiert die Lidar-Anzeige und berechnet eine zusätzliche Ausweichlogik.
-        Für jedes Fahrzeug:
-          - Wenn ein anderes Fahrzeug zu nahe kommt (Abstand < 3 m), so wird:
-              * Der Kreis rot gefärbt.
-              * Ein repulsiver Vektor berechnet, der in Richtung eines Ausweichmanövers zeigt.
-              * Ein individueller Geschwindigkeitsfaktor (hier 0.5) gesetzt, um das Fahrzeug abzubremsen.
-          - Andernfalls wird der Kreis grün, und es werden keine Eingriffe erzwungen.
-        """
-        sensor_threshold = 3.0  # 1.5 + 1.5, also Summe der Lidar-Radien.
-        for vehicle in self.vehicles:
-            if vehicle.hasPythonTag("lidar_circle"):
-                lidar_circle = vehicle.getPythonTag("lidar_circle")
-                pos = vehicle.getPos(self.render)
-                collision = False
-                avoidance_vec = Vec3(0, 0, 0)
-                for other in self.vehicles:
-                    if other is not vehicle:
-                        pos_other = other.getPos(self.render)
-                        diff = pos - pos_other
-                        distance = diff.length()
-                        if distance < sensor_threshold:
-                            collision = True
-                            if distance > 0:
-                                # Berechne einen repulsiven Vektor, der umso stärker ist, je näher das Fahrzeug kommt.
-                                avoidance_vec += diff.normalized() * (sensor_threshold - distance)
-                if collision:
-                    lidar_circle.setColor(LColor(1, 0, 0, 1))  # rot.
-                    vehicle.setPythonTag("avoidance", avoidance_vec)
-                    # Fahrzeug wird abgebremst.
-                    vehicle.setPythonTag("speed_multiplier", 0.5)
-                else:
-                    lidar_circle.setColor(LColor(0, 1, 0, 1))  # grün.
-                    vehicle.setPythonTag("avoidance", Vec3(0, 0, 0))
-                    vehicle.setPythonTag("speed_multiplier", 1.0)
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-
-        if current_max_wait_time > 0:
-            current_wait_text = f"Liegedauer (aktuell): {current_max_wait_time:.1f}s"
-        else:
-            current_wait_text = "Kein Paket an Annahmestation"
-
-        maximal_wait_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-
-        if self.sim_clock > 0:
-            delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0)
-        else:
-            delivered_per_minute = 0
-
-        self.info_label['text'] = (f"Laufzeit: {formatted_time}\n"
-                                   f"Abgegebene Pakete: {self.delivered_packages}\n"
-                                   f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-                                   f"{current_wait_text}\n"
-                                   f"{maximal_wait_text}")
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def check_vehicle2_start(self, task):
-        if self.sim_clock >= 8.0 and not hasattr(self, 'vehicle2_started'):
-            self.vehicle2_started = True
-            self.start_delivery_cycle(self.vehicles[1], self.vehicles[1].getPos())
-            return Task.done
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(
-            station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1)
-        )
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        """
-        Bewegt ein Fahrzeug schrittweise in Richtung des Zielpunkts.
-        Hier wird neben der direkten Zielerreichung (target) auch
-        der aktuell berechnete Ausweichvektor (falls vorhanden) berücksichtigt.
-        """
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            to_target = target - current_pos
-            distance = to_target.length()
-            # Hole den individuellen Geschwindigkeitsfaktor (Standard: 1.0)
-            multiplier = 1.0
-            if vehicle.hasPythonTag("speed_multiplier"):
-                multiplier = vehicle.getPythonTag("speed_multiplier")
-            effective_speed = self.base_speed * self.speed_factor * multiplier
-            step_distance = effective_speed * dt
-
-            # Wenn das Fahrzeug in diesem Schritt das Ziel erreicht, beende die Bewegung.
-            if distance <= step_distance:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-
-            # Hole den Ausweichvektor (falls vorhanden)
-            avoidance = Vec3(0, 0, 0)
-            if vehicle.hasPythonTag("avoidance"):
-                avoidance = vehicle.getPythonTag("avoidance")
-            # Kombiniere die Zielrichtung mit dem Ausweichvektor (wenn dieser signifikant ist)
-            if avoidance.length() > 0.001:
-                combined = to_target.normalized() + avoidance.normalized() * 0.5
-                combined.normalize()
-                new_direction = combined
-            else:
-                new_direction = to_target.normalized()
-            vehicle.setPos(current_pos + new_direction * step_distance)
-            return Task.cont
-
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        pickup_pos = pickup_station.getPos()
-
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.occupied_pickups.remove(pickup_station)
-            def wait_for_dropoff(task):
-                if any(ds not in self.occupied_dropoffs for ds in self.abgabe_stationen):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_for_dropoff, f"WaitDropoff_{id(vehicle)}")
-            return
-
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_pos = dropoff_station.getPos()
-
-        self.move_vehicle_to(vehicle, pickup_pos, lambda: self.after_pickup(vehicle, pickup_station, dropoff_pos))
-
-    def after_pickup(self, vehicle, pickup_station, dropoff_pos):
-        self.pickup_package(vehicle, pickup_station)
-        self.move_vehicle_to(vehicle, dropoff_pos, lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        self.drop_cargo(vehicle)
-        start_wait = self.sim_clock
-        def wait_task(task):
-            if self.sim_clock - start_wait >= self.sim_time(1):
-                self.finish_cycle(vehicle)
-                return Task.done
-            return Task.cont
-        self.taskMgr.add(wait_task, f"WaitAfterDrop_{id(vehicle)}")
-
-    def finish_cycle(self, vehicle):
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        if dropoff_station in self.occupied_dropoffs:
-            self.occupied_dropoffs.remove(dropoff_station)
-            del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
Index: FFZ/FFZ3.py
===================================================================
diff --git a/FFZ/FFZ3.py b/FFZ/FFZ3.py
deleted file mode 100644
--- a/FFZ/FFZ3.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,294 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    LineSegs  # Wird für den Rahmen verwendet
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte für Simulationszeit und -geschwindigkeit
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kameraeinstellungen: Wir positionieren die Kamera so, dass das Fahrzeug gut sichtbar ist.
-        # (Fahrtrichtung wird entlang der Y-Achse angenommen.)
-        self.cam.setPos(0, -30, 10)
-        self.cam.lookAt(0, 0, 0)
-
-        # Licht und Raster (Raster-Zellen: 0.1 x 0.1)
-        self.setup_light()
-        self.create_grid(center_extent=10, cell_size=0.1)
-
-        # Fahrzeug erstellen
-        self.create_vehicle()
-
-        # Slider zur Anpassung der Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Anzeige der Laufzeit
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktionalität: Mausrad heran-/herauszoomen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben zur Aktualisierung der Simulationszeit und Anzeige
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def create_grid(self, center_extent=40, cell_size=1):
-        """
-        Erstellt ein Raster in der XY-Ebene (Z=0 entspricht dem Boden)
-        mit der angegebenen Zellengröße.
-        """
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        # Horizontale Linien
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            y += cell_size
-
-        # Vertikale Linien
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            x += cell_size
-
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        grid_np = self.render.attachNewNode(node)
-        grid_np.setColor(0.7, 0.7, 0.7, 1)
-        return grid_np
-
-    def setup_light(self):
-        ambient_light = AmbientLight("ambient_light")
-        ambient_light.setColor((0.5, 0.5, 0.5, 1))
-        ambient_np = self.render.attachNewNode(ambient_light)
-        self.render.setLight(ambient_np)
-
-        directional_light = DirectionalLight("directional_light")
-        directional_light.setColor((1, 1, 1, 1))
-        directional_np = self.render.attachNewNode(directional_light)
-        directional_np.setPos(10, -10, 10)
-        self.render.setLight(directional_np)
-
-    def create_vehicle(self):
-        """
-        Erzeugt ein fahrerloses Transportfahrzeug als 3D-Modell,
-        bestehend aus drei lückenlos verbundenen Modulen:
-
-          • Fahrmodul (Chassis): Größe 1 x 0.5 x 1.2,
-            platziert von (0,0,0) bis (1,0.5,1.2).
-
-          • Gabelmodul (Fork): Größe 1 x 1.2 x 0.2,
-            wird hinten am Fahrmodul angesetzt.
-            (Das Modul wird so verschoben, dass die an das Fahrmodul anstoßende Seite
-             (global y = 0) nicht vom Rahmen überdeckt wird, sondern die freie Seite
-             (global y = -1.2) genutzt wird.)
-
-          • Mast: Größe 1 x 0.1 x 1,
-            sitzt oben auf dem Fahrmodul (beginnt bei z = 1.2) und wird in Y zentriert.
-        """
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Fahrmodul (Chassis) – Farbe: Rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)  # x: 0-1, y: 0-0.5, z: 0-1.2
-
-        # Gabelmodul (Fork) – Farbe: Grau, Höhe 0.2
-        box_fork = self.create_box(1, 1.2, 0.2, (0.3, 0.3, 0.3, 1))
-        node_fork = vehicle_node.attachNewNode(box_fork)
-        node_fork.setTwoSided(True)
-        node_fork.setPos(0, -1.2, 0)  # x: 0-1, y: -1.2 bis 0, z: 0-0.2
-
-        # Füge ein Rahmen-Rechteck (1x1) auf der oberen Fläche des Gabelmoduls hinzu.
-        self.add_rectangle_to_fork(node_fork)
-
-        # Mast – Farbe: Dunkles Grau (0.2, 0.2, 0.2, 1)
-        box_mast = self.create_box(1, 0.1, 1, (0.2, 0.2, 0.2, 1))
-        node_mast = vehicle_node.attachNewNode(box_mast)
-        node_mast.setTwoSided(True)
-        node_mast.setPos(0, 0.2, 1.2)  # x: 0-1, y: 0.2-0.3, z: 1.2-2.2
-
-        # Zentriere den gesamten Fahrzeugknoten in X
-        vehicle_node.setPos(-0.5, 0, 0)
-
-    def add_rectangle_to_fork(self, fork_node):
-        """
-        Fügt dem übergebenen Gabelmodul-Knoten ein Rahmen-Rechteck hinzu.
-        Es wird ein 1x1-Rahmen (ohne Füllung) mithilfe von LineSegs erzeugt,
-        der in lokalen XY-Koordinaten von (0,0) bis (1,1) liegt und auf der oberen
-        Fläche (z = 0.201) des Gabelmoduls positioniert wird.
-        """
-        ls = LineSegs()
-        ls.setThickness(2.0)  # Optional: Linienstärke
-        ls.setColor(1.0, 0.5, 0.0, 1)  # Orange
-
-        # Zeichne den Rahmen (Beginn bei (0,0), dann (1,0), (1,1), (0,1) und zurück zu (0,0))
-        ls.moveTo(0, 0, 0.201)
-        ls.drawTo(1, 0, 0.201)
-        ls.drawTo(1, 1, 0.201)
-        ls.drawTo(0, 1, 0.201)
-        ls.drawTo(0, 0, 0.201)
-
-        # Hänge den erstellten Linien-Node als Kind des Gabelmodul-Knotens an
-        fork_node.attachNewNode(ls.create())
-
-    def create_box(self, width, depth, height, color):
-        """
-        Erzeugt einen vollflächigen Quader (Box) mit den Dimensionen:
-          - Breite (X): width
-          - Tiefe (Y): depth
-          - Höhe (Z): height
-
-        Für jede Seite werden eigene Eckpunkte mit korrekten Normalen erzeugt,
-        sodass das Objekt wirklich solide wirkt.
-        """
-        format = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData('box', format, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, 'vertex')
-        normal = GeomVertexWriter(vdata, 'normal')
-        col = GeomVertexWriter(vdata, 'color')
-
-        # Unterseite (z = 0) mit Normal (0, 0, -1)
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-
-        # Oberseite (z = height) mit Normal (0, 0, 1)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-
-        # Vorderseite (y = 0) mit Normal (0, -1, 0)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-
-        # Rückseite (y = depth) mit Normal (0, 1, 0)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-
-        # Linke Seite (x = 0) mit Normal (-1, 0, 0)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-
-        # Rechte Seite (x = width) mit Normal (1, 0, 0)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        triangles = GeomTriangles(Geom.UHStatic)
-        # Jede Seite besteht aus 2 Dreiecken (insgesamt 12 Dreiecke)
-        for i in range(6):
-            base = i * 4
-            triangles.addVertices(base, base + 1, base + 2)
-            triangles.closePrimitive()
-            triangles.addVertices(base, base + 2, base + 3)
-            triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(triangles)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: KI/KI35.py
===================================================================
diff --git a/KI/KI35.py b/KI/KI35.py
deleted file mode 100644
--- a/KI/KI35.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,594 +0,0 @@
-import random
-import math
-import matplotlib.pyplot as plt  # Matplotlib zum Plotten importieren
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs,
-    CardMaker
-)
-
-# Wir nutzen globalClock für dt.
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit & Zeitskalierungsfaktor
-        self.base_speed = 1.5
-        self.speed_factor = 1.0
-
-        # Simulationszeitticker & Statistik
-        self.sim_clock = 0.0
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        self.sim_start_real = globalClock.getFrameTime()
-
-        # Kameraeinstellungen
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-        self.draw_coordinate_axes(axis_length=5)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Zeichne für jede Annahmestation den Align-Punkt (2 m in positive X-Richtung)
-        for station in self.annahme_stationen:
-            station_pos = station.getPos()
-            ls_pickup = LineSegs()
-            ls_pickup.setThickness(3.0)
-            ls_pickup.setColor(LColor(1, 1, 1, 1))
-            ls_pickup.moveTo(station_pos)
-            ls_pickup.drawTo(station_pos + Vec3(2, 0, 0))
-            self.render.attachNewNode(ls_pickup.create())
-
-        # Zeichne für jede Abgabestation den Align-Punkt (2 m in negative X-Richtung)
-        for station in self.abgabe_stationen:
-            station_pos = station.getPos()
-            ls_dropoff = LineSegs()
-            ls_dropoff.setThickness(3.0)
-            ls_dropoff.setColor(LColor(1, 1, 1, 1))
-            ls_dropoff.moveTo(station_pos)
-            ls_dropoff.drawTo(station_pos + Vec3(-2, 0, 0))
-            self.render.attachNewNode(ls_dropoff.create())
-
-        # --- Anfahrstationen (Startstationen) für die Fahrzeuge ---
-        # Diese Stationen sollen bei Y = 15 nebeneinander mit 4 Meter Abstand in X-Richtung liegen.
-        self.anfahrstationen = []
-        num_departure = 2  # Es sollen zu Beginn nur 2 Fahrzeuge genutzt werden.
-        spacing_departure = 4.0
-        start_x = -spacing_departure * (num_departure - 1) / 2
-        for i in range(num_departure):
-            pos = Vec3(start_x + i * spacing_departure, 15, 0)
-            station = self.erzeuge_gitterbox(pos.getX(), pos.getY(), pos.getZ(), LColor(0.8, 0.8, 0, 1))
-            self.anfahrstationen.append(station)
-
-        # Fahrzeuge erstellen, jeweils eines pro Anfahrstation (insgesamt 2 Fahrzeuge)
-        self.vehicles = []
-        self.cargos = {}              # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}    # Fahrzeug -> zugewiesene Dropoff-Station
-        for i, start_station in enumerate(self.anfahrstationen):
-            vehicle = self.loader.loadModel("models/box")
-            vehicle.setScale(1, 1, 0.5)
-            if i % 2 == 0:
-                vehicle.setColor(LColor(0, 0, 1, 1))
-            else:
-                vehicle.setColor(LColor(0, 0, 0.8, 1))
-            vehicle.setPos(start_station.getPos())
-            vehicle.reparentTo(self.render)
-            self.vehicles.append(vehicle)
-            # Beim Start eines neuen Auftrags ist die Phase "pickup"
-            vehicle.setPythonTag("phase", "pickup")
-            self.add_center_marker(vehicle)
-            self.add_offset_circle(vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Reste der Pick-up-/Drop-off-Logik
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Erfassung von Daten für Graphen (einmal pro Simulationssekunde)
-        self.graph_data = []
-        self.taskMgr.doMethodLater(1, self.record_graph_data, "RecordGraphDataTask")
-
-        # Graphen öffnen per Taste "G" (nach Schließen wieder möglich)
-        self.graph_opened = False
-        self.accept("g", self.open_graph)
-
-        # Zoom-Funktionalität: Mit Mausrad hereinz- bzw. herauszoomen
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_lidar_status, "UpdateLidarStatusTask")
-
-        # Liefervorgang starten (Pickup-Phase) für jedes Fahrzeug
-        for vehicle in self.vehicles:
-            self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def zoom_in(self):
-        # Hereinzoomen: Field-of-View (FOV) verkleinern (nicht unter 10°)
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        # Herauszoomen: FOV vergrößern (nicht über 100°)
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def record_graph_data(self, task):
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0
-        self.graph_data.append((self.sim_clock, delivered_per_minute, avg_dwell_time))
-        return Task.again
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def add_offset_circle(self, vehicle, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5, num_segments=32):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        for i in range(num_segments + 1):
-            angle = 2 * math.pi * i / num_segments
-            x = circle_radius * math.cos(angle)
-            y = circle_radius * math.sin(angle)
-            if i == 0:
-                ls.moveTo(x, y, 0)
-            else:
-                ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        circle_np = vehicle.attachNewNode(circle_geom)
-        circle_np.setPos(offset)
-        vehicle.setPythonTag("lidar_circle", circle_np)
-
-    def draw_coordinate_axes(self, axis_length=5):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(1, 0, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(axis_length, 0, 0)
-        ls.setColor(0, 1, 0, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, axis_length, 0)
-        ls.setColor(0, 0, 1, 1)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, axis_length)
-        axes = self.render.attachNewNode(ls.create())
-        for axis, pos, color, label in [
-            ("X", (axis_length, 0, 0), (1, 0, 0, 1), "X"),
-            ("Y", (0, axis_length, 0), (0, 1, 0, 1), "Y"),
-            ("Z", (0, 0, axis_length), (0, 0, 1, 1), "Z")
-        ]:
-            tn = TextNode(f"axis_{axis}")
-            tn.setText(label)
-            tn.setAlign(TextNode.ACenter)
-            np_label = self.render.attachNewNode(tn)
-            np_label.setScale(0.5)
-            np_label.setPos(pos[0], pos[1], pos[2])
-            np_label.setColor(color)
-        return axes
-
-    def update_lidar_status(self, task):
-        sensor_threshold = 3.0
-        for vehicle in self.vehicles:
-            pos = vehicle.getPos(self.render)
-            total_avoidance = Vec3(0, 0, 0)
-            multiplier = 1.0
-            phase = vehicle.getPythonTag("phase") if vehicle.hasPythonTag("phase") else "pickup"
-            for other in self.vehicles:
-                if other is vehicle:
-                    continue
-                pos_other = other.getPos(self.render)
-                diff = pos - pos_other
-                d = diff.length()
-                if d < sensor_threshold:
-                    other_phase = other.getPythonTag("phase") if other.hasPythonTag("phase") else "pickup"
-                    # Wenn ein Fahrzeug in der Pickup-Phase einem Fahrzeug in der Dropoff-Phase gegenübersteht:
-                    if phase == "pickup" and other_phase == "dropoff":
-                        candidate = 0.1
-                    # Wenn beide Fahrzeuge in der Dropoff-Phase sind, hat das Fahrzeug, das weiter von seiner Dropoff-Station entfernt ist, Vorrang:
-                    elif phase == "dropoff" and other_phase == "dropoff":
-                        # Hole die Ziel-Abgabestation, falls vorhanden:
-                        my_dropoff = self.current_dropoffs.get(vehicle)
-                        other_dropoff = self.current_dropoffs.get(other)
-                        if my_dropoff and other_dropoff:
-                            my_distance = (pos - my_dropoff.getPos()).length()
-                            other_distance = (pos_other - other_dropoff.getPos()).length()
-                            if my_distance > other_distance:
-                                candidate = 0.1
-                            else:
-                                candidate = 1.0
-                        else:
-                            candidate = 1.0
-                    else:
-                        # In allen anderen Fällen bleibt es bei Volldruck
-                        candidate = 1.0
-                    multiplier = min(multiplier, candidate)
-                    if d > 0:
-                        total_avoidance += diff.normalized() * (sensor_threshold - d)
-            vehicle.setPythonTag("speed_multiplier", multiplier)
-            vehicle.setPythonTag("avoidance", total_avoidance)
-            # Änderung der Farbe des Lidar-Kreises zur visuellen Rückmeldung:
-            if multiplier < 1.0 or total_avoidance.length() > 0.001:
-                vehicle.getPythonTag("lidar_circle").setColor(LColor(1, 0, 0, 1))
-            else:
-                vehicle.getPythonTag("lidar_circle").setColor(LColor(0, 1, 0, 1))
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-        current_wait_text = (
-            f"Liegedauer (aktuell): {current_max_wait_time:.1f}s"
-            if current_max_wait_time > 0 else "Kein Paket an Annahmestation"
-        )
-        maximal_wait_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-        avg_dwell_time = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted_time}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-            f"{current_wait_text}\n"
-            f"{maximal_wait_text}\n"
-            f"Liegedauer (Durchschnitt): {avg_dwell_time:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(
-            station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1)
-        )
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            to_target = target - current_pos
-            distance = to_target.length()
-            multiplier = vehicle.getPythonTag("speed_multiplier") if vehicle.hasPythonTag("speed_multiplier") else 1.0
-            effective_speed = self.base_speed * self.speed_factor * multiplier
-            step_distance = effective_speed * dt
-            if distance <= step_distance:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-            avoidance = vehicle.getPythonTag("avoidance") if vehicle.hasPythonTag("avoidance") else Vec3(0, 0, 0)
-            if avoidance.length() > 0.001:
-                combined = to_target.normalized() + avoidance.normalized() * 0.5
-                combined.normalize()
-                new_direction = combined
-            else:
-                new_direction = to_target.normalized()
-            vehicle.setPos(current_pos + new_direction * step_distance)
-            return Task.cont
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        # Beim Beginn eines neuen Auftrags: Phase auf "pickup" setzen und Startzeit speichern.
-        vehicle.setPythonTag("job_start", self.sim_clock)
-        vehicle.setPythonTag("phase", "pickup")
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        pickup_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        self.move_vehicle_to(vehicle, pickup_align,
-            lambda: self.move_vehicle_to(vehicle, pickup_station.getPos(),
-                lambda: self.after_pickup(vehicle, pickup_station)
-            )
-        )
-
-    def after_pickup(self, vehicle, pickup_station):
-        self.pickup_package(vehicle, pickup_station)
-        # Nach erfolgreichem Pickup: Phase auf "dropoff" setzen.
-        vehicle.setPythonTag("phase", "dropoff")
-        self.depart_from_pickup(vehicle, pickup_station,
-            lambda: self.start_dropoff_phase(vehicle)
-        )
-
-    def depart_from_pickup(self, vehicle, pickup_station, callback):
-        departure_align = pickup_station.getPos() + Vec3(2, 0, 0)
-        departure_target = pickup_station.getPos() + Vec3(4, 0, 0)
-        self.move_vehicle_to(vehicle, departure_align,
-            lambda: self.move_vehicle_to(vehicle, departure_target, callback)
-        )
-
-    def start_dropoff_phase(self, vehicle):
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.start_dropoff_phase(vehicle)
-            return
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-        self.move_vehicle_to(vehicle, dropoff_align,
-            lambda: self.move_vehicle_to(vehicle, dropoff_station.getPos(),
-                lambda: self.after_dropoff(vehicle)
-            )
-        )
-
-    def after_dropoff(self, vehicle):
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        self.drop_cargo(vehicle)
-        self.remove_cargo(vehicle, remove_dropoff=True)
-        if dropoff_station is not None:
-            departure_align = dropoff_station.getPos() + Vec3(-2, 0, 0)
-            departure_target = dropoff_station.getPos() + Vec3(-4, 0, 0)
-            self.move_vehicle_to(vehicle, departure_align,
-                lambda: self.move_vehicle_to(vehicle, departure_target,
-                    lambda: self.start_delivery_cycle(vehicle, departure_target)
-                )
-            )
-        else:
-            self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle, remove_dropoff=True):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        if remove_dropoff:
-            dropoff_station = self.current_dropoffs.get(vehicle)
-            if dropoff_station in self.occupied_dropoffs:
-                self.occupied_dropoffs.remove(dropoff_station)
-            if vehicle in self.current_dropoffs:
-                del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices+1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices+1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z+1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
Index: FFZ/FFZ13.py
===================================================================
diff --git a/FFZ/FFZ13.py b/FFZ/FFZ13.py
deleted file mode 100644
--- a/FFZ/FFZ13.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,443 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    LineSegs,
-    Vec3,
-    NodePath
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import math
-
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Kameraeinstellungen (Fahrtrichtung: entlang Y-Achse)
-        self.cam.setPos(0, -30, 10)
-        self.cam.lookAt(0, 0, 0)
-
-        # Licht und Raster erstellen
-        self.setup_light()
-        self.create_grid(center_extent=10, cell_size=0.1)
-
-        # Fahrzeug (inklusive Chassis, Fork, Mast etc.) erstellen
-        self.vehicle = self.create_vehicle()
-
-        # Slider für Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Slider zur Einstellung der Forkhöhe (0 bis 1 Meter)
-        self.fork_slider = DirectSlider(
-            range=(0.0, 1.0),
-            value=0.0,
-            pageSize=0.01,
-            command=self.update_fork_height,
-            pos=(-0.7, 0, -0.85),
-            scale=0.3
-        )
-        self.fork_label = DirectLabel(
-            text="Fork Höhe: 0.00m",
-            pos=(-0.7, 0, -0.75),
-            scale=0.07
-        )
-
-        # Laufzeitanzeige
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom via Mausrad
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben hinzufügen (hier bleibt das Fahrzeug stationär, Fork wird animiert)
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_cable, "UpdateCableTask")
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def update_fork_height(self, height=0, *args):
-        try:
-            height = float(height)
-        except ValueError:
-            height = 0.0
-        self.fork_node.setZ(height)
-        self.fork_label['text'] = f"Fork Höhe: {height:.2f}m"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def create_grid(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            y += cell_size
-
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            lines.closePrimitive()
-            n_vertices += 2
-            x += cell_size
-
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        grid_np = self.render.attachNewNode(node)
-        grid_np.setColor(0.7, 0.7, 0.7, 1)
-        return grid_np
-
-    def setup_light(self):
-        ambient_light = AmbientLight("ambient_light")
-        ambient_light.setColor((0.5, 0.5, 0.5, 1))
-        ambient_np = self.render.attachNewNode(ambient_light)
-        self.render.setLight(ambient_np)
-
-        directional_light = DirectionalLight("directional_light")
-        directional_light.setColor((1, 1, 1, 1))
-        directional_np = self.render.attachNewNode(directional_light)
-        directional_np.setPos(10, -10, 10)
-        self.render.setLight(directional_np)
-
-    def create_vehicle(self):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Fahrmodul (Chassis): 1 x 0.5 x 1.2 in Rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        # Schwarze Kanten für das Chassis
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # Gabelmodul (Fork): Zwei Zähne (je 0.2 x 1.2 x 0.1)
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-        self.fork_node = fork_node
-
-        # Mast: Rahmen aus vier Balken
-        mast_node = vehicle_node.attachNewNode("mast")
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-
-        # Diagonalen auf der oberen Fläche des Mastes
-        self.add_diagonals_to_mast(mast_node)
-        # Definierter Schnittpunkt der Diagonalen in Mast-Koordinaten
-        intersection = Vec3(0.5, 0.05, 1.0)
-
-        # Gelber Zylinder: Durchmesser 0.1, Höhe 0.1, Farbe Gelb
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        # Lidar-Kreis: Mittelpunkt soll 1 m in negativer Z-Richtung liegen, d.h. auf Z=-1.
-        lidar_center = Vec3(intersection.x, intersection.y, -1)
-        self.add_lidar_circle(mast_node, lidar_center, 2)
-
-        # Setze den Fahrzeugknoten so, dass sein Ursprung (bottom des Fahrzeugs) auf der Ebene liegt
-        # und seine X- und Y-Koordinaten denen des projizierten Schnittpunkts der Diagonalen entsprechen.
-        # Wir nehmen an, dass die Projektion des Schnittpunkts (global) – wenn vehicle_node ursprünglich bei (0,0,0)
-        # läge – den Wert (0.5, 0.25, 2.2) hätte.
-        # Damit der Fahrzeugknoten auf der Ebene liegt (Z=0) und horizontal auf den Schnittpunktsprojektion,
-        # setzen wir:
-        vehicle_node.setPos(0.5 - 0.5, 0.25 - 0.25, 0)
-        # Das entspricht einfach: vehicle_node.setPos(0, 0, 0)
-        # Aufgrund unserer bisherigen Konstruktion, bei der die relativen Offsets des Mastes
-        # (0,0.2,1.2) und des Schnittpunkts (0.5,0.05,1.0) zusammen (0.5,0.25,2.2)
-        # ergeben, heißt dies: Vorgabe:
-        # global_intersection = vehicle_node + (0.5, 0.25, 2.2)
-        # Wir möchten aber, dass die xy-Koordinaten des globalen Schnittpunkts dem Fahrzeugknoten entsprechen,
-        # und das Fahrzeug unten auf der Ebene sitzt. Am einfachsten ist, vehicle_node.setPos(0,0,0) zu verwenden.
-        # (Anpassungen können hier vorgenommen werden, falls andere Referenzpunkte gewünscht sind.)
-        vehicle_node.setPos(0, 0, 0)
-
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)  # Orange
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)  # Grün
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        # Top center
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        # Top circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        # Bottom center
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        # Bottom circumference
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        # Top fan
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        # Bottom fan
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        # Side faces
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        # Unterseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        # Oberseite
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        # Vorderseite
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        # Rückseite
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        # Linke Seite
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        # Rechte Seite
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base+1, base+2)
-            tris.closePrimitive()
-            tris.addVertices(base, base+2, base+3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        # Unterkante
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        # Oberkante
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        # Vertikale Kanten
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        self.fork_label['text'] = f"Fork Höhe: {new_height:.2f}m"
-        return Task.cont
-
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
Index: Grundmodell/Gm16.py
===================================================================
diff --git a/Grundmodell/Gm16.py b/Grundmodell/Gm16.py
deleted file mode 100644
--- a/Grundmodell/Gm16.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,1450 +0,0 @@
-import random
-import math
-import tkinter as tk  # Für das extra Fenster der Auftragsübersicht
-from tkinter import ttk  # Für die tabellarische Darstellung (Treeview)
-import matplotlib.pyplot as plt  # Für interaktive Graphen
-
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-from direct.task.TaskManagerGlobal import taskMgr
-
-
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basis-Simulationsvariablen
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5  # Wird in update_vehicle genutzt
-        self.state_timer = 0.0
-
-        # Kennzahlen (KPIs)
-        self.delivered_packages = 0
-        self.max_overall_wait_time = 0.0
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Paketspawning an den Annahmestationen:
-        # Mapping: station (Dummy-Node) -> (Paket, Spawnzeit, Timer Node)
-        self.pickup_packages = {}
-        self.last_removed = {}
-
-        # Neues Attribut: Verknüpfung Fahrzeug -> transportiertes Paket
-        self.cargos = {}
-
-        # NEU: Initialisiere die belegten Annahmestationen
-        self.occupied_pickups = set()  # Oder: [] für eine Liste
-
-        # Graph-Daten (Sim-Zeit, Pakete pro Minute, durchschnittliche Liegedauer)
-        self.graph_data = []
-        self.graph_opened = False
-
-        # Auftragsverwaltung: Speichere alle Aufträge (für die Anzeige) sowie in
-        # einer Queue (Liste) zur sequentiellen Abarbeitung.
-        self.orders = {}         # Für die Anzeige
-        self.orders_queue = []   # Für die Fahrzeugabwicklung (FIFO)
-        self.next_order_id = 1
-
-        # Tkinter-Fenster für Auftragsübersicht
-        self.order_win = None
-        self.order_tree = None
-
-        # Umgebung initialisieren
-        self.draw_origin()
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.create_wall()
-        self.create_annahme_stations()
-        self.create_abgabe_stations()  # Hier wird auch self.abgabe_stations angelegt.
-        self.create_garagen_stations()
-
-        for station in self.annahme_stations:
-            self.spawn_package_at_station(station)
-
-        # Fahrzeuge in den Garagen erstellen (genau 5 Fahrzeuge)
-        self.create_garage_vehicles()
-
-        # NEU: Auftragssystem für das Testfahrzeug initialisieren
-        # Zustände: "idle", "to_pickup", "wait_pickup", "to_delivery", "deliver"
-        self.first_vehicle_order_state = "idle"
-        self.attached_package = None
-        self.current_order = None  # Der aktuell abgearbeitete Auftrag
-        self.taskMgr.add(self.vehicle_order_task, "VehicleOrderTask")
-
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-        self.taskMgr.doMethodLater(1, self.update_graph_data, "UpdateGraphDataTask")
-
-    # ---------------------------
-    # SIMULATION UND UI-METHODEN
-    # ---------------------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s"
-        )
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    # ---------------------------
-    # METHODEN FÜR RASTER, LICHT, MAUER, URSPRUNG
-    # ---------------------------
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3f(min_line, y, 0)
-            writer.addData3f(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3f(x, min_line, 0)
-            writer.addData3f(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-        d = seg_vector.normalized()
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def draw_origin(self):
-        ls = LineSegs()
-        ls.setThickness(2)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # STATIONSOBJEKTE UND ZUORDNUNG
-    # -----------------------------------
-    def create_annahme_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        # Beispielhafte Station-Punkte (siehe dein ursprünglicher Code)
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        self.annahme_stations = []
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basisstation (zum Beispiel Rahmen)
-            self.create_annahme_station(pt)
-            station_dummy = self.render.attachNewNode(f"annahme_station_{i}")
-            station_dummy.setPos(pt)
-            self.annahme_stations.append(station_dummy)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Erzeuge den Marker (großer weißer Punkt) als Orientierung
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Erzeuge den grünen Punkt an der Station (als optionaler Punkt)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Zeichne die weiße Linie an der Station.
-            # Die Linie beginnt bei: center + Vec3(0,0,-0.5) und verläuft 3 Meter in X-Richtung.
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            white_line_node = self.render.attachNewNode(line_seg.create())
-
-            # Speichere den Node der weißen Linie global
-            self.white_line = white_line_node
-
-            # Berechne den Mittelpunkt der weißen Linie
-            self.white_line_center = (start_line + end_line) * 0.5
-
-            # Berechne die Richtung der weißen Linie (als 2D-Vektor, normalisiert)
-            line_vec = end_line - start_line
-            self.station_white_direction = Vec2(line_vec.getX(), line_vec.getY()).normalized()
-
-            # Erzeuge den blauen Punkt – dieser dient als Ziel in Phase 1.
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-
-            # Speichere global relevante Punkte für die erste Station
-            if i == 1:
-                self.blue_dot = blue_dot
-                self.station_green_dot = green_dot
-
-            # (Optional) Textanzeige der Stationsnummer:
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) – falls benötigt:
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(0, 1, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 1, 0, 1))
-
-    def create_abgabe_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v1)
-        ls.drawTo(v2)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        self.abgabe_stations = []  # Liste der Abgabestationen
-        self.abgabe_blue_dots = []  # Liste zum Speichern der blauen Marker für die Abgabe
-
-        for i, pt in enumerate(station_points, start=1):
-            # Erstelle die Basiskonstruktion der Abgabestation
-            node = self.create_abgabe_station(pt)
-            self.abgabe_stations.append(node)
-
-            # Berechne den Mittelpunkt der Station
-            center = pt + Vec3(0.5, 0.5, 0.5)
-
-            # Marker am Zentrum (weiß)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-
-            # Grüner Punkt: center + Vec3(0, 0, -0.5)
-            green_dot = self.loader.loadModel("models/misc/sphere")
-            green_dot.setScale(0.1)
-            green_dot.setColor(LColor(0, 1, 0, 1))
-            green_dot.setPos(center + Vec3(0, 0, -0.5))
-            green_dot.reparentTo(self.render)
-
-            # Weiße Linie: Startet bei center + Vec3(0, 0, -0.5)
-            # und verläuft 3 Meter in negativer X-Richtung
-            line_seg = LineSegs()
-            line_seg.setThickness(2.0)
-            line_seg.setColor(LColor(1, 1, 1, 1))
-            start_line = center + Vec3(0, 0, -0.5)
-            end_line = start_line + Vec3(-3, 0, 0)
-            line_seg.moveTo(start_line)
-            line_seg.drawTo(end_line)
-            self.render.attachNewNode(line_seg.create())
-
-            # Blauer Punkt: wird an der Endposition der Linie erzeugt
-            blue_dot = self.loader.loadModel("models/misc/sphere")
-            blue_dot.setScale(0.1)
-            blue_dot.setColor(LColor(0, 0, 1, 1))
-            blue_dot.setPos(end_line)
-            blue_dot.reparentTo(self.render)
-            # Speichere den blauen Marker für spätere Navigation der Abgabestation
-            self.abgabe_blue_dots.append(blue_dot)
-
-            # Anzeige der Stationsnummer (textuell)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-            # Zusätzliche Markierungen (Kreuze) auf der Station
-            v0 = pt + Vec3(0, 0, 0)
-            v1 = pt + Vec3(1, 0, 0)
-            v2 = pt + Vec3(1, 1, 0)
-            v3 = pt + Vec3(0, 1, 0)
-            v4 = pt + Vec3(0, 0, 1)
-            v5 = pt + Vec3(1, 0, 1)
-            v6 = pt + Vec3(1, 1, 1)
-            v7 = pt + Vec3(0, 1, 1)
-            self.add_cross_on_face([v1, v2, v6, v5], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v0, v1, v5, v4], color=LColor(1, 0, 0, 1))
-            self.add_cross_on_face([v3, v2, v6, v7], color=LColor(1, 0, 0, 1))
-
-    def create_garage_station(self, pos):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 0, 1, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 2, 0)
-        v3 = pos + Vec3(0, 2, 0)
-        v4 = pos + Vec3(0, 0, 3)
-        v5 = pos + Vec3(1, 0, 3)
-        v6 = pos + Vec3(1, 2, 3)
-        v7 = pos + Vec3(0, 2, 3)
-        edges = [
-            (v0, v1), (v1, v2), (v2, v3), (v3, v0),
-            (v4, v5), (v5, v6), (v6, v7), (v7, v4),
-            (v0, v4), (v1, v5), (v2, v6), (v3, v7)
-        ]
-        for p, q in edges:
-            if p.getY() == pos.getY() and q.getY() == pos.getY():
-                continue
-            ls.moveTo(p)
-            ls.drawTo(q)
-        node = self.render.attachNewNode(ls.create())
-        self.add_cross_on_face([v3, v2, v6, v7], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v0, v3, v7, v4], color=LColor(0, 0, 1, 1))
-        self.add_cross_on_face([v1, v2, v6, v5], color=LColor(0, 0, 1, 1))
-        return node
-
-    def add_garage_roof(self, pos):
-        cm = CardMaker("garage_roof")
-        cm.setFrame(0, 1, 0, 2)
-        roof = self.render.attachNewNode(cm.generate())
-        roof.setHpr(0, -90, 0)
-        roof.setPos(pos.x, pos.y, pos.z + 3)
-        roof.setColor(LColor(0, 0, 1, 1))
-        return roof
-
-    def create_garagen_stations(self):
-        station_points = [
-            Vec3(3, 58, 0), Vec3(7, 58, 0), Vec3(11, 58, 0),
-            Vec3(15, 58, 0), Vec3(19, 58, 0)
-        ]
-        self.garagen_stations = []
-        self.garagen_parking_points = []
-        for i, pt in enumerate(station_points, start=1):
-            self.create_garage_station(pt)
-            self.add_garage_roof(pt)
-            self.garagen_stations.append(pt)
-            # ParkpunktGarage: Verschoben um 0.5 in negativer Y-Richtung:
-            center = pt + Vec3(0.5, 0.5, 1.5)
-            ParkpunktGarage = center + Vec3(0, 0, 0.7)
-            self.garagen_parking_points.append(ParkpunktGarage)
-            tn = TextNode("garage_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 0.5, pt.y - 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def create_garage_vehicles(self):
-        """
-        Erzeugt nur das erste Fahrzeug in der Simulation.
-
-        Ursprünglich wurde für jeden Garagen-Parkpunkt ein Fahrzeug erstellt.
-        Mit dieser Anpassung wird nur das Fahrzeug am ersten Parkpunkt erzeugt,
-        alle weiteren Fahrzeuge werden nicht erzeugt.
-        """
-        self.garage_vehicles = []
-        if self.garagen_parking_points:
-            park = self.garagen_parking_points[0]  # Nur der erste Parkpunkt wird verwendet.
-            veh = self.create_vehicle(park_point=None)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            # Statt newPos.setZ(0.1) setzen wir den Z-Wert als Offset zum berechneten Wert:
-            newPos.setZ(newPos.getZ() + 0.1)
-            veh.setPos(newPos)
-            self.garage_vehicles.append(veh)
-
-            # Erzeuge Fahrzeugmarker
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-    def add_cross_on_face(self, corners, color=LColor(1, 1, 1, 1), thickness=1.5):
-        ls = LineSegs()
-        ls.setThickness(thickness)
-        ls.setColor(color)
-        ls.moveTo(corners[0])
-        ls.drawTo(corners[2])
-        ls.moveTo(corners[1])
-        ls.drawTo(corners[3])
-        return self.render.attachNewNode(ls.create())
-
-    # -----------------------------------
-    # FAHRZEUGERSTELLUNG (FFZ20-INTEGRATION)
-    # -----------------------------------
-    def create_vehicle(self, park_point=None):
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # Chassis: 1 x 0.5 x 1.2, Farbe Rot
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # Fork (Gabel): Zwei Zähne
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        node_left.setPos(0, 0, 0)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-        self.fork_node = fork_node
-
-        # Berechne den Mittelpunkt der Gabel (mittels der linken und rechten Eckpunkte)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_corner_global = fork_node.getPos() + left_corner_local
-        right_corner_global = fork_node.getPos() + right_corner_local
-
-        ls_new = LineSegs()
-        ls_new.setThickness(2.0)
-        ls_new.setColor(1, 1, 1, 1)
-        ls_new.moveTo(left_corner_global)
-        ls_new.drawTo(right_corner_global)
-        vehicle_node.attachNewNode(ls_new.create())
-
-        midpoint = (left_corner_global + right_corner_global) * 0.5
-        white_line_vec = right_corner_global - left_corner_global
-        if white_line_vec.length() != 0:
-            white_line_dir = white_line_vec.normalized()
-        else:
-            white_line_dir = Vec3(0, 0, 0)
-        candidate = Vec3(-white_line_dir.getY(), white_line_dir.getX(), 0)
-        vehicle_pos = vehicle_node.getPos()
-        if candidate.dot(vehicle_pos - midpoint) < 0:
-            candidate = -candidate
-        if candidate.length() != 0:
-            perp_direction = candidate.normalized()
-        else:
-            perp_direction = Vec3(0, 0, 0)
-        line_length = 1.0
-        line_end = midpoint + perp_direction * line_length
-        ls_mid = LineSegs()
-        ls_mid.setThickness(2.0)
-        ls_mid.setColor(1, 1, 1, 1)
-        ls_mid.moveTo(midpoint)
-        ls_mid.drawTo(line_end)
-        vehicle_node.attachNewNode(ls_mid.create())
-
-        # Fahrzeug: Gabel – grüner Punkt (als Referenz)
-        green_point_global = midpoint + perp_direction * 0.5
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        self.fork_green = green_marker_np  # Global abgespeichert
-
-        # Mast: Erzeuge den Mast und hänge den Zylinder als Referenz an
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-
-        self.add_diagonals_to_mast(mast_node)
-        intersection = Vec3(0.5, 0.05, 1.0)
-
-        # Fahrzeug: Zylinder – Erzeuge den Zylinder und speichere ihn global
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-        self.vehicle_cylinder = cylinder_node  # Global abgespeichert
-
-        # Optional: Zusätzliche Fahrzeugbestandteile (wie Lidar) können hier ergänzt werden.
-
-        if park_point is None:
-            vehicle_node.setPos(intersection.x, intersection.y, 0)
-        else:
-            vehicle_node.setPos(park_point - intersection)
-
-        return vehicle_node
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def add_lidar_circle(self, parent_node, center, radius):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(0, 1, 0, 1)
-        segments = 64
-        start_x = center.x + radius * math.cos(0)
-        start_y = center.y + radius * math.sin(0)
-        ls.moveTo(start_x, start_y, center.z)
-        for i in range(1, segments + 1):
-            angle = 2 * math.pi * i / segments
-            x = center.x + radius * math.cos(angle)
-            y = center.y + radius * math.sin(angle)
-            ls.drawTo(x, y, center.z)
-        parent_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    def update_cable(self, task):
-        t = task.time
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    # -----------------------------------
-    # FEHLENDE METHODEN: Paketspawning, Würfelerzeugung u.a.
-    # -----------------------------------
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        if hasattr(self, "abgabe_stations") and self.abgabe_stations:
-            target_index = random.randint(1, len(self.abgabe_stations))
-        else:
-            target_index = 1
-
-        # Der Auftrag wird hier erstellt – und zwar genau dann, wenn ein Paket gespawnt wird.
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def update_order_table(self):
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen (z.B. "annahme_station_3") nur die Nummer.
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z.B. "Abgabestation 5") nur die Nummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Bestimme die Fahrzeugzuordnung.
-            # Wird "1" angezeigt, wenn der Auftrag aktuell (und noch nicht erledigt) dem Fahrzeug zugeordnet ist.
-            # Andernfalls wird ein "-" angezeigt.
-            if self.current_order is not None and order["id"] == self.current_order["id"] and order.get(
-                    "status") != "Erledigt":
-                vehicle_display = "1"
-            else:
-                vehicle_display = "-"
-
-            self.order_tree.insert("", tk.END, values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def check_and_spawn_packages(self, task):
-        # Maximale Anzahl an Aufträgen beschränken auf die Anzahl der Pakete in der Simulation
-        max_orders = len(self.pickup_packages)
-        if len(self.orders) >= max_orders:
-            return Task.cont
-
-        spawn_delay = 5.0  # 5 Sekunden Verzögerung zwischen Spawns
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def update_graph_data(self, task):
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0.0
-        self.graph_data.append((self.sim_clock, ppm, avg_dwell))
-        return Task.again
-
-    def open_graph(self):
-        if not self.graph_opened:
-            self.init_graph()
-            self.fig.canvas.mpl_connect("close_event", self.on_graph_close)
-            self.taskMgr.add(self.update_graph_task, "UpdateGraphTask")
-            self.graph_opened = True
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(8, 6))
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-        plt.show(block=False)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Wir legen hier die Spalten in der gewünschten Reihenfolge an: Auftrags ID, Annahmestation, Ziel, Fahrzeug.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Setze das Paket relativ zum Gabelmodul mit einem Offset in X- und Y-Richtung
-            green_point_pos = self.fork_green.getPos(self.fork_node)
-            package.wrtReparentTo(self.fork_node)
-            package.setPos(
-                green_point_pos.getX() + 0.5,  # Versatz um +0.5 in X-Richtung
-                green_point_pos.getY() + -0.5,  # Versatz um +0.5 in Y-Richtung
-                green_point_pos.getZ() + 1  # Z-Offset, um das Paket oberhalb der Gabel zu platzieren
-            )
-
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    from direct.task.TaskManagerGlobal import taskMgr  # Sicherstellen, dass taskMgr verfügbar ist
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden removeCargoTask aufruft,
-            # und übergib dabei das cargo als extra Argument:
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return Task.done
-
-    def vehicle_order_task(self, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-
-        # Phase 1: Translate – Fahrt zur blauen Markierung der Annahmestation (Pickup)
-        if not hasattr(self, "vehicle_state"):
-            self.vehicle_state = "translate"
-        if not hasattr(self, "package_attached"):
-            self.package_attached = False
-
-        if not self.garage_vehicles:
-            return task.cont
-
-        vehicle = self.garage_vehicles[0]
-
-        # ------------------ [Phase 1: Translate] ------------------
-        if self.vehicle_state == "translate":
-            blue_target = self.blue_dot.getPos(self.render)
-            local_mast = Vec3(0.5, 0.05, 1.0)
-            mast_global = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(local_mast)
-            target_xy = Vec2(blue_target.getX(), blue_target.getY())
-            mast_xy = Vec2(mast_global.getX(), mast_global.getY())
-            error_vector = target_xy - mast_xy
-            threshold = 0.05  # 5 cm Toleranz
-            if error_vector.length() > threshold:
-                direction = error_vector.normalized()
-                move_distance = 1.5 * dt
-                current_pos = vehicle.getPos(self.render)
-                new_pos = Vec3(current_pos.getX() + direction.getX() * move_distance,
-                               current_pos.getY() + direction.getY() * move_distance,
-                               0)
-                vehicle.setPos(new_pos)
-            else:
-                local_offset = vehicle.getQuat(self.render).xform(local_mast)
-                exact_pos = Vec3(blue_target.getX() - local_offset.getX(),
-                                 blue_target.getY() - local_offset.getY(),
-                                 0)
-                vehicle.setPos(exact_pos)
-                self.vehicle_state = "rotate"
-
-        # ------------------ [Phase 2: Rotate] ------------------
-        elif self.vehicle_state == "rotate":
-            desired_angle = math.degrees(math.atan2(self.station_white_direction.getY(),
-                                                    self.station_white_direction.getX()))
-            desired_angle = (desired_angle + 180) % 360  # berücksichtige 180°-Offset
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_angle - current_heading + 180) % 360) - 180
-            kp_heading = 0.5
-            new_heading = current_heading + kp_heading * angle_diff
-            vehicle.setH(new_heading)
-            if abs(angle_diff) < 1.0:
-                self.vehicle_state = "turn_right"
-
-        # ------------------ [Phase 3: Turn Right] ------------------
-        elif self.vehicle_state == "turn_right":
-            # Initialisierung: Einmalige Festlegung des Start- und Ziel-Headings
-            if not hasattr(self, "turn_right_init"):
-                self.turn_right_init = vehicle.getH() % 360
-                self.turn_right_target = (self.turn_right_init + 90) % 360
-                print("Phase 3: Initialisiert. Start Heading =", self.turn_right_init,
-                      "Target Heading =", self.turn_right_target)
-
-            # Aktuelles Heading und Fehlerberechnung (minimale Winkelabweichung im Bereich [-180, 180])
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((self.turn_right_target - current_heading + 180) % 360) - 180
-
-            # Proportionale Regelung: Drehgeschwindigkeit (in Grad/Sekunde)
-            kp_turn = 0.5
-            turn_rate = kp_turn * angle_diff
-
-            # Inkrementelle Aktualisierung des Headings basierend auf dt
-            new_heading = current_heading + turn_rate * dt
-            vehicle.setH(new_heading)
-
-            print("Phase 3: Aktuelles Heading =", current_heading,
-                  "Winkelabweichung =", angle_diff,
-                  "Neues Heading =", new_heading)
-
-            # Zustandswechsel, wenn der Fehler klein genug ist
-            if abs(angle_diff) < 1.0:
-                print("Phase 3: Drehung abgeschlossen. Übergang in 'approach'.")
-                self.vehicle_state = "approach"
-                del self.turn_right_init, self.turn_right_target
-
-
-        # ------------------ [Phase 4: Approach] ------------------
-        elif self.vehicle_state == "approach":
-            target = self.station_green_dot.getPos(self.render) + Vec3(0.5, 0.5, 0)
-            current = vehicle.getPos(self.render)
-            error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-            if error_vec.length() > 0.05:
-                direction = error_vec.normalized()
-                move_distance = 1.5 * dt
-                new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                               current.getY() + direction.getY() * move_distance,
-                               target.getZ())
-                vehicle.setPos(new_pos)
-            else:
-                self.vehicle_state = "pickup"
-
-        # ------------------ [Phase 5: Pickup] ------------------
-        elif self.vehicle_state == "pickup":
-            current_z = self.fork_node.getZ()
-            target_z = 1.0  # Höhe der Gabel beim Aufnehmen
-            raise_speed = 0.5
-            if current_z < target_z:
-                self.fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-            else:
-                if self.current_order is None:
-                    if self.orders_queue:
-                        self.current_order = self.orders_queue.pop(0)
-                    else:
-                        print("Keine verfügbaren Aufträge. Überspringe Pickup-Phase.")
-                        self.vehicle_state = "drive_out"
-                        return task.cont
-                pickup_station = self.current_order["pickup_station"]
-                self.pickup_package(vehicle, pickup_station)
-                self.package_attached = True
-                self.drive_out_start = vehicle.getPos(self.render)
-                self.drive_out_target = self.drive_out_start + vehicle.getQuat(self.render).getForward() * 5.0
-                self.vehicle_state = "drive_out"
-
-        # ------------------ [Phase 6: Drive Out] ------------------
-        elif self.vehicle_state == "drive_out":
-            current_z = self.fork_node.getZ()
-            if current_z > 0.0:
-                lower_speed = 0.5
-                self.fork_node.setZ(max(0.0, current_z - lower_speed * dt))
-            current_pos = vehicle.getPos(self.render)
-            diff = self.drive_out_target - current_pos
-            if diff.length() > 0.1:
-                move_distance = 0.5 * dt
-                step = diff.normalized() * move_distance
-                vehicle.setPos(current_pos + step)
-            else:
-                self.vehicle_state = "to_delivery"
-
-        # ------------------ [Phase 7: To Delivery] ------------------
-        elif self.vehicle_state == "to_delivery":
-            delivery_target_str = self.current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-            current_pos = vehicle.getPos(self.render)
-            diff = blue_target - current_pos
-            threshold = 0.5  # großzügiger Toleranzwert in Metern
-            move_distance = 1.5 * dt
-            if move_distance > diff.length():
-                vehicle.setPos(blue_target)
-            else:
-                vehicle.setPos(current_pos + diff.normalized() * move_distance)
-            if (blue_target - vehicle.getPos(self.render)).length() <= threshold:
-                print("Phase 7 abgeschlossen: Fahrzeug hat den blauen Punkt der Abgabestation erreicht.")
-                self.vehicle_state = "align_delivery"
-
-        # ------------------ [Phase 8: Align Delivery] ------------------
-        elif self.vehicle_state == "align_delivery":
-            desired_heading = 90.0
-
-            current_heading = vehicle.getH() % 360
-            angle_diff = ((desired_heading - current_heading + 180) % 360) - 180
-
-            print("Phase 8: Align Delivery | Current Heading: {:.2f}°, Desired: {:.2f}°, Diff: {:.2f}°".format(
-                current_heading, desired_heading, angle_diff))
-
-            fixed_turn_speed = 90.0  # Grad pro Sekunde
-            turn_amount = fixed_turn_speed * dt
-
-            if abs(angle_diff) < 1.0:
-                vehicle.setH(desired_heading)
-                print("Phase 8 abgeschlossen: Fahrzeug ausgerichtet (Heading = {:.2f}°).".format(desired_heading))
-                # Nach erfolgreicher Ausrichtung wechseln wir in die neue Phase (Delivery Center)
-                self.vehicle_state = "delivery_center"
-            else:
-                if angle_diff > 0:
-                    new_heading = current_heading + turn_amount
-                else:
-                    new_heading = current_heading - turn_amount
-                new_heading %= 360
-                vehicle.setH(new_heading)
-                print("Phase 8: Rotating - New Heading set to {:.2f}°".format(new_heading))
-
-        # ------------------ [Phase 9: Delivery Approach] ------------------
-        elif self.vehicle_state == "delivery_center":
-            # Extrahiere aus dem Auftrag den Zielindex, z. B. "Abgabestation 3"
-            delivery_target_str = self.current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-
-            # Wähle den entsprechenden blauen Marker aus der Liste der Abgabestation-Marker
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-
-            current = vehicle.getPos(self.render)
-            target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-            print("Phase 9: Zielpunkt der Abgabestation =", target_point)
-
-            # Berechne den Fehlervektor im XY-Bereich zwischen der aktuellen Fahrzeugposition und target_point
-            error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-            tolerance = 0.05  # Toleranz in Metern im XY-Bereich
-            move_distance = 1.5 * dt  # Annäherungsgeschwindigkeit analog zu Phase 4
-
-            if error_vec.length() > tolerance:
-                direction = error_vec.normalized()
-                new_pos = Vec3(
-                    current.getX() + direction.getX() * move_distance,
-                    current.getY() + direction.getY() * move_distance,
-                    current.getZ()  # Z bleibt unverändert (Boden)
-                )
-                vehicle.setPos(new_pos)
-                print("Phase 9: Fahrzeug bewegt sich von", current, "nach", new_pos)
-            else:
-                vehicle.setPos(target_point)
-                print("Phase 9: Fahrzeug hat den Zielpunkt erreicht.")
-                self.vehicle_state = "drop"  # Wechsel in die Drop-Phase
-
-            # (Optional) Hebe parallel das Gabelmodul (fork_node) sanft an, falls benötigt.
-            current_fork_z = self.fork_node.getZ()
-            if current_fork_z < 1.0:
-                new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-                self.fork_node.setZ(new_fork_z)
-                print("Phase 9: Gabel wird angehoben (Z =", new_fork_z, ").")
-
-        # ------------------ [Phase 10: Dropoff] ------------------
-        elif self.vehicle_state == "drop":
-            # Zuerst: Paket absetzen, falls es noch angebunden ist.
-            if self.package_attached:
-                # Extrahiere aus dem Auftrag den Zielindex, z. B. "Abgabestation 3"
-                delivery_target_str = self.current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-
-                # Wähle den entsprechenden blauen Marker aus der Liste der Abgabestation-Marker
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-
-                # Jetzt wird das Paket abgesetzt:
-                self.drop_cargo(vehicle)
-                print("Phase 10: Paket abgesetzt.")
-                self.package_attached = False
-
-            else:
-                # Nachdem das Paket abgesetzt wurde, senke die Gabeln ab.
-                current_z = self.fork_node.getZ()
-                if current_z > 0.0:
-                    lower_speed = 0.5  # Absenkgeschwindigkeit in m/s
-                    new_z = max(0.0, current_z - lower_speed * dt)
-                    self.fork_node.setZ(new_z)
-                    print("Phase 10: Gabel wird abgesenkt, aktueller Z-Wert =", new_z)
-                else:
-                    print("Phase 10: Dropoff vollständig abgeschlossen.")
-                    # Setze den Zustand für den nächsten Auftrag zurück.
-                    self.vehicle_state = "translate"
-                    self.current_order["status"] = "Erledigt"
-                    self.current_order["delivered_at"] = self.sim_clock
-                    self.current_order = None
-
-        # ------------------ [Phase 11: Exit Station and Start Next Order] ------------------
-        elif self.vehicle_state == "phase11":
-            # Verwende den in Phase 10 gespeicherten blauen Marker der Abgabestation
-            if hasattr(self, "last_delivery_marker"):
-                target_point = self.last_delivery_marker
-            else:
-                # Fallback: wenn der Marker nicht gespeichert wurde, bestimme ihn aus dem aktuellen Auftrag
-                delivery_target_str = self.current_order.get("ziel", "Abgabestation 1")
-                try:
-                    target_index = int(delivery_target_str.split()[-1])
-                except ValueError:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                    target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-                else:
-                    target_point = self.abgabe_blue_dots[0].getPos(self.render)
-            print("Phase 11: Zielpunkt (blauer Marker) =", target_point)
-
-            # Hole die aktuelle Fahrzeugposition
-            current_pos = vehicle.getPos(self.render)
-            diff = target_point - current_pos
-
-            # Bewege das Fahrzeug mit konstanter Geschwindigkeit von 0.5 m/s
-            if diff.length() > 0.1:
-                move_distance = 0.5 * dt
-                step = diff.normalized() * move_distance
-                vehicle.setPos(current_pos + step)
-                print("Phase 11: Fahrzeug fährt aus der Station, neue Position =", current_pos + step)
-            else:
-                # Zielpunkt erreicht – nächster Auftrag wird eingeleitet.
-                vehicle.setPos(target_point)
-                print("Phase 11: Fahrzeug hat den blauen Marker erreicht. Nächster Auftrag wird gestartet.")
-                self.vehicle_state = "next_order"  # Zustandswechsel zur nächsten Auftragsphase
-
-        return task.cont
-
-
-if __name__ == "__main__":
-    app = LagerSimulation()
-    app.run()
Index: KI/KI5.py
===================================================================
diff --git a/KI/KI5.py b/KI/KI5.py
deleted file mode 100644
--- a/KI/KI5.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,297 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData,
-    GeomNode, GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode
-)
-# Globaler Clock über ClockObject
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.interval.IntervalGlobal import Sequence, Wait, LerpPosInterval, Func
-from direct.task import Task
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Fahrzeuggeschwindigkeit: 1.5 m/s * 5 = 7.5 m/s
-        self.speed = 1.5 * 5
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie (gleicher Abstand)
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            # Annahmestation links (rot) bei x = -9
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            # Abgabestation rechts (grün) bei x = 9
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeuge initialisieren – wir erzeugen zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}             # Dictionary: Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}   # Dictionary: Fahrzeug -> aktuelle Abgabestation (für drop_cargo)
-
-        # Fahrzeug 1
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-
-        # Fahrzeug 2 – leicht versetzt, damit die Modelle nicht exakt übereinander liegen.
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)  # y-Offset von 2 Einheiten
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-
-        # Dictionary für alle Pickup-Pakete:
-        # Schlüssel = Annahmestation, Wert = (Paket, Spawnzeit, Timer-TextNode)
-        self.pickup_packages = {}
-        # Dictionary für die letzte Entfernung (bzw. Initialisierung) pro Station
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = globalClock.getFrameTime()
-
-        # Starte einen Task, der regelmäßig prüft, ob an einer Annahmestation ein Paket fehlen soll.
-        self.taskMgr.doMethodLater(1, self.check_and_spawn_packages, "CheckSpawnPackages")
-        # Task zum Aktualisieren der angezeigten Timer (Wartezeit) auf den Paketen.
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-
-        # Starte für jedes Fahrzeug einen eigenen Lieferzyklus.
-        for v in self.vehicles:
-            self.start_delivery_cycle(v, v.getPos())
-
-    def check_and_spawn_packages(self, task):
-        """
-        Für jede Annahmestation wird geprüft, ob bereits ein Paket vorhanden ist.
-        Falls nicht, und wenn seit dem letzten Entfernen mindestens 5 Sekunden vergangen sind,
-        wird an dieser Station ein neues Paket erzeugt.
-        """
-        spawn_delay = 5  # 5 Sekunden Wartezeit pro Station
-        current_time = globalClock.getFrameTime()
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if current_time - self.last_removed.get(station, current_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.again
-
-    def spawn_package_at_station(self, station):
-        """
-        Erzeugt ein Paket (als Würfel) an der gegebenen Annahmestation.
-        Das Paket wird mit einem Z-Offset von +1 positioniert. Zusätzlich wird über dem Paket
-        ein TextNode angehängt, der später die Wartezeit anzeigt.
-        """
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = globalClock.getFrameTime()
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        """
-        Aktualisiert den Text (Wartezeit) aller wartenden Pakete.
-        """
-        current_time = globalClock.getFrameTime()
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = current_time - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        """
-        Ablauf für ein einzelnes Fahrzeug:
-          - Das Fahrzeug startet vom aktuellen Punkt (start_pos) und sucht sich aus
-            dem globalen Pickup-Pool **das Paket mit der höchsten Wartezeit**.
-          - Bevor das Fahrzeug diesen Auftrag übernimmt, prüfen beide Fahrzeuge, welches
-            Fahrzeug sich näher an der betreffenden Annahmestation (Pickup-Station) befindet.
-            Nur das Fahrzeug, das näher ist, fährt den Auftrag ab.
-          - Nachdem das Fahrzeug zum Pickup gefahren ist, wird das Paket eingesammelt,
-            anschließend wird zufällig eine Abgabestation gewählt, zu der das Fahrzeug fährt.
-          - Dort wird das Paket auf den Würfel der Abgabestation gesetzt; nach 1 Sekunde
-            wird es entfernt.
-          - Der nächste Zyklus startet von der aktuellen Position (der Abgabestation) erneut.
-        """
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-
-        # Falls gerade keine Pakete existieren, kurze Wartephase und dann erneut versuchen.
-        if not self.pickup_packages:
-            self.taskMgr.doMethodLater(1,
-                                       lambda t: self.start_delivery_cycle(vehicle, start_pos),
-                                       "RetryCycle_"+str(id(vehicle)))
-            return
-
-        # Auswahl des Pickups mit höchster Wartezeit (niedrigste Spawnzeit)
-        target_station = min(self.pickup_packages, key=lambda s: self.pickup_packages[s][1])
-        # Berechne für jedes Fahrzeug die Distanz zu dieser Station.
-        distances = {v: v.getPos().distance(target_station.getPos()) for v in self.vehicles}
-        # Bestimme, welches Fahrzeug am nächsten ist.
-        closest_vehicle = min(distances, key=distances.get)
-        # Nur das Fahrzeug, das am nächsten ist, soll diesen Auftrag übernehmen.
-        if vehicle != closest_vehicle:
-            # Dieses Fahrzeug ist nicht zuständig – es wartet und prüft erneut.
-            self.taskMgr.doMethodLater(1,
-                                       lambda t: self.start_delivery_cycle(vehicle, vehicle.getPos()),
-                                       "RetryCycle_"+str(id(vehicle)))
-            return
-
-        # Jetzt fährt das (nächste) Fahrzeug zur entsprechenden Pickup-Station.
-        pickup_station = target_station
-        pickup_pos = pickup_station.getPos()
-        seg1_duration = (pickup_pos - start_pos).length() / self.speed
-
-        # Zufällige Auswahl einer Abgabestation.
-        dropoff_station = random.choice(self.abgabe_stationen)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_pos = dropoff_station.getPos()
-        seg2_duration = (dropoff_pos - pickup_pos).length() / self.speed
-
-        cycle = Sequence(
-            # Fahrt zur Annahmestation
-            LerpPosInterval(vehicle, duration=seg1_duration, pos=pickup_pos),
-            # Paket aufnehmen (das Fahrzeug holt das wartende Paket)
-            Func(self.pickup_package, vehicle, pickup_station),
-            # Fahrt zur zufällig ausgewählten Abgabestation
-            LerpPosInterval(vehicle, duration=seg2_duration, pos=dropoff_pos),
-            Func(self.drop_cargo, vehicle),
-            Wait(1),
-            Func(self.remove_cargo, vehicle),
-            # Nächsten Zyklus für dasselbe Fahrzeug starten (von der Abgabestation)
-            Func(self.start_delivery_cycle, vehicle, vehicle.getPos())
-        )
-        cycle.start()
-
-    def pickup_package(self, vehicle, station):
-        """
-        Das Fahrzeug nimmt an der gegebenen Annahmestation das wartende Paket auf.
-        Der zugehörige Timer-Text wird entfernt, der Eintrag aus dem globalen Pool gelöscht
-        und der Zeitpunkt in last_removed aktualisiert.
-        """
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            # Aktualisiere den Zeitpunkt, an dem ein Paket an dieser Station entfernt wurde.
-            self.last_removed[station] = globalClock.getFrameTime()
-
-    def drop_cargo(self, vehicle):
-        """
-        Setzt das vom Fahrzeug transportierte Paket exakt auf den Würfel der
-        (zufällig ausgewählten) Abgabestation (mit einem Z-Offset von +1).
-        """
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-
-    def remove_cargo(self, vehicle):
-        """
-        Entfernt das aktuell transportierte Paket des Fahrzeugs aus der Szene.
-        """
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-
-        # Horizontale Linien
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        # Vertikale Linien
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        """
-        Erzeugt ein Wireframe-Box-Modell als Station.
-        """
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        """
-        Erzeugt einen Würfel (als Paket), der etwas über dem Boden platziert wird.
-        """
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        """
-        Einfaches Beleuchtungssetup: Ambient- und Richtungslicht.
-        """
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-# Starte die Simulation
-app = LagerSimulation()
-app.run()
Index: Grundmodell Erweitert Split/GES6.py
===================================================================
diff --git a/Grundmodell Erweitert Split/GES6.py b/Grundmodell Erweitert Split/GES6.py
deleted file mode 100644
--- a/Grundmodell Erweitert Split/GES6.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,2213 +0,0 @@
-# Standardbibliothek
-import random
-import math
-import time
-import ctypes
-import multiprocessing
-from multiprocessing import Queue, Process
-from functools import partial
-import tkinter as tk
-from tkinter import ttk
-
-# Drittanbieter
-import matplotlib
-import matplotlib.pyplot as plt
-from PyQt5 import QtWidgets, QtCore
-import pyqtgraph as pg
-
-# Panda3D und Direct (Engine-spezifische Importe)
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    GeomTriangles,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec2,
-    Vec3,
-    LineSegs,
-    TextNode,
-    CardMaker,
-    NodePath,
-    RenderModeAttrib
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.task.TaskManagerGlobal import taskMgr
-from direct.gui.DirectGui import DirectButton, DirectSlider, DirectLabel
-
-from direct.showbase.ShowBase import ShowBase
-from environment_visualization import EnvironmentVisualizer
-
-class LagerSimulation(ShowBase):
-    def __init__(self, graph_queue=None):
-        # Basisinitialisierung (ShowBase, etc.)
-        super().__init__()
-
-        # ------------------------------------------------------------------------
-        # 1. Umgebung aufbauen: Verwende den extrahierten EnvironmentVisualizer
-        # ------------------------------------------------------------------------
-        self.env_viz = EnvironmentVisualizer(self.render, self.loader)
-
-        # Rufe die Methoden des Visualizers auf, um die Umgebung zu erstellen.
-        self.env_viz.draw_origin()
-        self.env_viz.erzeuge_licht()
-        self.env_viz.erzeuge_bodenraster(center_extent=70, cell_size=1)
-        self.env_viz.create_wall()
-        self.env_viz.create_annahme_stations()
-        self.env_viz.create_abgabe_stations()
-        self.env_viz.create_garagen_stations()
-
-        # Um in anderen Methoden (z. B. für Paket- oder Auftrags-Handling) auf die Stationen
-        # und deren Marker zugreifen zu können, übergeben wir die entsprechenden Listen.
-        self.annahme_stations = self.env_viz.annahme_stations
-        self.station_blue_dots = self.env_viz.station_blue_dots
-        self.abgabe_stations = self.env_viz.abgabe_stations
-        self.abgabe_blue_dots = self.env_viz.abgabe_blue_dots
-        self.garagen_stations = self.env_viz.garagen_stations
-        self.garagen_parking_points = self.env_viz.garagen_parking_points
-
-        # Setze den Pickup-Offset (dieser Vektor wird bei der Steuerung genutzt)
-        self.pickup_offset = Vec3(0.5, -0.5, 0)
-
-        # Falls du weitere Referenzen (wie self.blue_dot, self.station_green_dot) brauchst, ebenfalls setzen.
-        if hasattr(self.env_viz, 'blue_dot'):
-            self.blue_dot = self.env_viz.blue_dot
-        if hasattr(self.env_viz, 'station_green_dot'):
-            self.station_green_dot = self.env_viz.station_green_dot
-
-        # ------------------------------------------------------------------------
-        # 2. Restliche Initialisierung (Simulationsvariablen, UI, Tasks, etc.)
-        # (Der restliche Code bleibt weitgehend unverändert.)
-        # ------------------------------------------------------------------------
-
-        self.paused = False
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-        self.current_speed = 1.5
-
-        # Weitere Attribute, z. B. für KPIs, Paket- und Auftragsverwaltung usw.
-        self.delivered_packages = 0
-        self.pickup_packages = {}
-        self.last_removed = {}
-        self.orders = {}
-        self.orders_queue = []
-        self.next_order_id = 1
-        # (Weitere Initialisierungen kommen hier…)
-        self.cargos = {}
-        # Falls du auch weitere Attribute benötigst, wie beispielsweise eine Liste der belegten Pickup-Stations:
-        self.occupied_pickups = set()
-
-        self.max_overall_wait_time = 0.0  # Maximale Wartezeit der Pakete
-        self.total_dwell_time = 0.0  # Summe aller Liegedauern abgeholter Pakete
-        self.picked_up_count = 0  # Anzahl abgeholter Pakete
-        self.total_delivery_time = 0.0  # Summe aller Lieferzeiten
-        self.total_delivery_count = 0  # Anzahl der Lieferungen
-        self.max_overall_delivery_time = 0.0
-
-        self.graph_queue = None
-        self.graph_data = []
-        self.graph_process = None
-
-        # Beispiel: Initialisierung des Tkinter-Fensters
-        self.tk_root = tk.Tk()
-        self.tk_root.withdraw()
-
-        # Weiterer Code: Kamera, Lichter (falls weiterhin benötigt – ansonsten übernehmen wir vollständig den Visualizer)
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # UI-bezogene Attribute initialisieren:
-        self.order_win = None
-        self.order_tree = None
-        self.graph_queue = None
-        self.graph_data = []
-
-        # TensorFlow-Modell und RL-Agent initialisieren (wie gehabt)
-        try:
-            import tensorflow as tf
-            self.tf_model = tf.keras.models.load_model("mein_model.keras")
-            print("TensorFlow Modell erfolgreich geladen.")
-        except Exception as e:
-            print(f"Fehler beim Laden des TensorFlow Modells: {e}")
-            self.tf_model = None
-
-        state_bins = ((10, 10), (10, 10))
-        action_space = [0, 1, 2]
-        self.rl_agent = RLAgent(state_bins, action_space, learning_rate=0.1, discount_factor=0.9, epsilon=0.2)
-        self.training_data = []  # Trainingsdatenliste
-
-        # Spawn-Einstellungen (Standardwerte)
-        self.package_spawn_delay = 5.0
-        self.package_spawn_distribution = "uniform"
-        # Hier speichern wir die Variablen für die Stationen als Dictionary (Index -> BooleanVar)
-        self.spawn_station_vars = {}
-        # Falls du beispielsweise 10 Annahmestationen hast:
-        for i in range(10):
-            self.spawn_station_vars[i] = tk.BooleanVar(value=False)
-
-        # Fahrzeuge in den Garagen instanziieren:
-        self.create_garage_vehicles()
-        # --- UI-Elemente für Simulationssteuerung ---
-        # Slider für Simulationsgeschwindigkeit
-        # UI – Slider und Info-Anzeige
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        self.paused = False
-        # Pause-Knopf neben dem Slider platzieren – z.B. rechts davon.
-        self.pause_button = DirectButton(
-            text="Pause",
-            command=self.toggle_pause,
-            pos=(-0.5, 0, -0.85),  # Leicht links vom Slider
-            scale=0.07
-        )
-
-        # --- Tastenzuordnungen ---
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-        self.accept("g", self.open_graph)
-        self.accept("a", self.show_order_list)
-        self.accept("d", self.deliver_first_order)
-        # Taste "c" öffnet das Fahrzeug-Kontrollfenster
-        self.accept("c", self.show_vehicle_control)
-
-        # --- Tasks (TaskMgr) hinzufügen ---
-        self.taskMgr.add(self._tk_update, "tkUpdateTask")
-        self.taskMgr.add(self.update_delivery_timers, "UpdateDeliveryTimersTask")
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClock")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.update_graph_data, "UpdateGraphDataTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackagesTask")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimersTask")
-        self.taskMgr.add(self.update_order_status, "UpdateOrderStatusTask")
-    # ---------------1. Initialisierung & Simulationssteuerung---------------
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        self.sim_clock += dt
-        return Task.cont
-
-    def toggle_pause(self):
-        if not self.paused:
-            # Speichern des aktuellen speed_factor, damit wir ihn beim Resume wiederherstellen können
-            self.previous_speed_factor = self.speed_factor
-            self.speed_factor = 0  # Simulation einfrieren: alle dt-basierte Updates ergeben 0
-            self.pause_button['text'] = "Weiter"
-            self.paused = True
-            print("Gesamte Simulation angehalten")
-        else:
-            # Wiederaufnahme der Simulation: speed_factor auf den vorherigen Wert zurücksetzen
-            self.speed_factor = self.previous_speed_factor if hasattr(self, 'previous_speed_factor') else 1.0
-            self.pause_button['text'] = "Pause"
-            self.paused = False
-            print("Simulation läuft wieder")
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def update_vehicle(self, task):
-        # dt jetzt skaliert mit der Simulationsgeschwindigkeit
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-        pos = self.vehicle.getPos()
-        forward = self.vehicle.getQuat().getForward()
-
-        target_speed = 1.5
-        acc_rate = 2.0
-
-        if self.current_speed < target_speed:
-            self.current_speed = min(self.current_speed + acc_rate * dt, target_speed)
-        elif self.current_speed > target_speed:
-            self.current_speed = max(self.current_speed - acc_rate * dt, target_speed)
-
-        new_pos = pos + forward * self.current_speed * dt
-        self.vehicle.setPos(new_pos)
-        return Task.cont
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-    # ---------------2. Graphik & UI (GUI-/Tk-/Matplotlib-Funktionen)---------------
-    def open_graph(self):
-        # Starte den Graphprozess per Taste G (nur, wenn er noch nicht läuft)
-        if self.graph_process is None or not self.graph_process.is_alive():
-            from multiprocessing import Queue, Process
-            self.graph_queue = Queue()
-
-            # Sende alle bisher gesammelten Daten in die Queue:
-            for data in self.graph_data:
-                try:
-                    self.graph_queue.put(data, block=False)
-                except Exception:
-                    pass
-
-            from graph_pyqt import graph_process_pyqt
-            self.graph_process = Process(target=graph_process_pyqt, args=(self.graph_queue,))
-            self.graph_process.start()
-            print("Graphprozess gestartet.")
-        else:
-            print("Graphprozess läuft bereits.")
-
-    def init_graph(self):
-        plt.ion()
-        self.fig, (self.ax1, self.ax2, self.ax3) = plt.subplots(3, 1, figsize=(8, 9))
-
-        # Erster Plot: Pakete pro Minute
-        self.line1, = self.ax1.plot([], [], marker="o", label="Pakete pro Minute")
-        self.ax1.set_xlabel("Simulationszeit (s)")
-        self.ax1.set_ylabel("Pakete pro Minute")
-        self.ax1.set_title("Abgegebene Pakete pro Minute")
-        self.ax1.legend()
-        self.ax1.grid(True)
-
-        # Zweiter Plot: Durchschnittliche Liegedauer
-        self.line2, = self.ax2.plot([], [], marker="o", color="orange", label="Durchschnittliche Liegedauer (s)")
-        self.ax2.set_xlabel("Simulationszeit (s)")
-        self.ax2.set_ylabel("Liegedauer (s)")
-        self.ax2.set_title("Durchschnittliche Liegedauer")
-        self.ax2.legend()
-        self.ax2.grid(True)
-
-        # Dritter Plot: Durchschnittliche Lieferzeit
-        self.line3, = self.ax3.plot([], [], marker="o", color="green", label="Durchschnittliche Lieferzeit (s)")
-        self.ax3.set_xlabel("Simulationszeit (s)")
-        self.ax3.set_ylabel("Lieferzeit (s)")
-        self.ax3.set_title("Durchschnittliche Lieferzeit")
-        self.ax3.legend()
-        self.ax3.grid(True)
-
-        plt.show(block=False)
-        # Starte im Tkinter-Hauptloop eine periodische Aktualisierung:
-        self.tk_root.after(500, self.tk_graph_update)  # alle 500ms
-
-    def tk_graph_update(self):
-        # GIL sichern: Gibt einen Statuswert zurück, der später wieder freigegeben wird.
-        gil_state = ctypes.pythonapi.PyGILState_Ensure()
-        try:
-            times = [data[0] for data in self.graph_data]
-            rates = [data[1] for data in self.graph_data]
-            dwell = [data[2] for data in self.graph_data]
-            delivery = [data[3] for data in self.graph_data]
-
-            self.line1.set_data(times, rates)
-            self.ax1.relim()
-            self.ax1.autoscale_view()
-
-            self.line2.set_data(times, dwell)
-            self.ax2.relim()
-            self.ax2.autoscale_view()
-
-            self.line3.set_data(times, delivery)
-            self.ax3.relim()
-            self.ax3.autoscale_view()
-
-            self.fig.canvas.draw_idle()
-            self.fig.canvas.flush_events()
-        finally:
-            ctypes.pythonapi.PyGILState_Release(gil_state)
-
-        # Nächsten Aufruf in 500ms einplanen
-        self.tk_root.after(500, self.tk_graph_update)
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def update_info_display(self, task):
-        tot = self.sim_clock
-        h = int(tot // 3600)
-        m = int((tot % 3600) // 60)
-        s = tot % 60
-        formatted = f"{h}h {m}m {s:.1f}s"
-
-        # Bestimme die maximale Liegedauer aktueller Pakete an den Annahmestationen
-        current_max = 0.0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max:
-                current_max = elapsed
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max)
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        ppm = self.delivered_packages / (self.sim_clock / 60) if self.sim_clock > 0 else 0
-
-        # Lieferzeit-Kennzahlen ermitteln: für Fahrzeuge, die aktuell ein Paket tragen
-        current_delivery_time = 0.0
-        for veh in self.garage_vehicles:
-            if veh.getPythonTag("package_attached"):
-                ds = veh.getPythonTag("delivery_start_time")
-                if ds:
-                    elapsed_delivery = self.sim_clock - ds
-                    current_delivery_time = max(current_delivery_time, elapsed_delivery)
-        avg_delivery_time = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        # Aktualisiere den Info-Label-Text
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {ppm:.1f}\n"
-            f"Liegedauer (aktuell): {current_max:.1f}s\n"
-            f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s\n"
-            f"Durchschn. Liegedauer: {avg_dwell:.1f}s\n"
-            f"Lieferzeit (aktuell): {current_delivery_time:.1f}s\n"
-            f"Lieferzeit (maximal): {self.max_overall_delivery_time:.1f}s\n"
-            f"Durchschn. Lieferzeit: {avg_delivery_time:.1f}s"
-        )
-        return Task.cont
-
-    def update_graph_task(self, task):
-        times = [data[0] for data in self.graph_data]
-        rates = [data[1] for data in self.graph_data]
-        dwell = [data[2] for data in self.graph_data]
-        delivery = [data[3] for data in self.graph_data]
-
-        self.line1.set_data(times, rates)
-        self.ax1.relim()
-        self.ax1.autoscale_view()
-
-        self.line2.set_data(times, dwell)
-        self.ax2.relim()
-        self.ax2.autoscale_view()
-
-        self.line3.set_data(times, delivery)
-        self.ax3.relim()
-        self.ax3.autoscale_view()
-
-        self.fig.canvas.draw_idle()
-        self.fig.canvas.flush_events()
-        plt.pause(0.001)
-        return Task.cont
-
-    def on_graph_close(self, event):
-        self.graph_opened = False
-        self.taskMgr.remove("UpdateGraphTask")
-
-    def update_graph_data(self, task):
-        if self.sim_clock > 0:
-            ppm = self.delivered_packages / (self.sim_clock / 60)
-        else:
-            ppm = 0.0
-        avg_dwell = self.total_dwell_time / self.picked_up_count if self.picked_up_count > 0 else 0.0
-        avg_delivery = self.total_delivery_time / self.total_delivery_count if self.total_delivery_count > 0 else 0.0
-
-        new_data = (self.sim_clock, ppm, avg_dwell, avg_delivery)
-        # Speichere alle Daten ab Simulationsbeginn:
-        self.graph_data.append(new_data)
-
-        # Zusätzlich: Falls der Graphprozess aktiv ist, schicke den neuen Datensatz auch an die Queue
-        if self.graph_queue is not None:
-            try:
-                self.graph_queue.put(new_data, block=False)
-            except Exception:
-                pass
-        return Task.cont
-
-    def show_order_list(self):
-        if self.order_win is None:
-            self.order_win = tk.Tk()
-            self.order_win.title("Auftragsübersicht")
-            self.order_win.protocol("WM_DELETE_WINDOW", self.close_order_window)
-            # Hier werden nur die gewünschten Spalten "ID", "Annahmestation", "Ziel" und "Fahrzeug" definiert.
-            self.order_tree = ttk.Treeview(
-                self.order_win,
-                columns=("ID", "Annahmestation", "Ziel", "Fahrzeug"),
-                show="headings",
-                height=15
-            )
-            self.order_tree.heading("ID", text="Auftrags ID")
-            self.order_tree.heading("Annahmestation", text="Annahmestation")
-            self.order_tree.heading("Ziel", text="Ziel")
-            self.order_tree.heading("Fahrzeug", text="Fahrzeug")
-            self.order_tree.column("ID", width=100, anchor="center")
-            self.order_tree.column("Annahmestation", width=150, anchor="center")
-            self.order_tree.column("Ziel", width=150, anchor="center")
-            self.order_tree.column("Fahrzeug", width=100, anchor="center")
-            self.order_tree.pack(fill=tk.BOTH, expand=True)
-        else:
-            self.order_win.deiconify()
-        self.update_order_table()
-        self.order_win.lift()
-
-    def close_order_window(self):
-        if self.order_win is not None:
-            self.order_win.withdraw()
-
-    #-------Fahrzeugsteuerung(Bedienfenster)-------
-    def update_vehicle_control(self):
-        for veh, var in self.vehicle_state_vars.items():
-            new_state = var.get()
-            if new_state == "idle" and veh.getPythonTag("current_order") is not None:
-                veh.setPythonTag("standby_pending", True)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Standby angefordert (Auftrag wird fortgesetzt).")
-            else:
-                veh.setPythonTag("standby_pending", False)
-                veh.setPythonTag("order_state", new_state)
-                print(f"Fahrzeug {veh.getPythonTag('vehicle_id')}: Zustand auf {new_state} gesetzt.")
-
-    def _tk_update(self, task):
-        try:
-            self.tk_root.update()
-        except Exception:
-            pass
-        return Task.cont
-
-    def update_cable(self, task):
-        # Verwende die simulative Zeit, die bereits in update_sim_clock hochgezählt wird
-        t = self.sim_clock
-        new_height = 0.5 + 0.5 * math.sin(t * 2.0)
-        self.fork_node.setZ(new_height)
-        return Task.cont
-
-    def create_garage_vehicles(self):
-        self.garage_vehicles = []
-        vehicle_id_counter = 1
-        for park in self.garagen_parking_points:
-            veh = self.create_vehicle(park_point=park)
-            veh.setH(veh.getH() + 180)
-            intersection = Vec3(0.5, 0.05, 1.0)
-            newPos = park - veh.getQuat().xform(intersection)
-            newPos.setZ(0)
-            veh.setPos(newPos)
-
-            # Fahrzeuge starten im Standby (idle)
-            veh.setPythonTag("current_order", None)
-            veh.setPythonTag("order_state", "idle")
-            veh.setPythonTag("package_attached", False)
-            veh.setPythonTag("vehicle_id", vehicle_id_counter)
-            # Speichere den Parkpunkt als Rückkehrziel
-            veh.setPythonTag("garage_target", park)
-            # Speichere auch das Anfangs-Heading, um es später beim Parken wiederherzustellen.
-            veh.setPythonTag("start_heading", veh.getH())
-            vehicle_id_counter += 1
-
-            self.garage_vehicles.append(veh)
-
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.2)
-            marker.setColor(LColor(0, 0, 1, 1))
-            marker.setPos(park.getX(), park.getY(), 0)
-            marker.reparentTo(self.render)
-
-            # Füge einen Textknoten hinzu, der die Fahrzeugnummer vorne auf dem Fahrzeug anzeigt.
-            # Wir suchen den Mast-Knoten.
-            mast = veh.find("**/mast")
-            if not mast.isEmpty():
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)  # Schwarz
-                tn.setAlign(TextNode.ACenter)
-                text_np = mast.attachNewNode(tn)
-                # Positioniere den Text relativ zum Mast: Wir nutzen den Vektor "intersection"
-                # und versetzen ihn in Z-Richtung um 0.2 Einheiten oberhalb des Zylinders.
-                text_np.setPos(intersection.x, intersection.y, intersection.z + 0.2)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-            else:
-                from panda3d.core import TextNode
-                tn = TextNode("vehicle_number")
-                tn.setText(str(veh.getPythonTag("vehicle_id")))
-                tn.setTextColor(0, 0, 0, 1)
-                tn.setAlign(TextNode.ACenter)
-                text_np = veh.attachNewNode(tn)
-                text_np.setPos(0, 1.2, 1.5)
-                text_np.setScale(0.8)
-                text_np.setHpr(0, 0, 0)
-
-            self.taskMgr.add(partial(self.vehicle_order_task, veh),
-                             f"VehicleOrderTask_{veh.getPythonTag('vehicle_id')}")
-
-    # --------------- Erstellung des Fahrzeugs---------------
-    def create_vehicle(self, park_point=None):
-        # Erzeuge den übergeordneten Fahrzeug-Knoten
-        vehicle_node = self.render.attachNewNode("vehicle")
-
-        # --------------------------
-        # Chassis erstellen (1 x 0.5 x 1.2, Farbe Rot)
-        # --------------------------
-        box_chassis = self.create_box(1, 0.5, 1.2, (1.0, 0.0, 0.0, 1))
-        node_chassis = vehicle_node.attachNewNode(box_chassis)
-        node_chassis.setTwoSided(True)
-        node_chassis.setPos(0, 0, 0)
-        edges_chassis = self.create_box_edges(1, 0.5, 1.2, (0, 0, 0, 1))
-        edges_chassis.reparentTo(node_chassis)
-
-        # --------------------------
-        # Gabel (Fork) erstellen: Zwei Zähne
-        # --------------------------
-        fork_node = vehicle_node.attachNewNode("fork")
-        fork_node.setPos(0, -1.2, 0)
-        vehicle_node.setPythonTag("fork_node", fork_node)
-
-        left_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_left = fork_node.attachNewNode(left_tooth)
-        node_left.setTwoSided(True)
-        right_tooth = self.create_box(0.2, 1.2, 0.1, (0.3, 0.3, 0.3, 1))
-        node_right = fork_node.attachNewNode(right_tooth)
-        node_right.setTwoSided(True)
-        node_right.setPos(0.8, 0, 0)
-
-        # --------------------------
-        # Statt weißer Kante von der Gabel: bereits eingezeichnete grüne Mittellinie verwenden.
-        # In diesem Beispiel nehmen wir an, dass du schon eine „mittlere“ Linie gezeichnet hast.
-        # Zeichne die grüne Mittellinie, z. B. von einem Punkt an der Gabel (als Ausgangspunkt)
-        # bis zu einem Referenzpunkt – hier nutzen wir einen zuvor festgelegten Offset.
-        #
-        # Wir definieren:
-        #   - Den Ausgangspunkt als den grün markierten Punkt, der den mittleren Punkt der Gabel repräsentieren soll.
-        #   - Den Zielpunkt als den Referenzpunkt, der als Idealwert in create_vehicle bestimmt wurde.
-        # In unserem Beispiel berechnen wir den Zielpunkt einmalig aus den lokalen Offsets an der weißen Kante.
-        # (Diese Werte kannst du bei Bedarf anpassen.)
-        left_corner_local = Vec3(0, 0, 0.05)
-        right_corner_local = Vec3(1.0, 0, 0.05)
-        left_global = fork_node.getPos(self.render) + left_corner_local
-        right_global = fork_node.getPos(self.render) + right_corner_local
-        # Berechne den idealen (statischen) Mittelpunkt als Referenz – dieser wird nur einmal gesetzt.
-        midpoint_white = (left_global + right_global) * 0.5
-        # Nun lege den grünen Marker so, dass er exakt in der Mitte der Gabel liegt.
-        # Hier entspricht der grüne Punkt der Mittellinie der Gabel.
-        green_point_global = midpoint_white  # Hier wird angenommen, dass der ideale Mittelpunkt gleich dem Referenzpunkt ist.
-        green_marker = self.create_box(0.05, 0.05, 0.05, (0, 1, 0, 1))
-        green_marker_np = vehicle_node.attachNewNode(green_marker)
-        green_marker_np.setPos(green_point_global - Vec3(0.025, 0.025, 0.025))
-        vehicle_node.setPythonTag("fork_green", green_marker_np)
-
-        # Zeichne die grüne Mittellinie.
-        # Als Beispiel: Zeichne eine Linie vom grünen Marker in Richtung +Y (relativ zum Fahrzeug),
-        # weil du den idealen Zustand so festgelegt hast, dass genau diese Linie mit der Station übereinstimmen soll.
-        ls_mid = LineSegs()
-        ls_mid.setThickness(2.0)
-        ls_mid.setColor(0, 1, 0, 1)  # grün
-        # Starte die Linie am grünen Marker.
-        ls_mid.moveTo(green_point_global)
-        # Zeichne beispielsweise eine Linie 1 Einheit lang in +Y-Richtung:
-        ls_mid.drawTo(green_point_global + Vec3(0, 1, 0))
-        fork_center_line = vehicle_node.attachNewNode(ls_mid.create())
-        # Speichere den NodePath der grünen Mittellinie
-        vehicle_node.setPythonTag("fork_center_line", fork_center_line)
-        print("[DEBUG] create_vehicle: Grüne Mittellinie (fork_center_line) gesetzt.")
-
-        # --------------------------
-        # Restliche Fahrzeugteile (Mast, Lenkachse, etc.)
-        # --------------------------
-        mast_node = vehicle_node.attachNewNode("mast")
-        mast_node.setPos(0, 0.2, 1.2)
-        top_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        top_bar_node = mast_node.attachNewNode(top_bar)
-        top_bar_node.setPos(0, 0, 0.9)
-        bottom_bar = self.create_box(1, 0.1, 0.1, (0.2, 0.2, 0.2, 1))
-        bottom_bar_node = mast_node.attachNewNode(bottom_bar)
-        bottom_bar_node.setPos(0, 0, 0)
-        left_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        left_bar_node = mast_node.attachNewNode(left_bar)
-        left_bar_node.setPos(0, 0, 0.1)
-        right_bar = self.create_box(0.1, 0.1, 0.8, (0.2, 0.2, 0.2, 1))
-        right_bar_node = mast_node.attachNewNode(right_bar)
-        right_bar_node.setPos(0.9, 0, 0.1)
-        mast_node.setTwoSided(True)
-        mast_node.setPos(0, 0.2, 1.2)
-        self.add_diagonals_to_mast(mast_node)
-
-        intersection = Vec3(0.5, 0.05, 1.0)
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(mast_node)
-        cylinder_node.setPos(intersection)
-
-        # --------------------------
-        # Lenkachse erzeugen (Pivot-Node)
-        # --------------------------
-        steering_axis = mast_node.attachNewNode("steering_axis")
-        steering_axis.setPos(0.5, 0.25, -1.2)
-        steering_axis.setH(90)
-        vehicle_node.setPythonTag("steering_axis", steering_axis)
-
-        cylinder_node = NodePath(self.create_cylinder(0.1, 0.1, 16, (1, 1, 0, 1)))
-        cylinder_node.reparentTo(steering_axis)
-        cylinder_node.setPos(0, 0, 0)
-        self.vehicle_cylinder = steering_axis
-        self.add_steering_arrow(steering_axis, color=(0, 1, 0, 1))
-
-        # --------------------------
-        # Positioniere das Fahrzeug am Parkpunkt
-        # --------------------------
-        if park_point is None:
-            vehicle_node.setPos(0, 0, 0)
-        else:
-            intersection = Vec3(0, 0, 1.0)
-            vehicle_node.setPos(park_point - vehicle_node.getQuat().xform(intersection))
-
-        # ********** Ursprung (Koordinatensystem) am Fahrzeug einzeichnen **********
-        ls_x = LineSegs()
-        ls_x.setThickness(2)
-        ls_x.setColor(LColor(1, 0, 0, 1))
-        ls_x.moveTo(0, 0, 0)
-        ls_x.drawTo(1, 0, 0)
-        vehicle_node.attachNewNode(ls_x.create())
-
-        ls_y = LineSegs()
-        ls_y.setThickness(2)
-        ls_y.setColor(LColor(0, 1, 0, 1))
-        ls_y.moveTo(0, 0, 0)
-        ls_y.drawTo(0, 1, 0)
-        vehicle_node.attachNewNode(ls_y.create())
-
-        ls_z = LineSegs()
-        ls_z.setThickness(2)
-        ls_z.setColor(LColor(0, 0, 1, 1))
-        ls_z.moveTo(0, 0, 0)
-        ls_z.drawTo(0, 0, 1)
-        vehicle_node.attachNewNode(ls_z.create())
-
-        from panda3d.core import TextNode
-        tn_x = TextNode("label_x")
-        tn_x.setText("X")
-        tn_x.setTextColor(1, 0, 0, 1)
-        label_x = vehicle_node.attachNewNode(tn_x)
-        label_x.setScale(0.3)
-        label_x.setPos(2.0, 0, 0)
-
-        tn_y = TextNode("label_y")
-        tn_y.setText("Y")
-        tn_y.setTextColor(0, 1, 0, 1)
-        label_y = vehicle_node.attachNewNode(tn_y)
-        label_y.setScale(0.3)
-        label_y.setPos(0, 2.0, 0)
-
-        tn_z = TextNode("label_z")
-        tn_z.setText("Z")
-        tn_z.setTextColor(0, 0, 1, 1)
-        label_z = vehicle_node.attachNewNode(tn_z)
-        label_z.setScale(0.3)
-        label_z.setPos(0, 0, 2.0)
-
-        return vehicle_node
-
-    def add_steering_arrow(self, steering_axis, color=(0, 1, 0, 1)):
-        """
-        Erzeugt einen Pfeil, der die Vorwärtsrichtung (lokale X-Achse) des Lenkpivots anzeigt.
-        Der Pfeil wird als Kind des übergebenen steering_axis-Node angehängt und passt sich
-        automatisch dessen Rotation an.
-        """
-        arrow_ls = LineSegs()
-        arrow_ls.setThickness(2.0)
-        arrow_ls.setColor(*color)
-
-        # Zeichne eine Linie von (0,0,0) bis (2,0,0) – das ist die Basis des Pfeils
-        arrow_ls.moveTo(0, 0, 0)
-        arrow_ls.drawTo(2, 0, 0)
-
-        # Zeichne den Pfeilkopf: zwei kurze schräge Linien am Ende der Pfeillinie
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, 0.3, 0)
-        arrow_ls.moveTo(2, 0, 0)
-        arrow_ls.drawTo(1.5, -0.3, 0)
-
-        arrow_np = steering_axis.attachNewNode(arrow_ls.create())
-        arrow_np.setPos(0, 0, 0)  # Falls nötig, hier noch zusätzlichen Offset anpassen
-        return arrow_np
-
-    def rotate_around_pivot(self, vehicle, pivot, delta_angle):
-        """
-        Dreht das Fahrzeug (vehicle) um den gegebenen Pivotpunkt (pivot) um delta_angle (in Grad).
-        Dabei wird die Position des Fahrzeugs neu berechnet, sodass es um den Pivot rotiert.
-        """
-        # Aktuelle globale Fahrzeugposition
-        pos = vehicle.getPos(self.render)
-        # Globaler Pivotpunkt
-        pivot_pos = pivot.getPos(self.render)
-        # Berechne den Vektor vom Pivot zum Fahrzeug
-        rel = pos - pivot_pos
-        # Wandle den Drehwinkel in Bogenmaß um
-        rad = math.radians(delta_angle)
-        cos_val = math.cos(rad)
-        sin_val = math.sin(rad)
-        # Drehe den relativen Vektor
-        new_x = rel.getX() * cos_val - rel.getY() * sin_val
-        new_y = rel.getX() * sin_val + rel.getY() * cos_val
-        new_rel = Vec3(new_x, new_y, rel.getZ())
-        # Neue globale Fahrzeugposition
-        new_pos = pivot_pos + new_rel
-        vehicle.setPos(new_pos)
-        # Aktualisiere auch das Heading des Fahrzeugs (aufaddieren des Drehwinkels)
-        vehicle.setH(vehicle.getH() + delta_angle)
-
-    def add_diagonals_to_mast(self, mast_node):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(1.0, 0.5, 0.0, 1)
-        ls.moveTo(0, 0, 1.0)
-        ls.drawTo(1, 0.1, 1.0)
-        ls.moveTo(1, 0, 1.0)
-        ls.drawTo(0, 0.1, 1.0)
-        mast_node.attachNewNode(ls.create())
-
-    def create_cylinder(self, diameter, height, segments, color):
-        fmt = GeomVertexFormat.getV3n3c4()
-        vdata = GeomVertexData("cylinder", fmt, Geom.UHStatic)
-        vwriter = GeomVertexWriter(vdata, "vertex")
-        nwriter = GeomVertexWriter(vdata, "normal")
-        cwriter = GeomVertexWriter(vdata, "color")
-        r = diameter / 2.0
-        top_z = height / 2.0
-        bottom_z = -height / 2.0
-
-        vwriter.addData3f(0, 0, top_z)
-        nwriter.addData3f(0, 0, 1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, top_z)
-            nwriter.addData3f(0, 0, 1)
-            cwriter.addData4f(*color)
-
-        vwriter.addData3f(0, 0, bottom_z)
-        nwriter.addData3f(0, 0, -1)
-        cwriter.addData4f(*color)
-
-        for i in range(segments):
-            angle = 2 * math.pi * i / segments
-            x = r * math.cos(angle)
-            y = r * math.sin(angle)
-            vwriter.addData3f(x, y, bottom_z)
-            nwriter.addData3f(0, 0, -1)
-            cwriter.addData4f(*color)
-
-        top_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_triangles.addVertices(0, i, next_i)
-            top_triangles.closePrimitive()
-
-        bottom_center = segments + 1
-        bottom_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(segments):
-            curr = segments + 2 + i
-            next_i = segments + 2 if i == segments - 1 else curr + 1
-            bottom_triangles.addVertices(bottom_center, next_i, curr)
-            bottom_triangles.closePrimitive()
-
-        side_triangles = GeomTriangles(Geom.UHStatic)
-        for i in range(1, segments + 1):
-            next_i = 1 if i == segments else i + 1
-            top_i = i
-            bottom_i = segments + 1 + i
-            bottom_next = segments + 1 + next_i
-            side_triangles.addVertices(top_i, next_i, bottom_next)
-            side_triangles.closePrimitive()
-            side_triangles.addVertices(top_i, bottom_next, bottom_i)
-            side_triangles.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(top_triangles)
-        geom.addPrimitive(bottom_triangles)
-        geom.addPrimitive(side_triangles)
-        node = GeomNode("cylinder")
-        node.addGeom(geom)
-        return node
-
-
-    def create_box(self, width, depth, height, color):
-        fmt = GeomVertexFormat.getV3n3cp()
-        vdata = GeomVertexData("box", fmt, Geom.UHStatic)
-        vertex = GeomVertexWriter(vdata, "vertex")
-        normal = GeomVertexWriter(vdata, "normal")
-        col = GeomVertexWriter(vdata, "color")
-
-        for v in [(0, 0, 0), (width, 0, 0), (width, depth, 0), (0, depth, 0)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, -1)
-            col.addData4f(*color)
-        for v in [(0, 0, height), (width, 0, height), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 0, 1)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (width, 0, 0), (width, 0, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, -1, 0)
-            col.addData4f(*color)
-        for v in [(0, depth, 0), (width, depth, 0), (width, depth, height), (0, depth, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(0, 1, 0)
-            col.addData4f(*color)
-        for v in [(0, 0, 0), (0, depth, 0), (0, depth, height), (0, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(-1, 0, 0)
-            col.addData4f(*color)
-        for v in [(width, 0, 0), (width, depth, 0), (width, depth, height), (width, 0, height)]:
-            vertex.addData3f(*v)
-            normal.addData3f(1, 0, 0)
-            col.addData4f(*color)
-
-        tris = GeomTriangles(Geom.UHStatic)
-        for i in range(6):
-            base = i * 4
-            tris.addVertices(base, base + 1, base + 2)
-            tris.closePrimitive()
-            tris.addVertices(base, base + 2, base + 3)
-            tris.closePrimitive()
-
-        geom = Geom(vdata)
-        geom.addPrimitive(tris)
-        node = GeomNode("box")
-        node.addGeom(geom)
-        return node
-
-    def create_box_edges(self, width, depth, height, color):
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(width, 0, 0)
-        ls.drawTo(width, depth, 0)
-        ls.drawTo(0, depth, 0)
-        ls.drawTo(0, 0, 0)
-        ls.moveTo(0, 0, height)
-        ls.drawTo(width, 0, height)
-        ls.drawTo(width, depth, height)
-        ls.drawTo(0, depth, height)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, height)
-        ls.moveTo(width, 0, 0)
-        ls.drawTo(width, 0, height)
-        ls.moveTo(width, depth, 0)
-        ls.drawTo(width, depth, height)
-        ls.moveTo(0, depth, 0)
-        ls.drawTo(0, depth, height)
-        return NodePath(ls.create())
-
-    # ---------------6. Paket- & Auftragsverwaltung---------------
-        # Beispiel einer Methode, die weiterhin auf die extrahierten Umgebungselemente zugreift:
-    def spawn_package_at_station(self, station):
-        pos = station.getPos(self.render)
-        package = self.erzeuge_wuerfel(pos.x, pos.y, pos.z, LColor(1, 1, 0, 1))
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-
-        # Paket eintragen
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-        self.last_removed[station] = self.sim_clock
-
-        # Je nach gewählter Verteilung kannst du hier Anpassungen vornehmen.
-        # Für den Moment wählen wir einfach zufällig aus allen Abgabestationen,
-        # falls keine spezielle Logik für die Verteilung implementiert ist.
-        target_index = random.randint(1, len(self.abgabe_stations))
-
-        order = {
-            "id": self.next_order_id,
-            "status": "Wartend",
-            "ziel": f"Abgabestation {target_index}",
-            "annahmestation": station.getName(),
-            "pickup_station": station,
-            "package": package,
-            "timer_np": timer_np,
-            "spawn_time": spawn_time
-        }
-        self.orders[order["id"]] = order
-        self.orders_queue.append(order)
-        self.next_order_id += 1
-
-        print(f"Neuer Auftrag erstellt: {order}")
-
-    def erzeuge_wuerfel(self, x, y, z, color):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        # Hier wird der Höhenoffset innerhalb der Methode gesetzt:
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(color)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in list(self.pickup_packages.items()):
-            # Prüfe, ob der Timer-Knoten noch gültig ist
-            if not timer_np.isEmpty():
-                elapsed = self.sim_clock - spawn_time
-                timer_np.node().setText(f"{elapsed:.1f}s")
-            else:
-                del self.pickup_packages[station]
-        return Task.cont
-
-    def check_and_spawn_packages(self, task):
-        # Verwende den neuen Delay-Wert aus den Einstellungen
-        spawn_delay = self.package_spawn_delay
-        for station in self.annahme_stations:
-            if station not in self.pickup_packages:
-                last_time = self.last_removed.get(station, self.sim_clock)
-                if (self.sim_clock - last_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-        # Beispiel für eine vorhandene Methode, die auf die Umgebungselemente zugreift:
-    def update_order_table(self):
-        # Lösche alle vorhandenen Einträge in der Auftragsliste.
-        for entry in self.order_tree.get_children():
-            self.order_tree.delete(entry)
-
-        # Iteriere über alle Aufträge.
-        for order_id, order in list(self.orders.items()):
-            # Extrahiere aus dem Annahmestationsnamen die Stationsnummer (oder verwende "N/A").
-            pickup_station_str = order.get("annahmestation", "N/A")
-            if pickup_station_str != "N/A" and "_" in pickup_station_str:
-                pickup_number = pickup_station_str.split("_")[-1]
-            else:
-                pickup_number = "N/A"
-
-            # Extrahiere aus dem Ziel (z.B. "Abgabestation 5") die Stationsnummer.
-            target_station_str = order.get("ziel", "N/A")
-            if target_station_str != "N/A" and " " in target_station_str:
-                target_number = target_station_str.split()[-1]
-            else:
-                target_number = "N/A"
-
-            # Zeige den zugewiesenen Fahrzeugnamen an (oder "-" falls noch keiner zugeordnet wurde).
-            vehicle_display = order.get("vehicle", "-")
-
-            self.order_tree.insert("", tk.END,
-                                   values=(order_id, pickup_number, target_number, vehicle_display))
-        self.order_win.update()
-
-    def update_order_status(self, task):
-        # Entferne Aufträge, die den Status "Abgegeben" haben und deren Lieferzeit älter als 2 Sekunden ist.
-        for order_id, order in list(self.orders.items()):
-            if order.get("status") == "Abgegeben" and self.sim_clock - order.get("delivered_at", 0) >= 2:
-                del self.orders[order_id]
-        if hasattr(self, 'order_win') and self.order_win is not None:
-            self.update_order_table()
-        return Task.cont
-
-    def deliver_first_order(self):
-        # Diese Methode wird beim Paket-Zustellen aufgerufen.
-        for order_id, order in self.orders.items():
-            if order.get("status") == "Wartend":
-                order["status"] = "Abgegeben"
-                order["delivered_at"] = self.sim_clock
-                print(f"Auftrag {order['id']} wurde geliefert.")
-                break
-
-    # ---------------7. Cargo-Handling (Pickup, Drop & Timer)---------------
-    def pickup_package(self, vehicle, station):
-        # Falls das Fahrzeug bereits ein Paket trägt, abbrechen.
-        if vehicle.getPythonTag("package_attached"):
-            return
-
-        # Führe den Pickup nur aus, wenn an der Station ein Paket vorhanden ist.
-        if station in self.pickup_packages:
-            # Hole das Paket, den Spawn-Zeitpunkt und den zugehörigen Timer-Knoten.
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            # Entferne den Timer-Knoten, sodass der angezeigte Zähler nicht weiter aktualisiert wird.
-            timer_np.removeNode()
-            # Berechne die Liegedauer (Differenz zwischen aktueller Simulationszeit und Spawn-Zeit).
-            dwell_time = self.sim_clock - spawn_time
-            # Aktualisiere globale Kennzahlen.
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            # Suche in den Aufträgen nach dem Auftrag, dessen Paket mit diesem Paket übereinstimmt,
-            # und speichere den errechneten Endwert (fixe Liegedauer) sowie den Status.
-            for order_id, order in self.orders.items():
-                if order.get("package") == package:
-                    order["dwell_time"] = dwell_time
-                    order["status"] = "Abgeholt"
-                    break
-
-            # Hole Referenzen zum Gabel-Knoten und zum grünen Marker des Fahrzeugs.
-            fork_node = vehicle.getPythonTag("fork_node")
-            fork_green = vehicle.getPythonTag("fork_green")
-            green_point_pos = fork_green.getPos(fork_node)
-
-            # Übergib das Paket an den Gabel-Knoten (sodass es optisch dem Fahrzeug zugeordnet wird)
-            # und positioniere es relativ zum grünen Marker.
-            package.wrtReparentTo(fork_node)
-            package.setPos(green_point_pos.getX() + 0.5,
-                           green_point_pos.getY() - 0.5,
-                           green_point_pos.getZ() + 1)
-            self.cargos[vehicle] = package
-
-            # Starte den Lieferzeit-Timer: Speichere den Zeitpunkt, an dem das Paket abgeholt wurde,
-            # und hänge einen neuen Timer-Knoten an das Paket.
-            vehicle.setPythonTag("delivery_start_time", self.sim_clock)
-            from panda3d.core import TextNode
-            delivery_timer_text = TextNode("delivery_timer")
-            delivery_timer_text.setText("0.0s")
-            delivery_timer_np = package.attachNewNode(delivery_timer_text)
-            delivery_timer_np.setScale(0.5)
-            delivery_timer_np.setPos(0, 0, 1.2)
-            package.setPythonTag("delivery_timer", delivery_timer_np)
-
-            # Aktualisiere den Zeitpunkt, zu dem an dieser Station zuletzt ein Paket entfernt wurde.
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            # Paket wird in Fahrzeug-Nähe abgelegt (kleiner Z-Offset)
-            targetPos = vehicle.getPos(self.render) + Vec3(1.2, 1, 1)
-            cargo.setPos(targetPos)
-
-            # Berechne Lieferzeit:
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start is not None:
-                delivery_time = self.sim_clock - delivery_start
-                self.total_delivery_time += delivery_time
-                self.total_delivery_count += 1
-                self.max_overall_delivery_time = max(self.max_overall_delivery_time, delivery_time)
-                vehicle.clearPythonTag("delivery_start_time")
-
-            # Entferne den Lieferzeit-Timer vom Paket
-            delivery_timer_np = cargo.getPythonTag("delivery_timer")
-            if delivery_timer_np:
-                delivery_timer_np.removeNode()
-
-            self.delivered_packages += 1
-
-            # Starte einen Task, der nach 3 Sekunden das Paket entfernt
-            taskMgr.doMethodLater(3, self.removeCargoTask, "removeCargoTask", extraArgs=[cargo], appendTask=True)
-
-    def update_delivery_timers(self, task):
-        for vehicle, package in list(self.cargos.items()):
-            delivery_start = vehicle.getPythonTag("delivery_start_time")
-            if delivery_start:
-                elapsed_delivery = self.sim_clock - delivery_start
-                delivery_timer_np = package.getPythonTag("delivery_timer")
-                if delivery_timer_np and not delivery_timer_np.isEmpty():
-                    delivery_timer_np.node().setText(f"{elapsed_delivery:.1f}s")
-        return Task.cont
-
-    def removeCargoTask(self, cargo, task):
-        cargo.removeNode()  # Entfernt das Paket aus der Szene
-        return task.done
-
-
-    # ---------------8. Auftrags-/Fahrzeuglogik---------------
-    def select_next_order(self, vehicle):
-        # Sammle alle Aufträge, die noch "Wartend" sind
-        waiting_orders = [order for order in self.orders.values() if order.get("status") == "Wartend"]
-        if not waiting_orders:
-            return None
-
-        # Aktualisiere die Dwell-Zeit für jeden Auftrag
-        for order in waiting_orders:
-            order["dwell_time"] = self.sim_clock - order.get("spawn_time", self.sim_clock)
-
-        # Wähle den Auftrag mit der maximalen Dwell-Zeit (evtl. mit etwas Toleranz)
-        max_dwell = max(order["dwell_time"] for order in waiting_orders)
-        tolerance = 0.01
-        candidates = [order for order in waiting_orders if abs(order["dwell_time"] - max_dwell) < tolerance]
-        if not candidates:
-            candidates = waiting_orders
-
-        # Finde aus den Kandidaten den Auftrag, dessen Pickup-Station (order["pickup_station"])
-        # am nächsten zur aktuellen Fahrzeugposition liegt.
-        vehicle_pos = vehicle.getPos(self.render)
-        candidates.sort(key=lambda order: (order["pickup_station"].getPos(self.render) - vehicle_pos).length())
-        return candidates[0]
-
-    def show_vehicle_control(self):
-        # Falls das Fenster bereits existiert, wiederverwenden
-        if hasattr(self, "control_win") and self.control_win.winfo_exists():
-            self.control_win.deiconify()
-            self.control_win.lift()
-            self.control_win.focus_force()
-            return
-
-        self.control_win = tk.Toplevel(self.tk_root)
-        self.control_win.title("Kontrollfenster")
-        self.control_win.protocol("WM_DELETE_WINDOW", self.control_win.withdraw)
-        self.control_win.attributes("-topmost", True)
-        self.control_win.after(100, lambda: self.control_win.attributes("-topmost", False))
-
-        # ---------------- Fahrzeugsteuerung ----------------
-        # Zunächst einen Button einfügen, der ALLE Fahrzeuge auf "Aufträge bearbeiten" setzt.
-        all_vehicles_btn = tk.Button(
-            self.control_win,
-            text="Alle Fahrzeuge auf 'Aufträge bearbeiten' setzen",
-            command=lambda: [self.vehicle_state_vars[veh].set("translate") for veh in self.garage_vehicles]
-        )
-        all_vehicles_btn.grid(row=0, column=0, sticky="w", padx=5, pady=5)
-
-        # Nun die einzelnen Fahrzeugzeilen – starte ab Zeile 1
-        self.vehicle_state_vars = {}
-        row = 1
-        for veh in self.garage_vehicles:
-            frame = tk.Frame(self.control_win)
-            frame.grid(row=row, column=0, sticky="w", padx=5, pady=2)
-            vid = veh.getPythonTag("vehicle_id")
-            label = tk.Label(frame, text=f"Fahrzeug {vid}")
-            label.pack(side=tk.LEFT)
-            state = veh.getPythonTag("order_state") or "idle"
-            var = tk.StringVar(value=state)
-            self.vehicle_state_vars[veh] = var
-            rb_active = tk.Radiobutton(frame, text="Aufträge bearbeiten", variable=var, value="translate")
-            rb_active.pack(side=tk.LEFT)
-            rb_standby = tk.Radiobutton(frame, text="Standby", variable=var, value="idle")
-            rb_standby.pack(side=tk.LEFT)
-            row += 1
-
-        update_btn = tk.Button(self.control_win, text="Übernehmen", command=self.update_vehicle_control)
-        update_btn.grid(row=row, column=0, pady=5)
-        row += 1
-
-        # ---------------- Spawn-Einstellungen ----------------
-        spawn_frame = tk.LabelFrame(self.control_win, text="Spawn Einstellungen", padx=5, pady=5)
-        spawn_frame.grid(row=row, column=0, sticky="w", padx=5, pady=5)
-
-        # Eingabe der Spawnverzögerung
-        tk.Label(spawn_frame, text="Spawnverzögerung (Sekunden):").grid(row=0, column=0, sticky="w")
-        self.spawn_delay_var = tk.DoubleVar(value=self.package_spawn_delay)
-        delay_entry = tk.Entry(spawn_frame, textvariable=self.spawn_delay_var, width=6)
-        delay_entry.grid(row=0, column=1, sticky="w")
-
-        # Direkt in diesem Spawn-Feld: Button, der alle Annahmestationen auswählt
-        btn_select_all_stations = tk.Button(
-            spawn_frame,
-            text="Alle Annahmestationen auswählen",
-            command=lambda: [self.spawn_station_vars[i].set(True) for i in self.spawn_station_vars]
-        )
-        btn_select_all_stations.grid(row=0, column=2, padx=5)
-
-        # Auswahl der Annahmestationen (Checkbuttons)
-        tk.Label(spawn_frame, text="Annahmestationen:").grid(row=1, column=0, sticky="w", pady=(5, 0))
-        stations_frame = tk.Frame(spawn_frame)
-        stations_frame.grid(row=2, column=0, columnspan=3, sticky="w")
-        for i in range(min(10, len(self.annahme_stations))):
-            cb = tk.Checkbutton(stations_frame, text=f"Annahmestation {i + 1}",
-                                variable=self.spawn_station_vars[i])
-            cb.pack(anchor="w")
-
-        def apply_spawn_from_control():
-            self.package_spawn_delay = self.spawn_delay_var.get()
-            selected = []
-            for i, var in self.spawn_station_vars.items():
-                if var.get():
-                    selected.append(self.annahme_stations[i])
-            self.package_spawn_stations = selected
-            print(
-                f"Spawn Einstellungen übernommen: Delay={self.package_spawn_delay}s, "
-                f"Stations: {[i + 1 for i, var in self.spawn_station_vars.items() if var.get()]}"
-            )
-            # Spawne nur an Stationen, an denen noch kein Paket existiert:
-            for station in self.package_spawn_stations:
-                if station not in self.pickup_packages:
-                    self.spawn_package_at_station(station)
-            # Option: spawn_win schließen oder offen lassen
-            # self.control_win.withdraw()
-
-        apply_btn = tk.Button(
-            spawn_frame,
-            text="Einstellungen übernehmen und spawnen",
-            command=apply_spawn_from_control
-        )
-        apply_btn.grid(row=3, column=0, columnspan=3, pady=5)
-
-    def show_spawn_control(self):
-        spawn_win = tk.Toplevel(self.tk_root)
-        spawn_win.title("Paketspawn Einstellungen")
-
-        # Eingabefeld für Spawnverzögerung
-        tk.Label(spawn_win, text="Spawnverzögerung (Sekunden):").pack(pady=2)
-        delay_entry = tk.Entry(spawn_win)
-        delay_entry.insert(0, str(self.package_spawn_delay))
-        delay_entry.pack(pady=2)
-
-        # (Dropdown für Spawn-Verteilung wurde entfernt)
-
-        # Checkbuttons für die Auswahl der Annahmestationen
-        tk.Label(spawn_win, text="Annahmestationen auswählen (1-10):").pack(pady=2)
-        stations_frame = tk.Frame(spawn_win)
-        stations_frame.pack(pady=2)
-
-        station_vars = {}
-        for idx, station in enumerate(self.annahme_stations):
-            var = tk.BooleanVar(value=False)
-            station_label = f"Annahmestation {idx + 1}"
-            cb = tk.Checkbutton(stations_frame, text=station_label, variable=var)
-            cb.pack(anchor="w")
-            station_vars[idx] = var
-
-        def apply_spawn_settings():
-            try:
-                new_delay = float(delay_entry.get())
-            except ValueError:
-                new_delay = self.package_spawn_delay
-            new_stations = []
-            for idx, var in station_vars.items():
-                if var.get():
-                    new_stations.append(self.annahme_stations[idx])
-
-            self.package_spawn_delay = new_delay
-            self.package_spawn_stations = new_stations
-
-            print(f"Spawn-Einstellungen aktualisiert: Delay={new_delay}s, "
-                  f"Stationen: {[f'Annahmestation {idx + 1}' for idx, var in station_vars.items() if var.get()]}")
-            # Spawne nur dort Pakete, wo noch kein Paket vorhanden ist:
-            for station in self.package_spawn_stations:
-                if station not in self.pickup_packages:
-                    self.spawn_package_at_station(station)
-
-            spawn_win.destroy()
-
-        tk.Button(spawn_win, text="Einstellungen speichern", command=apply_spawn_settings).pack(pady=5)
-
-    def vehicle_order_task(self, vehicle, task):
-        # Berechne dt (berücksichtigt die Simulationsgeschwindigkeit)
-        dt = ClockObject.getGlobalClock().getDt() * self.speed_factor
-
-        # (Optional) Überprüfe, ob ein Zustand gesetzt ist. Bleibt das Fahrzeug in "idle", wird nichts gemacht.
-        state = vehicle.getPythonTag("order_state")
-        if state is None:
-            vehicle.setPythonTag("order_state", "idle")
-            return Task.cont
-        if state == "idle":
-            return Task.cont
-
-        # --- Modellinferenz & Trainingsdatenerfassung ---
-        frame_count = vehicle.getPythonTag("frame_count")
-        if frame_count is None:
-            frame_count = 0
-        frame_count += 1
-        vehicle.setPythonTag("frame_count", frame_count)
-
-        sensor_data = self.collect_sensor_data(vehicle)
-        import numpy as np
-        if self.tf_model is not None and (frame_count % 10 == 0):
-            input_data = sensor_data.reshape(1, sensor_data.shape[0], sensor_data.shape[1], 1)
-            prediction = self.tf_model.predict(input_data)
-            model_delta_angle = prediction[0][0]
-            print(f"[TF] Modell-Korrektur: {model_delta_angle:.2f}°")
-        else:
-            model_delta_angle = 0.0
-            if self.tf_model is not None:
-                print(f"[TF] Modell-Korrektur übersprungen (Frame Count: {frame_count})")
-            else:
-                print("[TF] Kein Modell vorhanden, Modell-Korrektur wird übersprungen.")
-
-        ideal_correction = self.compute_ideal_steering_correction(vehicle)
-        print(f"[IDEAL] Ideal berechneter Korrekturwinkel: {ideal_correction:.2f}°")
-        if state == "translate":
-            self.log_training_sample(sensor_data, ideal_correction)
-        # --- Ende Modellinferenz & Logging ---
-
-        # Zustandsbasierte Handler-Aufrufe:
-        if state == "translate":
-            self.handle_translate_phase(vehicle, dt)
-        elif state == "rotate":
-            self.handle_rotate_phase(vehicle, dt)
-        elif state == "approach":
-            self.handle_approach_phase(vehicle, dt)
-        elif state == "pickup":
-            self.handle_pickup_phase(vehicle, dt)
-        elif state == "drive_out":
-            self.handle_drive_out_phase(vehicle, dt)
-        elif state == "to_delivery":
-            self.handle_to_delivery_phase(vehicle, dt)
-        elif state == "align_delivery":
-            self.handle_align_delivery_phase(vehicle, dt)
-        elif state == "delivery_center":
-            self.handle_delivery_center_phase(vehicle, dt)
-        elif state == "drop":
-            self.handle_drop_phase(vehicle, dt)
-        elif state == "delivery_exit":
-            self.handle_drive_out_phase_delivery(vehicle, dt)
-        elif state == "return_to_garage":
-            self.handle_return_to_garage_phase(vehicle, dt)
-        else:
-            print(
-                f"Unbekannter Zustand '{state}' für Fahrzeug {vehicle.getPythonTag('vehicle_id')}. Setze auf 'translate'.")
-            vehicle.setPythonTag("order_state", "translate")
-
-        return Task.cont
-
-    # -------------------- Handler für einzelne Phasen --------------------
-
-    def handle_translate_phase(self, vehicle, dt):
-        import math
-        from panda3d.core import Vec3
-
-        current_order = vehicle.getPythonTag("current_order")
-        station_occupied = False
-        if current_order is not None and "pickup_station" in current_order:
-            pickup_station = current_order["pickup_station"]
-            # Login-Mechanismus: Wenn noch niemand eingeloggt ist, logge dieses Fahrzeug ein.
-            occupant = pickup_station.getPythonTag("occupied_by")
-            if occupant is None:
-                pickup_station.setPythonTag("occupied_by", vehicle)
-                print(
-                    f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} loggt sich an Pickup-Station {pickup_station.getName()}.")
-            elif occupant != vehicle:
-                station_occupied = True
-                print(
-                    f"[WARTEN] Pickup-Station {pickup_station.getName()} bereits besetzt durch Fahrzeug {occupant.getPythonTag('vehicle_id')}.")
-        # Falls die Station blockiert ist, steht die Basisgeschwindigkeit auf 0.
-        base_speed = 1.5 if not station_occupied else 0.0
-        adjusted_speed = self.collision_avoidance_adjustment(vehicle, base_speed)
-
-        # Falls noch kein Auftrag zugewiesen, wähle einen neuen Auftrag.
-        if current_order is None:
-            next_order = self.select_next_order(vehicle)
-            if next_order is not None:
-                next_order["status"] = "In Bearbeitung"
-                next_order["vehicle"] = f"Fahrzeug {vehicle.getPythonTag('vehicle_id')}"
-                vehicle.setPythonTag("current_order", next_order)
-                print(f"Auftrag {next_order['id']} wird zugewiesen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}.")
-            current_order = vehicle.getPythonTag("current_order")
-
-        # Bestimme das Ziel: Verwende den blauen Marker der Pickup-Station oder den allgemeinen blauen Marker.
-        if current_order is not None:
-            pickup_station = current_order.get("pickup_station")
-            if pickup_station in self.station_blue_dots:
-                target = self.station_blue_dots[pickup_station].getPos(self.render)
-            else:
-                target = self.blue_dot.getPos(self.render)
-        else:
-            target = self.blue_dot.getPos(self.render)
-
-        current_pos = vehicle.getPos(self.render)
-        pivot = vehicle.getPythonTag("steering_axis")
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-        heading_error = desired_heading_rad - current_heading_rad
-        while heading_error > math.pi:
-            heading_error -= 2 * math.pi
-        while heading_error < -math.pi:
-            heading_error += 2 * math.pi
-
-        gain = 1.0
-        max_delta = gain * dt
-        delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-        self.rotate_around_pivot(vehicle, pivot, math.degrees(delta_heading_rad))
-
-        global_hpr = pivot.getNetTransform().getHpr()
-        new_heading_rad = math.radians(global_hpr.getX())
-        new_x = current_pos.getX() + adjusted_speed * math.cos(new_heading_rad) * dt
-        new_y = current_pos.getY() + adjusted_speed * math.sin(new_heading_rad) * dt
-        new_pos = Vec3(new_x, new_y, 0)
-        vehicle.setPos(new_pos)
-
-        new_offset_pos = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        if (target - new_offset_pos).length() < 0.1:
-            vehicle.setPythonTag("order_state", "rotate")
-        return Task.cont
-
-    def handle_rotate_phase(self, vehicle, dt):
-        import math
-        # Diese Methode sorgt dafür, dass das Fahrzeug sich dreht, bis sein Pivot-Heading
-        # dem gewünschten Winkel entspricht. Wir nehmen hier als Basis den Winkel der
-        # grünen Mittellinie der Gabel (fork_center_line) als Referenz.
-
-        # Hole den Pivot-Knoten (z. B. "steering_axis")
-        pivot = vehicle.getPythonTag("steering_axis")
-        if not pivot:
-            print(f"[Rotate] Kein Steering-Axis für Fahrzeug {vehicle.getPythonTag('vehicle_id')} gefunden.")
-            return Task.cont
-
-        # Beispielhafter Zielwinkel:
-        # Hier gehen wir davon aus, dass die gewünschte Ausrichtung für die Rotation
-        # in einer Variablen oder einem festgelegten Wert liegt.
-        # Alternativ kannst du den Zielwinkel auch mithilfe eines Markers (etwa der weiß markierten Linie) berechnen.
-        # Für dieses Beispiel nehmen wir an, der gewünschte Endwinkel soll dem Winkel der grünen Mittellinie entsprechen.
-        try:
-            # Wir greifen hier auf den existierenden Node "fork_center_line" zu.
-            fork_center_line = vehicle.getPythonTag("fork_center_line")
-            if fork_center_line:
-                # Der aktuelle globale Heading vom Pivot:
-                current_heading = pivot.getNetTransform().getHpr().getX() % 360
-                # Nehmen wir an, der Zielwert für die Rotation ist, dass die Gabel genau auf 0° ausgerichtet sein soll:
-                target_heading = 0.0
-                # Du kannst hier auch andere Logik einbauen, z. B. der Winkel der weißen Linie plus einem Offset.
-            else:
-                target_heading = 0.0
-                current_heading = pivot.getNetTransform().getHpr().getX() % 360
-        except Exception as e:
-            print(f"[Rotate] Fehler beim Ermitteln des Zielwinkels: {e}")
-            return Task.cont
-
-        # Berechne den kleinsten Winkelunterschied (normiert auf [-180, 180])
-        error = (target_heading - current_heading + 180) % 360 - 180
-
-        # Debug-Ausgabe
-        print(
-            f"[Rotate] Fahrzeug {vehicle.getPythonTag('vehicle_id')}: Current Heading = {current_heading:.2f}°, Target = {target_heading:.2f}°, Error = {error:.2f}°")
-
-        # Wenn der Fehler klein genug ist, wechseln wir in die nächste Phase.
-        if abs(error) < 1.0:
-            vehicle.setPythonTag("order_state", "approach")
-            print(f"[Rotate] Fahrzeug {vehicle.getPythonTag('vehicle_id')} beendet Rotation, wechselt in 'approach'.")
-            return Task.cont
-
-        # Berechne den Drehschritt: Mit einer festen maximalen Rotationsgeschwindigkeit, z.B. 90°/s.
-        turn_speed = 90.0  # Grad pro Sekunde
-        max_turn = turn_speed * dt
-        turn_angle = max(-max_turn, min(max_turn, error))
-
-        # Wende die Drehung über die Methode rotate_around_pivot an:
-        self.rotate_around_pivot(vehicle, pivot, turn_angle)
-
-        return Task.cont
-
-    def handle_approach_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None:
-            pickup_station = current_order.get("pickup_station")
-            target = pickup_station.getPos(self.render) + Vec3(1.2, 1, 0)
-        else:
-            target = self.station_green_dot.getPos(self.render) + Vec3(1.2, 1, 0)
-        current = vehicle.getPos(self.render)
-        error_vec = Vec2(target.getX() - current.getX(), target.getY() - current.getY())
-        if error_vec.length() > 0.05:
-            direction = error_vec.normalized()
-            move_distance = 1.5 * dt
-            new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                           current.getY() + direction.getY() * move_distance, target.getZ())
-            vehicle.setPos(new_pos)
-        else:
-            vehicle.setPos(target)
-            vehicle.setPythonTag("order_state", "pickup")
-
-    def handle_pickup_phase(self, vehicle, dt):
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        target_z = 1.0
-        raise_speed = 0.5
-        if current_z < target_z:
-            fork_node.setZ(min(target_z, current_z + raise_speed * dt))
-        else:
-            if vehicle.getPythonTag("current_order") is None:
-                if self.orders_queue:
-                    vehicle.setPythonTag("current_order", self.orders_queue.pop(0))
-                else:
-                    print(
-                        f"Keine verfügbaren Aufträge für Fahrzeug {vehicle.getPythonTag('vehicle_id')}. Überspringe Pickup-Phase.")
-                    vehicle.setPythonTag("order_state", "drive_out")
-                    return
-            if not vehicle.getPythonTag("package_attached"):
-                pickup_station = vehicle.getPythonTag("current_order")["pickup_station"]
-                self.pickup_package(vehicle, pickup_station)
-                vehicle.setPythonTag("package_attached", True)
-            if vehicle.getPythonTag("drive_out_target") is None:
-                vehicle.setPythonTag("drive_out_target",
-                                     vehicle.getPos(self.render) + vehicle.getQuat(self.render).getForward() * 5.0)
-            vehicle.setPythonTag("order_state", "drive_out")
-
-    def handle_drive_out_phase(self, vehicle, dt):
-        from panda3d.core import Vec3
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        if current_z > 0:
-            lower_speed = 0.5
-            fork_node.setZ(max(0, current_z - lower_speed * dt))
-        current_pos = vehicle.getPos(self.render)
-        drive_out_target = vehicle.getPythonTag("drive_out_target")
-        if drive_out_target is None:
-            drive_out_target = current_pos + vehicle.getQuat(self.render).getForward() * 5.0
-            vehicle.setPythonTag("drive_out_target", drive_out_target)
-        diff = drive_out_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            # Sobald das Fahrzeug seinen Drive-Out erreicht hat, geben wir den Lock an der Pickup-Station frei
-            current_order = vehicle.getPythonTag("current_order")
-            if current_order is not None and "pickup_station" in current_order:
-                pickup_station = current_order["pickup_station"]
-                # Ersetze clearPythonTag durch setPythonTag(..., None) für die Freigabe
-                pickup_station.setPythonTag("occupied_by", None)
-                print(
-                    f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} verlässt Pickup-Station {pickup_station.getName()} und entsperrt diese.")
-            vehicle.setPythonTag("order_state", "to_delivery")
-            vehicle.setPythonTag("drive_out_target", None)
-        return Task.cont
-
-    def handle_to_delivery_phase(self, vehicle, dt):
-        import math
-        from panda3d.core import Vec3
-
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is None:
-            return Task.cont
-
-        # Bestimme das Ziel: Verwende den blauen Marker der Abgabestation (z. B. "Abgabestation 3")
-        try:
-            target_index = int(current_order.get("ziel", "Abgabestation 1").split()[-1])
-        except Exception:
-            target_index = 1
-        if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-            target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-        else:
-            target = self.abgabe_blue_dots[0].getPos(self.render)
-
-        current_pos = vehicle.getPos(self.render)
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-
-        # Prüfe, ob an der Abgabestation bereits ein Fahrzeug in einem blockierenden Zustand ist.
-        if self.is_delivery_station_occupied(target, exclude_vehicle=vehicle):
-            print(f"[WARTEN] Abgabestation blockiert. Fahrzeug {vehicle.getPythonTag('vehicle_id')} wartet.")
-            return Task.cont
-
-        # Berechne den gewünschten Basiswinkel vom Offset-Punkt zum Ziel.
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-        pivot = vehicle.getPythonTag("steering_axis")
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-        heading_error = desired_heading_rad - current_heading_rad
-        while heading_error > math.pi:
-            heading_error -= 2 * math.pi
-        while heading_error < -math.pi:
-            heading_error += 2 * math.pi
-
-        gain = 1.0
-        max_delta = gain * dt
-        delta_heading_rad = max(-max_delta, min(max_delta, heading_error))
-        self.rotate_around_pivot(vehicle, pivot, math.degrees(delta_heading_rad))
-
-        global_hpr = pivot.getNetTransform().getHpr()
-        new_heading_rad = math.radians(global_hpr.getX())
-        adjusted_speed = self.collision_avoidance_adjustment(vehicle, base_speed=1.5)
-        new_x = current_pos.getX() + adjusted_speed * math.cos(new_heading_rad) * dt
-        new_y = current_pos.getY() + adjusted_speed * math.sin(new_heading_rad) * dt
-        new_pos = Vec3(new_x, new_y, current_pos.getZ())
-        vehicle.setPos(new_pos)
-
-        new_offset_pos = vehicle.getPos(self.render) + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        if (target - new_offset_pos).length() < 0.1:
-            vehicle.setPythonTag("order_state", "align_delivery")
-        return Task.cont
-
-    def handle_align_delivery_phase(self, vehicle, dt):
-        import math
-
-        # 1. Ermittle den Basiszielwinkel aus der weißen Linie der Abgabestation.
-        # Wir gehen davon aus, dass self.abgabe_white_line existiert und den globalen Heading liefert.
-        try:
-            base_target_heading = self.abgabe_white_line.getH(self.render) % 360
-        except Exception as e:
-            base_target_heading = 90.0
-            print(
-                f"[Align Delivery] Warning: self.abgabe_white_line nicht gefunden, verwende Default {base_target_heading}°.")
-
-        # 2. Füge den zusätzlichen Versatz von 90° hinzu.
-        # Das bedeutet: Der gewünschte End-Heading ist 90° mehr als der von der weißen Linie gemessene Winkel.
-        desired_heading = (base_target_heading + 90) % 360
-
-        # 3. Ermittle den aktuellen globalen Heading über den Pivot-Knoten (z. B. steering_axis).
-        pivot = vehicle.getPythonTag("steering_axis")
-        pivot_hpr = pivot.getNetTransform().getHpr()
-        current_heading = pivot_hpr.getX() % 360
-
-        # 4. Berechne den minimalen Winkelunterschied (normiert auf [-180, 180]).
-        error = desired_heading - current_heading
-        while error > 180:
-            error -= 360
-        while error < -180:
-            error += 360
-
-        print(f"[Align Delivery] Vehicle {vehicle.getPythonTag('vehicle_id')}: "
-              f"Current Pivot Heading: {current_heading:.2f}°, "
-              f"Desired Heading: {desired_heading:.2f}° (Basis: {base_target_heading:.2f}°+90°), "
-              f"Error: {error:.2f}°")
-
-        # 5. Falls der Fehler sehr klein ist (< 1°), gilt die Ausrichtung als abgeschlossen.
-        if abs(error) < 1.0:
-            # Optional: kleine abschließende Korrektur
-            self.rotate_around_pivot(vehicle, pivot, error)
-            vehicle.setPythonTag("order_state", "delivery_center")
-            print(f"[Align Delivery] Alignment complete for vehicle {vehicle.getPythonTag('vehicle_id')}.")
-            return Task.cont
-
-        # 6. Berechne den Drehschritt (proportional, begrenzt durch einen festen maximalen Drehwinkel pro Frame).
-        turn_speed = 90.0  # maximale Drehgeschwindigkeit in Grad pro Sekunde
-        max_turn = turn_speed * dt
-        turn_angle = max(-max_turn, min(max_turn, error))
-
-        # 7. Drehe das Fahrzeug über den Pivot-Knoten.
-        self.rotate_around_pivot(vehicle, pivot, turn_angle)
-
-        return Task.cont
-
-    def handle_delivery_center_phase(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is None:
-            return
-        delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-        try:
-            target_index = int(delivery_target_str.split()[-1])
-        except ValueError:
-            target_index = 1
-        if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-            blue_target = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-        else:
-            blue_target = self.abgabe_blue_dots[0].getPos(self.render)
-        current = vehicle.getPos(self.render)
-        target_point = Vec3(blue_target.getX() + 2.3, blue_target.getY() - 0.5, current.getZ())
-        print(f"Phase 9: Zielpunkt der Abgabestation für Fahrzeug {vehicle.getPythonTag('vehicle_id')}: {target_point}")
-        error_vec = Vec2(target_point.getX() - current.getX(), target_point.getY() - current.getY())
-        tolerance = 0.05
-        move_distance = 1.5 * dt
-        if error_vec.length() > tolerance:
-            direction = error_vec.normalized()
-            new_pos = Vec3(current.getX() + direction.getX() * move_distance,
-                           current.getY() + direction.getY() * move_distance, current.getZ())
-            vehicle.setPos(new_pos)
-            print(f"Phase 9: Fahrzeug {vehicle.getPythonTag('vehicle_id')} bewegt sich von {current} nach {new_pos}")
-        else:
-            vehicle.setPos(target_point)
-            print(f"Phase 9: Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den Zielpunkt erreicht.")
-            vehicle.setPythonTag("order_state", "drop")
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_fork_z = fork_node.getZ()
-        if current_fork_z < 1.0:
-            new_fork_z = min(1.0, current_fork_z + 0.5 * dt)
-            fork_node.setZ(new_fork_z)
-            print(
-                f"Phase 9: Gabel wird angehoben für Fahrzeug {vehicle.getPythonTag('vehicle_id')} (Z = {new_fork_z}).")
-
-    def handle_drop_phase(self, vehicle, dt):
-        # Falls das Fahrzeug ein Paket trägt, wird dieses abgesetzt.
-        if vehicle.getPythonTag("package_attached"):
-            self.drop_cargo(vehicle)
-            print(f"Phase 10: Paket abgesetzt für Fahrzeug {vehicle.getPythonTag('vehicle_id')}")
-            vehicle.setPythonTag("package_attached", False)
-        else:
-            # Falls die Gabel noch abgesenkt werden muss:
-            fork_node = vehicle.getPythonTag("fork_node")
-            current_z = fork_node.getZ()
-            if current_z > 0:
-                lower_speed = 0.5
-                fork_node.setZ(max(0, current_z - lower_speed * dt))
-            print(f"Phase 10: Dropoff abgeschlossen für Fahrzeug {vehicle.getPythonTag('vehicle_id')}")
-
-        # Setze den Zustand nun auf "delivery_exit", damit das Fahrzeug aus dem Lieferbereich herausfährt.
-        vehicle.setPythonTag("order_state", "delivery_exit")
-        # Optional: den Auftrag als "Abgegeben" markieren und löschen.
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None:
-            current_order["status"] = "Abgegeben"
-            current_order["delivered_at"] = self.sim_clock
-        vehicle.clearPythonTag("current_order")
-
-        return Task.cont
-
-    def handle_drive_out_phase_delivery(self, vehicle, dt):
-        from panda3d.core import Vec3
-        fork_node = vehicle.getPythonTag("fork_node")
-        current_z = fork_node.getZ()
-        if current_z > 0:
-            lower_speed = 0.5
-            fork_node.setZ(max(0, current_z - lower_speed * dt))
-        current_pos = vehicle.getPos(self.render)
-        drive_out_target = vehicle.getPythonTag("drive_out_target")
-        if drive_out_target is None:
-            drive_out_target = current_pos + vehicle.getQuat(self.render).getForward() * 5.0
-            vehicle.setPythonTag("drive_out_target", drive_out_target)
-        diff = drive_out_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            # Sobald das Fahrzeug seinen Drive-Out im Lieferbereich erreicht hat, geben wir den Lock frei
-            current_order = vehicle.getPythonTag("current_order")
-            if current_order is not None:
-                try:
-                    target_index = int(current_order.get("ziel", "Abgabestation 1").split()[-1])
-                except Exception:
-                    target_index = 1
-                if 0 <= target_index - 1 < len(self.abgabe_stations):
-                    delivery_station = self.abgabe_stations[target_index - 1]
-                else:
-                    delivery_station = self.abgabe_stations[0]
-                # Freigabe des Locks an der Delivery-Station
-                delivery_station.setPythonTag("occupied_by", None)
-                print(
-                    f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} verlässt Delivery-Station {delivery_station.getName()} und entsperrt diese.")
-            vehicle.setPythonTag("order_state", "translate")
-            vehicle.setPythonTag("drive_out_target", None)
-            print(
-                f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den Lieferbereich verlassen und wechselt in 'translate'.")
-        return Task.cont
-
-    def handle_phase11(self, vehicle, dt):
-        current_order = vehicle.getPythonTag("current_order")
-        if vehicle.getPythonTag("last_delivery_marker") is not None:
-            target_point = vehicle.getPythonTag("last_delivery_marker")
-        else:
-            delivery_target_str = current_order.get("ziel", "Abgabestation 1")
-            try:
-                target_index = int(delivery_target_str.split()[-1])
-            except ValueError:
-                target_index = 1
-            if 0 <= target_index - 1 < len(self.abgabe_blue_dots):
-                target_point = self.abgabe_blue_dots[target_index - 1].getPos(self.render)
-            else:
-                target_point = self.abgabe_blue_dots[0].getPos(self.render)
-        print(f"Phase 11: Zielpunkt (blauer Marker) für Fahrzeug {vehicle.getPythonTag('vehicle_id')}: {target_point}")
-        current_pos = vehicle.getPos(self.render)
-        diff = target_point - current_pos
-        if diff.length() > 0.1:
-            move_distance = 0.5 * dt
-            step = diff.normalized() * move_distance
-            new_pos = current_pos + step
-            vehicle.setPos(new_pos)
-            print(
-                f"Phase 11: Fahrzeug {vehicle.getPythonTag('vehicle_id')} fährt aus der Station, neue Position: {new_pos}")
-        else:
-            vehicle.setPos(target_point)
-            print(
-                f"Phase 11: Fahrzeug {vehicle.getPythonTag('vehicle_id')} hat den blauen Marker erreicht. Nächster Auftrag wird gestartet.")
-            vehicle.setPythonTag("order_state", "next_order")
-
-    def handle_return_to_garage_phase(self, vehicle, dt):
-        garage_target = vehicle.getPythonTag("garage_target")
-        if garage_target is None:
-            garage_target = self.garagen_parking_points[0]
-        current_pos = vehicle.getPos(self.render)
-        diff = garage_target - current_pos
-        if diff.length() > 0.1:
-            move_distance = 1.0 * dt
-            new_pos = current_pos + diff.normalized() * move_distance
-            new_pos.setZ(0)
-            vehicle.setPos(new_pos)
-        else:
-            if vehicle.hasPythonTag("start_heading"):
-                vehicle.setH(vehicle.getPythonTag("start_heading"))
-            vehicle.setPythonTag("order_state", "idle")
-            vehicle.setPythonTag("standby_pending", False)
-            print(f"Fahrzeug {vehicle.getPythonTag('vehicle_id')} ist in der Garage (Standby).")
-
-    def collect_sensor_data(self, vehicle, sensor_range=5, grid_resolution=0.5):
-        """
-        Erzeugt ein einfaches 2D-Occupancy-Grid, das den Bereich um das Fahrzeug simuliert.
-
-        Parameter:
-          sensor_range: Radius (in Welt-Einheiten) um das Fahrzeug.
-          grid_resolution: Größe der einzelnen Zellen im Grid.
-
-        Rückgabe:
-          Ein NumPy-Array (2D) mit 0 (frei) als Platzhalter.
-        """
-        import numpy as np
-        grid_size = int((sensor_range * 2) / grid_resolution)
-        sensor_grid = np.zeros((grid_size, grid_size))
-        # --- Hier kannst du später echte Kollisionsabfragen oder Ray-Casting integrieren ---
-        return sensor_grid
-
-    def compute_ideal_steering_correction(self, vehicle):
-        """
-        Berechnet einen idealen Korrekturwinkel (in Grad) für die Navigation in der 'translate'-Phase.
-        Es wird ein vereinfachtes Modell genutzt, das den Unterschied zwischen dem gewünschten und dem aktuellen
-        Heading (über die Fahrzeug-Steuerachse) ermittelt.
-        """
-        import math
-
-        current_order = vehicle.getPythonTag("current_order")
-        if current_order is not None and "pickup_station" in current_order:
-            pickup_station = current_order["pickup_station"]
-            if pickup_station in self.station_blue_dots:
-                target = self.station_blue_dots[pickup_station].getPos(self.render)
-            else:
-                target = self.blue_dot.getPos(self.render)
-        else:
-            target = self.blue_dot.getPos(self.render)
-
-        current_pos = vehicle.getPos(self.render)
-        # Bestimme einen Offset-Punkt, basierend auf der bereits existierenden pickup_offset
-        offset_pos = current_pos + vehicle.getQuat(self.render).xform(self.pickup_offset)
-        # Berechne den gewünschten Heading-Winkel (in Radiant): Richtung von offset_pos zu target
-        desired_heading_rad = math.atan2(target.getY() - offset_pos.getY(),
-                                         target.getX() - offset_pos.getX())
-
-        # Hole den aktuellen Heading-Wert vom Steuerachsen-Node (pivot)
-        pivot = vehicle.getPythonTag("steering_axis")
-        global_hpr = pivot.getNetTransform().getHpr()
-        current_heading_rad = math.radians(global_hpr.getX())
-
-        ideal_correction_rad = desired_heading_rad - current_heading_rad
-        # Winkelbereich anpassen [-pi, pi]
-        while ideal_correction_rad > math.pi:
-            ideal_correction_rad -= 2 * math.pi
-        while ideal_correction_rad < -math.pi:
-            ideal_correction_rad += 2 * math.pi
-
-        return math.degrees(ideal_correction_rad)
-
-    def compute_avoidance_angle(self, current_vehicle, safe_distance=3.0):
-        """
-        Berechnet einen zusätzlichen Ausweichwinkel (in Grad) basierend auf den
-        Positionen anderer Fahrzeuge. Fahrzeuge, die sehr nah sind, sollen einen
-        höheren Einfluss haben. Der Rückgabewert wird mit einem Gewichtungsfaktor
-        multipliziert, sodass der Ausweichimpuls moderat bleibt.
-        """
-        import math
-        from panda3d.core import Vec2
-
-        current_pos = current_vehicle.getPos(self.render)
-        avoidance_vector = Vec2(0, 0)
-
-        # Schleife über alle Fahrzeuge (außer dem eigenen)
-        for other in self.garage_vehicles:
-            if other == current_vehicle:
-                continue
-            other_pos = other.getPos(self.render)
-            diff = Vec2(current_pos.getX() - other_pos.getX(),
-                        current_pos.getY() - other_pos.getY())
-            dist = diff.length()
-            if dist > 0 and dist < safe_distance:
-                # Je näher das Fahrzeug, desto größer der Einfluss (gewichtete Summe)
-                weight = (safe_distance - dist) / safe_distance
-                avoidance_vector += diff.normalized() * weight
-
-        # Falls kein Fahrzeug in der Nähe ist, wird kein Ausweichwinkel angewendet.
-        if avoidance_vector.length() == 0:
-            return 0.0
-
-        # Berechne den Winkel, den der resultierende Ausweichvektor vorgibt.
-        avoidance_angle = math.degrees(math.atan2(avoidance_vector.getY(), avoidance_vector.getX()))
-        # Mit einem Faktor abschwächen, um den Einfluss zu mildern.
-        weight_factor = 0.5  # Passe diesen Faktor bei Bedarf an (0 = kein Ausweichen, 1 = voll)
-        return avoidance_angle * weight_factor
-
-    def log_training_sample(self, sensor_data, ideal_angle):
-        """
-        Speichert ein Trainingssample bestehend aus den gesammelten Sensorwerten und dem idealen Korrekturwinkel.
-        """
-        self.training_data.append((sensor_data.copy(), ideal_angle))
-        # Optional: Gib eine Debug-Ausgabe aus, um das Logging zu überwachen.
-        print(
-            f"[LOG] Trainingssample gespeichert: Ideal Correction = {ideal_angle:.2f}°, Sensor Shape = {sensor_data.shape}")
-
-    def apply_safety_rules(self, vehicle, sensor_data, model_delta_angle, ideal_correction):
-        """
-        Kombiniert den vom Modell (model_delta_angle) und den ideal berechneten Korrekturwert (ideal_correction)
-        nur dann mit einem festen Sicherheitswert, wenn die Sensordaten einen kritischen Occupancy-Level anzeigen.
-
-        Falls der Occupancy-Level niedrig ist, wird ausschließlich der ideal vorhandene Korrekturwert verwendet.
-        """
-        import numpy as np
-        # Beispiel: Untersuche die mittlere Zeile des sensor_data-Grids als Indikator für frontale Hindernisse
-        middle_row = sensor_data[sensor_data.shape[0] // 2]
-        occupancy_level = np.sum(middle_row)
-
-        # Definiere einen kritischen Schwellenwert (diesen Wert ggf. anpassen)
-        threshold = 1.0
-
-        if occupancy_level > threshold:
-            print(
-                f"[RULE] Kritischer Occupancy-Level = {occupancy_level:.2f} erkannt. Sicherheitskorrektur wird angewendet.")
-            # Hier legen wir fest, dass in kritischen Situationen der Sicherheitswert stärker gewichtet wird.
-            safety_correction = 15.0  # z. B. 15° als feste Korrektur (Wert anpassen)
-            # Gewichteter Ansatz: Sicherheitskorrektur dominiert, während ein kleiner Anteil des idealen Wertes einfließt.
-            final_angle = 0.7 * safety_correction + 0.3 * ideal_correction
-        else:
-            # Wenn kein kritischer Wert vorliegt, einfach den ideal berechneten Korrekturwert verwenden.
-            final_angle = ideal_correction
-
-        return final_angle
-
-    def collision_avoidance_adjustment(self, current_vehicle, base_speed, safe_distance=3.0):
-        """
-        Berechnet eine angepasste Geschwindigkeit für ein Fahrzeug (current_vehicle), sodass
-        dessen Basisgeschwindigkeit (base_speed) entsprechend reduziert wird, wenn andere Fahrzeuge
-        in der Nähe sind. Wenn der Abstand zu einem anderen Fahrzeug unter 1 Einheit liegt, wird
-        die Geschwindigkeit auf 0 gesetzt.
-
-        Parameter:
-          current_vehicle: Das Fahrzeug, dessen Geschwindigkeit angepasst werden soll.
-          base_speed: Die Basisgeschwindigkeit (ohne Kollisionseffekt).
-          safe_distance: Der Abstand, unterhalb dessen Fahrzeuge ihre Geschwindigkeit reduzieren.
-
-        Rückgabe:
-          Die angepasste Geschwindigkeit.
-        """
-        current_pos = current_vehicle.getPos(self.render)
-        adjusted_speed = base_speed
-        for veh in self.garage_vehicles:
-            if veh == current_vehicle:
-                continue
-            other_pos = veh.getPos(self.render)
-            distance = (current_pos - other_pos).length()
-            if distance < safe_distance:
-                # Wenn Fahrzeuge extrem nahe kommen, wird die Geschwindigkeit auf 0 gesetzt.
-                if distance < 1.0:
-                    candidate_speed = 0.0
-                else:
-                    # Lineare Reduktion: Je näher das Fahrzeug, desto geringer die erlaubte Geschwindigkeit.
-                    candidate_speed = base_speed * (distance / safe_distance)
-                # Wähle den minimalen Wert
-                if candidate_speed < adjusted_speed:
-                    adjusted_speed = candidate_speed
-                print(f"[Collision Avoidance] Fahrzeug {current_vehicle.getPythonTag('vehicle_id')} "
-                      f"reduziert Geschwindigkeit auf {adjusted_speed:.2f} (Abstand zu Fahrzeug {veh.getPythonTag('vehicle_id')}: {distance:.2f})")
-        return adjusted_speed
-
-    def is_station_occupied(self, station, exclude_vehicle=None, occupancy_threshold=1.0):
-        """
-        Prüft, ob sich bereits ein Fahrzeug an der gegebenen Station (z. B. Pickup‑Station)
-        befindet. Dabei wird als Zielpunkt zumeist der blaue Marker genutzt, der der Station
-        zugeordnet ist. Das Fahrzeug exclude_vehicle (z. B. das aktuell agierende Fahrzeug)
-        wird dabei nicht berücksichtigt.
-        """
-        # Falls ein blauer Marker vorhanden ist, nutze dessen Position als Zielort:
-        if hasattr(self, 'station_blue_dots') and station in self.station_blue_dots:
-            station_pos = self.station_blue_dots[station].getPos(self.render)
-        else:
-            station_pos = station.getPos(self.render)
-        for veh in self.garage_vehicles:
-            if veh == exclude_vehicle:
-                continue
-            if (veh.getPos(self.render) - station_pos).length() < occupancy_threshold:
-                return True
-        return False
-
-    def is_delivery_station_occupied(self, target_pos, exclude_vehicle=None, occupancy_threshold=1.0):
-        """
-        Prüft, ob sich ein Fahrzeug in der Nähe der Abgabestation (target_pos) befindet,
-        welches in einer Lieferphase (z. B. drop, delivery_center oder align_delivery) ist oder noch ein Paket
-        transportiert (package_attached = True). Das Fahrzeug exclude_vehicle (z. B. das aktuell anfahrende Fahrzeug)
-        wird dabei nicht berücksichtigt.
-        """
-        for veh in self.garage_vehicles:
-            if veh == exclude_vehicle:
-                continue
-            # Hole den aktuellen Zustand und ob ein Paket noch angebracht ist.
-            state = veh.getPythonTag("order_state")
-            package_attached = veh.getPythonTag("package_attached")
-            if state in ["drop", "delivery_center", "align_delivery"] or package_attached:
-                if (veh.getPos(self.render) - target_pos).length() < occupancy_threshold:
-                    return True
-        return False
-
-    def check_collisions(self):
-        """
-        Ermittelt alle Fahrzeugpaare, die näher als collision_threshold (z.B. 1 Einheit)
-        beieinander liegen – also als kollidierend gelten.
-        """
-        collision_threshold = 1.0  # Fahrzeuge gelten als kollidierend, wenn ihr Abstand unter 1 Einheit liegt
-        collisions = []
-        for i in range(len(self.garage_vehicles)):
-            veh1 = self.garage_vehicles[i]
-            pos1 = veh1.getPos(self.render)
-            for j in range(i + 1, len(self.garage_vehicles)):
-                veh2 = self.garage_vehicles[j]
-                pos2 = veh2.getPos(self.render)
-                if (pos1 - pos2).length() < collision_threshold:
-                    collisions.append((veh1, veh2))
-        return collisions
-
-    def update_rl_on_collisions(self):
-        """
-        Prüft regelmäßig, ob Fahrzeuge kollidieren. Für jedes kollidierende Fahrzeugpaar
-        wird die Kollisionsdauer ermittelt. Liegt diese Dauer über 5 Sekunden,
-        wird der Zustand der Fahrzeuge auf "drive_out" gesetzt – also sollen sie dann
-        einfach weiterfahren.
-        """
-        collisions = self.check_collisions()
-        current_time = self.sim_clock
-
-        # Erstelle oder verwende ein Dictionary, um die Startzeiten der Kollisionspaare zu speichern.
-        if not hasattr(self, "collision_start_times"):
-            self.collision_start_times = {}
-
-        # Erstelle eine Menge der aktuell kollidierenden Fahrzeugpaare (als frozenset, um die Reihenfolge zu ignorieren)
-        current_collision_keys = set()
-        for veh1, veh2 in collisions:
-            key = frozenset({veh1, veh2})
-            current_collision_keys.add(key)
-            if key not in self.collision_start_times:
-                self.collision_start_times[key] = current_time
-            else:
-                duration = current_time - self.collision_start_times[key]
-                if duration > 5.0:
-                    # Wenn die Fahrzeuge länger als 5 Sekunden kollidieren, werden sie "unblocked"
-                    if veh1.getPythonTag("order_state") != "drive_out":
-                        print(
-                            f"[COLLISION] Fahrzeug {veh1.getPythonTag('vehicle_id')} kollidiert seit {duration:.1f}s – Losfahren!")
-                        veh1.setPythonTag("order_state", "drive_out")
-                    if veh2.getPythonTag("order_state") != "drive_out":
-                        print(
-                            f"[COLLISION] Fahrzeug {veh2.getPythonTag('vehicle_id')} kollidiert seit {duration:.1f}s – Losfahren!")
-                        veh2.setPythonTag("order_state", "drive_out")
-                    # Nach dem Unblocken löschen wir den Eintrag für diese kollidierende Fahrzeugpaar.
-                    if key in self.collision_start_times:
-                        del self.collision_start_times[key]
-
-        # Bereinige Einträge, die nicht mehr aktuell sind.
-        keys_to_remove = [key for key in self.collision_start_times if key not in current_collision_keys]
-        for key in keys_to_remove:
-            del self.collision_start_times[key]
-
-        # Falls du hier noch RL-Updates vornehmen möchtest, kannst du an dieser Stelle zusätzliche Logik einfügen.
-
-
-class RLAgent:
-    def __init__(self, state_bins, action_space, learning_rate=0.1, discount_factor=0.9, epsilon=0.2):
-        """
-        state_bins: Tuple oder Liste, um kontinuierliche Zustände zu diskretisieren (z.B. (max_distance, num_bins))
-        action_space: Liste diskreter Aktionen (z.B. [0, 1, 2] --> 0: keine Bremsung, 1: leicht, 2: stark)
-        """
-        self.state_bins = state_bins
-        self.action_space = action_space
-        self.lr = learning_rate
-        self.gamma = discount_factor
-        self.epsilon = epsilon
-        # Initialisiere Q-Tabelle als Dictionary: key: (discretisierter_state), value: Liste von Q-Werten pro Aktion
-        self.q_table = {}
-
-    def discretize_state(self, state):
-        """
-        Nimmt einen Zustandsvektor (z.B. [distance, speed]) und gibt einen diskreten Zustand zurück.
-        Hier ein Beispiel: Falls state[0] = Abstand und state[1] = Geschwindigkeit.
-        """
-        # Beispiel: Wir nehmen an, dass state_bins = ((max_distance, num_bins), (max_speed, num_bins))
-        discrete_state = []
-        for i, (max_val, bins) in enumerate(self.state_bins):
-            # Begrenze state[i] um max_val:
-            val = min(state[i], max_val)
-            bin_size = max_val / bins
-            discrete_state.append(int(val // bin_size))
-        return tuple(discrete_state)
-
-    def select_action(self, state):
-        discrete_state = self.discretize_state(state)
-        if discrete_state not in self.q_table:
-            self.q_table[discrete_state] = [0.0 for _ in self.action_space]
-        # Epsilon-greedy Auswahl:
-        if random.random() < self.epsilon:
-            return random.choice(self.action_space)
-        else:
-            q_values = self.q_table[discrete_state]
-            return self.action_space[np.argmax(q_values)]
-
-    def update(self, state, action, reward, next_state):
-        s = self.discretize_state(state)
-        s_next = self.discretize_state(next_state)
-        if s not in self.q_table:
-            self.q_table[s] = [0.0 for _ in self.action_space]
-        if s_next not in self.q_table:
-            self.q_table[s_next] = [0.0 for _ in self.action_space]
-        a_index = self.action_space.index(action)
-        # Q-Learning Update-Regel:
-        best_next = max(self.q_table[s_next])
-        self.q_table[s][a_index] += self.lr * (reward + self.gamma * best_next - self.q_table[s][a_index])
-
-    def is_station_occupied(self, station, exclude_vehicle=None, occupancy_threshold=1.0):
-        # Bestimme den Zielpunkt der Station – falls über station_blue_dots verfügbar.
-        if hasattr(self, 'station_blue_dots') and station in self.station_blue_dots:
-            station_pos = self.station_blue_dots[station].getPos(self.render)
-        else:
-            station_pos = station.getPos(self.render)
-        for veh in self.garage_vehicles:
-            if veh == exclude_vehicle:
-                continue
-            current_order = veh.getPythonTag("current_order")
-            if current_order is not None and current_order.get("pickup_station") == station:
-                # Blockiere die Station, solange das Fahrzeug nicht den Zustand erreicht hat,
-                # der anzeigt, dass es die Station verlassen hat.
-                if veh.getPythonTag("order_state") not in ["to_delivery", "idle", "next_order"]:
-                    return True
-            # Zusätzlich: Blockiere, wenn ganz nahe am Station-Zielpunkt
-            if (veh.getPos(self.render) - station_pos).length() < occupancy_threshold:
-                return True
-        return False
-
-    def is_delivery_station_occupied(self, station, exclude_vehicle=None, occupancy_threshold=1.0):
-        occupant = station.getPythonTag("occupied_by")
-        if occupant is not None and occupant != exclude_vehicle:
-            return True
-        # Optional: Falls du noch eine physikalische Näheprüfung implementieren möchtest, kannst du dies ergänzen.
-        return False
-
-
-if __name__ == "__main__":
-    # Wichtig: setze auf Windows die Startmethode auf "spawn"
-    multiprocessing.set_start_method('spawn')
-
-    # Erzeuge eine Queue, auch wenn sie später eventuell neu erstellt wird, wenn "G" gedrückt wird.
-    graph_q = Queue()
-    app = LagerSimulation(graph_q)
-    app.run()
-
-    # Beim Schließen der Simulation den Graphprozess ggf. beenden
-    if app.graph_process is not None:
-        app.graph_process.terminate()
-        app.graph_process.join()
\ No newline at end of file
Index: KI/KI24.py
===================================================================
diff --git a/KI/KI24.py b/KI/KI24.py
deleted file mode 100644
--- a/KI/KI24.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,499 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode, LineSegs
-)
-
-# Wir nutzen globalClock für dt.
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit
-        self.base_speed = 1.5
-        # Zeitskalierungsfaktor
-        self.speed_factor = 1.0
-        # Simulationszeitticker in simulierten Sekunden
-        self.sim_clock = 0.0
-        # Zähler der abgegebenen Pakete
-        self.delivered_packages = 0
-        # Speichert über die gesamte Simulation die maximal erreichte Liegedauer eines Paketes
-        self.max_overall_wait_time = 0.0
-        # Neue Attribute zur Erfassung der durchschnittlichen Liegedauer
-        self.total_dwell_time = 0.0
-        self.picked_up_count = 0
-
-        # Zeitpunkt des Simulationsstarts (reale Zeit)
-        self.sim_start_real = globalClock.getFrameTime()
-
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erstelle 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeuge initialisieren – zwei Fahrzeuge.
-        self.vehicles = []
-        self.cargos = {}  # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}  # Fahrzeug -> aktuell reservierte Abgabestation
-
-        # Fahrzeug 1: startet sofort.
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-        # Markiere den Fahrzeugmittelpunkt (weißer Punkt) und füge den Lidar-Kreis als zusätzliche Visualisierung hinzu.
-        self.add_center_marker(vehicle1)
-        self.add_offset_circle(vehicle1, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Fahrzeug 2: startet 8 simulierte Sekunden später.
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)  # y-Offset von 2 Einheiten.
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-        self.add_center_marker(vehicle2)
-        self.add_offset_circle(vehicle2, offset=Vec3(0.5, 0.5, 0.01), circle_radius=1.5)
-
-        # Globaler Pool für Pickup-Pakete und Zeitstempel (in simulierten Sekunden).
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = self.sim_clock
-
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider zur Anpassung des Zeitskalierungsfaktors.
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Info-Anzeige.
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0 s\nAbgegebene Pakete: 0",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Tasks.
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-        self.taskMgr.add(self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-        self.taskMgr.add(self.check_vehicle2_start, "CheckVehicle2StartTask")
-        # Task zur Aktualisierung der Lidar-Farbe und Kollisionsausweichlogik.
-        self.taskMgr.add(self.update_lidar_status, "UpdateLidarStatusTask")
-
-        # Starte Liefervorgänge.
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-        # Fahrzeug 2 startet, sobald 8 simulierte Sekunden erreicht sind (via Task).
-
-    def add_center_marker(self, vehicle, scale=0.2):
-        """
-        Fügt dem Fahrzeug einen weißen Punkt als Markierung des Fahrzeugmittelpunkts hinzu.
-        """
-        marker = self.loader.loadModel("models/misc/sphere")
-        marker.setScale(scale)
-        marker.setColor(LColor(1, 1, 1, 1))  # Weiß.
-        marker.reparentTo(vehicle)
-        marker.setPos(0, 0, 0.01)
-
-    def add_offset_circle(self, vehicle, offset=Vec3(0.5, 0.5, 0.01),
-                          circle_radius=1.5, num_segments=32):
-        """
-        Zeichnet einen Kreis als Visualisierung der Lidar-Grenze des Fahrzeugs.
-        Der Kreis wird relativ zum Fahrzeug angehängt (als Kindknoten) und über
-        den angegebenen Offset positioniert. Der Kreis ist standardmäßig grün.
-        """
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))  # Standard: grün.
-        for i in range(num_segments + 1):
-            angle = 2 * math.pi * i / num_segments
-            x = circle_radius * math.cos(angle)
-            y = circle_radius * math.sin(angle)
-            if i == 0:
-                ls.moveTo(x, y, 0)
-            else:
-                ls.drawTo(x, y, 0)
-        circle_geom = ls.create()
-        circle_np = vehicle.attachNewNode(circle_geom)
-        circle_np.setPos(offset)
-        # Speichern des Kreis-Knotens per PythonTag, damit wir ihn später modifizieren können.
-        vehicle.setPythonTag("lidar_circle", circle_np)
-
-    def update_lidar_status(self, task):
-        """
-        Aktualisiert die Lidar-Anzeige und berechnet eine zusätzliche Ausweichlogik.
-        Für jedes Fahrzeug:
-          - Wenn ein anderes Fahrzeug zu nahe kommt (Abstand < 3 m), so wird:
-              * Der Kreis rot gefärbt.
-              * Ein repulsiver Vektor berechnet, der in Richtung eines Ausweichmanövers zeigt.
-              * Ein individueller Geschwindigkeitsfaktor (hier 0.5) gesetzt, um das Fahrzeug abzubremsen.
-          - Andernfalls wird der Kreis grün, und es werden keine Eingriffe erzwungen.
-        """
-        sensor_threshold = 3.0  # 1.5 + 1.5, also Summe der Lidar-Radien.
-        for vehicle in self.vehicles:
-            if vehicle.hasPythonTag("lidar_circle"):
-                lidar_circle = vehicle.getPythonTag("lidar_circle")
-                pos = vehicle.getPos(self.render)
-                collision = False
-                avoidance_vec = Vec3(0, 0, 0)
-                for other in self.vehicles:
-                    if other is not vehicle:
-                        pos_other = other.getPos(self.render)
-                        diff = pos - pos_other
-                        distance = diff.length()
-                        if distance < sensor_threshold:
-                            collision = True
-                            if distance > 0:
-                                # Berechne einen repulsiven Vektor, der umso stärker ist, je näher das Fahrzeug kommt.
-                                avoidance_vec += diff.normalized() * (sensor_threshold - distance)
-                if collision:
-                    lidar_circle.setColor(LColor(1, 0, 0, 1))  # rot.
-                    vehicle.setPythonTag("avoidance", avoidance_vec)
-                    # Fahrzeug wird abgebremst.
-                    vehicle.setPythonTag("speed_multiplier", 0.5)
-                else:
-                    lidar_circle.setColor(LColor(0, 1, 0, 1))  # grün.
-                    vehicle.setPythonTag("avoidance", Vec3(0, 0, 0))
-                    vehicle.setPythonTag("speed_multiplier", 1.0)
-        return Task.cont
-
-    def update_sim_clock(self, task):
-        dt = globalClock.getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        current_max_wait_time = 0
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            if elapsed > current_max_wait_time:
-                current_max_wait_time = elapsed
-
-        self.max_overall_wait_time = max(self.max_overall_wait_time, current_max_wait_time)
-
-        if current_max_wait_time > 0:
-            current_wait_text = f"Liegedauer (aktuell): {current_max_wait_time:.1f}s"
-        else:
-            current_wait_text = "Kein Paket an Annahmestation"
-
-        maximal_wait_text = f"Liegedauer (maximal): {self.max_overall_wait_time:.1f}s"
-
-        # Berechne die durchschnittliche Liegedauer basierend auf bereits abgeholten Paketen.
-        if self.picked_up_count > 0:
-            avg_dwell_time = self.total_dwell_time / self.picked_up_count
-        else:
-            avg_dwell_time = 0.0
-
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-
-        if self.sim_clock > 0:
-            delivered_per_minute = self.delivered_packages / (self.sim_clock / 60.0)
-        else:
-            delivered_per_minute = 0
-
-        self.info_label['text'] = (
-            f"Laufzeit: {formatted_time}\n"
-            f"Abgegebene Pakete: {self.delivered_packages}\n"
-            f"Pakete pro Minute: {delivered_per_minute:.1f}\n"
-            f"{current_wait_text}\n"
-            f"{maximal_wait_text}\n"
-            f"Liegedauer (Durchschnitt): {avg_dwell_time:.1f}s"
-        )
-        return Task.cont
-
-    def sim_time(self, t):
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        self.update_simulation_speed()
-        return Task.again
-
-    def check_vehicle2_start(self, task):
-        if self.sim_clock >= 8.0 and not hasattr(self, 'vehicle2_started'):
-            self.vehicle2_started = True
-            self.start_delivery_cycle(self.vehicles[1], self.vehicles[1].getPos())
-            return Task.done
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def check_and_spawn_packages(self, task):
-        spawn_delay = self.sim_time(1)
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if (self.sim_clock - self.last_removed.get(station, self.sim_clock)) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.cont
-
-    def spawn_package_at_station(self, station):
-        package = self.erzeuge_wuerfel(
-            station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1)
-        )
-        spawn_time = self.sim_clock
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed = self.sim_clock - spawn_time
-            tn = timer_np.node()
-            tn.setText(f"{elapsed:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        """
-        Bewegt ein Fahrzeug schrittweise in Richtung des Zielpunkts.
-        Hier wird neben der direkten Zielerreichung (target) auch
-        der aktuell berechnete Ausweichvektor (falls vorhanden) berücksichtigt.
-        """
-
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            to_target = target - current_pos
-            distance = to_target.length()
-            # Hole den individuellen Geschwindigkeitsfaktor (Standard: 1.0)
-            multiplier = 1.0
-            if vehicle.hasPythonTag("speed_multiplier"):
-                multiplier = vehicle.getPythonTag("speed_multiplier")
-            effective_speed = self.base_speed * self.speed_factor * multiplier
-            step_distance = effective_speed * dt
-
-            # Wenn das Fahrzeug in diesem Schritt das Ziel erreicht, beende die Bewegung.
-            if distance <= step_distance:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-
-            # Hole den Ausweichvektor (falls vorhanden)
-            avoidance = Vec3(0, 0, 0)
-            if vehicle.hasPythonTag("avoidance"):
-                avoidance = vehicle.getPythonTag("avoidance")
-            # Kombiniere die Zielrichtung mit dem Ausweichvektor (wenn dieser signifikant ist)
-            if avoidance.length() > 0.001:
-                combined = to_target.normalized() + avoidance.normalized() * 0.5
-                combined.normalize()
-                new_direction = combined
-            else:
-                new_direction = to_target.normalized()
-            vehicle.setPos(current_pos + new_direction * step_distance)
-            return Task.cont
-
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}_{target}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-        if not self.pickup_packages:
-            def wait_task(task):
-                if self.pickup_packages:
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_task, f"WaitPackage_{id(vehicle)}")
-            return
-        current_time = self.sim_clock
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            def wait_for_pickup(task):
-                if any(s not in self.occupied_pickups for s in self.pickup_packages.keys()):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_pickup, f"WaitPickup_{id(vehicle)}")
-            return
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        pickup_pos = pickup_station.getPos()
-
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.occupied_pickups.remove(pickup_station)
-
-            def wait_for_dropoff(task):
-                if any(ds not in self.occupied_dropoffs for ds in self.abgabe_stationen):
-                    self.start_delivery_cycle(vehicle, vehicle.getPos())
-                    return Task.done
-                return Task.cont
-
-            self.taskMgr.add(wait_for_dropoff, f"WaitDropoff_{id(vehicle)}")
-            return
-
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_pos = dropoff_station.getPos()
-
-        self.move_vehicle_to(vehicle, pickup_pos, lambda: self.after_pickup(vehicle, pickup_station, dropoff_pos))
-
-    def after_pickup(self, vehicle, pickup_station, dropoff_pos):
-        self.pickup_package(vehicle, pickup_station)
-        self.move_vehicle_to(vehicle, dropoff_pos, lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        self.drop_cargo(vehicle)
-        start_wait = self.sim_clock
-
-        def wait_task(task):
-            if self.sim_clock - start_wait >= self.sim_time(1):
-                self.finish_cycle(vehicle)
-                return Task.done
-            return Task.cont
-
-        self.taskMgr.add(wait_task, f"WaitAfterDrop_{id(vehicle)}")
-
-    def finish_cycle(self, vehicle):
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            # Erfasse die Liegedauer (Wartezeit) des Pakets und aktualisiere den Durchschnitt.
-            dwell_time = self.sim_clock - spawn_time
-            self.total_dwell_time += dwell_time
-            self.picked_up_count += 1
-
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = self.sim_clock
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-            self.delivered_packages += 1
-
-    def remove_cargo(self, vehicle):
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        if dropoff_station in self.occupied_dropoffs:
-            self.occupied_dropoffs.remove(dropoff_station)
-            del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-app = LagerSimulation()
-app.run()
Index: Test/Test Panda3d.py
===================================================================
diff --git a/Test/Test Panda3d.py b/Test/Test Panda3d.py
deleted file mode 100644
--- a/Test/Test Panda3d.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,374 +0,0 @@
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import LineSegs, NodePath
-from direct.interval.IntervalGlobal import Sequence, Parallel, LerpPosInterval, Func
-import math
-import random
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Parameter für den Betriebsmodus: "einlagern" oder "auslagerung"
-        # Hier testen wir aktuell den Auslagerungsmodus
-        self.mode = "auslagerung"
-
-        # Parameter für das Lagerlayout
-        self.num_storage_x = 10  # 10 Lagerplätze in X-Richtung
-        self.num_blocks = 5      # ergibt 2*5+2 = 12 Reihen -> 6 Gassen
-        self.num_storage_y = 2 * self.num_blocks + 2
-        self.num_levels = 3
-        self.level_gap = 0.2
-        self.box_size = 1.0
-        self.gap = 0.5
-        self.aisle_gap = 2.0
-        self.inner_gap = 0.1
-
-        # Berechnung der Regalreihen-Positionen (Y-Achse)
-        total_rows = self.num_storage_y
-        raw_row_positions = []
-        for r in range(total_rows):
-            if r == 0:
-                raw_row_positions.append(0)
-            else:
-                gap_y = self.aisle_gap if r % 2 == 1 else self.inner_gap
-                raw_row_positions.append(raw_row_positions[-1] + self.box_size + gap_y)
-
-        raw_min = raw_row_positions[0] - self.box_size / 2
-        raw_max = raw_row_positions[-1] + self.box_size / 2
-        center_y = (raw_min + raw_max) / 2
-        offset_y = -center_y
-        self.row_positions = [r + offset_y for r in raw_row_positions]
-
-        # X-Positionierung (zentriert)
-        total_width = self.num_storage_x * self.box_size + (self.num_storage_x - 1) * self.gap
-        offset_x = -total_width / 2 + self.box_size / 2
-        self.offset_x = offset_x
-
-        # Erzeuge Regalzellen
-        self.storage_cells = []
-        base_z = self.box_size / 2
-        for row_index, row_y in enumerate(self.row_positions):
-            for col in range(self.num_storage_x):
-                for level in range(self.num_levels):
-                    x = offset_x + col * (self.box_size + self.gap)
-                    y = row_y
-                    z = base_z + level * (self.box_size + self.level_gap)
-                    cell_node = self.create_storage_box(self.box_size, (0, 1, 0, 1))
-                    cell_node.setPos(x, y, z)
-                    cell_node.reparentTo(self.render)
-                    self.storage_cells.append({
-                        "node": cell_node,
-                        "occupied": False,
-                        "pos": (x, y, z),
-                        "row": row_index,
-                        "col": col,
-                        "level": level
-                    })
-
-        # Pre-fill: 70% der Zellen werden belegt
-        total_cells = len(self.storage_cells)
-        num_pre_fill = int(total_cells * 0.7)
-        cells_to_fill = random.sample(self.storage_cells, num_pre_fill)
-        for cell in cells_to_fill:
-            cell["occupied"] = True
-            pos = cell["pos"]
-            cell["node"].removeNode()
-            # Roter Kasten als belegter Lagerplatz
-            occupied_box = self.create_storage_box(self.box_size, (1, 0, 0, 1))
-            occupied_box.setPos(pos)
-            occupied_box.reparentTo(self.render)
-            cell["node"] = occupied_box
-            # Zeige zusätzlich eine gelbe LE im belegten Lagerplatz an
-            load_unit = self.create_storage_box(self.box_size * 0.8, (1, 1, 0, 1))
-            load_unit.setPos(pos)
-            load_unit.reparentTo(self.render)
-            # Speichere die Referenz zur gelben LE in der Zelle:
-            cell["load_unit_node"] = load_unit
-
-        # Grenzen der Regale
-        self.shelf_bottom = min(self.row_positions) - self.box_size / 2
-        self.shelf_top = max(self.row_positions) + self.box_size / 2
-        self.shelf_left = offset_x - self.box_size / 2
-        self.shelf_right = offset_x + total_width - self.box_size / 2
-
-        # Berechne sichere Korridore (je 2 Reihen ergeben 6 Gassen)
-        self.safe_corridors = []
-        for i in range(0, self.num_storage_y, 2):
-            corridor = (self.row_positions[i] + self.row_positions[i + 1]) / 2
-            self.safe_corridors.append(corridor)
-
-        # LE‑Quelle (Ladeeinheiten-Quelle) wird hier nur für den Einlagerungsmodus genutzt
-        source_y = self.shelf_bottom - 3.0
-        self.source_pos = (0, source_y, base_z)
-        source_indicator = self.create_storage_box(self.box_size * 1.2, (0, 0, 1, 1))
-        source_indicator.setPos(self.source_pos)
-        source_indicator.reparentTo(self.render)
-
-        # Auslagerungsstation
-        unload_offset = (self.box_size * 2.0, 0, 0)
-        self.unload_pos = (self.source_pos[0] + unload_offset[0],
-                           self.source_pos[1] + unload_offset[1],
-                           self.source_pos[2] + unload_offset[2])
-        unload_indicator = self.create_storage_box(self.box_size * 1.2, (1, 0, 0, 1))
-        unload_indicator.setPos(self.unload_pos)
-        unload_indicator.reparentTo(self.render)
-
-        # Kamera-Setup
-        self.disableMouse()
-        center_x = (self.shelf_left + self.shelf_right) / 2
-        center_y_bound = (self.shelf_bottom + self.shelf_top) / 2
-        self.camera_target = (center_x, center_y_bound, base_z)
-        self.camera_radius = max(self.shelf_right - self.shelf_left, self.shelf_top - self.shelf_bottom) + 10
-        self.camera_h = 90.0
-        self.camera_p = 15.0
-        self.updateCameraOrbit()
-
-        # Kamera-Steuerung
-        self.dragging = False
-        self.lastMousePos = None
-
-        # Shuttle‑Parameter
-        self.load_unit_speed = 7.0
-        self.max_shuttles = 2
-        self.active_shuttles = 0
-        self.taskMgr.doMethodLater(1.33, self.spawn_load_unit, "SpawnLoadUnitTask")
-
-    def updateCameraOrbit(self):
-        h_rad = math.radians(self.camera_h)
-        p_rad = math.radians(self.camera_p)
-        cx, cy, cz = self.camera_target
-        r = self.camera_radius
-        cam_x = cx + r * math.cos(p_rad) * math.sin(h_rad)
-        cam_y = cy + r * math.cos(p_rad) * math.cos(h_rad)
-        cam_z = cz + r * math.sin(p_rad)
-        self.camera.setPos(cam_x, cam_y, cam_z)
-        self.camera.lookAt(cx, cy, cz)
-
-    def startCameraDrag(self):
-        self.dragging = True
-        if self.mouseWatcherNode.hasMouse():
-            self.lastMousePos = (self.mouseWatcherNode.getMouseX(),
-                                 self.mouseWatcherNode.getMouseY())
-
-    def stopCameraDrag(self):
-        self.dragging = False
-        self.lastMousePos = None
-
-    def updateCameraTask(self, task):
-        if self.dragging and self.mouseWatcherNode.hasMouse():
-            currentMousePos = (self.mouseWatcherNode.getMouseX(),
-                               self.mouseWatcherNode.getMouseY())
-            if self.lastMousePos is not None:
-                dx = currentMousePos[0] - self.lastMousePos[0]
-                dy = currentMousePos[1] - self.lastMousePos[1]
-                self.camera_h += dx * 100
-                self.camera_p -= dy * 100
-                self.camera_p = max(-80, min(80, self.camera_p))
-                self.updateCameraOrbit()
-            self.lastMousePos = currentMousePos
-        return task.cont
-
-    def create_storage_box(self, size, color):
-        half = size / 2.0
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(*color)
-        ls.moveTo(-half, -half, -half)
-        ls.drawTo(half, -half, -half)
-        ls.drawTo(half, half, -half)
-        ls.drawTo(-half, half, -half)
-        ls.drawTo(-half, -half, -half)
-        ls.moveTo(-half, -half, half)
-        ls.drawTo(half, -half, half)
-        ls.drawTo(half, half, half)
-        ls.drawTo(-half, half, half)
-        ls.drawTo(-half, -half, half)
-        ls.moveTo(-half, -half, -half)
-        ls.drawTo(-half, -half, half)
-        ls.moveTo(half, -half, -half)
-        ls.drawTo(half, -half, half)
-        ls.moveTo(half, half, -half)
-        ls.drawTo(half, half, half)
-        ls.moveTo(-half, half, -half)
-        ls.drawTo(-half, half, half)
-        return NodePath(ls.create())
-
-    def spawn_load_unit(self, task):
-        if self.active_shuttles >= self.max_shuttles:
-            return task.again
-
-        # Auswahl der Zielzelle abhängig vom Modus:
-        if self.mode == "einlagern":
-            available_cells = [cell for cell in self.storage_cells if not cell["occupied"]]
-            if not available_cells:
-                print("Lager voll!")
-                return task.again
-            chosen_cell = random.choice(available_cells)
-            start_point = self.source_pos
-            # Erzeuge eine neue LE (gelb) als Fracht
-            load_unit = self.create_storage_box(self.box_size * 0.8, (1, 1, 0, 1))
-            load_unit.setPos(start_point)
-            load_unit.reparentTo(self.render)
-        else:  # auslagerung
-            # Für die Auslagerung wählt man eine belegte Zelle, in der auch eine gelbe LE gespeichert ist
-            available_cells = [cell for cell in self.storage_cells if cell["occupied"] and cell.get("load_unit_node")]
-            if not available_cells:
-                print("Keine LE im Lager vorhanden!")
-                return task.again
-            chosen_cell = random.choice(available_cells)
-            start_point = self.unload_pos
-            # Anstatt eine neue LE zu erzeugen, holen wir die vorhandene gelbe LE aus der Zelle.
-            load_unit = chosen_cell["load_unit_node"]
-            load_unit.setPos(chosen_cell["pos"])
-            # Entferne die Referenz, damit nicht versehentlich dieselbe LE mehrfach verwendet wird.
-            chosen_cell["load_unit_node"] = None
-
-        # Erzeuge Shuttle (lila) am Startpunkt
-        shuttle = self.create_storage_box(self.box_size * 1.2, (0.5, 0, 0.5, 1))
-        shuttle.setPos(start_point)
-        shuttle.reparentTo(self.render)
-        self.active_shuttles += 1
-
-        base_z = self.box_size / 2
-        source = start_point
-        margin = 0.5
-        side_x_right = self.shelf_right + margin
-        side_x_left = self.shelf_left - margin
-
-        forward_offset = self.box_size * 1.5
-        forward_point = (source[0], source[1] + forward_offset, base_z)
-
-        target_x, target_y, target_z = chosen_cell["pos"]
-        lane = chosen_cell["row"] // 2
-        safe_y = self.safe_corridors[lane]
-
-        if target_x >= 0:
-            inbound_points = [
-                source,
-                forward_point,
-                (side_x_right, forward_point[1], base_z),
-                (side_x_right, safe_y, base_z),
-                (target_x, safe_y, base_z),
-                (target_x, safe_y, target_z),
-                (target_x, target_y, target_z)
-            ]
-            return_points = [
-                (target_x, target_y, target_z),
-                (target_x, safe_y, target_z),
-                (target_x, safe_y, base_z),
-                (side_x_right, safe_y, base_z),
-                (side_x_right, forward_point[1], base_z),
-                forward_point,
-                source
-            ]
-        else:
-            inbound_points = [
-                source,
-                forward_point,
-                (side_x_left, forward_point[1], base_z),
-                (side_x_left, safe_y, base_z),
-                (target_x, safe_y, base_z),
-                (target_x, safe_y, target_z),
-                (target_x, target_y, target_z)
-            ]
-            return_points = [
-                (target_x, target_y, target_z),
-                (target_x, safe_y, target_z),
-                (target_x, safe_y, base_z),
-                (side_x_left, safe_y, base_z),
-                (side_x_left, forward_point[1], base_z),
-                forward_point,
-                source
-            ]
-
-        speed = self.load_unit_speed
-        inbound_durations = [math.dist(inbound_points[i], inbound_points[i + 1]) / speed
-                             for i in range(len(inbound_points) - 1)]
-        return_durations = [math.dist(return_points[i], return_points[i + 1]) / speed
-                            for i in range(len(return_points) - 1)]
-
-        # Erzeuge die Inbound-Intervalle:
-        inbound_shuttle_intervals = []
-        inbound_load_intervals = []
-        if self.mode == "einlagern":
-            # Beide, Shuttle und LE, bewegen sich gemeinsam von der Quelle zum Lagerplatz.
-            for i in range(len(inbound_durations)):
-                interval_shuttle = LerpPosInterval(shuttle, inbound_durations[i], inbound_points[i + 1])
-                interval_load = LerpPosInterval(load_unit, inbound_durations[i], inbound_points[i + 1])
-                inbound_shuttle_intervals.append(interval_shuttle)
-                inbound_load_intervals.append(interval_load)
-        else:
-            # Im Auslagerungsmodus fährt zunächst nur das Shuttle vom Unload-Punkt zum Lagerplatz;
-            # die gelbe LE bleibt anfangs in der Zelle.
-            for i in range(len(inbound_durations)):
-                interval_shuttle = LerpPosInterval(shuttle, inbound_durations[i], inbound_points[i + 1])
-                inbound_shuttle_intervals.append(interval_shuttle)
-            # Keine Intervalle für die LE inbound.
-
-        # Erzeuge die Return-Intervalle:
-        return_shuttle_intervals = []
-        return_load_intervals = []
-        if self.mode == "einlagern":
-            # Beim Einlagern fährt nur das Shuttle zurück.
-            for i in range(len(return_durations)):
-                r_int = LerpPosInterval(shuttle, return_durations[i], return_points[i + 1])
-                return_shuttle_intervals.append(r_int)
-        else:
-            # Beim Auslagern sollen Shuttle und LE gemeinsam von der Zelle zurück zur Auslagerungsstation fahren.
-            for i in range(len(return_durations)):
-                r_int_shuttle = LerpPosInterval(shuttle, return_durations[i], return_points[i + 1])
-                r_int_load = LerpPosInterval(load_unit, return_durations[i], return_points[i + 1])
-                return_shuttle_intervals.append(r_int_shuttle)
-                return_load_intervals.append(r_int_load)
-
-        # Beim Auslagerungsmodus: Ankunft im Lagerplatz – LE vom Regal aufnehmen ("anheften")
-        def attach_load_unit():
-            load_unit.setPos(shuttle.getPos())
-
-        def update_cell_status():
-            pos = chosen_cell["node"].getPos()
-            chosen_cell["node"].removeNode()
-            if self.mode == "einlagern":
-                new_box = self.create_storage_box(self.box_size, (1, 0, 0, 1))
-                chosen_cell["occupied"] = True
-            else:
-                new_box = self.create_storage_box(self.box_size, (0, 1, 0, 1))
-                chosen_cell["occupied"] = False
-            new_box.setPos(pos)
-            new_box.reparentTo(self.render)
-            chosen_cell["node"] = new_box
-
-        def decrement_active_shuttles():
-            self.active_shuttles -= 1
-
-        if self.mode == "einlagern":
-            inbound_sequence = []
-            for i in range(len(inbound_shuttle_intervals)):
-                inbound_sequence.append(Parallel(inbound_shuttle_intervals[i], inbound_load_intervals[i]))
-            route = Sequence(
-                *inbound_sequence,
-                Func(update_cell_status),
-                *return_shuttle_intervals,
-                Func(decrement_active_shuttles)
-            )
-        else:
-            route = Sequence(
-                *inbound_shuttle_intervals,
-                Func(attach_load_unit),
-                Func(update_cell_status),
-                *[Parallel(return_shuttle_intervals[i], return_load_intervals[i])
-                  for i in range(len(return_shuttle_intervals))],
-                Func(decrement_active_shuttles)
-            )
-        route.start()
-
-        return task.again
-
-
-if __name__ == "__main__":
-    simulation = LagerSimulation()
-    simulation.accept("mouse1", simulation.startCameraDrag)
-    simulation.accept("mouse1-up", simulation.stopCameraDrag)
-    simulation.taskMgr.add(simulation.updateCameraTask, "UpdateCameraTask")
-    simulation.run()
\ No newline at end of file
Index: KI/KI12.py
===================================================================
diff --git a/KI/KI12.py b/KI/KI12.py
deleted file mode 100644
--- a/KI/KI12.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,382 +0,0 @@
-import random
-import math
-from panda3d.core import (
-    LColor, RenderModeAttrib, GeomVertexFormat, GeomVertexData, GeomNode,
-    GeomVertexWriter, GeomLines, Geom, Vec3, ClockObject, TextNode
-)
-
-# Globaler Clock
-globalClock = ClockObject.getGlobalClock()
-
-from direct.showbase.ShowBase import ShowBase
-from panda3d.core import AmbientLight, DirectionalLight
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-
-
-class LagerSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Basisgeschwindigkeit (1.5 m/s) und initialer Faktor 1.0,
-        # also normale Simulationsgeschwindigkeit.
-        self.base_speed = 1.5
-        self.speed_factor = 1.0
-        self.speed = self.base_speed * self.speed_factor
-
-        self.cam.setPos(0, -60, 30)
-        self.cam.lookAt(0, 0, 0)
-
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=40, cell_size=1)
-
-        # Erzeuge 5 Annahme- (rot) und 5 Abgabe-Stationen (grün) in einer Linie.
-        station_count = 5
-        spacing = 5
-        y_start = -((station_count - 1) * spacing) / 2
-
-        self.annahme_stationen = []
-        self.abgabe_stationen = []
-        for i in range(station_count):
-            y = y_start + i * spacing
-            pickup_station = self.erzeuge_gitterbox(-9, y, 0, LColor(1, 0, 0, 1))
-            self.annahme_stationen.append(pickup_station)
-            dropoff_station = self.erzeuge_gitterbox(9, y, 0, LColor(0, 1, 0, 1))
-            self.abgabe_stationen.append(dropoff_station)
-
-        # Fahrzeuge initialisieren (zwei Fahrzeuge)
-        self.vehicles = []
-        self.cargos = {}  # Fahrzeug -> aktuell transportiertes Paket
-        self.current_dropoffs = {}  # Fahrzeug -> aktuell reservierte Abgabestation
-
-        # Fahrzeug 1 startet sofort:
-        vehicle1 = self.loader.loadModel("models/box")
-        vehicle1.setScale(1, 1, 0.5)
-        vehicle1.setColor(LColor(0, 0, 1, 1))
-        vehicle1.setPos(0, 0, 0)
-        vehicle1.reparentTo(self.render)
-        self.vehicles.append(vehicle1)
-
-        # Fahrzeug 2 startet 8 Sekunden später:
-        vehicle2 = self.loader.loadModel("models/box")
-        vehicle2.setScale(1, 1, 0.5)
-        vehicle2.setColor(LColor(0, 0, 0.8, 1))
-        vehicle2.setPos(0, 2, 0)
-        vehicle2.reparentTo(self.render)
-        self.vehicles.append(vehicle2)
-
-        # Globaler Pool für Pickup-Pakete:
-        self.pickup_packages = {}
-        self.last_removed = {}
-        for station in self.annahme_stationen:
-            self.last_removed[station] = globalClock.getFrameTime()
-
-        # Reservierungssets:
-        self.occupied_dropoffs = set()
-        self.occupied_pickups = set()
-
-        # Slider zur Anpassung des Geschwindigkeitsfaktors:
-        # Wertebereich: 0.1 bis 10, Startwert: 1.0
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Speed: {self.speed_factor:.1f} (eff: {self.speed:.1f} m/s)",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-        # Task, der den Sliderwert einmal pro Echtsekunde abfragt
-        self.taskMgr.doMethodLater(1, self.check_slider_task, "CheckSliderTask")
-
-        # Alle zeitbasierten Tasks nutzen sim_time zur Anpassung
-        self.taskMgr.doMethodLater(self.sim_time(1), self.check_and_spawn_packages, "CheckSpawnPackages")
-        self.taskMgr.add(self.update_package_timers, "UpdatePackageTimers")
-
-        # Start der Lieferzyklen: Fahrzeug 1 sofort, Fahrzeug 2 nach sim_time(8) Sekunden
-        self.start_delivery_cycle(self.vehicles[0], self.vehicles[0].getPos())
-        self.taskMgr.doMethodLater(self.sim_time(8), lambda t, veh=self.vehicles[1]:
-        self.start_delivery_cycle(veh, veh.getPos()),
-                                   "StartVehicle2")
-
-    def sim_time(self, t):
-        """
-        Gibt den skalierten Zeitwert zurück. Dabei wird die Eingabezeit t (in Sekunden)
-        durch den aktuellen Geschwindigkeitsfaktor geteilt.
-        Dadurch laufen Prozesse z. B. t/speed_factor Sekunden in Echtzeit.
-        """
-        return t / self.speed_factor if self.speed_factor else t
-
-    def check_slider_task(self, task):
-        """
-        Diese Funktion wird einmal pro Echtsekunde aufgerufen, um den Sliderwert abzufragen
-        und damit alle zeitbasierten Abläufe in Echtzeit anzupassen.
-        """
-        self.update_simulation_speed()
-        return Task.again
-
-    def update_simulation_speed(self, speed_factor=None):
-        """
-        Aktualisiert den Geschwindigkeitsfaktor, berechnet die effektive Fahrzeuggeschwindigkeit
-        und passt das zugehörige Label an.
-        """
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed = self.base_speed * self.speed_factor
-        self.speed_label['text'] = f"Sim Speed: {self.speed_factor:.1f} (eff: {self.speed:.1f} m/s)"
-
-    def check_and_spawn_packages(self, task):
-        """
-        Überprüft alle Annahmestationen: falls an einer Station kein Paket vorhanden
-        und die simulierte Wartezeit (Basis 1 Sekunde) vergangen ist, wird ein Paket erzeugt.
-        """
-        spawn_delay = self.sim_time(1)
-        current_time = globalClock.getFrameTime()
-        for station in self.annahme_stationen:
-            if station not in self.pickup_packages:
-                if current_time - self.last_removed.get(station, current_time) >= spawn_delay:
-                    self.spawn_package_at_station(station)
-        return Task.again
-
-    def spawn_package_at_station(self, station):
-        """
-        Erzeugt ein Paket (Würfel) an der gegebenen Annahmestation, positioniert es um +1 in Z
-        und hängt einen TextNode zur Anzeige der Wartezeit an.
-        """
-        package = self.erzeuge_wuerfel(station.getX(), station.getY(), station.getZ(), LColor(1, 1, 0, 1))
-        spawn_time = globalClock.getFrameTime()
-        timer_text = TextNode("package_timer")
-        timer_text.setText("0.0s")
-        timer_np = package.attachNewNode(timer_text)
-        timer_np.setScale(0.5)
-        timer_np.setPos(0, 0, 1.2)
-        self.pickup_packages[station] = (package, spawn_time, timer_np)
-
-    def update_package_timers(self, task):
-        """
-        Aktualisiert in jedem Frame den angezeigten Timer aller wartenden Pakete.
-        Hierbei wird die verstrichene Zeit (current_time - spawn_time) mit dem speed_factor
-        multipliziert (simulierte Zeit).
-        """
-        current_time = globalClock.getFrameTime()
-        for station, (package, spawn_time, timer_np) in self.pickup_packages.items():
-            elapsed_sim = (current_time - spawn_time) * self.speed_factor
-            tn = timer_np.node()
-            tn.setText(f"{elapsed_sim:.1f}s")
-        return Task.cont
-
-    def move_vehicle_to(self, vehicle, target, on_complete):
-        """
-        Bewegt das Fahrzeug dynamisch bis zum Ziel (target). Dabei wird in jedem Frame
-        der aktuelle Speed (self.speed) verwendet, sodass Änderungen des Reglers sofort
-        wirksam werden. Sobald das Fahrzeug das Ziel erreicht hat, wird on_complete() aufgerufen.
-        """
-
-        def move_task(task):
-            dt = globalClock.getDt()
-            current_pos = vehicle.getPos()
-            direction = target - current_pos
-            dist = direction.length()
-            # Wenn die Distanz kleiner als der Schritt ist, Ziel erreichen.
-            if dist <= self.speed * dt:
-                vehicle.setPos(target)
-                on_complete()
-                return Task.done
-            else:
-                move_step = direction.normalized() * self.speed * dt
-                vehicle.setPos(current_pos + move_step)
-                return Task.cont
-
-        self.taskMgr.add(move_task, f"move_vehicle_{id(vehicle)}")
-
-    def start_delivery_cycle(self, vehicle, start_pos=None):
-        """
-        Führt für ein Fahrzeug den Liefervorgang aus (alle Wartezeiten werden mittels sim_time skaliert):
-          1. Wählt das älteste Paket (basierend auf simulierten Wartezeiten), sofern its Pickup-Station frei ist.
-          2. Reserviert die Pickup-Station, fährt dorthin und übergibt das Paket.
-          3. Wählt dann zufällig eine freie Abgabestation, reserviert sie und fährt dorthin.
-          4. Nach einer simulierten Wartezeit von 1 Sekunde wird das Paket abgesetzt,
-             die Reservierungen aufgehoben und der nächste Zyklus gestartet.
-        """
-        if start_pos is None:
-            start_pos = vehicle.getPos()
-
-        if not self.pickup_packages:
-            self.taskMgr.doMethodLater(self.sim_time(1),
-                                       lambda t: self.start_delivery_cycle(vehicle, vehicle.getPos()),
-                                       "RetryCycle_" + str(id(vehicle)))
-            return
-
-        current_time = globalClock.getFrameTime()
-        available_pickups = [s for s in self.pickup_packages.keys() if s not in self.occupied_pickups]
-        if not available_pickups:
-            self.taskMgr.doMethodLater(self.sim_time(1),
-                                       lambda t: self.start_delivery_cycle(vehicle, vehicle.getPos()),
-                                       "RetryCycle_" + str(id(vehicle)))
-            return
-
-        pickup_station = max(available_pickups, key=lambda s: current_time - self.pickup_packages[s][1])
-        self.occupied_pickups.add(pickup_station)
-        pickup_pos = pickup_station.getPos()
-
-        available_dropoffs = [ds for ds in self.abgabe_stationen if ds not in self.occupied_dropoffs]
-        if not available_dropoffs:
-            self.occupied_pickups.remove(pickup_station)
-            self.taskMgr.doMethodLater(self.sim_time(1),
-                                       lambda t: self.start_delivery_cycle(vehicle, vehicle.getPos()),
-                                       "RetryCycle_" + str(id(vehicle)))
-            return
-
-        dropoff_station = random.choice(available_dropoffs)
-        self.occupied_dropoffs.add(dropoff_station)
-        self.current_dropoffs[vehicle] = dropoff_station
-        dropoff_pos = dropoff_station.getPos()
-
-        # Jetzt: bewege das Fahrzeug zuerst zur Pickup-Station, dann zur Abgabestation.
-        self.move_vehicle_to(vehicle, pickup_pos, lambda: self.after_pickup(vehicle, pickup_station, dropoff_pos))
-
-    def after_pickup(self, vehicle, pickup_station, dropoff_pos):
-        """
-        Wird aufgerufen, sobald das Fahrzeug die Pickup-Station erreicht hat.
-        Übergibt das Paket und startet die Bewegung zur Abgabestation.
-        """
-        self.pickup_package(vehicle, pickup_station)
-        self.move_vehicle_to(vehicle, dropoff_pos, lambda: self.after_dropoff(vehicle))
-
-    def after_dropoff(self, vehicle):
-        """
-        Nachdem das Fahrzeug die Abgabestation erreicht hat, wird das Paket abgesetzt.
-        Nach einer simulierten Wartezeit von 1 Sekunde wird das Fahrzeug bereit gemacht
-        für den nächsten Lieferzyklus.
-        """
-        self.drop_cargo(vehicle)
-        self.taskMgr.doMethodLater(self.sim_time(1),
-                                   lambda t: self.finish_cycle(vehicle),
-                                   f"FinishCycle_{id(vehicle)}")
-
-    def finish_cycle(self, vehicle):
-        """
-        Nach dem Absetzen des Pakets wird das Paket entfernt und der nächste Zyklus gestartet.
-        """
-        self.remove_cargo(vehicle)
-        self.start_delivery_cycle(vehicle, vehicle.getPos())
-
-    def pickup_package(self, vehicle, station):
-        """
-        Das Fahrzeug übernimmt an der Pickup-Station das Paket.
-        Entfernt den Timer-Text, löscht den Eintrag aus dem Pickup-Pool, aktualisiert den Zeitpunkt
-        und hebt die Pickup-Reservierung auf.
-        """
-        if station in self.pickup_packages:
-            package, spawn_time, timer_np = self.pickup_packages.pop(station)
-            timer_np.removeNode()
-            package.wrtReparentTo(vehicle)
-            package.setPos(0, 0, 1)
-            self.cargos[vehicle] = package
-            self.last_removed[station] = globalClock.getFrameTime()
-            if station in self.occupied_pickups:
-                self.occupied_pickups.remove(station)
-
-    def drop_cargo(self, vehicle):
-        """
-        Das transportierte Paket wird an der reservierten Abgabestation (Z+1) abgesetzt.
-        """
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.wrtReparentTo(self.render)
-            targetPos = self.current_dropoffs[vehicle].getPos() + Vec3(0, 0, 1)
-            cargo.setPos(targetPos)
-
-    def remove_cargo(self, vehicle):
-        """
-        Entfernt das aktuell transportierte Paket und gibt die reservierte Abgabestation frei.
-        """
-        cargo = self.cargos.get(vehicle)
-        if cargo:
-            cargo.removeNode()
-            self.cargos[vehicle] = None
-        dropoff_station = self.current_dropoffs.get(vehicle)
-        if dropoff_station in self.occupied_dropoffs:
-            self.occupied_dropoffs.remove(dropoff_station)
-            del self.current_dropoffs[vehicle]
-
-    def erzeuge_bodenraster(self, center_extent=40, cell_size=1):
-        """
-        Erzeugt ein Bodenraster als Referenz.
-        """
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line, max_line = -center_extent - 0.5, center_extent + 0.5
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(0.7, 0.7, 0.7, 1)
-        return np_grid
-
-    def erzeuge_gitterbox(self, x, y, z, farbe):
-        """
-        Erzeugt ein Wireframe-Box-Modell als Station.
-        """
-        gitterbox = self.loader.loadModel("models/box")
-        gitterbox.setScale(1, 1, 1)
-        gitterbox.setPos(x, y, z)
-        gitterbox.setColor(farbe)
-        gitterbox.setRenderMode(RenderModeAttrib.MWireframe, 1)
-        gitterbox.reparentTo(self.render)
-        return gitterbox
-
-    def erzeuge_wuerfel(self, x, y, z, farbe):
-        """
-        Erzeugt einen Würfel (als Paket), der etwas über dem Boden platziert wird.
-        """
-        wuerfel = self.loader.loadModel("models/box")
-        wuerfel.setScale(1, 1, 1)
-        wuerfel.setPos(x, y, z + 1)
-        wuerfel.setColor(farbe)
-        wuerfel.reparentTo(self.render)
-        return wuerfel
-
-    def erzeuge_licht(self):
-        """
-        Einfache Beleuchtung mittels Ambient- und Richtungslicht.
-        """
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        self.render.setLight(self.render.attachNewNode(alight))
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlightNP = self.render.attachNewNode(dlight)
-        dlightNP.setPos(10, -10, 10)
-        self.render.setLight(dlightNP)
-
-
-# Starte die Simulation
-app = LagerSimulation()
-app.run()
Index: Feld/Feld5.py
===================================================================
diff --git a/Feld/Feld5.py b/Feld/Feld5.py
deleted file mode 100644
--- a/Feld/Feld5.py	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
+++ /dev/null	(revision f18e5508a2c6dba36f974488d6054595d03f38f2)
@@ -1,373 +0,0 @@
-from panda3d.core import (
-    LColor,
-    GeomVertexFormat,
-    GeomVertexData,
-    GeomVertexWriter,
-    GeomLines,
-    Geom,
-    GeomNode,
-    ClockObject,
-    AmbientLight,
-    DirectionalLight,
-    Vec3,
-    LineSegs,
-    CardMaker,
-    TextNode
-)
-from direct.showbase.ShowBase import ShowBase
-from direct.task import Task
-from direct.gui.DirectGui import DirectSlider, DirectLabel
-import math
-
-class SimpleSimulation(ShowBase):
-    def __init__(self):
-        super().__init__()
-
-        # Initialwerte für Simulationszeit und -geschwindigkeit
-        self.sim_clock = 0.0
-        self.speed_factor = 1.0
-
-        # Ursprung (Koordinatenachsen) zeichnen
-        self.draw_origin()
-
-        # Kameraeinstellungen: So, dass das gesamte Feld gut sichtbar ist.
-        self.cam.setPos(11, -80, 40)
-        self.cam.lookAt(11, 30, 0)
-
-        # Licht und Bodenraster erzeugen
-        self.erzeuge_licht()
-        self.erzeuge_bodenraster(center_extent=70, cell_size=1)
-
-        # Erzeuge die Mauer (flush, bündig ein Rechteck abschließend)
-        # Eckpunkte: (0,0,0), (0,60,0), (22,60,0) und (22,0,0)
-        self.create_wall()
-
-        # Erzeuge Aufnahmestationen – jetzt mit X = 0 anstatt X = 1.
-        self.create_annahme_stations()
-
-        # Erzeuge die Abgabestationen (X-Wert = 21 bleiben unverändert)
-        self.create_abgabe_stations()
-
-        # Slider zur Anpassung der Simulationsgeschwindigkeit
-        self.speed_slider = DirectSlider(
-            range=(0.1, 10.0),
-            value=self.speed_factor,
-            pageSize=0.1,
-            command=self.update_simulation_speed,
-            pos=(0, 0, -0.85),
-            scale=0.3
-        )
-        self.speed_label = DirectLabel(
-            text=f"Sim Time Factor: {self.speed_factor:.1f}",
-            pos=(0, 0, -0.75),
-            scale=0.07
-        )
-
-        # Anzeige der Kennzahlen (z. B. Laufzeit)
-        self.info_label = DirectLabel(
-            text="Laufzeit: 0.0s",
-            pos=(1.2, 0, 0.8),
-            scale=0.07,
-            frameColor=(0, 0, 0, 0)
-        )
-
-        # Zoom-Funktion: Mit Mausrad hereinz- bzw. herauszoomen.
-        self.accept("wheel_up", self.zoom_in)
-        self.accept("wheel_down", self.zoom_out)
-
-        # Aufgaben: Simulationszeit fortlaufend aktualisieren.
-        self.taskMgr.add(self.update_sim_clock, "UpdateSimClockTask")
-        self.taskMgr.add(self.update_info_display, "UpdateInfoDisplayTask")
-
-    def draw_origin(self):
-        """Zeichnet die drei farbigen Achsen im Ursprung (0,0,0)."""
-        ls = LineSegs()
-        ls.setThickness(2)
-        # X-Achse (rot)
-        ls.setColor(LColor(1, 0, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(1, 0, 0)
-        # Y-Achse (grün)
-        ls.setColor(LColor(0, 1, 0, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 1, 0)
-        # Z-Achse (blau)
-        ls.setColor(LColor(0, 0, 1, 1))
-        ls.moveTo(0, 0, 0)
-        ls.drawTo(0, 0, 1)
-        self.render.attachNewNode(ls.create())
-
-    def update_sim_clock(self, task):
-        dt = ClockObject.getGlobalClock().getDt()
-        self.sim_clock += dt * self.speed_factor
-        return Task.cont
-
-    def update_info_display(self, task):
-        total_seconds = self.sim_clock
-        hours = int(total_seconds // 3600)
-        minutes = int((total_seconds % 3600) // 60)
-        seconds = total_seconds % 60
-        formatted_time = f"{hours}h {minutes}m {seconds:.1f}s"
-        self.info_label['text'] = f"Laufzeit: {formatted_time}"
-        return Task.cont
-
-    def update_simulation_speed(self, speed_factor=None):
-        if speed_factor is None:
-            speed_factor = self.speed_slider['value']
-        else:
-            speed_factor = float(speed_factor)
-        self.speed_factor = speed_factor
-        self.speed_label['text'] = f"Sim Time Factor: {self.speed_factor:.1f}"
-
-    def zoom_in(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = max(10, current_fov - 5)
-        lens.setFov(new_fov)
-        print(f"Zoom In: FOV von {current_fov} auf {new_fov}")
-
-    def zoom_out(self):
-        lens = self.cam.node().getLens()
-        current_fov = lens.getFov()[0]
-        new_fov = min(100, current_fov + 5)
-        lens.setFov(new_fov)
-        print(f"Zoom Out: FOV von {current_fov} auf {new_fov}")
-
-    def erzeuge_bodenraster(self, center_extent=70, cell_size=1):
-        vertex_format = GeomVertexFormat.getV3()
-        vdata = GeomVertexData("grid", vertex_format, Geom.UHStatic)
-        writer = GeomVertexWriter(vdata, "vertex")
-        lines = GeomLines(Geom.UHStatic)
-        n_vertices = 0
-        min_line = -center_extent - 0.5
-        max_line = center_extent + 0.5
-
-        # Horizontale Linien
-        y = min_line
-        while y <= max_line:
-            writer.addData3(min_line, y, 0)
-            writer.addData3(max_line, y, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            y += cell_size
-
-        # Vertikale Linien
-        x = min_line
-        while x <= max_line:
-            writer.addData3(x, min_line, 0)
-            writer.addData3(x, max_line, 0)
-            lines.addVertices(n_vertices, n_vertices + 1)
-            n_vertices += 2
-            x += cell_size
-
-        lines.closePrimitive()
-        geom = Geom(vdata)
-        geom.addPrimitive(lines)
-        node = GeomNode("grid")
-        node.addGeom(geom)
-        np_grid = self.render.attachNewNode(node)
-        np_grid.setColor(LColor(0.7, 0.7, 0.7, 1))
-        return np_grid
-
-    def erzeuge_licht(self):
-        alight = AmbientLight("ambient_light")
-        alight.setColor((0.5, 0.5, 0.5, 1))
-        alight_np = self.render.attachNewNode(alight)
-        self.render.setLight(alight_np)
-
-        dlight = DirectionalLight("directional_light")
-        dlight.setColor((1, 1, 1, 1))
-        dlight_np = self.render.attachNewNode(dlight)
-        dlight_np.setPos(10, -10, 10)
-        self.render.setLight(dlight_np)
-
-    def create_wall(self):
-        """
-        Erzeugt vier Wandsegmente, die ein Rechteck abschließen.
-        Die vier Eckpunkte sind:
-          p1 = (0, 0, 0)
-          p2 = (0, 60, 0)
-          p3 = (22, 60, 0)
-          p4 = (22, 0, 0)
-        Der innere Rand der Mauer liegt exakt auf diesen Punkten.
-        """
-        p1 = Vec3(0, 0, 0)
-        p2 = Vec3(0, 60, 0)
-        p3 = Vec3(22, 60, 0)
-        p4 = Vec3(22, 0, 0)
-        self.add_wall_segment(p1, p2)
-        self.add_wall_segment(p2, p3)
-        self.add_wall_segment(p3, p4)
-        self.add_wall_segment(p4, p1)
-
-    def add_wall_segment(self, start, end, height=2.0, thickness=0.5):
-        """
-        Fügt ein Wandsegment hinzu – sodass dessen innere Kante
-        exakt die Verbindung zwischen 'start' und 'end' bildet.
-        Die Eckpunkte werden in Clockwise-Reihenfolge angegeben.
-        """
-        seg_vector = end - start
-        length = seg_vector.length()
-        if length == 0:
-            return
-
-        d = seg_vector.normalized()
-        # Für Clockwise angegebene Eckpunkte (innerer Bereich rechts) berechnen wir:
-        outward = Vec3(-d.getY(), d.getX(), 0)
-        center = (start + end) * 0.5 + outward * (thickness / 2.0)
-        center.setZ(height / 2.0)
-        angle = math.degrees(math.atan2(seg_vector.getY(), seg_vector.getX()))
-
-        wall_np = self.render.attachNewNode("wall_np")
-        wall = self.loader.loadModel("models/box")
-        # Pivot-Korrektur: Zentriere das Modell anhand der TightBounds.
-        bounds = wall.getTightBounds()
-        if bounds:
-            low, high = bounds
-            box_center = (low + high) * 0.5
-            wall.setPos(-box_center)
-        wall.reparentTo(wall_np)
-
-        wall_np.setScale(length, thickness, height)
-        wall_np.setPos(center)
-        wall_np.setH(angle)
-        wall_np.setTextureOff(1)
-        wall_np.setColor(LColor(0.5, 0.5, 0.5, 1))
-
-    def create_annahme_station(self, pos):
-        """
-        Erzeugt eine Aufnahmestation als 1×1×1-Würfel aus Linien (Gitter) in Grün.
-        Die Seite in positiver X-Richtung (x = pos.x+1) bleibt offen.
-        'pos' wird als untere linke Ecke des Würfels verwendet.
-        """
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(0, 1, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        # Für Aufnahmestationen: offene Seite ist positive X, daher wird die Kante zwischen v1 und v2 weggelassen.
-        ls.moveTo(v0)
-        ls.drawTo(v1)
-        ls.moveTo(v2)
-        ls.drawTo(v3)
-        ls.moveTo(v3)
-        ls.drawTo(v0)
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v6)
-        ls.drawTo(v7)
-        ls.moveTo(v7)
-        ls.drawTo(v4)
-        ls.moveTo(v0)
-        ls.drawTo(v4)
-        ls.moveTo(v3)
-        ls.drawTo(v7)
-        return self.render.attachNewNode(ls.create())
-
-    def create_annahme_stations(self):
-        """
-        Platziert Aufnahmestationen an den Positionen:
-          (0, 5, 0), (0, 10, 0), (0, 15, 0), (0, 20, 0), (0, 25, 0),
-          (0, 30, 0), (0, 35, 0), (0, 40, 0), (0, 45, 0) und (0, 50, 0).
-        Jede Station erhält einen Mittelpunktmarker (kleine weiße Kugel) und
-        eine Nummerierung, die rechts der Station (in positiver X-Richtung) angezeigt wird.
-        """
-        station_points = [
-            Vec3(0, 5, 0), Vec3(0, 10, 0), Vec3(0, 15, 0),
-            Vec3(0, 20, 0), Vec3(0, 25, 0), Vec3(0, 30, 0),
-            Vec3(0, 35, 0), Vec3(0, 40, 0), Vec3(0, 45, 0),
-            Vec3(0, 50, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_annahme_station(pt)
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            tn_np.setPos(pt.x + 1.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-    def create_abgabe_station(self, pos):
-        """
-        Erzeugt eine Abgabestation als 1×1×1-Würfel aus Linien (Gitter) in Rot.
-        Die offene Seite zeigt in negative X-Richtung.
-        'pos' wird als untere linke Ecke des Würfels verwendet.
-        """
-        ls = LineSegs()
-        ls.setThickness(2.0)
-        ls.setColor(LColor(1, 0, 0, 1))
-        v0 = pos + Vec3(0, 0, 0)
-        v1 = pos + Vec3(1, 0, 0)
-        v2 = pos + Vec3(1, 1, 0)
-        v3 = pos + Vec3(0, 1, 0)
-        v4 = pos + Vec3(0, 0, 1)
-        v5 = pos + Vec3(1, 0, 1)
-        v6 = pos + Vec3(1, 1, 1)
-        v7 = pos + Vec3(0, 1, 1)
-        # Für Abgabestationen: offene Seite ist negative X, daher wird die linke Kante (v0->v3 und v7->v4) weggelassen.
-        ls.moveTo(v0)
-        ls.drawTo(v1)    # untere Kante
-        ls.moveTo(v1)
-        ls.drawTo(v2)    # rechte Kante
-        ls.moveTo(v2)
-        ls.drawTo(v3)    # obere Kante
-        ls.moveTo(v4)
-        ls.drawTo(v5)
-        ls.moveTo(v5)
-        ls.drawTo(v6)    # rechte Kante
-        ls.moveTo(v6)
-        ls.drawTo(v7)    # obere Kante
-        # Vertikale Kanten: Zeichne nur die, die zur rechten Seite gehören.
-        ls.moveTo(v1)
-        ls.drawTo(v5)
-        ls.moveTo(v2)
-        ls.drawTo(v6)
-        return self.render.attachNewNode(ls.create())
-
-    def create_abgabe_stations(self):
-        """
-        Platziert Abgabestationen an den Positionen:
-          (21, 5, 0), (21, 10, 0), (21, 15, 0), (21, 20, 0), (21, 25, 0),
-          (21, 30, 0), (21, 35, 0), (21, 40, 0), (21, 45, 0) und (21, 50, 0).
-        Jede Abgabestation erhält einen weißen Mittelpunktmarker und
-        eine Nummerierung, die links (in negativer X-Richtung) angezeigt wird.
-        """
-        station_points = [
-            Vec3(21, 5, 0), Vec3(21, 10, 0), Vec3(21, 15, 0),
-            Vec3(21, 20, 0), Vec3(21, 25, 0), Vec3(21, 30, 0),
-            Vec3(21, 35, 0), Vec3(21, 40, 0), Vec3(21, 45, 0),
-            Vec3(21, 50, 0)
-        ]
-        for i, pt in enumerate(station_points, start=1):
-            self.create_abgabe_station(pt)
-            center = pt + Vec3(0.5, 0.5, 0.5)
-            marker = self.loader.loadModel("models/misc/sphere")
-            marker.setScale(0.15)
-            marker.setColor(LColor(1, 1, 1, 1))
-            marker.setPos(center)
-            marker.reparentTo(self.render)
-            tn = TextNode("station_number")
-            tn.setText(str(i))
-            tn.setAlign(TextNode.ACenter)
-            tn.setTextColor(LColor(0, 0, 0, 1))
-            tn_np = self.render.attachNewNode(tn)
-            # Da die Öffnung in negative X zeigt, wird der Text links von der Station platziert.
-            tn_np.setPos(pt.x - 0.1, pt.y + 0.5, 0.01)
-            tn_np.setHpr(0, -90, 0)
-
-if __name__ == "__main__":
-    app = SimpleSimulation()
-    app.run()
diff --git a/TestFFZ/TestFFZ6.py b/TestFFZ/TestFFZ6.py
deleted file mode 100644
